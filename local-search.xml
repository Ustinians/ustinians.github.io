<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>位运算及其应用</title>
    <link href="/2023/04/08/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <url>/2023/04/08/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="判断一个整数n是否为负数"><a href="#判断一个整数n是否为负数" class="headerlink" title="判断一个整数n是否为负数"></a>判断一个整数n是否为负数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 判断n是负数还是非负数</span><br><span class="hljs-comment"> * if n是非负数,返回1</span><br><span class="hljs-comment"> * if n是负数,返回0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">sign</span> = (<span class="hljs-params">n</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>-((n &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="比较两个数的大小"><a href="#比较两个数的大小" class="headerlink" title="比较两个数的大小"></a>比较两个数的大小</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 位运算获取较的大值</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getMax1</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> c = a-b; <span class="hljs-comment">// a&gt;=b时,c&gt;=0;否则c&lt;0</span><br>    <span class="hljs-keyword">let</span> scA = <span class="hljs-title function_">sign</span>(c); <span class="hljs-comment">// a-b为非负,scA为1,a-b为负,scA为0(当scA为1的时候,a比较大)</span><br>    <span class="hljs-keyword">let</span> scB = <span class="hljs-number">1</span>-scA; <span class="hljs-comment">// 当scB为1的时候,b比较大</span><br>    <span class="hljs-comment">// 当scA为0的时候,scB一定为1,当scA为1的时候,scB一定为0</span><br>    <span class="hljs-comment">// (若scA为1,返回a,若scB为1,返回b)</span><br>    <span class="hljs-keyword">return</span> a*scA + b*scB;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码有一个缺点,即当a,b异号且相差较大的时候,c可能溢出</p><p>改善后的代码为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 优化后</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getMax2</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> c = a-b; <span class="hljs-comment">// a&gt;=b时,c&gt;=0;否则c&lt;0</span><br>    <span class="hljs-keyword">let</span> sa = <span class="hljs-title function_">sign</span>(a); <span class="hljs-comment">// a&gt;=0时sa=1,否则sa=0</span><br>    <span class="hljs-keyword">let</span> sb = <span class="hljs-title function_">sign</span>(b); <span class="hljs-comment">// b&gt;=0时sb=1,否则sb=0</span><br>    <span class="hljs-keyword">let</span> sc = <span class="hljs-title function_">sign</span>(c); <span class="hljs-comment">// c&gt;=0时sc=1,否则sc=0</span><br>    <span class="hljs-comment">// 异或运算,判断a,b是否同号</span><br>    <span class="hljs-keyword">let</span> difSab = sa ^ sb; <span class="hljs-comment">// a和b的符號不同为1,相同为0</span><br>    <span class="hljs-keyword">let</span> sameSab = <span class="hljs-number">1</span> - difSab; <span class="hljs-comment">// a和b的符号一样为1,不一样为0</span><br>    <span class="hljs-comment">// 当二者不同号且a&gt;=0时,returnA=1,当二者同号且a&gt;=b(c&gt;=0)时,returnA为1,否则为0</span><br>    <span class="hljs-keyword">let</span> returnA = difSab * sa + sameSab * sc;<br>    <span class="hljs-keyword">let</span> returnB = <span class="hljs-number">1</span> - returnA;<br>    <span class="hljs-comment">// 返回较大的数</span><br>    <span class="hljs-keyword">return</span> a*returnA + b*returnB;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="判断一个32位正数是不是2的幂-4的幂"><a href="#判断一个32位正数是不是2的幂-4的幂" class="headerlink" title="判断一个32位正数是不是2的幂,4的幂"></a>判断一个32位正数是不是2的幂,4的幂</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 判断一个32位正数是不是2的幂</span><br><span class="hljs-comment"> * 思路:</span><br><span class="hljs-comment"> * 如果一个正数是2的幂,则它的二进制上只有一个1</span><br><span class="hljs-comment"> * 00001 -&gt; 2^0</span><br><span class="hljs-comment"> * 00010 -&gt; 2^1</span><br><span class="hljs-comment"> * 00100 -&gt; 2^2</span><br><span class="hljs-comment"> * 01000 -&gt; 2^3</span><br><span class="hljs-comment"> * 10000 -&gt; 2^4</span><br><span class="hljs-comment"> * .....</span><br><span class="hljs-comment"> * 当最后一位为1时,num-1 = 0</span><br><span class="hljs-comment"> * 其他情况下,1会被打散 </span><br><span class="hljs-comment"> * 2^1-1 -&gt; 00001</span><br><span class="hljs-comment"> * 2^2-1 = 000011</span><br><span class="hljs-comment"> * ......</span><br><span class="hljs-comment"> * 因此,num &amp; (num-1)=0时.就是2的幂</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 判断一个32位正数是不是4的幂</span><br><span class="hljs-comment"> * 同理,二进制只能有一个1,且必须在0,2,4,6...位上</span><br><span class="hljs-comment"> * 1. num &amp; (num-1) = 0 (只有一个1)</span><br><span class="hljs-comment"> * 2. num &amp; 01010101...01 !== 0(1在偶数位上)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 判断一个数是不是2的幂</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">is2Power</span> = (<span class="hljs-params">n</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> n &amp; (n-<span class="hljs-number">1</span>) === <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 判断一个数是不是4的幂</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">is4Power</span> = (<span class="hljs-params">n</span>) =&gt; &#123;<br>    <span class="hljs-comment">//                               ...1010101</span><br>    <span class="hljs-keyword">return</span> (n &amp; (n-<span class="hljs-number">1</span>)) === <span class="hljs-number">0</span> &amp;&amp; (n &amp; <span class="hljs-number">0x55555555</span>) != <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="位运算实现加减乘除"><a href="#位运算实现加减乘除" class="headerlink" title="位运算实现加减乘除"></a>位运算实现加减乘除</h2><p>给定两个有符号32位整数a和b,不能使用算术运算符,分别实现a和b的加,减,乘,除运算</p><p><strong>[要求]</strong></p><p>如果给定a,b执行加减乘除的运算结果就会导致数据溢出,那你实现的函数不必对此负责,除此之外请保证计算过程不发生溢出</p><h3 id="两个数的二进制进行相加"><a href="#两个数的二进制进行相加" class="headerlink" title="两个数的二进制进行相加"></a>两个数的二进制进行相加</h3><p>进行异或运算,得到的结果就是<strong>二者相加后无进位的值</strong></p><p>通过与运算能获取要进位的数</p><p>与运算向左移一位,得到的就是<strong>进位结果</strong></p><p>然后将异或运算得到的结果和与运算得到的结果再进行如上运算</p><p>直到与运算的结果为0(没有进位了)</p><p><img src="http://dawning.fun/wp-content/uploads/2022/06/image-20220513203808367.png" alt="img"> 进行异或运算和与运算得到结果</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//@ 加法</span><br><span class="hljs-comment">// 如果用户传入的参数,a+b就是溢出的,那结果就可能出错</span><br>const add = <span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> &#123;<br>    let <span class="hljs-built_in">sum</span> = a;<br>    <span class="hljs-keyword">while</span>(b ^= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 当与运算的值不为0,一直进行循环</span><br>        <span class="hljs-built_in">sum</span> = a ^ b; <span class="hljs-comment">// 无进位相加的结果</span><br>        b = (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 进位信息</span><br>        a = <span class="hljs-built_in">sum</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两个数的二进制进行相减"><a href="#两个数的二进制进行相减" class="headerlink" title="两个数的二进制进行相减"></a>两个数的二进制进行相减</h3><p>a-b即为a加上b的相反数(a-(-b))</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">negNum</span> = (<span class="hljs-params">n</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 计算n取反后与1相加的结果(即为n的相反数-n)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">add</span>(~n,<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">minus</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 计算a与-b相加的结果</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">add</span>(a,<span class="hljs-title function_">negNum</span>(b));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两个数的二进制进行相乘"><a href="#两个数的二进制进行相乘" class="headerlink" title="两个数的二进制进行相乘"></a>两个数的二进制进行相乘</h3><p>两个二进制相乘的时候,直接使用二进制的每一位互相乘(和十进制乘法相同),最后将结果相加即可</p><p><img src="http://dawning.fun/wp-content/uploads/2022/06/16524503131.png" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//@ 二进制计算两个数相乘</span><br><span class="hljs-comment">// 如果用户传入的参数中,a*b就是溢出的,那结果肯定会出错</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">mulit</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(b !== <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>((b &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// b的最后一位不为0</span><br>            res = <span class="hljs-title function_">add</span>(res,a);<br>        &#125; <br>        a &lt;&lt;= <span class="hljs-number">1</span>;<br>        b &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两个数的二进制进行相除"><a href="#两个数的二进制进行相除" class="headerlink" title="两个数的二进制进行相除"></a>两个数的二进制进行相除</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isNeg</span> = (<span class="hljs-params">n</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> n &lt; <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//@ 二进制计算两个数相除</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">div</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">isNeg</span>(a) ? <span class="hljs-title function_">negNum</span>(a) : a;<br>    <span class="hljs-keyword">let</span> y = <span class="hljs-title function_">isNeg</span>(b) ? <span class="hljs-title function_">negNum</span>(b) : b;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">31</span>;i &gt; -<span class="hljs-number">1</span>;i = <span class="hljs-title function_">minus</span>(i,<span class="hljs-number">1</span>))&#123;<br>        <span class="hljs-keyword">if</span>((x &gt;&gt; i) &gt;= y)&#123;<br>            res |= (<span class="hljs-number">1</span> &lt;&lt; i);<br>            x = <span class="hljs-title function_">minus</span>(x,y &lt;&lt; i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">isNeg</span>(a) ^ <span class="hljs-title function_">isNeg</span>(b) ? <span class="hljs-title function_">negNum</span>(res) : res;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">divide</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span>(b === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 分母不能为0</span><br>    <span class="hljs-keyword">if</span>(a === <span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_VALUE</span> &amp;&amp; b === <span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_VALUE</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b === <span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_VALUE</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a === <span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_VALUE</span>)&#123;<br>        <span class="hljs-keyword">let</span> res = <span class="hljs-title function_">div</span>(<span class="hljs-title function_">add</span>(a,<span class="hljs-number">1</span>),b);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">add</span>(req,<span class="hljs-title function_">div</span>(<span class="hljs-title function_">minus</span>(a,<span class="hljs-title function_">mulit</span>(res,b)),b));<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">div</span>(a,b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结(4.1)</title>
    <link href="/2023/04/08/%E6%80%BB%E7%BB%93-4-1/"/>
    <url>/2023/04/08/%E6%80%BB%E7%BB%93-4-1/</url>
    
    <content type="html"><![CDATA[<h1 id="携程一面"><a href="#携程一面" class="headerlink" title="携程一面"></a>携程一面</h1><h2 id="介绍项目"><a href="#介绍项目" class="headerlink" title="介绍项目"></a>介绍项目</h2><h2 id="Redux的实现原理？"><a href="#Redux的实现原理？" class="headerlink" title="Redux的实现原理？"></a>Redux的实现原理？</h2><p><code>Redux</code> 的实现原理可以概括为：单一数据源、状态不可变、纯函数更新状态。</p><p>具体来说，<code>Redux</code> 将应用程序的状态存储在一个单一的对象中，称为<code>store</code>。这个<code>store</code>对象是只读的，应用程序的状态只能通过派发“action”来改变。每个“action”描述了应用程序中发生的某个事件，它包含一个类型和一些数据。当派发一个<code>action</code>时，<code>Redux</code> 会将当前的状态和“action”一起传递给一个“reducer”函数，这个函数根据“action”的类型来更新状态，并返回一个新的状态对象。<code>Redux</code> 的状态更新是纯函数式的，它不会直接修改原来的状态，而是返回一个新的状态对象，从而保证了状态的不可变性。</p><p><code>Redux</code> 还提供了一些辅助函数，如<code>connect</code>和<code>mapStateToProps</code>，用于将<code>store</code>中的状态映射到组件的属性中，并在状态变化时自动更新组件。这些函数也是基于纯函数的原理实现的。</p><h2 id="React-Hooks是什么？"><a href="#React-Hooks是什么？" class="headerlink" title="React Hooks是什么？"></a>React Hooks是什么？</h2><p>React Hooks 是 React 16.8 引入的新特性，它可以让函数组件拥有类组件的一些特性，如状态管理、副作用处理等。</p><p>在 React 16.7 之前，函数组件只能通过 props 传递数据和方法，无法保存状态，也无法使用类组件的生命周期方法和其他特性。但是，函数组件具有代码简洁、易于测试和重构的优势，因此在实际开发中使用较多。React Hooks 的出现，使得函数组件也能够方便地管理状态、访问上下文和处理副作用。</p><h2 id="React官方为什么推荐使用Hooks？"><a href="#React官方为什么推荐使用Hooks？" class="headerlink" title="React官方为什么推荐使用Hooks？"></a>React官方为什么推荐使用Hooks？</h2><p>React 官方推荐使用 Hooks 的原因主要有以下几点：</p><ol><li>更好的代码复用：使用 Hooks 可以将组件之间的状态和逻辑进行复用，避免了 HOC 和 render props 带来的嵌套和重复。</li><li>更好的组件结构：使用 Hooks 可以将组件的状态和逻辑进行拆分，使组件的结构更加清晰和简洁。</li><li>更好的性能优化：使用 Hooks 可以避免不必要的渲染，从而提高组件的性能。</li><li>更好的测试性：使用 Hooks 可以更方便地进行单元测试，避免了类组件中需要使用 Enzyme 等工具进行测试的情况。</li><li>更好的开发体验：使用 Hooks 可以减少代码量，提高开发效率，使代码更加易读、易懂。</li></ol><h2 id="为什么React-Hooks对代码的可维护性更强？"><a href="#为什么React-Hooks对代码的可维护性更强？" class="headerlink" title="为什么React Hooks对代码的可维护性更强？"></a>为什么React Hooks对代码的可维护性更强？</h2><p>React Hooks 可以提高代码的可读性、可维护性、可测试性和性能优化，从而使得项目的可维护性更强。</p><h2 id="常见的React-Hooks"><a href="#常见的React-Hooks" class="headerlink" title="常见的React Hooks?"></a>常见的React Hooks?</h2><ul><li>useState</li><li>useEffect</li><li>useRef</li><li>useContext</li><li>useReducer</li><li>useCallback</li><li>useMemo</li></ul><h2 id="为什么要在项目中使用useMemo？"><a href="#为什么要在项目中使用useMemo？" class="headerlink" title="为什么要在项目中使用useMemo？"></a>为什么要在项目中使用useMemo？</h2><p>在项目中使用 useMemo 的主要原因是优化组件的性能，避免不必要的计算和渲染，从而提高项目性能和用户体验。</p><p>useMemo 是一个 Hooks API，它可以缓存计算结果，只有在依赖项发生变化时才重新计算。这样可以避免在每次渲染时都进行昂贵的计算，从而提高组件的性能。</p><p>在项目中，使用 useMemo 可以优化以下情况：</p><ol><li>计算昂贵的函数结果：如果一个函数的计算结果很昂贵，但是这个结果只在某些依赖项发生变化时才需要重新计算，这时就可以使用 useMemo 缓存计算结果，避免不必要的计算。</li><li>避免不必要的渲染：如果一个组件的某个属性是通过复杂计算得到的，但是这个属性并不是组件状态的一部分，这时可以使用 useMemo 缓存属性值，避免不必要的渲染。</li><li>优化子组件的渲染：如果一个组件的某个属性是一个函数，这个函数返回一个组件，但是这个函数并不是组件状态的一部分，这时可以使用 useMemo 缓存函数结果，避免不必要的子组件渲染。</li></ol><h2 id="useMemo相当于是对状态进行了一次缓存吗？"><a href="#useMemo相当于是对状态进行了一次缓存吗？" class="headerlink" title="useMemo相当于是对状态进行了一次缓存吗？"></a>useMemo相当于是对状态进行了一次缓存吗？</h2><p>是的，useMemo 可以看作是对计算结果进行缓存，仅在依赖项发生变化时才会重新计算。</p><p>useMemo 接收两个参数：一个是计算函数，另一个是依赖项数组。当依赖项数组中的任意一个依赖项发生变化时，useMemo 会重新计算计算函数的结果。如果依赖项数组中的依赖项没有发生变化，则 useMemo 返回上一次缓存的结果。</p><p>通过使用 useMemo，可以避免在每次渲染时都进行昂贵的计算，提高组件的性能。在某些情况下，如果没有使用 useMemo，组件可能会进行大量的重复计算，导致性能下降。</p><p>此外，虽然 useMemo 可以优化组件的性能，但是过度使用 useMemo 也会带来一些问题，如增加内存占用和代码复杂度等。因此，在使用 useMemo 时需要根据实际情况进行权衡和调整。</p><h2 id="useEffect和useLayoutEffect的区别？"><a href="#useEffect和useLayoutEffect的区别？" class="headerlink" title="useEffect和useLayoutEffect的区别？"></a>useEffect和useLayoutEffect的区别？</h2><p>useEffect 和 useLayoutEffect 都是 React 的 Hooks API，它们的主要区别在于执行的时机和是否会阻塞浏览器渲染。</p><ol><li>执行时机：useEffect 是在组件渲染完成后异步执行的，而 useLayoutEffect 是在组件渲染完成后同步执行的。因此，useLayoutEffect 的执行优先级更高。</li><li>是否阻塞浏览器渲染：useEffect 不会阻塞浏览器渲染，而 useLayoutEffect 会阻塞浏览器渲染。因此，在使用 useLayoutEffect 时要注意避免长时间的计算和操作，以免影响用户体验。</li><li>使用场景：useEffect 适合处理副作用，如数据获取、订阅事件等。而 useLayoutEffect 适合处理需要同步更新 DOM 的操作，如计算 DOM 元素的大小和位置等。</li></ol><p>综上所述，useEffect 和 useLayoutEffect 在执行时机和是否阻塞浏览器渲染方面有所不同，需要根据实际情况选择使用。一般来说，如果需要同步更新 DOM，可以使用 useLayoutEffect，否则可以使用 useEffect。</p><h2 id="Node-js在搭建服务器的时候起了哪些作用？"><a href="#Node-js在搭建服务器的时候起了哪些作用？" class="headerlink" title="Node.js在搭建服务器的时候起了哪些作用？"></a>Node.js在搭建服务器的时候起了哪些作用？</h2><p>在搭建服务端时，Node.js 起到了以下几个作用：</p><ol><li>提供 Web 服务器：Node.js 提供了内置的 HTTP 模块，可以用来创建 Web 服务器。开发者可以使用该模块创建 HTTP 服务器，接收和处理客户端请求，并返回响应。</li><li>处理请求和响应：Node.js 可以用来处理客户端请求，解析请求头和请求体，提取参数和数据等。同时，Node.js 也可以用来构建响应，设置响应头和响应体，返回数据给客户端。</li><li>实现业务逻辑：Node.js 可以用来实现业务逻辑，如处理数据、验证用户信息、调用其他服务等。同时，Node.js 也可以用来调用第三方库和 API，实现更丰富的业务功能。</li><li>数据库交互：Node.js 可以用来与数据库进行交互，执行查询、插入、更新和删除操作等。Node.js 支持多种数据库，如 MongoDB、MySQL、PostgreSQL 等，可以根据实际需求选择合适的数据库。</li><li>处理并发请求：Node.js 的事件驱动和非阻塞 I&#x2F;O 特性，可以处理大量并发请求，提高服务器的性能和吞吐量。</li></ol><h2 id="JS的基本数据类型有哪些？"><a href="#JS的基本数据类型有哪些？" class="headerlink" title="JS的基本数据类型有哪些？"></a>JS的基本数据类型有哪些？</h2><p>Null、Undefined、Number、String、Boolean、Symbol、BigInt、Object。</p><h2 id="判断数据类型的方式有哪些？"><a href="#判断数据类型的方式有哪些？" class="headerlink" title="判断数据类型的方式有哪些？"></a>判断数据类型的方式有哪些？</h2><ul><li>typeof</li><li>constructor</li><li>instanceof</li><li>Object.prototype.toString.call</li></ul><h2 id="什么是原型？"><a href="#什么是原型？" class="headerlink" title="什么是原型？"></a>什么是原型？</h2><p>在JavaScript中，每个对象都有一个原型。原型是一个对象，它包含着对象的属性和方法。当我们访问一个对象的属性或方法时，如果该对象本身没有该属性或方法，JavaScript引擎会沿着对象的原型链查找，直到找到该属性或方法为止。原型是JavaScript实现继承的基础，可以通过原型链实现属性和方法的继承。</p><h2 id="new一个对象发生了什么？"><a href="#new一个对象发生了什么？" class="headerlink" title="new一个对象发生了什么？"></a>new一个对象发生了什么？</h2><ol><li>首先创建一个空的对象</li><li>将该对象的原型指向构造函数的prototype属性</li><li>将构造函数的this指向该对象并执行构造函数</li><li>如果构造函数返回一个基本数据类型，则返回这个对象，否则返回构造函数返回的引用数据类型对象。</li></ol><h2 id="引入模块的两种方式？"><a href="#引入模块的两种方式？" class="headerlink" title="引入模块的两种方式？"></a>引入模块的两种方式？</h2><ul><li><p>ES6导入导出模块方式：<code>import</code>和<code>export</code>。</p><ul><li><p><code>import</code>：在一个模块中引入另一个模块的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> defaultExport <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> name <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; export1 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; export1 <span class="hljs-keyword">as</span> alias1 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; export1 , export2 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; export1 , export2 <span class="hljs-keyword">as</span> alias2 , [...] &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> defaultExport, &#123; export1 [ , [...] ] &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> defaultExport, * <span class="hljs-keyword">as</span> name <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li><code>defaultExport</code>表示模块的默认输出</li><li><code>name</code>表示模块的命名输出</li><li><code>export1</code>表示模块的具名输出</li></ul></li><li><p><code>export</code>：用于在一个模块中导出内容，让其他模块可以引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> expression;<br><span class="hljs-keyword">export</span> &#123; name1, name2, …, nameN &#125;;<br><span class="hljs-keyword">export</span> &#123; variable1 <span class="hljs-keyword">as</span> name1, variable2 <span class="hljs-keyword">as</span> name2, …, nameN &#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> name1, name2, …, nameN; <span class="hljs-comment">// also var</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> name1 = value1, name2 = value2, …, nameN = valueN;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span> &#123;...&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">FunctionName</span>(<span class="hljs-params"></span>)&#123;...&#125;<br></code></pre></td></tr></table></figure><ul><li><code>defalut</code>表示模块的默认输出</li><li><code>name</code>等表示模块的具名输出</li></ul></li></ul></li><li><p>CommonJS主要用于服务端的JS编程，<code>require()</code>导入模块，<code>module.exports</code>或<code>exports</code>导出模块。</p><ul><li><p><code>require()</code>导入模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;module-name&quot;</span>);<br></code></pre></td></tr></table></figure><p><code>module-name</code>为要导出的模块名</p></li><li><p><code>module.exports</code>或<code>exports</code>导出模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = value;<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">name</span> = values;<br></code></pre></td></tr></table></figure><p>其中<code>value</code>为要导出的值，可以是任意类型的值，包括对象、函数、字符串、数字等。</p></li></ul><p>需要注意的是，<code>module.exports</code>是直接将一个对象赋值给<code>exports</code>，而<code>exports</code>只是对<code>module.exports</code>的一个引用，因此可以使用<code>exports</code>导出多个属性，但不能使用<code>exports</code>直接覆盖<code>module.exports</code>。</p></li></ul><h2 id="ES6和CommonJS引入模块的区别？"><a href="#ES6和CommonJS引入模块的区别？" class="headerlink" title="ES6和CommonJS引入模块的区别？"></a>ES6和CommonJS引入模块的区别？</h2><ol><li><p>语法不同：</p><p>ES6使用<code>import</code>和<code>export</code>来导入和导出模块，而CommonJS使用<code>require()</code>和<code>module.exports</code>或<code>exports</code>来导入和导出模块。</p></li><li><p>加载方式不同：</p><p>ES6采用静态编译方式，在编译时就确定模块的依赖关系，然后再进行模块的加载。而CommonJS采用动态加载方式，在运行时根据代码需要动态加载模块。</p></li><li><p>可以导出的内容不同：</p><p>ES6中可以导出的内容包括变量、函数、类等，而CommonJS中只能导出对象。</p></li><li><p>作用域不同：</p><p>ES6中的模块是静态的，每个模块都有自己的作用域，不会污染全局作用域，而CommonJS中的模块是动态的，导出的对象是引用类型，会污染全局作用域。</p></li></ol><h2 id="ES6有哪些新特性？"><a href="#ES6有哪些新特性？" class="headerlink" title="ES6有哪些新特性？"></a>ES6有哪些新特性？</h2><ul><li><p>块级作用域：let和const</p></li><li><p>箭头函数</p></li><li><p>模板字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;XiaoMing&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`My name is <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br></code></pre></td></tr></table></figure></li><li><p>拓展运算符</p></li><li><p>类和继承 (<code>class</code>)</p></li><li><p>模块化：<code>import</code>和<code>export</code></p></li><li><p>Promise和async&#x2F;await</p></li><li><p>Symbol、BigInt</p></li><li><p>数组新增方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>() <span class="hljs-comment">// 将类数组对象or可迭代对象转换为数组</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>() <span class="hljs-comment">// 根据传入的参数创建一个数组</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">find</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">findIndex</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">fill</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">keys</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">values</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">includes</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">copyWithin</span>() <span class="hljs-comment">// 将数组的一部分复制到另一部分</span><br></code></pre></td></tr></table></figure></li><li><p>对象新增方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>()<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>()<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>()<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entires</span>() <span class="hljs-comment">// 返回一个数组，包含自身所有可枚举属性的键值对</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>() <span class="hljs-comment">// 返回一个对象，包含指定对象所有属性的描述符</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>() <span class="hljs-comment">// 冻结对象，使其属性不可修改、添加或删除</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">seal</span>() <span class="hljs-comment">// 封闭对象，使其属性不可添加或删除，但是可以修改</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>() <span class="hljs-comment">// 用于比较两个值是否完全相同</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="移动端epx-移动端适配-问题如何解决？"><a href="#移动端epx-移动端适配-问题如何解决？" class="headerlink" title="移动端epx(移动端适配)问题如何解决？"></a>移动端epx(移动端适配)问题如何解决？</h2><ul><li>使用em&#x2F;rem等单位设置元素尺寸</li><li>使用vw和vh单位</li><li>第三方库(lib-flexible、amfe-fiexible等)进行解决，这些库会根据屏幕像素密度和屏幕尺寸等信息自动计算出合适的rem值，从而解决移动端epx问题。</li></ul><h2 id="HTTP和HTTPS的区别？"><a href="#HTTP和HTTPS的区别？" class="headerlink" title="HTTP和HTTPS的区别？"></a>HTTP和HTTPS的区别？</h2><ul><li>HTTP是超文本传输协议，采用明文传输，而HTTPS采用SSL进行了数据加密，保证了数据的安全性</li><li>HTTP使用的是80端口，HTTPS是443端口</li><li>HTTPS需要数字证书，用于验证服务器身份和保证通信安全性</li><li>HTTPS加密和解密过程需要消耗更多计算资源，更加消耗性能</li><li>HTTPS的数据不容易被存储，因为每个请求和响应都需要加密和解密，而HTTP的数据易于被存储，可以提高访问速度。</li></ul><h2 id="302状态码是什么意思？和301有什么区别？"><a href="#302状态码是什么意思？和301有什么区别？" class="headerlink" title="302状态码是什么意思？和301有什么区别？"></a>302状态码是什么意思？和301有什么区别？</h2><p>302表示临时重定向，表示所请求的资源临时转移到了另一个URL上面。</p><p>301状态码表示永久重定向，告诉客户端所请求的资源已经被永久移动到了新的位置，以后应该使用新的URL访问，它会在响应头的Location字段中存储新的URL，浏览器收到后会对新的URL进行缓存，在以后的请求中会自动使用新的URL而不是旧的URL。</p><p>302状态码表示临时重定向，告诉客户端所请求的资源已经被临时移动到了新的位置，但以后还是应该使用原来的URL访问，浏览器在以后的请求中仍然会使用原来的URL，需要再次请求服务器获取新的URL。</p><h2 id="什么是防抖和节流？"><a href="#什么是防抖和节流？" class="headerlink" title="什么是防抖和节流？"></a>什么是防抖和节流？</h2><p>防抖：一个事件在触发n秒之后再进行执行，如果重复进行请求则重新进行计时。</p><p>节流：一个事件在一段时间内只能执行一次，如果多次触发也只会执行一次。</p><h2 id="手写防抖"><a href="#手写防抖" class="headerlink" title="手写防抖"></a>手写防抖</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> args = [...<span class="hljs-variable language_">arguments</span>], context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">if</span>(timer) &#123;<br>            <span class="hljs-built_in">clearTimeout</span>(timer);<br>            timer = <span class="hljs-literal">null</span>;<br>        &#125;<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            fn.<span class="hljs-title function_">apply</span>(context, args);<br>        &#125;, wait);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueArr</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">const</span> newArr = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(arr.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item1</span> =&gt;</span> item1 === item) === index) &#123;<br>            <span class="hljs-keyword">return</span> item;<br>        &#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> newArr;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法总结</title>
    <link href="/2023/04/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="常见的排序算法"><a href="#常见的排序算法" class="headerlink" title="常见的排序算法"></a>常见的排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><blockquote><p>冒泡排序(Bubble Sort)是一种最基础的排序方式，它的每个元素都可以像小气泡一样，根据自身大小一点点向数组的一侧移动</p></blockquote><p>冒泡排序<strong>每次比较相邻的两个节点</strong>，如果两个节点排序错误，将两个节点的位置调换，重复此步骤直到所有的元素归位。</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 冒泡排序</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">bubbleSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> len = arr.<span class="hljs-property">length</span>;<br>  <span class="hljs-comment">// 将元素按照从小到大的顺序排序</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; len;i++)&#123; <br>    <span class="hljs-comment">// 每次排序能确定一个元素的位置</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>;j &lt; len-i;j++)&#123;<br>      <span class="hljs-comment">// 当前面节点大于后面节点的时候</span><br>      <span class="hljs-comment">// 当一轮交换结束的时候，最大的元素一定在最后一位</span><br>      <span class="hljs-keyword">if</span>(arr[j-<span class="hljs-number">1</span>] &gt; arr[j])&#123;<br>          <span class="hljs-keyword">const</span> tmp = arr[j-<span class="hljs-number">1</span>];<br>          arr[j-<span class="hljs-number">1</span>] = arr[j];<br>          arr[j] = tmp;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。</p></blockquote><p>每次都从待排序的数据元素中选择出最小(或最大)的一个元素作为首元素，直到所有元素都排列完毕。</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">selectionSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> minIndex, temp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len-<span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-comment">// 在每次遍历中,将第一个元素设置为最小的元素</span><br>        minIndex = i;<br>        <span class="hljs-comment">// 遍历后面的元素,如果有比当前元素更小的元素,将其下标赋值给minIndex</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i+<span class="hljs-number">1</span>; j &lt; len; j++) &#123;<br>            <span class="hljs-keyword">if</span>(arr[j] &lt; arr[minIndex]) &#123;<br>                minIndex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果头一个元素不是最小元素,将其与后面最小元素交换位置</span><br>        <span class="hljs-keyword">if</span>(minIndex !== i) &#123;<br>            temp = arr[i];<br>            arr[i] = arr[minIndex];<br>            arr[minIndex] = temp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 返回排好序的arr</span><br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>插入排序，一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。</p></blockquote><p>每一步都将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素位置。</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">insertSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">// 每次进行排序的时候,0~i-1位置上一定是有序的</span><br>    <span class="hljs-comment">// 将当前元素进行比较并插入合适的位置</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">let</span> preIndex = i-<span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">let</span> current = arr[i]; <span class="hljs-comment">// 记录当前元素的值</span><br>        <span class="hljs-comment">// 将大于current的元素依次往后移,找到插入current的合适位置的时候停止</span><br>        <span class="hljs-keyword">while</span>(preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;<br>            arr[preIndex+<span class="hljs-number">1</span>] = arr[preIndex];<br>            preIndex--;<br>        &#125;<br>        <span class="hljs-comment">// 将current插入到合适的位置</span><br>        arr[preIndex+<span class="hljs-number">1</span>] = current;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p></blockquote><p>核心思想：分治，采用自上而下的递归方法</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">mergeSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> len = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">// 如果长度&lt;2, 无需进行排序</span><br>    <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr; <br>    <span class="hljs-comment">// 将数组从中间进行切割</span><br>    <span class="hljs-keyword">const</span> middle = len &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">const</span> left = arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, middle), right = arr.<span class="hljs-title function_">slice</span>(middle);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(<span class="hljs-title function_">mergeSort</span>(left), <span class="hljs-title function_">mergeSort</span>(right));<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">merge</span> = (<span class="hljs-params">left, right</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 存储最终结果的数组</span><br>    <span class="hljs-keyword">const</span> result = [];<br>    <span class="hljs-comment">// 比较left和right中的元素并将较小的先存入result中</span><br>    <span class="hljs-keyword">while</span>(left.<span class="hljs-property">length</span> &amp;&amp; right.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">if</span>(left[<span class="hljs-number">0</span>] &lt;= right[<span class="hljs-number">0</span>]) &#123;<br>            result.<span class="hljs-title function_">push</span>(left.<span class="hljs-title function_">shift</span>());<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            result.<span class="hljs-title function_">push</span>(right.<span class="hljs-title function_">shift</span>());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(left.<span class="hljs-property">length</span>) &#123;<br>        result.<span class="hljs-title function_">push</span>(left.<span class="hljs-title function_">shift</span>());<br>    &#125;<br>    <span class="hljs-keyword">while</span>(right.<span class="hljs-property">length</span>) &#123;<br>        result.<span class="hljs-title function_">push</span>(right.<span class="hljs-title function_">shift</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><blockquote><p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O(nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p></blockquote><p>根据键值的每位数字来分配桶</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">radixSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> []);<br>    <span class="hljs-keyword">let</span> maxDigit = (<span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...arr))).<span class="hljs-title function_">toString</span>().<span class="hljs-property">length</span> <span class="hljs-comment">// 取最大位数</span><br>    <span class="hljs-keyword">let</span> m = <span class="hljs-number">10</span>,n = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 取最大的数字的位数长度</span><br>    <span class="hljs-keyword">while</span>(maxDigit--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; arr.<span class="hljs-property">length</span>;i++)&#123;<br>            <span class="hljs-keyword">let</span> bucket = <span class="hljs-built_in">parseInt</span>((arr[i] % m) / n); <span class="hljs-comment">// 获取需要的位数</span><br>            ans[bucket].<span class="hljs-title function_">push</span>(arr[i]);<br>        &#125;<br>        <span class="hljs-keyword">let</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 将数组中的数字排序后重新放入arr数组中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; ans.<span class="hljs-property">length</span>;i++)&#123;<br>            <span class="hljs-keyword">let</span> value = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span>(ans[i].<span class="hljs-property">length</span> !== <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">while</span>((value = ans[i].<span class="hljs-title function_">shift</span>()) != <span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-comment">// 当ans[i]中还有值</span><br>                    arr[pos++] = value;<br>                &#125;<br>            &#125;<br>        &#125;<br>        m *= <span class="hljs-number">10</span>;<br>        n *= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><blockquote><p>桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后依次把各个桶中的记录列出来记得到有序序列。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ(n)）。但桶排序并不是比较排序，他不受到O(n log n)下限的影响。</p></blockquote><p>将元素分布在桶中：</p><p><img src="http://dawning.fun/wp-content/uploads/2022/11/Bucket_sort_1.svg_.png" alt="img"></p><p>然后，将每个桶中的元素进行排序：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_2.svg_.png" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">bucketSort</span> = (<span class="hljs-params">arr, bucketSize</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-keyword">let</span> minValue = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> maxValue = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 获取数据的最大值和最小值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span>(arr[i] &lt; minValue) &#123;<br>            minValue = arr[i];<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[i] &gt; maxValue) &#123;<br>            maxValue = arr[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 进行桶的初始化</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DEFAULT_BUCKET_SIZE</span> = <span class="hljs-number">5</span>; <span class="hljs-comment">// 设置桶的默认数量为5</span><br>    bucketSize = bucketSize || <span class="hljs-variable constant_">DEFAULT_BUCKET_SIZE</span>; <span class="hljs-comment">// 如果函数没有传值就将桶的默认数量设置为5</span><br>    <span class="hljs-keyword">const</span> bucketCount = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((maxValue - minValue) / bucketSize) + <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">const</span> buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(bucketCount).<span class="hljs-title function_">fill</span>([]);<br>    <span class="hljs-comment">// 利用映射函数将数据分配到各个桶中</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>        buckets[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((arr[i] - minValue) / bucketSize)].<span class="hljs-title function_">push</span>(arr[i]);<br>    &#125;<br>    arr.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; buckets.<span class="hljs-property">length</span>; i++)&#123;<br>        <span class="hljs-title function_">insertSort</span>(buckets[i]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; bucketCount[i].<span class="hljs-property">length</span>; i++) &#123;<br>            arr.<span class="hljs-title function_">push</span>(buckets[i][j]);;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序由于排序效率在同为<code>O(N*logN)</code>的几种排序方法中效率较高，因此经常被采用。快速排序的思想为——分治法。在快速排序中，一般选中第一个元素作为基准点<code>pivot</code>，定义<code>l</code>和<code>r</code>两个指针分别从数组的两边遍历，当从右边找到比<code>pivot</code>大的数字时，停止移动，再从左边找到比<code>pivot</code>小的元素，将两者进行交换，然后继续移动指针。</p><p>当移动到同一位置的时候，将该位置与基准点元素<code>pivot</code>进行交换，然后对<code>pivot</code>两边的元素进行如上遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @每次找一个基准点pivot，小于pivot的放在左边，大于pivot的放在右边，然后对左右进行同样的操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number[]</span>&#125; arr </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">quickSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-title function_">quick</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">quick</span> = (<span class="hljs-params">arr, start, end</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span>(start &gt; end) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">const</span> pivot = arr[start];<br>    <span class="hljs-keyword">let</span> l = start, r = end;<br>    <span class="hljs-keyword">while</span>(l !== r) &#123;<br>        <span class="hljs-keyword">while</span>(arr[r] &gt;= pivot &amp;&amp; l !== r) r--;<br>        <span class="hljs-keyword">while</span>(arr[l] &lt;= pivot &amp;&amp; l !== r) l++;<br>        <span class="hljs-keyword">if</span>(l !== r) &#123;<br>            <span class="hljs-keyword">const</span> temp = arr[l];<br>            arr[l] = arr[r];<br>            arr[r] = temp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(arr[l] &gt; pivot) l--;<br>    arr[start] = arr[l];<br>    arr[l] = pivot;<br>    <span class="hljs-title function_">quick</span>(arr, start, l-<span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">quick</span>(arr, l+<span class="hljs-number">1</span>, end);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单边快速排序"><a href="#单边快速排序" class="headerlink" title="单边快速排序"></a>单边快速排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; start </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; end </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">quickSort</span> = (<span class="hljs-params">arr, start, end</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span>(start &gt;= end) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 排序并得到基准元素</span><br>    <span class="hljs-keyword">let</span> pivotIndex = <span class="hljs-title function_">partition</span>(arr, start, end);<br>    <span class="hljs-comment">// 根据基准元素分成两部分并进行递归排序</span><br>    <span class="hljs-title function_">quickSort</span>(arr, start, pivotIndex-<span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">quickSort</span>(arr, pivotIndex+<span class="hljs-number">1</span>, end);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; start </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; end </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">partition</span> = (<span class="hljs-params">arr, start, end</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 取第一个位置的元素作为基准点</span><br>    <span class="hljs-keyword">let</span> pivot = arr[start];<br>    <span class="hljs-keyword">let</span> mark = start; <span class="hljs-comment">// 标记元素,用于交换</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = start+<span class="hljs-number">1</span>; i &lt;= end; i++) &#123;<br>        <span class="hljs-keyword">if</span>(arr[i] &lt; pivot) &#123; <span class="hljs-comment">// 当遍历到比基准元素小的元素,mark+1,将当前元素和基准元素交换位置</span><br>            mark++;<br>            <span class="hljs-keyword">let</span> tmp = arr[mark];<br>            arr[mark] = arr[i];<br>            arr[i] = tmp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 遍历完毕的时候,mark及其左边元素都小于基准点,mark右边都大于基准点</span><br>    arr[start] = arr[mark];<br>    arr[mark] = pivot;<br>    <span class="hljs-keyword">return</span> mark;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">main</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-title function_">quickSort</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h2><p>鸡尾酒排序又称双向冒泡排序、鸡尾酒搅拌排序、搅拌排序、涟漪排序、来回排序或快乐小时排序, 是冒泡排序的一种变形。该算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。</p><p><img src="https://pic4.zhimg.com/v2-f9716c786a05cb28547440f12e337a0b_b.webp" alt="动图"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @鸡尾酒排序与冒泡排序类似，不同的是冒泡排序是按照一种顺序进行是，而鸡尾酒是从两边轮流进行交换</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">cocktailSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(arr.<span class="hljs-property">length</span>/<span class="hljs-number">2</span>); i++) &#123;<br>        <span class="hljs-comment">// 使用isSorted标记是否进行交换顺序，如果没有进行交换，说明顺序已经符合要求，直接跳出循环</span><br>        <span class="hljs-keyword">let</span> isSorted = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 奇数轮的遍历，从左往右进行比较</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j &lt; arr.<span class="hljs-property">length</span>-i-<span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;<br>                tmp = arr[j];<br>                arr[j] = arr[j+<span class="hljs-number">1</span>];<br>                arr[j+<span class="hljs-number">1</span>] = tmp;<br>                isSorted = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        isSorted = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 重置isSorted</span><br>        <span class="hljs-comment">// 偶数轮的遍历，从右往左进行比较</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = arr.<span class="hljs-property">length</span>-i-<span class="hljs-number">1</span>; j &gt;= i; j--) &#123;<br>            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j-<span class="hljs-number">1</span>]) &#123;<br>                tmp = arr[j];<br>                arr[j] = arr[j-<span class="hljs-number">1</span>];<br>                arr[j-<span class="hljs-number">1</span>] = tmp;<br>                isSorted = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isSorted) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序（HeapSort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p><img src="https://pic3.zhimg.com/v2-b7907d351809293c60658b0b87053c66_b.webp" alt="动图"></p><p>传入一个数组，将其从最下面的非叶子结点进行排序，依次向上调整为最大堆，每次将顶上最大的数取出来放在数组res中，然后重新调整为最大堆，再取出最大的数放在res中…重复以上过程直到arr为空。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @堆排序</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr 要进行排序的数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">main</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> res = []; <span class="hljs-comment">// 存储排序后的结果</span><br>    <span class="hljs-title function_">buildHeap</span>(arr); <span class="hljs-comment">// 构建大根堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = n-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-title function_">swap</span>(arr, <span class="hljs-number">0</span>, i); <span class="hljs-comment">// 将最大值(顶点)交换到最后一个位置</span><br>        res.<span class="hljs-title function_">unshift</span>(arr.<span class="hljs-title function_">pop</span>()); <span class="hljs-comment">// 将最大值取出</span><br>        <span class="hljs-title function_">heapify</span>(arr, <span class="hljs-number">0</span>); <span class="hljs-comment">// 对大根堆进行自上而下重新调整(下一个最大值一定是根节点的两个孩子之一，因此从顶点进行调整即可)</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @构建大根堆</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr 要构建大根堆的数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">buildHeap</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">// 自下而上进行调整</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(n/<span class="hljs-number">2</span>)-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-title function_">heapify</span>(arr, i);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @调整大根堆</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr 进行大根堆调整的数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; index 要调整的节点下标</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">heapify</span> = (<span class="hljs-params">arr, index</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前节点的左子节点</span><br>    <span class="hljs-keyword">while</span>(left &lt; n) &#123;<br>        <span class="hljs-keyword">let</span> largest = index; <span class="hljs-comment">// 记录最大值下标,初始设置为当前节点</span><br>        <span class="hljs-comment">// 比较左右节点找出较大的节点</span><br>        largest = (left+<span class="hljs-number">1</span> &lt; n &amp;&amp; arr[left+<span class="hljs-number">1</span>] &gt; arr[left]) ? left+<span class="hljs-number">1</span> : left;<br>        <span class="hljs-comment">// 比较左右节点中较大的一个和当前节点</span><br>        largest = arr[largest] &gt; arr[index] ? largest : index;<br>        <span class="hljs-keyword">if</span>(largest === index) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 当前堆为大根堆，不需要继续调整 </span><br>        <span class="hljs-comment">// 子节点中存在比index节点大的值,继续向下调整</span><br>        <span class="hljs-title function_">swap</span>(arr, index, largest);<br>        index = largest;<br>        left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @对数组两个位置的值进行交换</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; i </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; j </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">swap</span> = (<span class="hljs-params">arr, i, j</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> tmp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>小根堆进行排序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">main</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-title function_">buildHeap</span>(arr);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = n-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-title function_">swap</span>(arr, <span class="hljs-number">0</span>, i);<br>        res.<span class="hljs-title function_">unshift</span>(arr.<span class="hljs-title function_">pop</span>());<br>        <span class="hljs-title function_">heapify</span>(arr, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">buildHeap</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(n/<span class="hljs-number">2</span>)-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-title function_">heapify</span>(arr, i);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; index </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">heapify</span> = (<span class="hljs-params">arr, index</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt; n) &#123;<br>        <span class="hljs-keyword">let</span> least = index;<br>        least = (left+<span class="hljs-number">1</span> &lt; n &amp;&amp; arr[left+<span class="hljs-number">1</span>] &lt; arr[left]) ? left+<span class="hljs-number">1</span> : left;<br>        least = (arr[least] &lt; arr[index]) ? least : index;<br>        <span class="hljs-keyword">if</span>(least === index) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-title function_">swap</span>(arr, index, least);<br>        index = least;<br>        left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @对数组两个位置的值进行交换</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; i </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; j </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">swap</span> = (<span class="hljs-params">arr, i, j</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> tmp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结(3.1)</title>
    <link href="/2023/04/08/%E6%80%BB%E7%BB%93-3-1/"/>
    <url>/2023/04/08/%E6%80%BB%E7%BB%93-3-1/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS常见的行内元素和块级元素？它们有什么区别？"><a href="#CSS常见的行内元素和块级元素？它们有什么区别？" class="headerlink" title="CSS常见的行内元素和块级元素？它们有什么区别？"></a>CSS常见的行内元素和块级元素？它们有什么区别？</h2><p><strong>行内元素：</strong>行内元素与其他行内元素并排，不能设置宽高，宽度默认为文字的宽度。</p><p><strong>块级元素：</strong>块级元素霸占一行，不能与其他任何元素并列，能接受宽高，如果不设置宽度，那么宽度将默认变为父级的100%。</p><p>常见的行内元素有：button、input、label、select、textarea、a、img、span、script等。</p><p>常见的块级元素有：div、section、p、table、form、header、footer、h1~h6、aside、canvas、ol、ul等。</p><p>CSS中，块级元素和行内元素的区别在于：</p><ul><li>块级元素独占一行，不能与其他任何元素并列；行内元素可以与其他行内元素并排。</li><li>块级元素可以设置宽高，而行内元素不能设置宽高，宽度由内容撑开。</li></ul><h2 id="什么是回流和重绘？"><a href="#什么是回流和重绘？" class="headerlink" title="什么是回流和重绘？"></a>什么是回流和重绘？</h2><p>回流：当DOM节点中的部分或全部元素的尺寸、结构、布局等发生变化的时候，浏览器就会重新渲染部分或全部文档，这个过程称为回流。</p><p>重绘：页面中元素的样式发生变化，但是不影响其在文档流中的位置，浏览器就会对该元素进行重绘。</p><p>发生回流一定会引起重绘，但是重绘不一定会引起回流。</p><h2 id="在什么情况下会触发回流？"><a href="#在什么情况下会触发回流？" class="headerlink" title="在什么情况下会触发回流？"></a>在什么情况下会触发回流？</h2><ul><li>添加或删除可见的DOM元素</li><li>元素位置、尺寸(包括外边距、内边距、边框大小、高度和宽度等)发生变化</li><li>内容发生变化(例如文本变化或图片被另一个不同尺寸的图片取代)</li><li>页面一开始渲染</li><li>浏览器窗口尺寸变化(因为回流是根据视口的大小来计算元素的位置和大小的)</li></ul><h2 id="获取元素的offsetHeight等会触发回流吗？"><a href="#获取元素的offsetHeight等会触发回流吗？" class="headerlink" title="获取元素的offsetHeight等会触发回流吗？"></a>获取元素的offsetHeight等会触发回流吗？</h2><p>会。</p><p><code>offsetHeight</code> 是一个元素的实时高度，必须重排重绘以后才能得到，如果不提前进行重排重绘，<code>offsetHeight</code> 有可能拿到的是浏览器缓存队列没执行完的时候的值。</p><h2 id="什么是flex布局？"><a href="#什么是flex布局？" class="headerlink" title="什么是flex布局？"></a>什么是flex布局？</h2><p>flex为”弹性布局”，可以简便、完整、响应式的实现各种页面布局。它的所有子元素自动成为容器成员，称为flex项目的item。</p><p>容器中默认存在两条轴，主轴和交叉轴，呈90°的关系。项目默认沿主轴排列，通过<code>flelx-direction</code>来决定主轴方向。</p><h2 id="flex-1具体指的是什么？"><a href="#flex-1具体指的是什么？" class="headerlink" title="flex: 1具体指的是什么？"></a>flex: 1具体指的是什么？</h2><ul><li><code>flex-grow: 1</code> (默认为0) ：表示元素的放大比例</li><li><code>flex-shrink: 1</code> (默认为1) ：表示元素的缩小比例</li><li><code>flex-basis: 0%</code> (默认为auto) ：元素本身的大小，这个属性定义了在分配多余空间之前，元素占据的主轴空间。浏览器根据这个属性计算是否有多余空间。</li></ul><h2 id="如何进行移动端适配？"><a href="#如何进行移动端适配？" class="headerlink" title="如何进行移动端适配？"></a>如何进行移动端适配？</h2><ul><li>rem布局</li><li>vw&#x2F;vh布局</li><li>百分比布局</li><li>响应式布局</li></ul><h2 id="em和rem的区别？"><a href="#em和rem的区别？" class="headerlink" title="em和rem的区别？"></a>em和rem的区别？</h2><p>em和rem都是相对单位长度</p><p>em是相对于父元素的字体大小来计算元素的大小</p><p>rem是相对于根元素的字体大小来计算元素的大小</p><h2 id="什么是vw和vh"><a href="#什么是vw和vh" class="headerlink" title="什么是vw和vh?"></a>什么是vw和vh?</h2><p>vw和vh是CSS3引入的视口单位，是相对于视口的宽度和高度来计算元素的大小。</p><p>1vw等于视口宽度的1%，1vh等于视口高度的1%。除了vw和vh，还有vmin和vmax两个单位，vmin是vw和vh中较小的那个，vmax是vw和vh中较大的那个。</p><h2 id="什么是JS的事件机制？"><a href="#什么是JS的事件机制？" class="headerlink" title="什么是JS的事件机制？"></a>什么是JS的事件机制？</h2><p>JavaScript 事件机制描述的是事件在 DOM 里面的传递顺序，以及我们可以对这些事件做出如何的响应。</p><p>DOM事件流（event flow ）存在三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。</p><p>事件捕获（event capturing）： 通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始<strong>由外到内</strong>进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。</p><p>事件冒泡（dubbed bubbling）： 与事件捕获恰恰相反，事件冒泡顺序是<strong>由内到外</strong>进行事件传播，直到根节点。无论是事件捕获还是事件冒泡，它们都有一个共同的行为，就是事件传播，它就像一跟引线，只有通过引线才能将绑在引线上的鞭炮（事件监听器）引爆。</p><p>DOM标准事件流的触发的先后顺序为 ：<strong>先捕获再冒泡，即当触发dom事件时，会先进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡</strong>。</p><h2 id="代码输出"><a href="#代码输出" class="headerlink" title="代码输出"></a>代码输出</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">fun2</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br><br><span class="hljs-title function_">fun1</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);<br>&#125;, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>);<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">7</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="Promise常用的API？"><a href="#Promise常用的API？" class="headerlink" title="Promise常用的API？"></a>Promise常用的API？</h2><p>Promise.then、Promise.catch、Promise.finally、Promise.all、Promise.race</p><h2 id="Promise-all和Promise-race的区别？"><a href="#Promise-all和Promise-race的区别？" class="headerlink" title="Promise.all和Promise.race的区别？"></a>Promise.all和Promise.race的区别？</h2><p>Promise.all()和Promise.race()都是Promise的静态方法，用于处理多个Promise对象。它们的区别在于：</p><ul><li>Promise.all()会在多个promise全部resolve之后执行.then，而Promise.race()会在任何一个promise resolve后就会执行.then。</li><li>Promise.all()会等待所有的promise对象都resolve或有一个reject后才会执行.then，而Promise.race()只要有一个promise对象resolve或reject就会执行.then。</li><li>Promise.all()会返回所有Promise resolved后的结果数组或第一个rejected的Promise对象的报错信息。</li></ul><h2 id="Promise的错误在哪里进行捕捉"><a href="#Promise的错误在哪里进行捕捉" class="headerlink" title="Promise的错误在哪里进行捕捉?"></a>Promise的错误在哪里进行捕捉?</h2><p>Promise发生的错误可以在try…catch中捕获，也可以在.catch()中捕获。如果在try…catch中捕获，需要在Promise对象前加await关键字，否则无法捕获异步错误。如果在.catch()中捕获，需要在Promise对象后加.catch()方法。</p><h2 id="假设一个function中有多个Promise任务，然后有某个Promise发生了异常，如何准确判断是哪个Promise发生了异常？"><a href="#假设一个function中有多个Promise任务，然后有某个Promise发生了异常，如何准确判断是哪个Promise发生了异常？" class="headerlink" title="假设一个function中有多个Promise任务，然后有某个Promise发生了异常，如何准确判断是哪个Promise发生了异常？"></a>假设一个function中有多个Promise任务，然后有某个Promise发生了异常，如何准确判断是哪个Promise发生了异常？</h2><p>在reject()中进行处理</p><h2 id="bind、call和apply的区别？"><a href="#bind、call和apply的区别？" class="headerlink" title="bind、call和apply的区别？"></a>bind、call和apply的区别？</h2><ul><li><code>apply</code>接受两个参数，第一个参数是<code>this</code>的指向，第二个参数是函数接受的参数，以数组的形式传入，改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次。</li><li><code>call</code>方法的第一个参数也是<code>this</code>的指向，后面传入的是一个参数列表，跟<code>apply</code>一样，改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次。</li><li>bind方法和call很相似，第一参数也是<code>this</code>的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)，改变<code>this</code>指向后不会立即执行，而是返回一个永久改变<code>this</code>指向的函数。</li></ul><h2 id="箭头函数和普通函数的区别？"><a href="#箭头函数和普通函数的区别？" class="headerlink" title="箭头函数和普通函数的区别？"></a>箭头函数和普通函数的区别？</h2><ul><li>箭头函数不绑定this，会捕获其所在上下文的this作为自己的this。</li><li>箭头函数没有arguments对象，只能通过rest参数获取参数。</li><li>箭头函数不能使用yield命令，不能用作Generator函数。</li><li>箭头函数是匿名函数，不能用作构造函数，不可以使用new命令。</li></ul><h2 id="React函数组件和类组件的区别？"><a href="#React函数组件和类组件的区别？" class="headerlink" title="React函数组件和类组件的区别？"></a>React函数组件和类组件的区别？</h2><ul><li>类组件有生命周期，函数组件无生命周期</li><li>类组件调用setStatet管理state状态，函数组件使用useState</li><li>函数组件调用即是执行函数，类组件需要先将组件实例化，再调用实例对象的render方法</li><li>函数组件更加简洁易懂，容易被开发、理解和测试。</li></ul><h2 id="函数式组件用哪个hook模拟声明周期"><a href="#函数式组件用哪个hook模拟声明周期" class="headerlink" title="函数式组件用哪个hook模拟声明周期"></a>函数式组件用哪个hook模拟声明周期</h2><p>useEffect</p><h2 id="React-state更新机制"><a href="#React-state更新机制" class="headerlink" title="React state更新机制"></a>React state更新机制</h2><p>React中类组件的state是通过setState()方法来更新的。当执行setState()时，会将需要更新的state合并后放入状态队列，不会立即更新。React也正是通过状态队列实现了setState的异步更新，避免频繁的重复更新state。当React需要更新组件时，会将状态队列中的state合并后一次性更新组件，这样可以提高性能。</p><p>React函数组件中的state是通过useState()方法来更新的。useState()方法返回一个数组，第一个元素是当前state的值，第二个元素是更新state的函数。当执行更新state的函数时，会将需要更新的state合并后放入状态队列，不会立即更新。React也正是通过状态队列实现了useState的异步更新，避免频繁的重复更新state。当React需要更新组件时，会将状态队列中的state合并后一次性更新组件，这样可以提高性能。</p><p>在React18优化了批处理之后，state的更新都表现为异步的。</p><h2 id="React虚拟DOM的Diff算法？"><a href="#React虚拟DOM的Diff算法？" class="headerlink" title="React虚拟DOM的Diff算法？"></a>React虚拟DOM的Diff算法？</h2><p>React中的虚拟DOM和diff算法是为了提高渲染效率而设计的。虚拟DOM是一种编程概念，UI以一种理想化的、或者说“虚拟的”表现形式存在于内存中，而不是真实的DOM树。当状态发生变化时，React会通过diff算法比较新旧虚拟DOM树的差异，然后只更新需要更新的部分，从而避免了全量渲染，提高了渲染效率。</p><p>React中的diff算法是通过比较新旧虚拟DOM树的差异来确定需要更新的节点。diff算法会遍历新旧虚拟DOM树，对比它们的节点，然后根据节点的变化情况来更新真实DOM。React中的diff算法是基于两个假设：同一层级的两个节点可以通过唯一的id进行区分；同一层级的节点可以通过位置进行区分。React中的diff算法是一个递归算法，它会递归遍历新旧虚拟DOM树，对比它们的节点，然后根据节点的变化情况来更新真实DOM。如果两个节点不同，则会直接替换掉旧节点，如果两个节点相同，则会更新该节点。</p><p><strong>查找需要更新的节点是从尾节点找还是头节点找还是中间二分择半？</strong></p><p>React的Diff算法进行虚拟节点比较是从头部开始，然后依次向后比较，直到找到不同的节点位置。如果新旧虚拟节点的数量不同，则从尾部开始比较，直到找到不同的节点为止。</p><h2 id="useMemo和useCallback的区别？"><a href="#useMemo和useCallback的区别？" class="headerlink" title="useMemo和useCallback的区别？"></a>useMemo和useCallback的区别？</h2><p>二者都是用于缓存数据，优化性能的，它们接受到的参数是一样的，第一个参数表示回调函数，第二个参数表示依赖的数据。</p><p>共同作用：在依赖数据发生变化的时候，才会调用传进去的回调函数去重新计算结果，起到缓冲的作用。</p><p>区别：</p><ul><li><code>useMemo</code>缓存的结果是回调函数中return回来的值，主要用于缓存计算结果的值，应用场景如需要计算的状态。</li><li><code>useCallback</code>缓存的结果是函数，主要用于缓存函数，应用场景如需要缓存的函数，因为函数式组件每次任何一个state发生变化都会触发整个组件更新，一些函数是没有必要更新的，此时就应该缓存起来，提高性能，减少对资源的浪费。<code>useCallback</code>应该和<code>React.memo</code>配套使用，缺少一个可能会导致性能不升反降。</li></ul><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useState, useMemo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Info</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">const</span> [info, setInfo] = <span class="hljs-title function_">useState</span>(&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;LiHua&quot;</span>,<br>        <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;male&quot;</span><br>    &#125;);<br>    <span class="hljs-comment">// 翻译性别的函数</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">formatGender</span> = (<span class="hljs-params">gender</span>) =&gt; &#123;<br>        <span class="hljs-keyword">return</span> gender === <span class="hljs-string">&quot;male&quot;</span> ? <span class="hljs-string">&quot;男&quot;</span> : <span class="hljs-string">&quot;女&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果不使用useMemo,修改其他属性，也会导致formatGender方法的调用，浪费计算资源</span><br>    <span class="hljs-comment">// const gender = formatGender(info.gender);</span><br>    <span class="hljs-comment">// 仅当info.gender发生变化的时候才调用formatGender</span><br>    <span class="hljs-keyword">const</span> gender = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">formatGender</span>(info.<span class="hljs-property">gender</span>);<br>    &#125;, [info.<span class="hljs-property">gender</span>]);<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        姓名：&#123;info.name&#125; - 性别：&#123;gender&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onClick</span> = <span class="hljs-string">&#123;()</span> =&gt;</span> setInfo(...info, name: &quot;XiaoMing&quot;)&#125;</span><br><span class="language-xml">        &gt;点击修改姓名<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>useCallback是设计初衷是为了<strong>减少子组件的不必要重读渲染</strong>，优化思路主要有以下两种：</p><ul><li>减少render的次数</li><li>减少计算量</li></ul><p>在如下场景中</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-comment">// 不使用useCallback和memo的时候</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Comp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [dataA, setDataA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> [dataB, setDataB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickA</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataA</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickB</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataB</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Cheap</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickA&#125;</span>&gt;</span>组件Cheap: &#123;dataA&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Cheap</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Expensive</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickB&#125;</span>&gt;</span>组件Expensive: &#123;dataB&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Expensive</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述组件中，每当点击Cheap组件的时候，Expensive组件也会重新渲染，即使dataB没有发生变化，原因就是onClickB被重新定义，导致React在diff新旧组件的时候判定了组件发生了变化。</p><p>此时，useCallback和memo就发挥作用了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useCallback, useState, memo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Expensive</span>(<span class="hljs-params">&#123;onClick, name&#125;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Expensive渲染&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><span class="hljs-keyword">const</span> memoExpensive = <span class="hljs-title function_">memo</span>(<span class="hljs-title class_">Expensive</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cheap</span>(<span class="hljs-params">&#123;onClick, name&#125;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Cheap渲染&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Comp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [dataA, setDataA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> [dataB, setDataB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickA</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataA</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> onClickB = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">setDataB</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;, [])<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Cheap</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickA&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">组件Cheap:</span> $&#123;<span class="hljs-attr">dataA</span>&#125;`&#125; /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Expensive</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickB&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">组件Expensive:</span> $&#123;<span class="hljs-attr">data</span>&#125;`&#125; /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>memo与PureComponent类似，对传入组件的新旧数据进行浅比较，如果相同则不会触发渲染。</p><p>useCallback保证onClickB不会发生变化，此时点击Cheap组件不会触发Expensive组件的刷新，只有点击Expensive组件才会触发。在实现减少不必要渲染的优化过程中，useCallback和memo是一对利器。</p><h2 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h2><p>要求：使用React的hook实现一个useRequest</p><ul><li>展示loading效果后告诉用户后台正在处理请求</li><li>接口异常时要进行错误处理</li><li>缓存同一请求(非结果)</li></ul><h2 id="Redux使用流程及场景？"><a href="#Redux使用流程及场景？" class="headerlink" title="Redux使用流程及场景？"></a>Redux使用流程及场景？</h2><ol><li>安装Redux。</li><li>创建一个store，store是一个对象，它有四个方法：dispatch、subscribe、getState和replaceReducer。</li><li>定义action，action是一个普通的JavaScript对象，用来描述发生了什么。</li><li>定义reducer，reducer是一个纯函数，接收旧的state和action，返回新的state。</li><li>使用combineReducers将多个reducer合并成一个根reducer。</li><li>使用Provider组件将store传递给子组件。</li><li>在组件中使用connect函数连接store和组件。</li></ol><h2 id="有没有了解Mobx"><a href="#有没有了解Mobx" class="headerlink" title="有没有了解Mobx?"></a>有没有了解Mobx?</h2><h2 id="Webpack如何进行配置？"><a href="#Webpack如何进行配置？" class="headerlink" title="Webpack如何进行配置？"></a>Webpack如何进行配置？</h2><p>主要配置过相关loader</p><h2 id="Webpack中loader和plugin的区别？"><a href="#Webpack中loader和plugin的区别？" class="headerlink" title="Webpack中loader和plugin的区别？"></a>Webpack中loader和plugin的区别？</h2><ul><li>loader是一种打包方案，对于某一种类型文件它知道如何打包，帮助Webpack完成打包工作。loader就是一个单纯的文件转化过程。</li><li>plugin是一个扩展器，丰富Webpack本身，增强功能，针对的是在loader结束之后，Webpack打包的整个过程。plugin并不直接操作文件，而是基于事件机制工作，会监听Webpack打包过程中的某些事件钩子，执行任务。</li></ul><h2 id="浏览器缓存机制？"><a href="#浏览器缓存机制？" class="headerlink" title="浏览器缓存机制？"></a>浏览器缓存机制？</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>Cache-Control &#x2F; Expires</p><p> expires <code>http1.0</code>控制网页缓存的字段，其值为服务器返回该请求结果的到期时间，即再次发送请求，如果客户端的时间小于expires的值时，直接使用缓存结果</p><p> cache-control(优先级更大) http1.1中控制网页缓存，是最重要的规则</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>Etag If-None-Match &#x2F; Last-Midified If-Midified-Since</p><p> <code>Last-Modified / If-Modified-Since</code> 和 <code>Etag / If-None-Match</code> (后者优先级更高)</p><p> Last-Modified 服务器响应请求时，返回该文件资源在服务器内最后被修改的时间</p><p> If-Modified-Since 客户端再次发起请求时，携带上次请求返回的Last-Modified值，通过此字段告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据此字段值与该资源在服务器的最后被修改的时间做对比，若服务器的资源最后被修改的时间大于If-Modified-Since字段值，则重新返回资源，状态码为200；否则返回304，代表资源无更新，可继续使用缓存文件</p><p> Etag 是服务区响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)</p><p> If-None-Match 服务器再次发起请求时，携带上次请求返回的唯一标识Etag，通过此字段告诉服务器该资源上次请求返回的唯一标识，服务器收到该请求后，发现请求头中含有If-None-Match的字段与该资源在服务器的Etag值进行比对，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码200</p><h2 id="前端常见的优化手段？"><a href="#前端常见的优化手段？" class="headerlink" title="前端常见的优化手段？"></a>前端常见的优化手段？</h2><p>常见的前端性能优化手段包括：减少请求数量、减小资源大小、优化网络连接、优化资源加载、减少重绘回流、使用性能更好的API和构建优化等。</p><p>其中，减少请求数量可以通过合并CSS和JS文件、使用CSS Sprites技术、使用字体图标等方式来实现；减小资源大小可以通过压缩CSS、JS和图片等方式来实现；优化网络连接可以通过使用CDN、开启Gzip压缩等方式来实现；优化资源加载可以通过使用预加载、懒加载等方式来实现；减少重绘回流可以通过避免频繁操作DOM、使用CSS3动画等方式来实现；使用性能更好的API可以通过使用requestAnimationFrame代替setTimeout、使用Web Workers等方式来实现；构建优化可以通过使用Webpack等打包工具进行代码分割、按需加载等方式来实现。</p><p>七大优化手段：<a href="https://juejin.cn/post/7016868803069886471">https://juejin.cn/post/7016868803069886471</a></p><h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>闭包是指一个函数能够访问其他函数内部变量的函数。在JavaScript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数”。</p><p>闭包的优点是可以保护变量不被污染，同时也可以实现数据私有化。缺点是会占用更多的内存空间，同时也会增加代码的复杂度。</p><h2 id="React过期闭包了解过吗？"><a href="#React过期闭包了解过吗？" class="headerlink" title="React过期闭包了解过吗？"></a>React过期闭包了解过吗？</h2><p>React过期闭包是指在使用React Hook时，由于函数组件多次render之间，函数的闭包可能会包住过期的上下文，也就是之前render时的上下文。这个问题在应用Hooks更突出。</p><p>React解决过期闭包问题的方法是依赖数组。针对过期state，可以使用函数的方法更新值。React确保通过更新函数可以得到最新的state值。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结(2.1)</title>
    <link href="/2023/04/08/%E6%80%BB%E7%BB%93-2-1/"/>
    <url>/2023/04/08/%E6%80%BB%E7%BB%93-2-1/</url>
    
    <content type="html"><![CDATA[<h2 id="进程和线程的概念及区别"><a href="#进程和线程的概念及区别" class="headerlink" title="进程和线程的概念及区别"></a>进程和线程的概念及区别</h2><p>进程是对正在运行中的程序的一个抽象，是系统进行资源分配和调度的基本单位。</p><p>线程是CPU任务调度和执行的基本单位。</p><p>区别：</p><ul><li>进程可以看作是一个独立应用，而线程不能。</li><li>进行是CPU进行资源分配的最小单位，而线程是CPU调度的最小单位。</li><li>线程间可以直接共享同一进程中的资源，而进程通信需要借助<strong>进程间通信</strong>。</li><li>进行切换的开销比线程切换的开销要大。线程的切换不会引起进程的切换，但某个进程中的线程切换到另一个进程中的线程会引起进程的切换。</li><li>撤销或创建进程的时候，系统要为之分配或回收资源，开销远大于创建或撤销线程时的开销。同样，进程切换的时候涉及到<strong>当前进程的CPU环境还有各种各样状态的保存及新调度进程状态的设置</strong>，而线程切换只需要保存和设置少量的寄存器内容，开销较小。</li></ul><h2 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h2><ul><li><p>管道通信</p><p>操作系统在内核中开辟一段缓冲区，进程A可以将需要交互的数据拷贝到这段缓冲区中，进程B就可以读取了。(只能单向通信，并只能在有血缘关系的进程间通信)</p></li><li><p>消息队列队列通信</p><p>消息队列就是一个消息的列表，用户可以在消息队列中添加消息、读取消息等。它提供了一种从一个进程向另一个进程发送数据块的方法。每个数据块都被认为含有一个类型，接收进程可以独立的接受含有不同类型的数据结构。但消息队列与命名管道一样，每个数据块都有一个<strong>最大长度的限制</strong>。</p></li><li><p>共享内存通信</p><p>共享内存就是映射了一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问(使多个进程可以访问同一块内存空间)。</p></li><li><p>信号量通信</p><p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。</p></li><li><p>信号通信</p><p>Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件(一组事件中的一个)，它也是用户进程间通信和同步的一种原始机制。</p></li><li><p>套接字通信</p><p>是计算机之间进行通信的一种约定或一种方式。</p></li></ul><h2 id="进程的状态有哪些？"><a href="#进程的状态有哪些？" class="headerlink" title="进程的状态有哪些？"></a>进程的状态有哪些？</h2><p>进程的状态通常分为五种基本状态：创建态、就绪态、运行态、阻塞态和终止态。</p><ul><li>创建态：进程刚被创建，但是还没有被操作系统调度执行。</li><li>就绪态：进程已经准备好运行，但是还没有被操作系统调度执行。</li><li>运行态：进程正在被操作系统调度执行。</li><li>阻塞态：进程因为某些原因而暂停执行，等待外部事件的发生。</li><li>终止态：进程已经完成了它的任务，或者因为某些原因被操作系统强制终止。</li></ul><h2 id="操作系统进程调度有哪几种？"><a href="#操作系统进程调度有哪几种？" class="headerlink" title="操作系统进程调度有哪几种？"></a>操作系统进程调度有哪几种？</h2><p>操作系统的进程调度的常见策略：</p><ul><li>先来先服务调度算法(FCFS)：按照进程到达的先后顺序进行调度，先到达的进程限制性，后到达的进程后执行。</li><li>短作业优先调度算法(SJF)：按照进程需要的CPU时间长短进行调度，即需要CPU时间最短的进程先执行。</li><li>优先级调度算法：按照进程的优先级进行调度，即优先级高的进程先执行。</li><li>时间片轮转调度算法：按照时间片轮流分配CPU时间进行调度，即每个进程分配一个时间片，当时间片用完后，该进程被挂起，等到下一次轮到它的时候再继续执行。</li><li>多级反馈队列算法：将就绪队列分成多个队列，每个队列有不同的优先级，每个队列采用不同的调度算法。新到达的进程首先放在第一级队列，如果该队列中没有可执行的进程，则将该队列放入第二级队列中等待执行。如果第一级队列中有可执行的进程，则按照时间片轮转调度算法去进行调度。如果一个进程再第一级队列中运行了一段时间仍然没有完成，则将其移动到第二级队列中等待执行，以此类推，直到该进程完成或被强制终止。</li></ul><h2 id="操作系统的堆区和栈区"><a href="#操作系统的堆区和栈区" class="headerlink" title="操作系统的堆区和栈区"></a>操作系统的堆区和栈区</h2><p>操作系统中的堆和栈都是指内存空间，不同的是堆为按需申请、动态分配，例如 C 中的 malloc 函数和 C++ 中的 new 操作。而栈是由编译器自动分配释放，存放函数的参数值，局部变量的值等。<br>堆和栈之间的区别主要有以下几点：</p><ul><li><p>分配方式：堆是动态分配的，而栈是静态分配的。</p></li><li><p>空间大小：堆的空间大小不确定，而栈的空间大小固定。</p></li><li><p>空间分配方式：堆是由程序员手动申请和释放，而栈是由编译器自动分配和释放。</p></li><li><p>空间使用方式：堆的空间可以随时申请和释放，而栈的空间只能在函数调用时申请，在函数返回时释放。</p></li></ul><h2 id="常见的数据结构有哪些？"><a href="#常见的数据结构有哪些？" class="headerlink" title="常见的数据结构有哪些？"></a>常见的数据结构有哪些？</h2><ul><li>数组 (Array)</li><li>队列 (Queue)</li><li>链表 (Linked List)</li><li>栈 (Stack)</li><li>树 (Tree)</li><li>散列表(Hash)</li><li>堆(Heap)</li><li>图 (Graph)</li></ul><h2 id="在JS中如何实现图结构？"><a href="#在JS中如何实现图结构？" class="headerlink" title="在JS中如何实现图结构？"></a>在JS中如何实现图结构？</h2><p>在JavaScript中，可以使用邻接表或邻接矩阵来实现图结构。其中，邻接表是一种链式存储方式，它将每个顶点的所有邻居顶点都存储在一个链表中。而邻接矩阵则是一个二维数组，其中每个元素表示两个顶点之间是否有边。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span> = []；<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()；<br>  &#125;<br><br>  <span class="hljs-title function_">addVertex</span>(<span class="hljs-params">v</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-title function_">push</span>(v)；<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">set</span>(v, [])；<br>  &#125;<br><br>  <span class="hljs-title function_">addEdge</span>(<span class="hljs-params">v, w</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(v).<span class="hljs-title function_">push</span>(w)；<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(w).<span class="hljs-title function_">push</span>(v)；<br>  &#125;<br><br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;&#x27;</span>；<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>； i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-property">length</span>； i++) &#123;<br>      s += <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.vertices[i]&#125;</span> -&gt; `</span>；<br>      <span class="hljs-keyword">const</span> neighbors = <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>[i])；<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>； j &lt; neighbors.<span class="hljs-property">length</span>； j++) &#123;<br>        s += <span class="hljs-string">`<span class="hljs-subst">$&#123;neighbors[j]&#125;</span> `</span>；<br>      &#125;<br>      s += <span class="hljs-string">&#x27;\n&#x27;</span>；<br>    &#125;<br>    <span class="hljs-keyword">return</span> s；<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Graph</span>()；<br><span class="hljs-keyword">const</span> vertices = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>]；<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>； i &lt; vertices.<span class="hljs-property">length</span>； i++) &#123;<br>  graph.<span class="hljs-title function_">addVertex</span>(vertices[i])；<br>&#125;<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;H&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>)；<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(graph.<span class="hljs-title function_">toString</span>())；<br></code></pre></td></tr></table></figure><h2 id="JS-DOM树用什么数据结构进行存储？"><a href="#JS-DOM树用什么数据结构进行存储？" class="headerlink" title="JS DOM树用什么数据结构进行存储？"></a>JS DOM树用什么数据结构进行存储？</h2><p>JavaScript的DOM树是以多叉树的形式存储的。DOM模型用一个逻辑树来表示一个文档，树的每个分支的终点都是一个节点(node)，每人节点都包含着对象(Obiects)。</p><h2 id="什么是哈希冲突？"><a href="#什么是哈希冲突？" class="headerlink" title="什么是哈希冲突？"></a>什么是哈希冲突？</h2><p>哈希冲突是指，当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象。在哈希表中，每个关键字都对应一个位置，但是不同的关键字可能会对应到相同的位置，这就是哈希冲突。哈希冲突的解决方法有很多种，其中比较常见的有链地址法和开放地址法。链地址法是将相同hash值的对象组织成一个链表放在hash值对应的槽位；开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。</p><h2 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h2><p>数组和链表是两种常见的数据结构。数组是一种线性数据结构，它在内存中占用一段连续的空间，每个元素都可以通过下标来访问。而链表则是一种非线性数据结构，它的元素在内存中不一定是连续的，每个元素都包含了指向下一个元素的指针。</p><p>因此，数组和链表有以下区别：</p><ul><li>数组在内存中占用一段连续的空间，而链表的元素在内存中不一定是连续的。</li><li>数组的元素可以通过下标来访问，而链表的元素只能通过指针来访问。</li><li>数组的大小是固定的，而链表的大小可以动态改变。</li><li>数组的插入和删除操作需要移动其他元素，时间复杂度为O(n)，而链表只需要改变指针指向，时间复杂度为0(1)。</li></ul><h2 id="数组和链表在内存分配上的区别？"><a href="#数组和链表在内存分配上的区别？" class="headerlink" title="数组和链表在内存分配上的区别？"></a>数组和链表在内存分配上的区别？</h2><p>数组和链表在内存分配上的区别是：</p><p>数组静态分配内存，链表动态分配内存；数组在内存中连续，链表不连续；数组元素在栈区，链表元素在堆区。此外，数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)； 数组插入或删除元素的时间复杂度0(n)，链表的时间复杂度0(1)。</p><h2 id="在使用JS进行开发的时候，什么情况下用数组存储数据-什么情况下用链表存储数据"><a href="#在使用JS进行开发的时候，什么情况下用数组存储数据-什么情况下用链表存储数据" class="headerlink" title="在使用JS进行开发的时候，什么情况下用数组存储数据? 什么情况下用链表存储数据?"></a>在使用JS进行开发的时候，什么情况下用数组存储数据? 什么情况下用链表存储数据?</h2><p>在使用JS进行开发时</p><p>使用数组存储数据的情况包括：需要快速访问元素，需要按照顺序存储元素，需要对元素进行排序或者操作，需要在数组中存储不同类型的数据等。</p><p>使用链表存储据的情况包括：需要动态添加或删除元素，不需要按照顺序存储元素，不需要快速访问元素等。</p><h2 id="JS中二叉树通过什么数据结构进行实现？"><a href="#JS中二叉树通过什么数据结构进行实现？" class="headerlink" title="JS中二叉树通过什么数据结构进行实现？"></a>JS中二叉树通过什么数据结构进行实现？</h2><p>在实现二叉树时，采用的存储结构为链式存储结构，链式结构的意思是采用一个链表来存储一颗二叉树，二叉树中每一个节点用链表的一个节点来存储，在二叉树中，节点结构至少有三个域：数据域data，左指针域left，右指针域right。</p><h2 id="栈和队列的特点及区别"><a href="#栈和队列的特点及区别" class="headerlink" title="栈和队列的特点及区别?"></a>栈和队列的特点及区别?</h2><p>栈和队列都是线性结构，但它们的特点和应用场景不同。栈是一种后进先出(LIFO)的数据结构，而队列是一种先进先出 (FIFO) 的数据结构。</p><p>栈和队列的区别在于它们的出入方式不同。栈是后进先出，队列是先进先出。在具体实现的时候操作的位置也不同:因为栈是后进先出，它在一端进行操作；而队列是先进先出，实现的时候在两端进行操作。</p><h2 id="OSI七层网络协议"><a href="#OSI七层网络协议" class="headerlink" title="OSI七层网络协议"></a>OSI七层网络协议</h2><p>OSI七层网络协议是一种通信协议的标准，它将计算机网络体系结构分为七个层次，每个层次都有自己的功能和任务。这些层次分别是：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p><p>物理层：负责传输比特流，即由1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换。<br>数据链路层：在计算机网络中由于各种干扰的存在，物理链路是不可靠的。该层的主要功能就是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。<br>网络层：负责数据包从源到宿的传递和网际互连。<br>传输层：负责向两台主机进程之间提供端到端的可靠数据传输服务。<br>会话层：负责建立、管理和终止会话。<br>表示层：负责数据格式转换、加密解密等。<br>应用层：为用户提供各种应用服务。</p><h3 id="HTTP属于哪层协议？"><a href="#HTTP属于哪层协议？" class="headerlink" title="HTTP属于哪层协议？"></a>HTTP属于哪层协议？</h3><p>应用层</p><h3 id="TCP和UDP属于哪层协议？"><a href="#TCP和UDP属于哪层协议？" class="headerlink" title="TCP和UDP属于哪层协议？"></a>TCP和UDP属于哪层协议？</h3><p>传输层</p><h2 id="TCP和UDP的区别？"><a href="#TCP和UDP的区别？" class="headerlink" title="TCP和UDP的区别？"></a>TCP和UDP的区别？</h2><p>TCP和UDP的区别如下:</p><ul><li>TCP是面向连接的，UDP是无连接的</li><li>TCP提供可靠的服务，UDP则不保证可靠交付数据 </li><li>TCP是一对一的两点服务，即一条连接只有两个端点。UDP支持一对一、一对多、多对多的交互通信</li><li>TCP有拥塞控制和流量控制机制，保证数据传输的安全性。UDP则没有，即使网络非常拥堵了，也不会影响UDP的发送速率</li><li>TCP首部长度较长，会有一定的开销，首部在没有使用[选项，字段时是20个字节，如果使用了[选项]字段则会变长。UDP首部只有8个字节，并且是固定不变的，开销较小。</li></ul><h2 id="TCP和UDP的应用场景？"><a href="#TCP和UDP的应用场景？" class="headerlink" title="TCP和UDP的应用场景？"></a>TCP和UDP的应用场景？</h2><p>TCP和UDP是两种不同的传输协议。TCP是面向连接的协议，而UDP是无连接的协议。TCP提供交付保证，这意味着一个使用TCP协议发送的消息是保证交付给客户端的，如果消息在传输过程中丢失，那么它将重发。而UDP不提供这种保证。因此，TCP适用于对准确性要求相对高的场景，如文件传输、发送或接收邮件、远程登录等，而UDP适用于对准确性要求相对低但速度要求相对高的场景，如即时通信、在线视频、网络语音电话等。</p><h2 id="TCP的三次挥手"><a href="#TCP的三次挥手" class="headerlink" title="TCP的三次挥手"></a>TCP的三次挥手</h2><p>TCP三次握手是TCP协议中用于在客户端和服务器之间建立连接的过程。三次握手的过程如下：</p><ol><li><p>客户端向服务器发送一个SYN包，其中标志位为SYN，表示请求建立连接，序号为Seq&#x3D;x(一般取随机数)。</p></li><li><p>服务器接收到客户端发来的SYN包后，对该包进行确认后结束LISTEN阶段，并返回一段TCP报文，其中标志位为SYN和ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接，序号为Seq&#x3D;y。</p></li><li><p>客户端接收到服务器发来的TCP报文后，对该报文进行确认，其中标志位为ACK，表示确认服务器的报文Seq序号有效，客户端能正常接收服务器发送的数据，并向服务器发送一段TCP报文，其中标志位为ACK，表示确认服务器的报文Seq序号有效。</p></li></ol><h2 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h2><p>TCP四次挥手是TCP协议中用于在客户端和服务器之间断开连接的过程。四次挥手的过程如下：</p><ol><li><p>客户端向服务器发送一个FIN包，其中标志位为FIN，表示请求断开连接，序号为Seq&#x3D;u。</p></li><li><p>服务器接收到客户端发来的FIN包后，对该包进行确认后结束ESTABLISHED阶段，并返回一段TCP抵文，其中标志位为ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并告诉客户端：我知道你想断开连接的请求了。</p></li><li><p>服务器向客户端发送一个FIN包，其中标志位为FIN，表示请求断开连接，序号为Seq&#x3D;V。</p></li><li><p>客户端接收到服务器发来的TCP报文后，对该报文进行确认，其中标志位为ACK，表示确认服务器的报文Seq序号有效，客户端能正常接收服务器发送的数据，并向服务器发送一段TCP报文，其中标志位为ACK，表示确认服务器的报文Seq序号有效。</p></li></ol><h2 id="TCP的三次握手为什么不能改成两次？"><a href="#TCP的三次握手为什么不能改成两次？" class="headerlink" title="TCP的三次握手为什么不能改成两次？"></a>TCP的三次握手为什么不能改成两次？</h2><p>TCP三次握手是TCP协议中用于在客户端和服务器之间建立连接的过程。其中，第一次握手是客户端向服务器发送一个SYN包，其中标志位为SYN，表示请求建立连接，序号为Seq&#x3D;x；</p><p>第二次握手是服务器接收到客户端发来的SYN包后，对该包进行确认后结束SYN_RECEIVED阶段，并返回一段TCP报文，其中标志位为SYN&#x2F;ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并告诉客户端:我知道你想建立连接的请求了，我的序号是Seq&#x3D;y；</p><p>第三次握手是客户端接收到服务器发来的TCP报文后，对该报文进行确认，其中标志位为ACK，表示确认服务器的报文Seq序号有效，客户端能正常接收服务器发送的数据，并告诉服务器:我知道你想建立连接的请求了，我的序号是Seq&#x3D;x+1。这样就完成了TCP三次握手过程。</p><p>如果采用两次握手，则<strong>只能确定从客户端到服务端的网络是可达的，但无法保证从服务端到客户端的网络是可达的</strong>。</p><p>此外，在采用两次握手时，如果已失效的连接请求报文段突然又传到了服务端，则会导致双方不一致，造成资源浪费。</p><h2 id="浏览器中输入网址并发起网络请求后都经历了什么？"><a href="#浏览器中输入网址并发起网络请求后都经历了什么？" class="headerlink" title="浏览器中输入网址并发起网络请求后都经历了什么？"></a>浏览器中输入网址并发起网络请求后都经历了什么？</h2><ol><li><p>首先判断输入的内容是否为合法的域名，如果不是则作为关键字交给搜索引擎进行处理；如果域名中有非法字符则进行转义。</p></li><li><p>首先判断浏览器中是否有所需资源的缓存，如果有则直接使用，否则进行DNS查询获取域名对应的IP地址。</p></li><li><p>DNS查询</p><ol><li><p>判断本地的DNS缓存中是否有该IP地址，如果命中则返回</p></li><li><p>如果还是没有命中，则将域名发送到本地域名服务器，本地域名服务器采用递归查询自己的DNS服务器，查找成功则返回。</p></li><li><p>如果本地域名服务器的DNS缓存没有命中，则向上级域名服务器进行迭代查询</p><ul><li><p>首先本地域名服务器向根域名服务器进行请求，获取顶级域名服务器的地址给本地服务器。</p></li><li><p>本地域名服务器拿到这个顶级域名服务器后就想起发送请求，获取权威域名服务器的地址。</p></li><li><p>本地域名服务器向权威域名服务器发送请求，获取域名对应的IP地址。</p></li></ul></li><li><p>本地域名服务器将得到的IP地址发送给操作系统，同时自己将IP地址缓存起来。</p></li><li><p>操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来。</p></li><li><p>至此，浏览器得到了域名对应的IP地址，并将IP地址缓存起来。</p></li></ol></li><li><p>通过IP地址与本地的子网掩码相与，判断是否与请求主机在一个子网中，如果在一个子网中，则使用ARP协议获取目标主机的MAC地址，如果不在一个子网中，那么请求应该转发给网关，由它代为转发，此时同样可以通过ARP协议获取网关MAC地址，此时目的主机的MAC地址应该为网关地址。</p></li><li><p>进行TCP的三次握手</p></li><li><p>进行HTTPS握手</p></li><li><p><strong>返回数据</strong>：将网页请求发送至服务器端，服务器端返回一个html文件作为响应。浏览器接受响应后，开始对html文件进行解析并开始页面的渲染过程。</p></li><li><p><strong>页面渲染</strong>：根据html文件构建DOM树，根据解析到的css构建CSSOM树，如果遇到script标签，则判断有无async和defer属性，否则script的加载和执行会造成页面渲染的阻塞。当DOM树和CSSOM树建立好后，根据他们构建渲染树。渲染树构建好后，根据渲染树进行布局，然后使用浏览器的UI接口对页面进行绘制。此时整个页面就显示出来了。</p></li><li><p>TCP四次挥手</p></li></ol><h2 id="什么是数据库的索引？"><a href="#什么是数据库的索引？" class="headerlink" title="什么是数据库的索引？"></a>什么是数据库的索引？</h2><p>数据库索引是一种数据结构，用于提高数据库表中数据的查询效率。索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。</p><p>在数据库中，索引类似于书籍的目录。如果您想查找书籍中的某个主题，您可以查找目录以找到该主题的页码，而不必翻阅整本书。同样，如果您想查找数据库表中的某个值，则可以使用索引来快速查找该值所在的行，而不必扫描整个表。</p><p>索引可以大大提高查询效率，但也会增加写入操作的时间和空间开销。因此，在设计数据库时，需要权衡查询效率和写入效率之间的平衡。</p><h2 id="数据库的索引有哪几种类型？"><a href="#数据库的索引有哪几种类型？" class="headerlink" title="数据库的索引有哪几种类型？"></a>数据库的索引有哪几种类型？</h2><p>数据库索引有多种类型，包括: 普通索引、唯一索引、主键索引、组合索引和全文索引等。</p><ul><li>普通索引：基本的索引类型，没有唯一性的限制，允许为NULL值。</li><li>唯一索引：数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</li><li>主键索引：主键是一种特殊的唯一索引，不允许为NULL值，一个表只能有一个主键</li><li>组合索引：将多个列作为一个索引建立，可以提高查询效率。</li><li>全文索引：用于全文搜索的特殊类型的索引。</li></ul><h2 id="什么是MySQL关联查询？"><a href="#什么是MySQL关联查询？" class="headerlink" title="什么是MySQL关联查询？"></a>什么是MySQL关联查询？</h2><p>MySQL关联查询是指在查询时，需要同时操作多张表来查询数据，即关联查询。MySQL关联查询的语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column name(s)<br>FROM tablel<br>JOIN table2<br>ON table1.column_name = table2.column_name;<br></code></pre></td></tr></table></figure><p>其中，<code>table1</code> 和 <code>table2</code> 是要连接的表的名称，column_name 是要检索的列的名称。JOIN关键字用于指定要连接的表，而关键字用于指定连接条件。</p><p>MySQL支持多种类型的关联查询，包括：内连接、左连接、右连接和全连接等。</p><h2 id="关系型数据库和非关系型数据库的区别？"><a href="#关系型数据库和非关系型数据库的区别？" class="headerlink" title="关系型数据库和非关系型数据库的区别？"></a>关系型数据库和非关系型数据库的区别？</h2><p>关系型数据库和非关系型数据库的区别在于，关系型数据库一般都是有固定的表结构，并且需要通知DDL语句来修改表结构，不是很容易进行扩展；而非关系型数据库的存储机制就有很多了，比如基于文档的，K-V键值对的，还有基于图的等，对于数据的格式十分灵活没有固定的表结构，方便扩展。因此<u>如果业务的数据结构并不是固定的或者经常变动比较大的，那么非关系型数据库是个好的选择</u>。</p><h2 id="关系型数据库与文档型数据库的区别？"><a href="#关系型数据库与文档型数据库的区别？" class="headerlink" title="关系型数据库与文档型数据库的区别？"></a>关系型数据库与文档型数据库的区别？</h2><p>关系型数据库（Relational Database）是建立在关系模型基础上的数据库，借助于几何代数等数学概念和方法来处理数据库中的数据。所谓关系模型是一对一、一对多或者多对多等关系，常见的关系型数据库有Oracle、SQL Server、DB2、MySQL等。</p><p>而文档型数据库是一种非关系型数据库，非关系型数据库（Not Only SQL，NoSQL）正好与关系型数据库相反，它不是建立在“关系模型”上的数据库。文档型数据库的典型代表是MongoDB。</p><h2 id="MongoDB和MySQL的区别"><a href="#MongoDB和MySQL的区别" class="headerlink" title="MongoDB和MySQL的区别"></a>MongoDB和MySQL的区别</h2><p>MongoDB是一种文档型数据库，而MySQL是一种关系型数据库。</p><p>MongoDB可以处理大量和非结构化数据量，而MySQL则<strong>缺乏处理大数据量的速度</strong>。因此，对于拥有较小数据库并寻求更通用解决方案的公司来说，MySQL可以胜任。</p><p>另外，MongoDB以一种直观文档的方式来完成数据的存储，它很像JavaScript中定义的JSON格式，不过数据在存储的时候MongoDB数据库为文档增加了序列化的操作，最终存进磁盘的其实是一种叫做BSON的格式，即Binary-JSON。</p><p>MySQL在<strong>处理关系数据方面具有更好的优势</strong>，而MongoDB则更能满足现代应用程序的需求。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结(1.1)</title>
    <link href="/2023/04/08/%E6%80%BB%E7%BB%93-1-1/"/>
    <url>/2023/04/08/%E6%80%BB%E7%BB%93-1-1/</url>
    
    <content type="html"><![CDATA[<h2 id="React函数组件的优势"><a href="#React函数组件的优势" class="headerlink" title="React函数组件的优势"></a>React函数组件的优势</h2><ul><li>函数式组件没有this困扰且代码简洁</li><li>不涉及到复杂的state和生命周期</li><li>类组件过于冗余不宜拆分</li></ul><h2 id="常用的React-Hooks"><a href="#常用的React-Hooks" class="headerlink" title="常用的React Hooks"></a>常用的React Hooks</h2><blockquote><p>Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数</p><p>Hook使用规则：</p><ul><li>只能在<strong>函数最外层</strong>调用Hook。不能在循环、条件判断或子函数中调用。</li><li>只能在React的<strong>函数组件</strong>中调用Hook。不能在其他JavaScript函数中调用。</li></ul></blockquote><ul><li><p>State Hook</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">count</span>, setCount] = useState(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li><p>Effect Hook</p><blockquote><p><code>useEffect</code>就是一个Effect Hook，给函数组件增加了操作副作用的能力。它跟class组件中的<code>componentDidMount</code>、<code>componentDidUpdate</code>和<code>componentWillUnMount</code>具有相同的用途，只不过被合并成了一个<code>API</code>。</p></blockquote><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 模拟componentDidMount</span><br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>   <span class="hljs-comment">// 第一次渲染时调用 </span><br>&#125;, [])<br><br><span class="hljs-comment">// 模拟componentDidUpdate</span><br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 任意属性发生改变该属性就会改变</span><br>&#125;)<br><br><span class="hljs-comment">// 模拟componentWillUnmount useEffect会在状态变化的时候进行解绑</span><br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    const timer = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;, <span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <span class="hljs-comment">// 返回的函数是用于清除副作用的</span><br>        <span class="hljs-comment">// 执行卸载操作</span><br>        clearInterval(timer);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>自定义Hooks</p><p>例如：自定义一个订阅好友在线状态的Hook</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">import React, &#123; useEffect, useState &#125; from <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> use<span class="hljs-constructor">FriendStatus(<span class="hljs-params">friendID</span>)</span> &#123;<br>    const <span class="hljs-literal">[<span class="hljs-identifier">isOnline</span>, <span class="hljs-identifier">setIsOnlone</span>]</span> = use<span class="hljs-constructor">State(<span class="hljs-params">null</span>)</span>;<br>    const handleStatusChange =<span class="hljs-function"> (<span class="hljs-params">status</span>) =&gt;</span> &#123;<br>        set<span class="hljs-constructor">IsOnline(<span class="hljs-params">status</span>)</span>;<br>    &#125;<br>    use<span class="hljs-constructor">Effect(()</span> =&gt; &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChatAPI</span>.</span></span>subscribe<span class="hljs-constructor">ToFriendStatus(<span class="hljs-params">friendId</span>, <span class="hljs-params">handleStatusChange</span>)</span>; <span class="hljs-comment">// 订阅好友在线状态</span><br>        return<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChatAPI</span>.</span></span>unsubscribe<span class="hljs-constructor">ToFriend(<span class="hljs-params">friendId</span>, <span class="hljs-params">handleStatusChange</span>)</span>; <span class="hljs-comment">// 解绑对好友在线状态的订阅</span><br>        &#125;<br>    &#125;)<br>    return isOnline;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们可以在别的组件中使用它</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">FriendStatus(<span class="hljs-params">props</span>)</span> &#123;<br>    const isOnline = use<span class="hljs-constructor">FriendStatus(<span class="hljs-params">props</span>.<span class="hljs-params">friend</span>.<span class="hljs-params">id</span>)</span>;<br>    <span class="hljs-keyword">if</span>(isOnline<span class="hljs-operator"> === </span>null) &#123;<br>        return <span class="hljs-string">&quot;Loading...&quot;</span>;<br>    &#125;<br>    return isOnline ? <span class="hljs-string">&quot;onLine&quot;</span> : <span class="hljs-string">&quot;OffLine&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>useContext</p><p>不使用组件嵌套就可以订阅React的Context</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">function Example() &#123;<br>    const locale <span class="hljs-operator">=</span> useContext(LocaleContext)<span class="hljs-comment">;</span><br>    const theme <span class="hljs-operator">=</span> useContext(ThemeContext)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>useReducer</p><p>通过reducer管理本地复杂的state</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Todos()</span> &#123;<br>    const <span class="hljs-literal">[<span class="hljs-identifier">todos</span>, <span class="hljs-identifier">setTodos</span>]</span> = use<span class="hljs-constructor">Reducer(<span class="hljs-params">todosReducer</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="React为什么推荐用Hook而不是生命周期"><a href="#React为什么推荐用Hook而不是生命周期" class="headerlink" title="React为什么推荐用Hook而不是生命周期"></a>React为什么推荐用Hook而不是生命周期</h2><p>生命周期不利于逻辑相关的状态的管理。</p><p>side effect相关逻辑被分散到不同的函数中可能会导致bug的出现和产生数据不一致的情况；我们也可能会在组件的同一生命周期中放很多不相关的side effect逻辑。</p><p>使用Hook可以将某个side effect相关的逻辑都放在同一个函数中，方便代码的维护，方便组件的复用。</p><h2 id="为什么不能在循环、条件或嵌套函数中调用React-Hook"><a href="#为什么不能在循环、条件或嵌套函数中调用React-Hook" class="headerlink" title="为什么不能在循环、条件或嵌套函数中调用React Hook"></a>为什么不能在循环、条件或嵌套函数中调用React Hook</h2><p>React是使用链表来存储Hook的，每次Hook的调用都对应着一个全局的index索引，通过这个索引运行当前组件上的_hooks数组查找保存的值，也就是Hook返回的<code>[state, useState]</code></p><p>假设如下代码：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">function Example() &#123;<br>    <span class="hljs-keyword">const</span> [state1, <span class="hljs-built_in">set</span>State1] = useState(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> [state2, <span class="hljs-built_in">set</span>State2] = useState(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">const</span> [state3, <span class="hljs-built_in">set</span>State3] = useState(<span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/5/166e20d92aa52108~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="react-hooks"></p><p>在执行函数组件的时候，第一次执行<code>useState</code>是时候，它会对应Fiber对象上的<code>memoizedState</code>，这个属性原来是设计来存储类组件的state的，因为在类组件中state是一整个对象，所以可以和<code>memoizedState</code>一一对应。</p><p>但是在Hooks中，React并不知道我们调用了几次<code>useState</code>，所以在保存state这件事上，React提出了另一种解决方案，即调用<code>useState</code>之后在<code>memoizedState</code>上的对象设计成如下样式：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">&#123;<br><span class="hljs-built_in">    baseState,</span><br><span class="hljs-built_in">    next,</span><br><span class="hljs-built_in">    baseUpdate,</span><br><span class="hljs-built_in">    queue,</span><br>    memoizedState<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将其称为Hook对象。这里最需要关心的是<code>memoizedState</code>和<code>next</code>，<code>memoizedState</code>用来记录该<code>useState</code>应该返回的结果，而<code>next</code>指向下一次<code>useState</code>对应的Hook对象。</p><p>即：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">hook1</span> <span class="hljs-operator">=</span>&gt; Fiber.memoizedState<br><span class="hljs-attribute">state1</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> hook1.memoizedState<br>hook1.next <span class="hljs-operator">=</span>&gt; hook2<br><span class="hljs-attribute">state2</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> hook2.memoizedState<br>hook2.next <span class="hljs-operator">=</span>&gt; hook3<br><span class="hljs-attribute">state3</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> hook3.memoizedState<br></code></pre></td></tr></table></figure><p>React按照执行顺序以类似链表的数据格式存放在<code>Fiber.memoizedState</code>上</p><p>由于按照这种方式存储state，因此<code>useState</code>(包括其他Hooks)都必须在函数组件的根作用域声明，而不能再条件或循环中声明。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if(something) &#123;<br>    const [state1] <span class="hljs-operator">=</span> useState(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>&#125;<br>// or<br>for(something) &#123;<br>    const [state2] <span class="hljs-operator">=</span> useState(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们无法保证条件语句每次执行的次数是一样的，也就是说如果第一次render创建了<code>state1 =&gt; hook1, state2 =&gt; hook2, state3 =&gt; hook3</code>这样的对应关系，再次render的时候因为<code>something</code>未达成，导致<code>useState(1)</code>没有执行的话，那么执行<code>useState(2)</code>的时候，拿到的hook对象是<code>state1</code>的，那么逻辑就会混乱，因此该条件必须遵守。</p><p>更新state的时候，调用<code>useState</code>的返回方法如下：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">var</span> dispatch = <span class="hljs-built_in">queue</span>.dispatch = dispatchAction.bind(<span class="hljs-built_in">null</span>, currentlyRenderingFiber$<span class="hljs-number">1</span>, <span class="hljs-built_in">queue</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-meta">[</span>workInProgressHook.memoizedState, dispatch<span class="hljs-meta">]</span>;<br></code></pre></td></tr></table></figure><p>调用该方法会创建一个update</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">var</span> <span class="hljs-string">update</span> <span class="hljs-string">=</span> &#123;<br>  <span class="hljs-attr">expirationTime:</span> <span class="hljs-string">_expirationTime</span>,<br>  <span class="hljs-attr">action:</span> <span class="hljs-string">action</span>,<br>  <span class="hljs-attr">callback:</span> <span class="hljs-string">callback</span> <span class="hljs-type">!==</span> <span class="hljs-string">undefined</span> <span class="hljs-string">?</span> <span class="hljs-attr">callback :</span> <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">next:</span> <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的action是调用<code>setState(1)</code>传入的值，而这个update会被加入到queue上，因此可能存在一次性调用多次setState1的情况。</p><p>在收集完这所有<code>update</code>之后，会调度一次<code>React</code>的更新，在更新的过程中，肯定会执行到函数组件，那么就会执行到对应的<code>useState</code>，然后就拿到了<code>Hook</code>对象，它保存了<code>queue</code>对象表示有哪些更新存在，然后依次进行更新，拿到最新的<code>state</code>保存在<code>memoizedState</code>上，并且返回，最终达到了<code>setState</code>的效果。</p><p>参考文档：<a href="https://juejin.cn/post/6844903704437456909">https://juejin.cn/post/6844903704437456909</a></p><h2 id="useMemo和useCallback的区别"><a href="#useMemo和useCallback的区别" class="headerlink" title="useMemo和useCallback的区别"></a>useMemo和useCallback的区别</h2><p>二者都是用于缓存数据，优化性能的，它们接受到的参数是一样的，第一个参数表示回调函数，第二个参数表示依赖的数据。</p><p>共同作用：在依赖数据发生变化的时候，才会调用传进去的回调函数去重新计算结果，起到缓冲的作用。</p><p>区别：</p><ul><li><code>useMemo</code>缓存的结果是回调函数中return回来的值，主要用于缓存计算结果的值，应用场景如需要计算的状态。</li><li><code>useCallback</code>缓存的结果是函数，主要用于缓存函数，应用场景如需要缓存的函数，因为函数式组件每次任何一个state发生变化都会触发整个组件更新，一些函数是没有必要更新的，此时就应该缓存起来，提高性能，减少对资源的浪费。<code>useCallback</code>应该和<code>React.memo</code>配套使用，缺少一个可能会导致性能不升反降。</li></ul><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useState, useMemo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Info</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">const</span> [info, setInfo] = <span class="hljs-title function_">useState</span>(&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;LiHua&quot;</span>,<br>        <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;male&quot;</span><br>    &#125;);<br>    <span class="hljs-comment">// 翻译性别的函数</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">formatGender</span> = (<span class="hljs-params">gender</span>) =&gt; &#123;<br>        <span class="hljs-keyword">return</span> gender === <span class="hljs-string">&quot;male&quot;</span> ? <span class="hljs-string">&quot;男&quot;</span> : <span class="hljs-string">&quot;女&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果不使用useMemo,修改其他属性，也会导致formatGender方法的调用，浪费计算资源</span><br>    <span class="hljs-comment">// const gender = formatGender(info.gender);</span><br>    <span class="hljs-comment">// 仅当info.gender发生变化的时候才调用formatGender</span><br>    <span class="hljs-keyword">const</span> gender = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">formatGender</span>(info.<span class="hljs-property">gender</span>);<br>    &#125;, [info.<span class="hljs-property">gender</span>]);<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        姓名：&#123;info.name&#125; - 性别：&#123;gender&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onClick</span> = <span class="hljs-string">&#123;()</span> =&gt;</span> setInfo(...info, name: &quot;XiaoMing&quot;)&#125;</span><br><span class="language-xml">        &gt;点击修改姓名<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>useCallback是设计初衷是为了<strong>减少子组件的不必要重读渲染</strong>，优化思路主要有以下两种：</p><ul><li>减少render的次数</li><li>减少计算量</li></ul><p>在如下场景中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-comment">// 不使用useCallback和memo的时候</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Comp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [dataA, setDataA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> [dataB, setDataB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickA</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataA</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickB</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataB</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Cheap</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickA&#125;</span>&gt;</span>组件Cheap: &#123;dataA&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Cheap</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Expensive</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickB&#125;</span>&gt;</span>组件Expensive: &#123;dataB&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Expensive</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述组件中，每当点击Cheap组件的时候，Expensive组件也会重新渲染，即使dataB没有发生变化，原因就是onClickB被重新定义，导致React在diff新旧组件的时候判定了组件发生了变化。</p><p>此时，useCallback和memo就发挥作用了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useCallback, useState, memo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Expensive</span>(<span class="hljs-params">&#123;onClick, name&#125;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Expensive渲染&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><span class="hljs-keyword">const</span> memoExpensive = <span class="hljs-title function_">memo</span>(<span class="hljs-title class_">Expensive</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cheap</span>(<span class="hljs-params">&#123;onClick, name&#125;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Cheap渲染&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Comp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [dataA, setDataA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> [dataB, setDataB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickA</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataA</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> onClickB = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">setDataB</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;, [])<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Cheap</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickA&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">组件Cheap:</span> $&#123;<span class="hljs-attr">dataA</span>&#125;`&#125; /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Expensive</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickB&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">组件Expensive:</span> $&#123;<span class="hljs-attr">data</span>&#125;`&#125; /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>memo与PureComponent类似，对传入组件的新旧数据进行浅比较，如果相同则不会触发渲染。</p><p>useCallback保证onClickB不会发生变化，此时点击Cheap组件不会触发Expensive组件的刷新，只有点击Expensive组件才会触发。在实现减少不必要渲染的优化过程中，useCallback和memo是一对利器。</p><h2 id="函数组件模拟componentWillUnmount组件"><a href="#函数组件模拟componentWillUnmount组件" class="headerlink" title="函数组件模拟componentWillUnmount组件"></a>函数组件模拟componentWillUnmount组件</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 执行卸载操作</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="项目：根据用户权限实现路由权限管理"><a href="#项目：根据用户权限实现路由权限管理" class="headerlink" title="项目：根据用户权限实现路由权限管理"></a>项目：根据用户权限实现路由权限管理</h2><p>在编写React路由列表的时候为每一个路由赋一个id值，在用户登录之后将用户的权限列表存储起来，并根据用户权限列表对路由列表进行筛选和展示，根据筛选后的结果部署系统的导航栏。</p><p>当用户想要通过直接输入url的方式访问某个页面的时候，在Route组件的render函数中根据url匹配到路由对应的id值，然后判断用户权限列表中是否存在该id值，如果存在则允许访问，否则警告用户没有权限并返回首页。</p><p>……</p><h2 id="为什么使用Redux进行状态管理"><a href="#为什么使用Redux进行状态管理" class="headerlink" title="为什么使用Redux进行状态管理"></a>为什么使用Redux进行状态管理</h2><ul><li><strong>Redux使状态可预测。</strong>传递相同的状态和动作传递给减速器，总会产生相同的结果，因为减速器是纯函数。</li><li><strong>Redux方便维护。</strong>Redux对代码的组织方式很严格，结构更容易理解，维护更加方便。同时有利于用户将业务逻辑与组件树分离。</li><li><strong>Redux调试简单。</strong>Redux使调试程序变得简单，通过记录操作和状态，很容易理解编码错误、网络错误和生产过程中出现的其他形式的错误。</li><li><strong>Redux有性能优势。</strong>Redux内部实现了很多优化，因此我们自己的连接组件仅在实际需要时才重新渲染。</li><li><strong>数据持久化。</strong></li><li><strong>Redux还能用于服务端渲染。</strong>我们可以通过将应用程序的状态连同它对服务器请求的响应发送到服务器来处理应用程序的初始呈现，然后所需组件以HTML格式呈现并发送到客户端。</li></ul><h2 id="哪些数据需要使用Redux进行存储？"><a href="#哪些数据需要使用Redux进行存储？" class="headerlink" title="哪些数据需要使用Redux进行存储？"></a>哪些数据需要使用Redux进行存储？</h2><p>全局公共数据用Redux进行管理，局部状态用state和props即可。</p><h2 id="浏览器的垃圾回收机制"><a href="#浏览器的垃圾回收机制" class="headerlink" title="浏览器的垃圾回收机制"></a>浏览器的垃圾回收机制</h2><p>JS代码运行时，需要分配内存空间来存储变量和值。当变量不再参与运行时，就需要回收被占用的空间，这就是垃圾回收。</p><p><strong>垃圾回收的方式</strong></p><ul><li><p><strong>标记清除</strong></p><p>当变量进入执行环境时，标记该变量”进入幻境”，此时变量不能回收。当变量离开环境的时候，就会被标记为”离开环境”，会被内存释放</p></li><li><p><strong>引用计数</strong></p><p>跟踪每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量的时候，这个值的引用次数就是1。当包含对该值引用的变量指向另一个值的时候，引用次数减1。当引用次数变为0的时候，说明该值已经没有利用价值，这个变量占用的内存空间就会被释放出来。</p><p>弊端：可能会引起<strong>循环引用</strong>的问题，例如：obj1和obj2通过属性互相进行引用，那么二者的引用次数永远不会归零，函数执行完结束后，两个变量仍然会继续存在，引用次数永远不为0，会引起循环引用。</p></li></ul><p><strong>减少垃圾回收的方式</strong></p><ul><li>对数组进行优化：清空一个数组的时候将其长度设为0</li><li>对对象进行优化：不再使用的时候将其设置为null</li><li>对函数进行优化：在循环中的函数表达式，如果可以复用则尽量放在外面</li></ul><h2 id="实现JS的深拷贝"><a href="#实现JS的深拷贝" class="headerlink" title="实现JS的深拷贝"></a>实现JS的深拷贝</h2><ul><li><p>使用JSON.stringify和JSON.parse实现</p></li><li><p>for…in + Object.assign</p></li><li><p>for…in + 拓展运算符</p></li><li><p><strong>Object.create</strong></p></li><li><p><strong>jQuery.extend(deep, target, obj1, …)</strong></p></li><li><p>函数库lodash</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;lodash&quot;</span>;<br><span class="hljs-keyword">const</span> obj = &#123;a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span>&#125;;<br><span class="hljs-keyword">const</span> deep = _.cloneDeep(obj);<br></code></pre></td></tr></table></figure></li></ul><h2 id="JS作用域是在什么时候创建的"><a href="#JS作用域是在什么时候创建的" class="headerlink" title="JS作用域是在什么时候创建的"></a>JS作用域是在什么时候创建的</h2><p>全局作用域在window对象创建的时候产生。</p><p>局部作用域在函数执行时产生，函数执行完毕后，如果子作用域不需要使用它声明的变量就销毁，如果使用就形成闭包保存下来。</p><h2 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h2><p>有权访问另一个函数作用域内变量的函数</p><h2 id="宏任务和微任务的区别"><a href="#宏任务和微任务的区别" class="headerlink" title="宏任务和微任务的区别"></a>宏任务和微任务的区别</h2><p>宏任务一般是：整体代码script、setTimeout、setInterval、I&#x2F;O、UI render</p><p>微任务主要是：Promise、Object.observe、MutationObserver</p><p>二者都是异步。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
