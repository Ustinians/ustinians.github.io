<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring汇总</title>
    <link href="/2023/04/26/Spring%E6%B1%87%E6%80%BB/"/>
    <url>/2023/04/26/Spring%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p><a href="https://ustinians.github.io/2023/04/25/HTML%E3%80%81CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">HTML、CSS知识点总结</a></p><p><a href="https://ustinians.github.io/2023/04/25/JavaScript%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">JavaScript知识点总结</a></p><p><a href="https://ustinians.github.io/2023/04/25/React%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">React知识点总结</a></p><p><a href="https://ustinians.github.io/2023/04/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/">数据结构知识点总结</a></p><p><a href="https://ustinians.github.io/2023/04/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/">浏览器、进程与线程、计算机网络、数据库相关</a></p><p><a href="https://ustinians.github.io/2023/04/26/Webpack%EF%BC%8CGit%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%81%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/#Webpack%EF%BC%8CGit%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%81%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3">Webpack，Git打包部署、性能优化、安全相关</a></p><p><a href="https://ustinians.github.io/2023/04/26/NodeJS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">NodeJS知识点总结</a></p><p><a href="https://ustinians.github.io/2023/04/26/%E4%BB%A3%E7%A0%81%E6%89%8B%E5%86%99-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA/">代码手写&amp;代码输出</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring Recruitment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码手写&amp;代码输出</title>
    <link href="/2023/04/26/%E4%BB%A3%E7%A0%81%E6%89%8B%E5%86%99-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA/"/>
    <url>/2023/04/26/%E4%BB%A3%E7%A0%81%E6%89%8B%E5%86%99-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="代码手写题"><a href="#代码手写题" class="headerlink" title="代码手写题"></a>代码手写题</h1><h2 id="手写防抖"><a href="#手写防抖" class="headerlink" title="手写防抖"></a>手写防抖</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> args = [...<span class="hljs-variable language_">arguments</span>], context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">if</span>(timer) &#123;<br>            <span class="hljs-built_in">clearTimeout</span>(timer);<br>            timer = <span class="hljs-literal">null</span>;<br>        &#125;<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            fn.<span class="hljs-title function_">apply</span>(context, args);<br>        &#125;, wait);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么要使用apply？如果不使用的话fn的this会指向什么？</strong></p><p>apply() 方法可调用一个函数，其具有一个指定的 this 值，以及作为一个数组（或类似数组对象）提供的参数，这样参数可以传到函数中。</p><p>在上面的防抖函数中，为了保证原函数（即传入 debounce 函数中的第一个参数 func）被正确地执行，并且使用了正确的 this 值，我们需要使用 apply() 。使用 apply() 将该函数执行时的上下文（即 this 值）和参数传递给原始函数。</p><p>如果不使用 apply()，函数的 this 将指向全局对象 window（如果使用的是浏览器环境）或 global 对象（如果使用的是 Node.js 环境）。这是因为在 JavaScript 中，如果函数不作为某个对象的方法调用，其 this 将默认指向全局对象。</p><p>因此，在防抖函数中，如果没有使用 apply()，原函数将无法获取正确的 this 值，这通常会导致不可预料的错误或行为。</p><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueArr</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">const</span> newArr = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(arr.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item1</span> =&gt;</span> item1 === item) === index) &#123;<br>            <span class="hljs-keyword">return</span> item;<br>        &#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> newArr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="手写图片懒加载"><a href="#手写图片懒加载" class="headerlink" title="手写图片懒加载"></a>手写图片懒加载</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">lazyload</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> imgs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;img&#x27;</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> len = imgs.<span class="hljs-property">length</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> viewHeight = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span>;</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> scrollHeight = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span>;</span><br><span class="language-javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> offsetHeight = imgs[i].<span class="hljs-property">offsetTop</span>;</span><br><span class="language-javascript">            <span class="hljs-keyword">if</span> (offsetHeight &lt; viewHeight + scrollHeight) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">const</span> src = imgs[i].<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>;</span><br><span class="language-javascript">                imgs[i].<span class="hljs-property">src</span> = src;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, lazyload);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="原生JS实现图片拖拽"><a href="#原生JS实现图片拖拽" class="headerlink" title="原生JS实现图片拖拽"></a>原生JS实现图片拖拽</h2><p><img src="D:\Users\HP\Pictures\Typora\image-20230409150136435.png" alt="image-20230409150136435"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-id">#box</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position: relative;overflow: hidden;&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 将要被拖拽的元素, 设置为绝对定位 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;img src=&quot;https://pic.imgdb.cn/item/64326d120d2dde57772c4eab.png&quot; alt=&quot;&quot; id=&quot;box&quot; /&gt; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;box&quot;</span>); <span class="hljs-comment">// 获取目标元素</span></span><br><span class="language-javascript">            <span class="hljs-comment">// 鼠标按下事件</span></span><br><span class="language-javascript">            box.<span class="hljs-property">onmousedown</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">let</span> e = ev || event;</span><br><span class="language-javascript">                <span class="hljs-comment">// 鼠标到元素左边缘距离 = 鼠标到屏幕左边缘距离 - 元素到屏幕左边缘距离</span></span><br><span class="language-javascript">                <span class="hljs-keyword">let</span> x = e.<span class="hljs-property">clientX</span> - box.<span class="hljs-property">offsetLeft</span>;</span><br><span class="language-javascript">                <span class="hljs-comment">// 鼠标到元素上边缘距离 = 鼠标到屏幕上边缘距离 - 元素到屏幕上边缘距离</span></span><br><span class="language-javascript">                <span class="hljs-keyword">let</span> y = e.<span class="hljs-property">clientY</span> - box.<span class="hljs-property">offsetTop</span>;</span><br><span class="language-javascript">                <span class="hljs-comment">// 鼠标移动事件</span></span><br><span class="language-javascript">                <span class="hljs-variable language_">document</span>.<span class="hljs-property">onmousemove</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>) &#123;</span><br><span class="language-javascript">                    <span class="hljs-keyword">let</span> e = ev || event;</span><br><span class="language-javascript">                    box.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = ev.<span class="hljs-property">clientX</span> - x + <span class="hljs-string">&quot;px&quot;</span>;</span><br><span class="language-javascript">                    box.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = ev.<span class="hljs-property">clientY</span> - y + <span class="hljs-string">&quot;px&quot;</span>;</span><br><span class="language-javascript">                    <span class="hljs-comment">// 鼠标距离浏览器窗口左边缘和上边缘的距离</span></span><br><span class="language-javascript">                    <span class="hljs-keyword">let</span> bodyScreenX = ev.<span class="hljs-property">screenX</span>, bodyScreenY = ev.<span class="hljs-property">screenY</span>;</span><br><span class="language-javascript">                    <span class="hljs-comment">// 屏幕的宽度和高度</span></span><br><span class="language-javascript">                    <span class="hljs-keyword">let</span> bodyClientWidth = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientWidth</span>,</span><br><span class="language-javascript">                        bodyClientHeight = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientHeight</span>;</span><br><span class="language-javascript">                    <span class="hljs-comment">// 鼠标松开事件</span></span><br><span class="language-javascript">                    <span class="hljs-variable language_">document</span>.<span class="hljs-property">onmouseup</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>) &#123;</span><br><span class="language-javascript">                        <span class="hljs-comment">// 判断松开的时候元素是否在屏幕中</span></span><br><span class="language-javascript">                        <span class="hljs-keyword">if</span>(ev.<span class="hljs-property">clientX</span> - x &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="language-javascript">                            <span class="hljs-comment">// 如果超出屏幕左边缘, 将元素放回屏幕最左边</span></span><br><span class="language-javascript">                            box.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = <span class="hljs-number">0</span>;</span><br><span class="language-javascript">                        &#125;</span><br><span class="language-javascript">                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bodyScreenX &gt; bodyClientWidth) &#123;</span><br><span class="language-javascript">                            <span class="hljs-comment">// 如果超出屏幕右边缘, 将元素放回屏幕最右边</span></span><br><span class="language-javascript">                            box.<span class="hljs-property">style</span>.<span class="hljs-property">right</span> = <span class="hljs-number">0</span>;</span><br><span class="language-javascript">                            box.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = bodyClientWidth - <span class="hljs-number">100</span> + <span class="hljs-string">&quot;px&quot;</span>;</span><br><span class="language-javascript">                        &#125;</span><br><span class="language-javascript">                        <span class="hljs-variable language_">document</span>.<span class="hljs-property">onmousemove</span> = <span class="hljs-literal">null</span>;</span><br><span class="language-javascript">                        <span class="hljs-variable language_">document</span>.<span class="hljs-property">onmouseup</span> = <span class="hljs-literal">null</span>;</span><br><span class="language-javascript">                    &#125;</span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="如何使用原生JS发送HTTP请求？"><a href="#如何使用原生JS发送HTTP请求？" class="headerlink" title="如何使用原生JS发送HTTP请求？"></a>如何使用原生JS发送HTTP请求？</h2><p>使用JS内置的<code>XMLHttpRequest</code>发送请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建一个xhr对象</span><br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">// 使用open方法设置请求方法、url和是否异步</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;http://test.com&quot;</span>, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 设置请求头(可选)</span><br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>);<br><span class="hljs-comment">// 状态监听函数</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 请求成功</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-title function_">handle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 请求失败时的监听函数</span><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>&#125;<br><span class="hljs-comment">// 发送请求</span><br>xhr.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><h2 id="手写数组扁平化"><a href="#手写数组扁平化" class="headerlink" title="手写数组扁平化"></a>手写数组扁平化</h2><p>递归实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">flat</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> newArr = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> arr) &#123;<br>        <span class="hljs-keyword">if</span>(item <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) &#123;<br>            newArr = newArr.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">flat</span>(item));<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            newArr.<span class="hljs-title function_">push</span>(item);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newArr;<br>&#125;<br></code></pre></td></tr></table></figure><p>reduce迭代实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">flat</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, item</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> prev.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item) ? <span class="hljs-title function_">flat</span>(item) : item);<br>    &#125;, [])<br>&#125;<br></code></pre></td></tr></table></figure><p>split和toString</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">flat</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;,&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>JSON.stringify和JSON.parse</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">flat</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> str = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(arr);<br>    str = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(\[|\])/g</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    str = <span class="hljs-string">&quot;[&quot;</span> + str + <span class="hljs-string">&quot;]&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="颜色转换-十六进制转换RGB格式"><a href="#颜色转换-十六进制转换RGB格式" class="headerlink" title="颜色转换: 十六进制转换RGB格式"></a>颜色转换: 十六进制转换RGB格式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">hexToRgb</span> = (<span class="hljs-params">hex</span>) =&gt; &#123;<br>    hex = hex.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^#/</span>, <span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 去除前面的#</span><br>    <span class="hljs-keyword">const</span> r = <span class="hljs-built_in">parseInt</span>(hex.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>), <span class="hljs-number">16</span>); <br>    <span class="hljs-keyword">const</span> g = <span class="hljs-built_in">parseInt</span>(hex.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>), <span class="hljs-number">16</span>);<br>    <span class="hljs-keyword">const</span> b = <span class="hljs-built_in">parseInt</span>(hex.<span class="hljs-title function_">substring</span>(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>), <span class="hljs-number">16</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`rgb(<span class="hljs-subst">$&#123;r&#125;</span>, <span class="hljs-subst">$&#123;g&#125;</span>, <span class="hljs-subst">$&#123;b&#125;</span>)`</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="替换字符串内容"><a href="#替换字符串内容" class="headerlink" title="替换字符串内容"></a>替换字符串内容</h2><p>给你一个字符串<code>Hello #1#, Is&#39;s a #2# day</code>和一个数组<code>[&quot;Jack&quot;, &quot;sunny&quot;]</code>，将字符串中井号之间的索引换成在字符串中的对应元素。</p><blockquote><p>substr是从起始索引号开始提取指定长度的字符串</p><p>substring是提取字符串中两个指定索引号之间的</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">matchKeywords</span> = (<span class="hljs-params">str, arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> matchs = str.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/#(\d+)#/g</span>); <span class="hljs-comment">// 获取所有#index#占位符</span><br>    <span class="hljs-keyword">let</span> result = str;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; matchs.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-comment">// 获取matchs[i]对应的数组元素</span><br>        <span class="hljs-keyword">const</span> index = <span class="hljs-built_in">parseInt</span>(matchs[i].<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>, matchs[i].<span class="hljs-property">length</span> - <span class="hljs-number">2</span>)) - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 进行替换</span><br>        result = result.<span class="hljs-title function_">replace</span>(matchs[i], arr[index]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="如何正则匹配一个手机号？"><a href="#如何正则匹配一个手机号？" class="headerlink" title="如何正则匹配一个手机号？"></a>如何正则匹配一个手机号？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">^<span class="hljs-number">1</span>[<span class="hljs-number">3</span>-<span class="hljs-number">9</span>]\d&#123;<span class="hljs-number">9</span>&#125;$<br></code></pre></td></tr></table></figure><ul><li><code>^</code> 表示字符串开始位置</li><li><code>1</code> 表示手机号码的第一位必须为1</li><li><code>[3-9]</code> 表示手机号码的第二位可以是3-9中的任意一个数字</li><li><code>\d&#123;9&#125;</code> 表示手机号码的后9位必须是数字</li><li><code>$</code> 表示字符串结束位置</li></ul><h2 id="设计一个Button组件，要求点击按钮发起一个POST请求，当请求结束后通知给父组件。"><a href="#设计一个Button组件，要求点击按钮发起一个POST请求，当请求结束后通知给父组件。" class="headerlink" title="设计一个Button组件，要求点击按钮发起一个POST请求，当请求结束后通知给父组件。"></a>设计一个<code>Button</code>组件，要求点击按钮发起一个<code>POST</code>请求，当请求结束后通知给父组件。</h2><ul><li>该请求耗时很长</li><li><code>POST</code>请求非幂等</li></ul><p>以下是一个简单的React <code>Button</code>组件的实现，满足上述要求：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> [loading, setLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(props.<span class="hljs-property">url</span>, &#123;<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>        <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(props.<span class="hljs-property">data</span>),<br>        <span class="hljs-attr">headers</span>: &#123;<br>          <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>        &#125;<br>      &#125;);<br>      <span class="hljs-keyword">if</span> (response.<span class="hljs-property">ok</span>) &#123;<br>        props.<span class="hljs-title function_">onSuccess</span>();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        props.<span class="hljs-title function_">onError</span>();<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      props.<span class="hljs-title function_">onError</span>();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>);<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span> <span class="hljs-attr">disabled</span>=<span class="hljs-string">&#123;loading&#125;</span>&gt;</span></span><br><span class="language-xml">      &#123;loading ? &#x27;Loading...&#x27; : props.label&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Button</span>;<br></code></pre></td></tr></table></figure><p>该组件接受以下属性：</p><ul><li><code>url</code>：<code>POST</code>请求的URL。</li><li><code>data</code>：要发送的数据。</li><li><code>label</code>：按钮上显示的文本。</li><li><code>onSuccess</code>：请求成功后的回调函数。</li><li><code>onError</code>：请求失败后的回调函数。</li></ul><p>该组件使用了React的状态钩子来管理按钮的加载状态，当按钮被点击时，它会设置<code>loading</code>状态为<code>true</code>并发起<code>POST</code>请求。如果请求成功，它会调用<code>props.onSuccess</code>回调函数，否则调用<code>props.onError</code>回调函数。无论请求成功与否，它都会将<code>loading</code>状态设置为<code>false</code>，以使按钮再次可用。</p><p>该组件可以在父组件中使用，如下所示：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Button&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSuccess</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Request succeeded!&#x27;</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleError</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Request failed!&#x27;</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;https://example.com/api&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">name:</span> &#x27;<span class="hljs-attr">John</span>&#x27; &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;Submit&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onSuccess</span>=<span class="hljs-string">&#123;handleSuccess&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onError</span>=<span class="hljs-string">&#123;handleError&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p>在这个例子中，当<code>Button</code>被点击时，它会向<code>https://example.com/api</code>发送一个<code>POST</code>请求，并将<code>&#123; name: &#39;John&#39; &#125;</code>作为请求体。如果请求成功，它会弹出一个消息框显示<code>Request succeeded!</code>，否则显示<code>Request failed!</code>。注意，这个例子并没有考虑请求的幂等性和请求耗时较长的情况，这些问题需要根据具体情况进行处理。</p><h2 id="如何获取URL中的参数？"><a href="#如何获取URL中的参数？" class="headerlink" title="如何获取URL中的参数？"></a>如何获取URL中的参数？</h2><p>获取URL中的参数可以使用JavaScript中的URLSearchParams对象。以下是一个简单的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取当前URL中的参数</span><br><span class="hljs-keyword">let</span> params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">search</span>);<br><br><span class="hljs-comment">// 获取特定参数的值</span><br><span class="hljs-keyword">let</span> id = params.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-keyword">let</span> name = params.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;name&quot;</span>);<br><br><span class="hljs-comment">// 打印参数值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id); <span class="hljs-comment">// 输出参数id的值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// 输出参数name的值</span><br></code></pre></td></tr></table></figure><p>上述代码中，首先使用<code>URLSearchParams</code>对象获取当前URL中的参数。然后使用<code>get</code>方法获取特定参数的值。最后使用<code>console.log</code>方法打印参数值。</p><p>字符串分割方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getAllParams</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 获取当前URL</span><br>  <span class="hljs-keyword">let</span> url = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>;<br><br>  <span class="hljs-comment">// 获取参数部分</span><br>  <span class="hljs-keyword">let</span> params = url.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;?&quot;</span>)[<span class="hljs-number">1</span>];<br><br>  <span class="hljs-comment">// 分割参数</span><br>  <span class="hljs-keyword">let</span> paramArr = params.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&amp;&quot;</span>);<br><br>  <span class="hljs-comment">// 创建一个空对象，用于存储参数</span><br>  <span class="hljs-keyword">let</span> paramObj = &#123;&#125;;<br><br>  <span class="hljs-comment">// 遍历参数数组，将参数存储到对象中</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; paramArr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> param = paramArr[i].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;=&quot;</span>);<br><br>    <span class="hljs-comment">// 将参数名和参数值存储到对象中</span><br>    paramObj[param[<span class="hljs-number">0</span>]] = param[<span class="hljs-number">1</span>];<br>  &#125;<br><br>  <span class="hljs-comment">// 返回参数对象</span><br>  <span class="hljs-keyword">return</span> paramObj;<br>&#125;<br><br><span class="hljs-comment">// 获取所有参数</span><br><span class="hljs-keyword">let</span> params = <span class="hljs-title function_">getAllParams</span>();<br><br><span class="hljs-comment">// 打印参数对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params);<br></code></pre></td></tr></table></figure><h2 id="手写JS计算m的n次方，要求时间复杂度O-logN-？-手写Math-pow"><a href="#手写JS计算m的n次方，要求时间复杂度O-logN-？-手写Math-pow" class="headerlink" title="手写JS计算m的n次方，要求时间复杂度O(logN)？(手写Math.pow())"></a>手写JS计算m的n次方，要求时间复杂度O(logN)？(手写Math.pow())</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">power</span>(<span class="hljs-params">m, n</span>) &#123;<br>  <span class="hljs-comment">// 如果n等于0，返回1</span><br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果n是负数，将m变为倒数，n变为相反数</span><br>  <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br>    m = <span class="hljs-number">1</span> / m;<br>    n = -n;<br>  &#125;<br><br>  <span class="hljs-comment">// 用二分法计算m的n次方</span><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 如果n是奇数，将结果乘上m</span><br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) &#123;<br>      result *= m;<br>    &#125;<br>    <span class="hljs-comment">// 将m平方，将n除以2</span><br>    m *= m;<br>    n = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(n / <span class="hljs-number">2</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 返回结果</span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 计算2的10次方</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">power</span>(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>)); <span class="hljs-comment">// 输出1024</span><br></code></pre></td></tr></table></figure><h2 id="归并排序如何实现？时间复杂度是多少？"><a href="#归并排序如何实现？时间复杂度是多少？" class="headerlink" title="归并排序如何实现？时间复杂度是多少？"></a>归并排序如何实现？时间复杂度是多少？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">mergeSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> len = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">// 如果长度&lt;2, 无需进行排序</span><br>    <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr; <br>    <span class="hljs-comment">// 将数组从中间进行切割</span><br>    <span class="hljs-keyword">const</span> middle = len &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">const</span> left = arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, middle), right = arr.<span class="hljs-title function_">slice</span>(middle);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(<span class="hljs-title function_">mergeSort</span>(left), <span class="hljs-title function_">mergeSort</span>(right));<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">merge</span> = (<span class="hljs-params">left, right</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 存储最终结果的数组</span><br>    <span class="hljs-keyword">const</span> result = [];<br>    <span class="hljs-comment">// 比较left和right中的元素并将较小的先存入result中</span><br>    <span class="hljs-keyword">while</span>(left.<span class="hljs-property">length</span> &amp;&amp; right.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">if</span>(left[<span class="hljs-number">0</span>] &lt;= right[<span class="hljs-number">0</span>]) &#123;<br>            result.<span class="hljs-title function_">push</span>(left.<span class="hljs-title function_">shift</span>());<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            result.<span class="hljs-title function_">push</span>(right.<span class="hljs-title function_">shift</span>());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(left.<span class="hljs-property">length</span>) &#123;<br>        result.<span class="hljs-title function_">push</span>(left.<span class="hljs-title function_">shift</span>());<br>    &#125;<br>    <span class="hljs-keyword">while</span>(right.<span class="hljs-property">length</span>) &#123;<br>        result.<span class="hljs-title function_">push</span>(right.<span class="hljs-title function_">shift</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度O(NlogN)</p><h2 id="如何实现函数的柯里化-长度不限-？"><a href="#如何实现函数的柯里化-长度不限-？" class="headerlink" title="如何实现函数的柯里化(长度不限)？"></a>如何实现函数的柯里化(长度不限)？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeToCurry</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> args = [...<span class="hljs-variable language_">arguments</span>]; <span class="hljs-comment">// 获取传入的所有参数</span><br>        <span class="hljs-keyword">if</span>(args.<span class="hljs-property">length</span> === fn.<span class="hljs-property">length</span>) &#123; <span class="hljs-comment">// 参数符合fn参数数量</span><br>            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args); <span class="hljs-comment">// 执行函数</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">newFn</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 返回一个函数</span><br>                <span class="hljs-keyword">const</span> newArgs = [...<span class="hljs-variable language_">arguments</span>]; <span class="hljs-comment">// 获取再传入的参数</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_">changeToCurry</span>(...[...args, ...newArgs]); <span class="hljs-comment">// 执行柯里化函数</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="JS手写构造一个Biglnt类型数据的函数？"><a href="#JS手写构造一个Biglnt类型数据的函数？" class="headerlink" title="JS手写构造一个Biglnt类型数据的函数？"></a>JS手写构造一个Biglnt类型数据的函数？</h2><p>一个简单的大整数（Bigln）数据结构可以用一个数组来表示，每个元素表示数位，并且从数组的最后一个元素开始，依次存储整数的各个位数。其中，每位的数字范围为0-9。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Bigln</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>    value = <span class="hljs-title class_">String</span>(value);<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br>&#125;<br><br><span class="hljs-title class_">Bigln</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>.<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;;<br><br><span class="hljs-title class_">Bigln</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">valueOf</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Number</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toString</span>());<br>&#125;;<br><br><span class="hljs-title class_">Bigln</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">add</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">other</span>) &#123;<br>  <span class="hljs-keyword">const</span> result = [];<br>  <span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">const</span> maxLength = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>.<span class="hljs-property">length</span>, other.<span class="hljs-property">value</span>.<span class="hljs-property">length</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; maxLength; i++) &#123;<br>    <span class="hljs-keyword">const</span> sum = (<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>[i] || <span class="hljs-number">0</span>) + (other.<span class="hljs-property">value</span>[i] || <span class="hljs-number">0</span>) + carry;<br>    result.<span class="hljs-title function_">push</span>(sum % <span class="hljs-number">10</span>);<br>    carry = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(sum / <span class="hljs-number">10</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>    result.<span class="hljs-title function_">push</span>(carry);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bigln</span>(result.<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>));<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="手写给对象添加去重方法？"><a href="#手写给对象添加去重方法？" class="headerlink" title="手写给对象添加去重方法？"></a>手写给对象添加去重方法？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 利用Map方法给对象去重</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">uniqueByKey</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <span class="hljs-keyword">const</span> newObj = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      <span class="hljs-keyword">const</span> value = <span class="hljs-variable language_">this</span>[key];<br>      <span class="hljs-keyword">if</span> (!map.<span class="hljs-title function_">has</span>(key)) &#123;<br>        map.<span class="hljs-title function_">set</span>(key, value);<br>        newObj[key] = value;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newObj;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="手写打点计时器？"><a href="#手写打点计时器？" class="headerlink" title="手写打点计时器？"></a>手写打点计时器？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Stopwatch</span>(<span class="hljs-params">interval, callback</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">startTime</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">timerId</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">interval</span> = interval;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">callback</span> = callback;<br>&#125;<br><br><span class="hljs-title class_">Stopwatch</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">start</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">timerId</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">startTime</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">timerId</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), <span class="hljs-variable language_">this</span>.<span class="hljs-property">interval</span>); <span class="hljs-comment">// 注意这里要先绑定this才能正确执行tick方法</span><br>  &#125;<br>&#125;;<br><br><span class="hljs-title class_">Stopwatch</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">tick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> elapsedTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - <span class="hljs-variable language_">this</span>.<span class="hljs-property">startTime</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">callback</span>(elapsedTime);<br>&#125;;<br><br><span class="hljs-title class_">Stopwatch</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">stop</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timerId</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">timerId</span> = <span class="hljs-literal">null</span>;<br>&#125;;<br><br><span class="hljs-title class_">Stopwatch</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">reset</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">stop</span>();<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">startTime</span> = <span class="hljs-literal">null</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>首先，我们定义一个 Stopwatch 构造函数，它接受两个参数 interval 和 callback，分别表示计时器的时间间隔和每次执行的任务。</li><li>在构造函数中，我们初始化了一些属性，包括 startTime、timerId、interval 和 callback。</li><li>然后，我们定义了 start、tick、stop 和 reset 方法。</li><li>start 方法用来启动计时器。它首先检查 timerId 是否为 null，如果是的话，就记录当前时间（也就是计时器的起始时间）并创建一个定时器。定时器会在每个时间间隔内调用 tick 方法。</li><li>tick 方法用来执行每次任务。它首先计算已经经过的时间（也就是当前时间减去起始时间），然后调用 callback 函数执行任务，将已经花费的时间作为参数传递给 callback 函数。</li><li>stop 方法用来停止计时器。它清除定时器并设置 timerId 为 null。</li><li>reset 方法用来重置计时器。它调用 stop 方法停止计时器并将 startTime 设置为 null。</li></ol><p>使用该计时器，我们可以像下面这样编写代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> stopwatch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stopwatch</span>(<span class="hljs-number">1000</span>, <span class="hljs-function"><span class="hljs-params">elapsedTime</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Elapsed time: <span class="hljs-subst">$&#123;elapsedTime&#125;</span> ms`</span>);<br>&#125;);<br><br>stopwatch.<span class="hljs-title function_">start</span>();<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  stopwatch.<span class="hljs-title function_">stop</span>();<br>&#125;, <span class="hljs-number">5000</span>);<br></code></pre></td></tr></table></figure><p>上面的代码创建了一个计时器，每隔 1 秒执行一次任务（输出已经花费的时间），并在 5 秒后停止计时器。运行上面的代码后，你会看到类似如下的输出内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Elapsed</span> <span class="hljs-attr">time</span>: <span class="hljs-number">1009</span> ms<br><span class="hljs-title class_">Elapsed</span> <span class="hljs-attr">time</span>: <span class="hljs-number">2012</span> ms<br><span class="hljs-title class_">Elapsed</span> <span class="hljs-attr">time</span>: <span class="hljs-number">3021</span> ms<br><span class="hljs-title class_">Elapsed</span> <span class="hljs-attr">time</span>: <span class="hljs-number">4028</span> ms<br><span class="hljs-title class_">Elapsed</span> <span class="hljs-attr">time</span>: <span class="hljs-number">5037</span> ms<br></code></pre></td></tr></table></figure><p>这表示计时器每隔 1 秒执行一次任务，并输出已经花费的时间。在 5 秒后，计时器被停止。</p><h2 id="实现大数相加？"><a href="#实现大数相加？" class="headerlink" title="实现大数相加？"></a>实现大数相加？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bigNumberAdd</span>(<span class="hljs-params">num1, num2</span>) &#123;<br>  <span class="hljs-keyword">let</span> i = num1.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> j = num2.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>; <span class="hljs-comment">// 进位</span><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-string">&#x27;&#x27;</span>; <span class="hljs-comment">// 结果</span><br><br>  <span class="hljs-comment">// 遍历两个数字的每个位数</span><br>  <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">let</span> a = num1[i] ? <span class="hljs-built_in">parseInt</span>(num1[i]) : <span class="hljs-number">0</span>; <span class="hljs-comment">// 取出num1当前位数上的数字</span><br>    <span class="hljs-keyword">let</span> b = num2[j] ? <span class="hljs-built_in">parseInt</span>(num2[j]) : <span class="hljs-number">0</span>; <span class="hljs-comment">// 取出num2当前位数上的数字</span><br>    <span class="hljs-keyword">let</span> sum = a + b + carry; <span class="hljs-comment">// 计算两个数的和，以及上一次的进位</span><br>    carry = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(sum / <span class="hljs-number">10</span>); <span class="hljs-comment">// 更新进位</span><br>    result = (sum % <span class="hljs-number">10</span>) + result; <span class="hljs-comment">// 更新结果</span><br>    i--;<br>    j--;<br>  &#125;<br><br>  <span class="hljs-comment">// 处理最高位的进位</span><br>  <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>    result = carry + result;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="在空间中已知三角形和一个点，求点到三角形平面的距离？"><a href="#在空间中已知三角形和一个点，求点到三角形平面的距离？" class="headerlink" title="在空间中已知三角形和一个点，求点到三角形平面的距离？"></a>在空间中已知三角形和一个点，求点到三角形平面的距离？</h2><p>求点到三角形平面的距离可以通过向量运算来实现。具体的实现方法如下：</p><ol><li>根据三角形的三个顶点计算法向量</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getNormal</span>(<span class="hljs-params">p1, p2, p3</span>) &#123;<br>  <span class="hljs-keyword">const</span> vec1 = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>().<span class="hljs-title function_">subVectors</span>(p2, p1);<br>  <span class="hljs-keyword">const</span> vec2 = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>().<span class="hljs-title function_">subVectors</span>(p3, p1);<br>  <span class="hljs-keyword">return</span> vec1.<span class="hljs-title function_">cross</span>(vec2).<span class="hljs-title function_">normalize</span>(); <span class="hljs-comment">// 叉积并标准化</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>计算点到三角形平面的距离</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">distanceToPlane</span>(<span class="hljs-params">point, normal, planePoint</span>) &#123;<br>  <span class="hljs-keyword">const</span> vec = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>().<span class="hljs-title function_">subVectors</span>(point, planePoint);<br>  <span class="hljs-keyword">return</span> vec.<span class="hljs-title function_">dot</span>(normal); <span class="hljs-comment">// 点积</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>point</code>是待求点的坐标，<code>normal</code>是三角形的法向量，<code>planePoint</code>是三角形平面上的任意一点的坐标。最后，如果距离为负数，则说明该点在三角形背面，距离取绝对值即可。</p><p>完整的实现代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getNormal</span>(<span class="hljs-params">p1, p2, p3</span>) &#123;<br>  <span class="hljs-keyword">const</span> vec1 = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>().<span class="hljs-title function_">subVectors</span>(p2, p1);<br>  <span class="hljs-keyword">const</span> vec2 = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>().<span class="hljs-title function_">subVectors</span>(p3, p1);<br>  <span class="hljs-keyword">return</span> vec1.<span class="hljs-title function_">cross</span>(vec2).<span class="hljs-title function_">normalize</span>(); <span class="hljs-comment">// 叉积并标准化</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">distanceToPlane</span>(<span class="hljs-params">point, normal, planePoint</span>) &#123;<br>  <span class="hljs-keyword">const</span> vec = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>().<span class="hljs-title function_">subVectors</span>(point, planePoint);<br>  <span class="hljs-keyword">return</span> vec.<span class="hljs-title function_">dot</span>(normal); <span class="hljs-comment">// 点积</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getPointToTriangleDistance</span>(<span class="hljs-params">point, triangle</span>) &#123;<br>  <span class="hljs-keyword">const</span> normal = <span class="hljs-title function_">getNormal</span>(triangle[<span class="hljs-number">0</span>], triangle[<span class="hljs-number">1</span>], triangle[<span class="hljs-number">2</span>]);<br>  <span class="hljs-keyword">const</span> distance = <span class="hljs-title function_">distanceToPlane</span>(point, normal, triangle[<span class="hljs-number">0</span>]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(distance);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>triangle</code>是包含三个顶点坐标的数组。</p><h2 id="使用Promise实现sleep-1s的函数"><a href="#使用Promise实现sleep-1s的函数" class="headerlink" title="使用Promise实现sleep 1s的函数"></a>使用Promise实现sleep 1s的函数</h2><p>可以使用<code>Promise</code>的定时器<code>setTimeout</code>来实现一个<code>sleep</code>函数，让其在一定时间后才执行下一步操作，具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params">ms</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, ms));<br>&#125;<br><br><span class="hljs-comment">// 使用方式</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">someFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这是第一步&#x27;</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-number">1000</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;一秒钟后执行第二步&#x27;</span>);<br>&#125;<br><br><span class="hljs-title function_">someFunction</span>();<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个<code>sleep</code>函数，它返回一个Promise对象，并在一定时间后通过<code>setTimeout</code>触发回调函数，从而让Promise的状态从<code>pending</code>变为<code>resolved</code>。在具体使用时，我们可以在某个<code>async</code>函数中使用<code>await sleep(1000)</code>，让其停顿一段时间后再执行后面的操作。</p><p>使用<code>Promise</code>实现的<code>sleep</code>函数并不是真正的“睡眠”，而是<strong>在等待时间内不执行下一步操作，而是将其放入Event Loop中，在调用栈空闲时再执行下一步操作</strong>。</p><h2 id="实现点击ul中的一个li时，返回点击的是第几个li"><a href="#实现点击ul中的一个li时，返回点击的是第几个li" class="headerlink" title="实现点击ul中的一个li时，返回点击的是第几个li"></a>实现点击ul中的一个li时，返回点击的是第几个li</h2><p>可以给每个li元素绑定一个点击事件，事件回调中获取当前点击的li的索引值，即可得到点击的是第几个li元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myList&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第一个li元素<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第二个li元素<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第三个li元素<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myList = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#myList&#x27;</span>);<br>myList.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-comment">// 获取点击的li元素</span><br>  <span class="hljs-keyword">const</span> targetLi = event.<span class="hljs-property">target</span>.<span class="hljs-title function_">closest</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br>  <span class="hljs-keyword">if</span>(targetLi) &#123;<br>    <span class="hljs-comment">// 获取点击的li元素在ul中的索引值</span><br>    <span class="hljs-keyword">const</span> index = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(myList.<span class="hljs-property">children</span>).<span class="hljs-title function_">indexOf</span>(targetLi);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`点击了第<span class="hljs-subst">$&#123;index+<span class="hljs-number">1</span>&#125;</span>个li元素`</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们给ul元素绑定一个<code>click</code>事件，当点击其中的一个li元素时，事件回调函数将被触发。在事件回调函数中，我们首先使用<code>event.target</code>属性获取当前点击的目标元素，如果该元素是一个li元素，则使用<code>Array.from(myList.children).indexOf(targetLi)</code>方法获取该li元素在ul中的索引值。需注意，<code>Array.from</code>将类数组对象转换成数组，所以我们才能使用数组的<code>indexOf</code>方法来获取索引值。最后我们使用<code>console.log</code>方法将点击的li元素的索引值输出到控制台。</p><p><strong>event.target.closest的作用是什么？</strong></p><p><code>event.target</code>属性返回触发事件的元素，而<code>closest</code>方法则可以获取指定元素的最近的祖先元素，使我们可以方便地向上遍历DOM树并获取指定的父元素或祖先元素。</p><p>该方法接受一个CSS选择器作为参数，并从当前元素开始在DOM树上向上遍历，直到找到一个与提供的选择器匹配的元素，或者到达根元素，则返回<code>null</code>。</p><p>在实际应用中，<code>closest</code>方法经常用于处理事件委托（event delegation）和特定元素的事件响应。在事件委托中，我们只在父元素绑定一个事件监听器，然后通过<code>event.target</code>来获取实际被点击的子元素，然后再获取该元素的祖先元素，从而根据祖先元素来判断具体要执行什么操作。</p><p>例如，在上面的代码示例中，我们通过<code>event.target</code>来获取实际被点击的li元素，并使用<code>closest(&#39;li&#39;)</code>获取该元素的最近的祖先li元素，以确保我们得到正确的li元素。这样的代码可以让我们的事件处理程序更加清晰、灵活和可维护。</p><h2 id="获取HTML文档树最深节点"><a href="#获取HTML文档树最深节点" class="headerlink" title="获取HTML文档树最深节点"></a>获取HTML文档树最深节点</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDeepestNode</span>(<span class="hljs-params">node, depth</span>) &#123;<br>  <span class="hljs-keyword">var</span> maxDepth = depth;<br>  <span class="hljs-keyword">var</span> deepestNode = node;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; node.<span class="hljs-property">childNodes</span>.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">var</span> child = node.<span class="hljs-property">childNodes</span>[i];<br>    <span class="hljs-keyword">if</span> (child.<span class="hljs-property">nodeType</span> === <span class="hljs-title class_">Node</span>.<span class="hljs-property">ELEMENT_NODE</span>) &#123;<br>      <span class="hljs-keyword">var</span> childDepth = <span class="hljs-title function_">getDeepestNode</span>(child, depth + <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">if</span> (childDepth &gt; maxDepth) &#123;<br>        deepestNode = child;<br>        maxDepth = childDepth;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> maxDepth === depth ? node : deepestNode;<br>&#125;<br><br><span class="hljs-keyword">var</span> html = <span class="hljs-string">&#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;p&gt;Paragraph 1&lt;/p&gt;&lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>;<br><span class="hljs-keyword">var</span> parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DOMParser</span>();<br><span class="hljs-keyword">var</span> doc = parser.<span class="hljs-title function_">parseFromString</span>(html, <span class="hljs-string">&#x27;text/html&#x27;</span>);<br><span class="hljs-keyword">var</span> deepestNode = <span class="hljs-title function_">getDeepestNode</span>(doc.<span class="hljs-property">documentElement</span>, <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(deepestNode.<span class="hljs-property">outerHTML</span>);<br></code></pre></td></tr></table></figure><p>在上面的示例代码中，我们定义了一个 <code>getDeepestNode</code> 函数，该函数使用递归方式计算给定节点的深度。我们遍历节点的所有子节点，并对每个子节点递归调用 <code>getDeepestNode</code> 函数，得到一个子节点的深度，然后将子节点的深度加1，最终计算出当前节点的深度。当节点没有子节点时，我们返回节点的当前深度。</p><p>接下来，我们遍历HTML文档树中的所有节点，调用 <code>getDeepestNode</code> 函数计算每个节点的深度，并找到最深的节点。当遇到有多个节点在最深处时，返回第一个最深的节点。</p><p>在示例代码中，HTML文档树中最深的节点是第二个 <code>&lt;p&gt;</code> 标签，因为它是在最深的分支的末端。所以我们输出这个节点的 <code>outerHTML</code>。</p><h2 id="类数组怎么转换为数组？"><a href="#类数组怎么转换为数组？" class="headerlink" title="类数组怎么转换为数组？"></a>类数组怎么转换为数组？</h2><ul><li><p>Array.from()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args); <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br>&#125;<br><br><span class="hljs-title function_">func</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>拓展运算符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> args = [...<span class="hljs-variable language_">arguments</span>];<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args); <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br>&#125;<br><br><span class="hljs-title function_">func</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>Array.prototype.slice.call()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args); <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br>&#125;<br><br><span class="hljs-title function_">func</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h1 id="代码输出"><a href="#代码输出" class="headerlink" title="代码输出"></a>代码输出</h1><h2 id="1-代码输出"><a href="#1-代码输出" class="headerlink" title="1. 代码输出"></a>1. 代码输出</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">fun2</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br><br><span class="hljs-title function_">fun1</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);<br>&#125;, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>);<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">7</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;)<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="2-代码输出"><a href="#2-代码输出" class="headerlink" title="2. 代码输出"></a>2. 代码输出</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    a = <span class="hljs-number">20</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>&#125;)()<br></code></pre></td></tr></table></figure><p>这段代码会在控制台输出 20。</p><p>因为变量a在全局作用域中被先声明并赋值为10，匿名函数立即被调用，而函数内部对a的赋值操作不使用var或let关键字声明新的变量，因此直接操作的是全局作用域中的变量a，使其值变为20。最终console.log()输出20。</p><p><strong>如果把var改成let呢？</strong></p><p>如果将 <code>var a = 10</code> 改为 <code>let a = 10</code>，则输出依然为20，这是因为立即执行函数表达式中的块级作用域中的 <code>a</code> 变量被改变为20后，在块级作用域外部的全局作用域中，对 <code>a</code> 变量的引用也改变了。而且，在使用 <code>let</code> 声明时，变量 <code>a</code> 的作用域被限制在该块级作用域内，不会在其它作用域中被修改或访问，因此代码块内部修改的是块级作用域中的 <code>a</code> 变量的值。</p><h2 id="3-代码输出"><a href="#3-代码输出" class="headerlink" title="3. 代码输出"></a>3. 代码输出</h2><p><code>var foo = 10</code>存在变量提升。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (!foo) &#123;<br>        <span class="hljs-keyword">var</span> foo = <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo);<br>&#125;<br><br><span class="hljs-title function_">fun</span>(); <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p><strong>如果把var改成const&#x2F;let呢？</strong></p><p>输出1。</p><h2 id="4-代码输出⭐"><a href="#4-代码输出⭐" class="headerlink" title="4. 代码输出⭐"></a><font color="#1b60a2">4. 代码输出⭐</font></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> object = &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello, World!&#x27;</span>,<br>    <span class="hljs-title function_">logMessage</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> message = <span class="hljs-string">&#x27;Hello Message&#x27;</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-built_in">setTimeout</span>(object.<span class="hljs-property">logMessage</span>, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>这段代码输出的结果将是 <code>undefined</code>，因为在 setTimeout 中，<code>object.logMessage</code> 函数中的 <code>this</code> 关键字将无法指向 <code>object</code> 对象本身，它将指向全局对象（例如 <code>window</code> 对象）。在全局对象中，并不存在名为 <code>message</code> 的属性，因此会输出 <code>undefined</code>。</p><p>如果我们希望它输出的是 <code>Hello, World!</code>，可以使用 <code>bind()</code> 方法将 <code>this</code> 关键字绑定到 <code>object</code> 对象上，例如 <code>setTimeout(object.logMessage.bind(object), 1000);</code> 这样就可以确保 <code>logMessage()</code> 函数中的 <code>this</code> 关键字指向 <code>object</code> 对象了。</p><h2 id="5-代码输出"><a href="#5-代码输出" class="headerlink" title="5. 代码输出"></a>5. 代码输出</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>    &#125;);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>&#125;);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-title function_">resolve</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>);<br>    <span class="hljs-title function_">reject</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">9</span>);<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10</span>);<br><span class="hljs-comment">// 1 5 6 7 10 4 8 3 2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Spring Recruitment</tag>
      
      <tag>Promise</tag>
      
      <tag>this</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NodeJS知识点总结</title>
    <link href="/2023/04/26/NodeJS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/26/NodeJS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="NodeJS相关"><a href="#NodeJS相关" class="headerlink" title="NodeJS相关"></a>NodeJS相关</h1><h2 id="是否了解Node-js的EventEmitter事件机制-实现I-x2F-O非阻塞的基础-？"><a href="#是否了解Node-js的EventEmitter事件机制-实现I-x2F-O非阻塞的基础-？" class="headerlink" title="是否了解Node.js的EventEmitter事件机制(实现I&#x2F;O非阻塞的基础)？"></a>是否了解<code>Node.js</code>的<code>EventEmitter</code>事件机制(实现I&#x2F;O非阻塞的基础)？</h2><p><code>EventEmitter</code>是Node.js中一个重要的模块，它提供了一种事件机制，用于实现基于观察者模式的事件处理。它的主要作用是在对象之间建立一种松耦合的联系，使得一个对象在发生某个动作时，可以通知多个对象进行相应的处理。</p><p>EventEmitter 实例对象具有两个主要功能：</p><ol><li>触发事件：通过 emit() 方法触发指定的事件，并把相关数据传递给事件监听函数（event listener or handler）。</li><li>注册监听器：通过 on() 或 addListener() 方法注册一个或多个事件监听函数，当事件被触发时，相关的监听函数将被调用执行。</li></ol><p>在Node.js中，<code>EventEmitter</code>模块是一个核心模块，可以直接使用。使用<code>EventEmitter</code>模块，需要先创建一个事件对象，然后在需要的时候触发事件，并绑定相应的事件处理函数。</p><p>下面是一个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyEmitter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">EventEmitter</span> &#123;&#125;<br><br><span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEmitter</span>();<br>myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;event&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;触发了事件&#x27;</span>);<br>&#125;);<br>myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;event&#x27;</span>);<br></code></pre></td></tr></table></figure><p>上述代码中，我们首先引入<code>events</code>模块，然后创建了一个自定义的事件类<code>MyEmitter</code>，并实例化它为<code>myEmitter</code>。接着，我们在<code>myEmitter</code>上绑定了一个<code>event</code>事件的处理函数，当事件被触发时，会输出<strong>触发了事件</strong>这个字符串。</p><p>在实际使用中，我们可以利用<code>EventEmitter</code>实现很多功能，例如实现自定义事件、异步处理、流处理等。在Node.js中，很多核心模块都是基于事件机制实现的，例如<code>http</code>模块、<code>fs</code>模块等。因此，熟练掌握<code>EventEmitter</code>机制对于Node.js开发非常重要。</p><h2 id="Node-js事件循环机制？"><a href="#Node-js事件循环机制？" class="headerlink" title="Node.js事件循环机制？"></a>Node.js事件循环机制？</h2><p><img src="https://static.vue-js.com/f2e34d80-c90e-11eb-ab90-d9ae814b240d.png" alt="img"></p><p>Node.js的EventLoop存在六个阶段，每个阶段都有对应的一个先进先出的回调队列。</p><ul><li>timers阶段：执行timer (setTimeout, setInterval) 的回调</li><li>I&#x2F;O事件回调阶段(I&#x2F;O callbacks)：执行延迟到下一个循环迭代的I&#x2F;O回调，即上一轮循环中为被执行的一些I&#x2F;O回调</li><li>闲置阶段：仅系统内部使用</li><li>轮询阶段(poll)：检索新的I&#x2F;O事件，执行I&#x2F;O相关的回调(几乎所有情况下，除了关闭的回调函数，那些由计时器和<code>setImmediate()</code>调度的之外)，其余情况node将适当在此阻塞</li><li>检查阶段(check)：<code>setImmediate()</code>回调函数在这里执行</li><li>关闭事件回调阶段(close callback)：一些关闭的回调函数，如：<code>socket.on(&quot;colse&quot;, ...)</code></li></ul><p>除了上述6个阶段，还存在<code>process.nextTick</code>，其不属于事件循环的任何一个阶段，它属于该阶段与下阶段之间的过渡, 即本阶段执行结束, 进入下一个阶段前, 所要执行的回调，类似插队</p><p>流程图如下所示：</p><p><img src="https://static.vue-js.com/fbe731d0-c90e-11eb-ab90-d9ae814b240d.png" alt="img"></p><h2 id="Node-js的宏任务队列与微任务队列"><a href="#Node-js的宏任务队列与微任务队列" class="headerlink" title="Node.js的宏任务队列与微任务队列"></a>Node.js的宏任务队列与微任务队列</h2><p>在<code>Node</code>中，同样存在宏任务和微任务，与浏览器中的事件循环相似</p><p>微任务对应有：</p><ul><li>next tick queue：process.nextTick</li><li>other queue：Promise的then回调、queueMicrotask</li></ul><p>宏任务对应有：</p><ul><li>timer queue：setTimeout、setInterval</li><li>poll queue：IO事件</li><li>check queue：setImmediate</li><li>close queue：close事件</li></ul><p>其执行顺序为：</p><ul><li>next tick microtask queue</li><li>other microtask queue</li><li>timer queue</li><li>poll queue</li><li>check queue</li><li>close queue</li></ul><h2 id="Node-js的事件循环机制和浏览器的事件循环机制有什么区别？"><a href="#Node-js的事件循环机制和浏览器的事件循环机制有什么区别？" class="headerlink" title="Node.js的事件循环机制和浏览器的事件循环机制有什么区别？"></a>Node.js的事件循环机制和浏览器的事件循环机制有什么区别？</h2><p>Node.js 的事件循环机制主要有以下几点特点：</p><ol><li>基于单线程。Node.js 在执行 JavaScript 代码时只有一个主线程，所有的异步任务都是在该线程中执行的。</li><li>采用时间驱动机制。Node.js 的事件循环机制以事件驱动的方式来处理异步任务，使用回调函数处理异步任务完成的事件。</li><li>实现了 I&#x2F;O 多路复用。Node.js 使用 I&#x2F;O 多路复用技术来处理网络 I&#x2F;O 操作，实现了非阻塞式的处理。</li></ol><p>而浏览器的事件循环机制主要有以下几点特点：</p><ol><li>基于多线程。浏览器使用多线程来执行 JavaScript 代码，可以同时处理多个任务。</li><li>采用事件循环或消息队列机制。在一般情况下，浏览器采用事件循环机制来处理 DOM 事件等异步任务。在一些特殊情况下，例如 Web Workers 中，浏览器采用消息队列机制来处理异步任务。</li><li>对于 Ajax 等异步任务，浏览器会将其交由浏览器内核的线程池来处理，同时也可能会使用缓存来优化异步请求的处理。</li></ol><h2 id="Node-ELEMENT-NODE是什么含义？"><a href="#Node-ELEMENT-NODE是什么含义？" class="headerlink" title="Node.ELEMENT_NODE是什么含义？"></a>Node.ELEMENT_NODE是什么含义？</h2><p><code>Node.ELEMENT_NODE</code> 是 JavaScript 中 Node 接口的一个属性，它表示节点类型为元素节点。元素节点是 HTML 文档中的一个重要组成部分，它由开始标签、结束标签和标签之间的内容组成。</p><p>DOM 树中的每个节点都可以用一个数字常量来表示它的节点类型，其中 <code>Node.ELEMENT_NODE</code> 的值为 1，表示当前节点是元素节点。其他节点类型包括 <code>Node.TEXT_NODE</code>，<code>Node.COMMENT_NODE</code>，<code>Node.DOCUMENT_NODE</code>等等。</p><p>在 JavaScript 中，我们可以使用节点的 <code>nodeType</code> 属性来获取节点类型。例如，如果我们有以下 HTML 元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span>Example<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们可以使用 JavaScript 来获取这个元素节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> elementNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;example&quot;</span>);<br><span class="hljs-keyword">if</span> (elementNode.<span class="hljs-property">nodeType</span> === <span class="hljs-title class_">Node</span>.<span class="hljs-property">ELEMENT_NODE</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This is an element node!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们检查 <code>elementNode</code> 的 <code>nodeType</code> 属性是否等于 <code>Node.ELEMENT_NODE</code>，以确保它是一个元素节点。如果是，我们打印一条提示信息到控制台。</p><h2 id="Node-js在搭建服务器的时候起了哪些作用？"><a href="#Node-js在搭建服务器的时候起了哪些作用？" class="headerlink" title="Node.js在搭建服务器的时候起了哪些作用？"></a>Node.js在搭建服务器的时候起了哪些作用？</h2><p>在搭建服务端时，Node.js 起到了以下几个作用：</p><ol><li>提供 Web 服务器：Node.js 提供了内置的 HTTP 模块，可以用来创建 Web 服务器。开发者可以使用该模块创建 HTTP 服务器，接收和处理客户端请求，并返回响应。</li><li>处理请求和响应：Node.js 可以用来处理客户端请求，解析请求头和请求体，提取参数和数据等。同时，Node.js 也可以用来构建响应，设置响应头和响应体，返回数据给客户端。</li><li>实现业务逻辑：Node.js 可以用来实现业务逻辑，如处理数据、验证用户信息、调用其他服务等。同时，Node.js 也可以用来调用第三方库和 API，实现更丰富的业务功能。</li><li>数据库交互：Node.js 可以用来与数据库进行交互，执行查询、插入、更新和删除操作等。Node.js 支持多种数据库，如 MongoDB、MySQL、PostgreSQL 等，可以根据实际需求选择合适的数据库。</li><li>处理并发请求：Node.js 的事件驱动和非阻塞 I&#x2F;O 特性，可以处理大量并发请求，提高服务器的性能和吞吐量。</li></ol><h2 id="node-js框架Express常用API？"><a href="#node-js框架Express常用API？" class="headerlink" title="node.js框架Express常用API？"></a>node.js框架Express常用API？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title function_">express</span>(); <span class="hljs-comment">// 创建一个express应用程序实例</span><br>app.<span class="hljs-title function_">use</span>(); <span class="hljs-comment">// 使用中间件函数，可以用来处理HTTP请求、响应和错误</span><br>app.<span class="hljs-title function_">set</span>(); <span class="hljs-comment">// 设置应用程序级别变量</span><br>app.<span class="hljs-title function_">get</span>(); <span class="hljs-comment">// 获取应用级别的变量</span><br>app.<span class="hljs-title function_">listen</span>(); <span class="hljs-comment">// 启动express应用程序并指定监听端口</span><br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>();<br>router.<span class="hljs-title function_">get</span>(); <span class="hljs-comment">// 创建HTTP GET路由</span><br>router.<span class="hljs-title function_">post</span>(); <span class="hljs-comment">// 创建HTTP POST路由</span><br>res.<span class="hljs-title function_">send</span>(); <span class="hljs-comment">// 将HTTP响应发送给客户端</span><br>res.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// 将JSON格式的HTTP响应发送给客户端</span><br>res.<span class="hljs-title function_">render</span>(); <span class="hljs-comment">// 将模板渲染成HTML，并将其发送给客户端</span><br>req.<span class="hljs-property">params</span>; <span class="hljs-comment">// 获取路由参数</span><br>req.<span class="hljs-property">query</span>; <span class="hljs-comment">// 获取查询参数</span><br>req.<span class="hljs-property">body</span>; <span class="hljs-comment">// 获取请求体的内容</span><br></code></pre></td></tr></table></figure><h2 id="Node-js实现统计所有接口的响应时间-服务端接到请求到给出内容的间隔时间-怎么实现？"><a href="#Node-js实现统计所有接口的响应时间-服务端接到请求到给出内容的间隔时间-怎么实现？" class="headerlink" title="Node.js实现统计所有接口的响应时间(服务端接到请求到给出内容的间隔时间)怎么实现？"></a>Node.js实现统计所有接口的响应时间(服务端接到请求到给出内容的间隔时间)怎么实现？</h2><p><strong>可以使用 Express 框架和一个自定义的中间件来实现统计所有接口的响应时间。具体的实现步骤如下：</strong></p><p>使用 Express 框架创建应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br></code></pre></td></tr></table></figure><p>实现一个自定义的中间件，记录请求开始时间和请求结束时间，并计算出请求响应时间：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">responseTimeLogger</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>  <span class="hljs-keyword">const</span> start = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>  res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;finish&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> end = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    <span class="hljs-keyword">const</span> duration = end - start;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>      <span class="hljs-string">`<span class="hljs-subst">$&#123;req.method&#125;</span> <span class="hljs-subst">$&#123;req.originalUrl&#125;</span> <span class="hljs-subst">$&#123;duration&#125;</span>ms`</span><br>    );<br>  &#125;);<br>  <span class="hljs-title function_">next</span>();<br>&#125;<br><br>app.<span class="hljs-title function_">use</span>(responseTimeLogger);<br></code></pre></td></tr></table></figure><p>在应用中添加路由，以便测试统计响应时间是否正常：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello, World!&#x27;</span>);<br>&#125;);<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/foo&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span> &#125;);<br>  &#125;, <span class="hljs-number">500</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>启动应用并测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;App is listening on port 3000.&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>打开浏览器，访问首页和 &#x2F;api&#x2F;foo 接口，可以在控制台中看到类似于以下的输出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> / 2ms<br><span class="hljs-built_in">GET</span> /api/foo 503ms<br></code></pre></td></tr></table></figure><p>其中，<code>GET / 2ms</code> 表示访问首页的响应时间为 2ms，<code>GET /api/foo 503ms</code> 表示访问 &#x2F;api&#x2F;foo 接口的响应时间为 503ms。</p><p>这样，我们就利用自定义的中间件实现了统计所有接口的响应时间的功能。</p><p><strong>还可以使用 Node.js 的原生模块 <code>http</code>、<code>fs</code> 等进行实现。具体步骤如下：</strong></p><p>创建 http 服务器，监听客户端请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server is running on port 3000.&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>创建一个对象用于保存接口响应时间：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> responseTime = &#123;&#125;;<br></code></pre></td></tr></table></figure><p>监听客户端请求，并记录请求开始时间：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> start = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>  <span class="hljs-comment">// ...</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>在发送请求响应之前，记录请求结束时间，并计算请求响应间隔时间：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript">http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> start = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><br>  res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;finish&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> end = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    <span class="hljs-keyword">const</span> duration = end - start;<br>    <span class="hljs-keyword">const</span> path = req.<span class="hljs-property">url</span>;<br><br>    <span class="hljs-keyword">if</span> (responseTime[path]) &#123;<br>      responseTime[path].<span class="hljs-property">count</span>++;<br>      responseTime[path].<span class="hljs-property">total</span> += duration;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      responseTime[path] = &#123;<br>        <span class="hljs-attr">count</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">total</span>: duration<br>      &#125;;<br>    &#125;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;req.method&#125;</span> <span class="hljs-subst">$&#123;req.url&#125;</span> <span class="hljs-subst">$&#123;duration&#125;</span>ms`</span>);<br>  &#125;);<br><br>  <span class="hljs-comment">// send response to client</span><br>  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span>&#125;);<br>  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;Hello, World!&#x27;</span>);<br>  res.<span class="hljs-title function_">end</span>();<br>&#125;)<br></code></pre></td></tr></table></figure><p>在服务器关闭时将统计数据输出到文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br>process.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  fs.<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-string">&#x27;response-time.txt&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(responseTime, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>));<br>  process.<span class="hljs-title function_">exit</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>将上述代码片段放入一个独立的模块中，以便在多个文件中使用。最终代码示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-keyword">const</span> responseTime = &#123;&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-keyword">const</span> start = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><br>  res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;finish&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> end = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    <span class="hljs-keyword">const</span> duration = end - start;<br>    <span class="hljs-keyword">const</span> path = req.<span class="hljs-property">url</span>;<br><br>    <span class="hljs-keyword">if</span> (responseTime[path]) &#123;<br>      responseTime[path].<span class="hljs-property">count</span>++;<br>      responseTime[path].<span class="hljs-property">total</span> += duration;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      responseTime[path] = &#123;<br>        <span class="hljs-attr">count</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">total</span>: duration<br>      &#125;;<br>    &#125;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;req.method&#125;</span> <span class="hljs-subst">$&#123;req.url&#125;</span> <span class="hljs-subst">$&#123;duration&#125;</span>ms`</span>);<br>  &#125;);<br>&#125;<br><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">log</span>(req, res);<br><br>  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span>&#125;);<br>  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;Hello, World!&#x27;</span>);<br>  res.<span class="hljs-title function_">end</span>();<br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server is running on port 3000.&#x27;</span>);<br>&#125;);<br><br>process.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  fs.<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-string">&#x27;response-time.txt&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(responseTime, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>));<br>  process.<span class="hljs-title function_">exit</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>以上代码使用了 Node.js 的原生模块 <code>fs</code> 将统计数据输出到文件中。</p><h2 id="Node-js的模块化和ES6的区别？"><a href="#Node-js的模块化和ES6的区别？" class="headerlink" title="Node.js的模块化和ES6的区别？"></a>Node.js的模块化和ES6的区别？</h2><ol><li>模块导出方式不同：Node.js 采用 <code>module.exports</code> 和 <code>exports</code> 导出模块，ES6 采用 <code>export</code> 导出模块。</li><li>模块引入方式不同：Node.js 采用 <code>require()</code> 引入模块，ES6 采用 <code>import</code> 引入模块。</li><li>支持的 ECMAScript 版本不同：Node.js 目前默认支持 ES5 和部分 ES6 特性，而 ES6 支持的特性更加丰富。</li><li>模块文件后缀名不同：Node.js 默认使用 <code>.js</code> 后缀作为模块文件后缀名，而在 ES6 中，可以使用 <code>.js</code>、<code>.mjs</code> 或 <code>.jsx</code> 作为模块文件后缀名。</li><li>模块依赖管理不同：Node.js 采用 CommonJS 规范管理模块依赖关系，并通过 <code>npm</code> 包管理器进行模块管理。而 ES6 采用 ECMAScript 规范管理模块依赖关系，并通过 <code>import</code> 和 <code>export</code> 语法进行模块管理。</li></ol><h2 id="Node-js文件查找的优先级？require方法的文件查找策略？"><a href="#Node-js文件查找的优先级？require方法的文件查找策略？" class="headerlink" title="Node.js文件查找的优先级？require方法的文件查找策略？"></a>Node.js文件查找的优先级？require方法的文件查找策略？</h2><ul><li>缓存的模块优先级最高</li><li>如果是内置模块，则直接返回，优先级仅次缓存的模块</li><li>如果是绝对路径 &#x2F; 开头，则从根目录找</li><li>如果是相对路径 .&#x2F;开头，则从当前require文件相对位置找</li><li>如果文件没有携带后缀，先从js、json、node按顺序查找</li><li>如果是目录，则根据 package.json的main属性值决定目录下入口文件，默认情况为 index.js</li><li>如果文件为第三方模块，则会引入 node_modules 文件，如果不在当前仓库文件中，则自动从上级递归查找，直到根目录</li></ul><p>NodeJS对CommonJS进行了支持和实现，让我们在开发node的过程中可以方便的进行模块化开发：</p><ul><li>在Node中每个JS文件都是一个单独的模块</li><li>模块中包含CommonJS规范的核心变量：</li></ul><h3 id="查找策略"><a href="#查找策略" class="headerlink" title="查找策略"></a>查找策略</h3><p><code>require</code>方法接收一下几种参数的传递：</p><ul><li>原生模块：http、fs、path等</li><li>相对路径的文件模块：.&#x2F;mod或..&#x2F;mod</li><li>绝对路径的文件模块：&#x2F;pathtomodule&#x2F;mod</li><li>目录作为模块：.&#x2F;dirname</li><li>非原生模块的文件模块：mod</li></ul><p><code>require</code>参数较为简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同，如下图：</p><p><img src="https://static.vue-js.com/33ae8ef0-c9ba-11eb-85f6-6fac77c0c9b3.png" alt="img"></p><p>从上图可以看见，文件模块存在缓存区，寻找模块路径的时候都会<strong>优先从缓存中加载已经存在的模块</strong>。</p><p><strong>原生模块</strong>：</p><p>像原生模块这些，通过<code>require</code>方法在解析文件名之后，优先检查模块是否在原生模块列表中，如果在则从原生模块中加载</p><p><strong>绝对路径、相对路径</strong>：</p><p>如果<code>require</code>绝对路径的文件，则直接查找对应的路径，速度最快</p><p>相对路径的模块则相对于当前调用<code>require</code>的文件去查找</p><p>如果按确切的文件名没有找到模块，则 <code>NodeJs</code> 会尝试带上 <code>.js</code>、<code>.json</code>或 <code>.node</code>拓展名再加载</p><p><strong>目录作为模块</strong>：</p><p>默认情况是根据根目录中<code>package.json</code>文件的<code>main</code>来指定目录模块，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123; <br>    <span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;some-library&quot;</span>,<br>  <span class="hljs-string">&quot;main&quot;</span> : <span class="hljs-string">&quot;main.js&quot;</span> <br>&#125;<br></code></pre></td></tr></table></figure><p>如果这是在<code>./some-library node_modules</code>目录中，则 <code>require(&#39;./some-library&#39;)</code> 会试图加载 <code>./some-library/main.js</code></p><p>如果目录里没有 <code>package.json</code>文件，或者 <code>main</code>入口不存在或无法解析，则会试图加载目录下的 <code>index.js</code> 或 <code>index.node</code> 文件</p><p><strong>非原生模块</strong>：</p><p>在每个文件中都存在<code>module.paths</code>，表示模块的搜索路径，<code>require</code>就是根据其来寻找文件</p><p>在<code>window</code>下输出如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">[ <br>    <span class="hljs-string">&#x27;c:\\nodejs\\node_modules&#x27;</span>,<br><span class="hljs-string">&#x27;c:\\node_modules&#x27;</span> <br>]<br></code></pre></td></tr></table></figure><p>可以看出<code>module path</code>的生成规则为：从当前文件目录开始查找<code>node_modules</code>目录；然后依次进入父目录，查找父目录下的<code>node_modules</code>目录，依次迭代，直到根目录下的<code>node_modules</code>目录</p><p>当都找不到的时候，则会从系统<code>NODE_PATH</code>环境变量查找</p><p>例如：</p><p>如果在<code>/home/ry/projects/foo.js</code>文件里调用了 <code>require(&#39;bar.js&#39;)</code>，则 Node.js 会按以下顺序查找：</p><ul><li>&#x2F;home&#x2F;ry&#x2F;projects&#x2F;node_modules&#x2F;bar.js</li><li>&#x2F;home&#x2F;ry&#x2F;node_modules&#x2F;bar.js</li><li>&#x2F;home&#x2F;node_modules&#x2F;bar.js</li><li>&#x2F;node_modules&#x2F;bar.js</li></ul><p>这使得程序本地化它们的依赖，避免它们产生冲突</p><h2 id="Node-js中间件？如何封装？"><a href="#Node-js中间件？如何封装？" class="headerlink" title="Node.js中间件？如何封装？"></a>Node.js中间件？如何封装？</h2><p>中间件（Middleware）是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的。</p><p>在<code>NodeJS</code>中，中间件主要是指封装<code>http</code>请求细节处理的方法</p><p>例如在<code>express</code>、<code>koa</code>等<code>web</code>框架中，中间件的本质为一个回调函数，参数包含请求对象、响应对象和执行下一个中间件的函数</p><p><img src="https://static.vue-js.com/6a6ed3f0-cce4-11eb-85f6-6fac77c0c9b3.png" alt="img"></p><p>在这些中间件函数中，我们可以执行业务逻辑代码，修改请求和响应对象、返回响应数据等操作。</p><p><strong>如何进行封装：</strong></p><p>编写中间件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logger</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;req.method&#125;</span> <span class="hljs-subst">$&#123;req.url&#125;</span> was requested`</span>);<br>  <span class="hljs-title function_">next</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">errorHandler</span>(<span class="hljs-params">err, req, res, next</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err.<span class="hljs-property">stack</span>);<br>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Something broke!&#x27;</span>);<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  logger,<br>  errorHandler<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用中间件(Express)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; logger, errorHandler &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./middleware&#x27;</span>);<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br>app.<span class="hljs-title function_">use</span>(logger);<br><span class="hljs-comment">// more middleware and routes</span><br>app.<span class="hljs-title function_">use</span>(errorHandler);<br><br><span class="hljs-comment">// start the server</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PORT</span> = <span class="hljs-number">3000</span>;<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-variable constant_">PORT</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Server listening on port <span class="hljs-subst">$&#123;PORT&#125;</span>`</span>));<br></code></pre></td></tr></table></figure><h2 id="NodeJS是单线程的，会发生阻塞吗？"><a href="#NodeJS是单线程的，会发生阻塞吗？" class="headerlink" title="NodeJS是单线程的，会发生阻塞吗？"></a>NodeJS是单线程的，会发生阻塞吗？</h2><p>虽然 Node.js 的主线程是单线程运行的，但是 Node.js 底层采用了基于 libuv 库的<strong>事件驱动和非阻塞 I&#x2F;O</strong> 的机制来实现异步非阻塞的编程模型，因此不会导致阻塞。</p><p>在 Node.js 中，<strong>当有异步 I&#x2F;O 操作时，主线程会将该事件交给 libuv（由 C++ 编写）来处理，然后继续处理后面的请求</strong>。在操作完成后，libuv 会<strong>触发相应的回调函数，通过事件循环机制，将数据返回给主线程</strong>。这样，就能在不阻塞主线程的情况下处理多个 I&#x2F;O 操作。</p><p>然而，也需要注意的是，如果在 Node.js 应用程序的代码编写中存在非异步操作（如大量运算、文件读取等），并且这些操作时间过长，将会导致 Node.js 暂停事件循环并终止响应，这种情况被称为事件循环阻塞。所以在编写 Node.js 代码时，还需要注意避免这种情况的发生。</p><h2 id="前端实现登录鉴权的方案有哪些？"><a href="#前端实现登录鉴权的方案有哪些？" class="headerlink" title="前端实现登录鉴权的方案有哪些？"></a>前端实现登录鉴权的方案有哪些？</h2><ol><li>Token 方案：在用户登录后，后端返回一个 Token，前端将 Token 存储在本地，之后每次请求时将 Token 带上，后端进行校验。Token 一般有两种形式：JWT 和自定义 Token。</li><li>Session 方案：后端将用户登录信息存储在服务器中，每次请求时进行校验，可以通过 cookie 或者 header 发送 sessionid 信息。</li><li>OAuth 方案：将用户授权给第三方应用，用户在第三方应用进行登录后，后端将用户信息进行获取，并进行鉴权和授权。</li><li>单点登录（SSO）方案：用户进行登录后，可以在多个应用之间进行共享，只需要在第一次登录时进行授权，之后在其他应用时不需要再次登录。</li></ol><h2 id="什么是JWT鉴权机制？"><a href="#什么是JWT鉴权机制？" class="headerlink" title="什么是JWT鉴权机制？"></a>什么是JWT鉴权机制？</h2><p>JWT（JSON Web Token），本质就是一个字符串书写规范，如下图，作用是用来在用户和服务器之间传递安全可靠的信息。</p><p>在目前前后端分离的开发过程中，使用<code>token</code>鉴权机制用于身份验证是最常见的方案，流程如下：</p><ul><li>服务器当验证用户账号和密码正确的时候，给用户颁发一个令牌，这个令牌作为后续用户访问一些接口的凭证</li><li>后续访问会根据这个令牌判断用户时候有权限进行访问</li></ul><p><code>Token</code>，分成了三部分，头部（Header）、载荷（Payload）、签名（Signature），并以<code>.</code>进行拼接。其中头部和载荷都是以<code>JSON</code>格式存放数据，只是进行了编码。</p><p>Express生成token</p><p>借助第三方库<code>jsonwebtoken</code>，通过<code>jsonwebtoken</code>的<code>sign</code>方法生成一个<code>token</code>：</p><ul><li>第一个参数指的是<code>PayLoad</code></li><li>第二个参数为密钥，服务端特有</li><li>第三个参数是option，可以定义token过期时间</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;jsonwebtoken&quot;</span>); <span class="hljs-comment">// 引入存储token</span><br><span class="hljs-keyword">const</span> secret = <span class="hljs-string">&quot;moodnotes&quot;</span>; <span class="hljs-comment">// token的前缀 </span><br><span class="hljs-keyword">const</span> token = jwt.<span class="hljs-title function_">sign</span>(userInfo, secret, &#123; <span class="hljs-comment">// 通过登录信息生成token</span><br>    <span class="hljs-attr">expiresIn</span>: <span class="hljs-number">60</span>*<span class="hljs-number">60</span>*<span class="hljs-number">24</span> <span class="hljs-comment">// 24小时后过期</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>验证token</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">decode = jwt.<span class="hljs-title function_">verify</span>(token, secret); <span class="hljs-comment">// 验证token</span><br></code></pre></td></tr></table></figure><h2 id="JWT鉴权机制的优缺点"><a href="#JWT鉴权机制的优缺点" class="headerlink" title="JWT鉴权机制的优缺点"></a>JWT鉴权机制的优缺点</h2><p>优点：</p><ul><li>json具有通用性，所以可以跨语言</li><li>组成简单，字节占用小，便于传输</li><li>服务端无需保存会话信息，很容易进行水平扩展</li><li>一处生成，多处使用，可以在分布式系统中，解决单点登录问题</li><li>可防护CSRF攻击</li></ul><p>缺点：</p><ul><li>payload部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息</li><li>需要保护好加密密钥，一旦泄露后果不堪设想</li><li>为避免token被劫持，最好使用https协议</li></ul><h2 id="JWT采用的是什么加密方法？"><a href="#JWT采用的是什么加密方法？" class="headerlink" title="JWT采用的是什么加密方法？"></a>JWT采用的是什么加密方法？</h2><p>JWT (JSON Web Tokens) 通常使用的加密算法是对称加密算法，其中最常用的是 <strong>HMAC-SHA256</strong>。对称加密算法需要<strong>在生成 JWT 时使用一个密钥进行加密，接收 JWT 时需要相同的密钥进行解密</strong>。除了对称加密算法，JWT 也可以使用非对称加密算法，例如 RSA。</p><p>(面试的时候真的没往这方面想…一直在考虑有什么加密方法…(´。＿。｀))</p><h2 id="NodeJS如何实现图片上传？"><a href="#NodeJS如何实现图片上传？" class="headerlink" title="NodeJS如何实现图片上传？"></a>NodeJS如何实现图片上传？</h2><p>文件上传在日常开发中应用很广泛，我们发微博、发微信朋友圈都会用到了图片上传功能。</p><p>因为浏览器限制，浏览器不能直接操作文件系统的，需要通过浏览器所暴露出来的统一接口，由用户主动授权发起来访问文件动作，然后读取文件内容进指定内存里，最后执行提交请求操作，将内存里的文件内容数据上传到服务端，服务端解析前端传来的数据信息后存入文件里。</p><p>对于文件上传，我们需要设置请求头为<code>content-type:multipart/form-data</code></p><blockquote><p>multipart互联网上的混合资源，就是资源由多种元素组成，form-data表示可以使用HTML Forms 和 POST 方法上传文件</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /t2/upload.do HTTP/<span class="hljs-number">1.1</span><br>User-Agent<span class="hljs-punctuation">:</span> SOHUWapRebot<br>Accept-Language<span class="hljs-punctuation">:</span> zh-cn<span class="hljs-punctuation">,</span>zh;q=<span class="hljs-number">0.5</span><br>Accept-Charset<span class="hljs-punctuation">:</span> GBK<span class="hljs-punctuation">,</span>utf<span class="hljs-number">-8</span>;q=<span class="hljs-number">0.7</span><span class="hljs-punctuation">,</span>*;q=<span class="hljs-number">0.7</span><br>Connection<span class="hljs-punctuation">:</span> keep-alive<br>Content-Length<span class="hljs-punctuation">:</span> <span class="hljs-number">60408</span><br>Content-Type<span class="hljs-punctuation">:</span>multipart/form-data; boundary=ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC<br>Host<span class="hljs-punctuation">:</span> w.sohu.com<br><br>--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC<br>Content-Disposition<span class="hljs-punctuation">:</span> form-data; name=<span class="hljs-string">&quot;city&quot;</span><br><br>Santa colo<br>--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC<br>Content-Disposition<span class="hljs-punctuation">:</span> form-data;name=<span class="hljs-string">&quot;desc&quot;</span><br>Content-Type<span class="hljs-punctuation">:</span> text/plain; charset=UTF<span class="hljs-number">-8</span><br>Content-Transfer-Encoding<span class="hljs-punctuation">:</span> <span class="hljs-number">8</span>bit<br> <br>...<br>--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC<br>Content-Disposition<span class="hljs-punctuation">:</span> form-data;name=<span class="hljs-string">&quot;pic&quot;</span>; filename=<span class="hljs-string">&quot;photo.jpg&quot;</span><br>Content-Type<span class="hljs-punctuation">:</span> application/octet-stream<br>Content-Transfer-Encoding<span class="hljs-punctuation">:</span> binary<br> <br>... binary data of the jpg ...<br>--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC--<br></code></pre></td></tr></table></figure><p><code>boundary</code>表示分隔符，如果要上传多个表单项，就要使用<code>boundary</code>分割，每个表单项由<code>———XXX</code>开始，以<code>———XXX</code>结尾</p><p>而<code>xxx</code>是即时生成的字符串，用以确保整个分隔符不会在文件或表单项的内容中出现</p><p>每个表单项必须包含一个 <code>Content-Disposition</code> 头，其他的头信息则为可选项， 比如 <code>Content-Type</code></p><p><code>Content-Disposition</code> 包含了 <code>type</code>和 一个名字为<code>name</code>的 <code>parameter</code>，<code>type</code> 是 <code>form-data</code>，<code>name</code>参数的值则为表单控件（也即 field）的名字，如果是文件，那么还有一个 <code>filename</code>参数，值就是文件名</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">Content-Disposition<span class="hljs-punctuation">:</span> form-data; name=<span class="hljs-string">&quot;user&quot;</span>; filename=<span class="hljs-string">&quot;logo.png&quot;</span><br></code></pre></td></tr></table></figure><p>至于使用<code>multipart/form-data</code>，是因为文件是以二进制的形式存在，其作用是专门用于传输大型二进制数据，效率高。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">处理文件上传的路由</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> multer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;multer&#x27;</span>)<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-keyword">const</span> dirPath = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;..&#x27;</span>, <span class="hljs-string">&#x27;public/upload&#x27;</span>)<br><br><span class="hljs-keyword">const</span> storage = multer.<span class="hljs-title function_">diskStorage</span>(&#123;<br>  <span class="hljs-comment">// destination: &#x27;upload&#x27;, //string时,服务启动将会自动创建文件夹</span><br>  <span class="hljs-attr">destination</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">req, file, cb</span>) &#123; <span class="hljs-comment">//函数需手动创建文件夹</span><br>    <span class="hljs-comment">// console.log(&#x27;destination()&#x27;, file)</span><br>    <span class="hljs-keyword">if</span> (!fs.<span class="hljs-title function_">existsSync</span>(dirPath)) &#123;<br>      fs.<span class="hljs-title function_">mkdir</span>(dirPath, <span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123;<br>        <span class="hljs-keyword">if</span> (err) &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-title function_">cb</span>(<span class="hljs-literal">null</span>, dirPath)<br>        &#125;<br>      &#125;)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">cb</span>(<span class="hljs-literal">null</span>, dirPath)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">filename</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">req, file, cb</span>) &#123;<br>    <span class="hljs-comment">// console.log(&#x27;filename()&#x27;, file)</span><br>    <span class="hljs-keyword">var</span> ext = path.<span class="hljs-title function_">extname</span>(file.<span class="hljs-property">originalname</span>)<br>    <span class="hljs-title function_">cb</span>(<span class="hljs-literal">null</span>, file.<span class="hljs-property">fieldname</span> + <span class="hljs-string">&#x27;-&#x27;</span> + <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() + ext)<br>  &#125;<br>&#125;)<br><span class="hljs-keyword">const</span> upload = <span class="hljs-title function_">multer</span>(&#123;storage&#125;)<br><span class="hljs-keyword">const</span> uploadSingle = upload.<span class="hljs-title function_">single</span>(<span class="hljs-string">&#x27;file&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">fileUpload</span>(<span class="hljs-params">router</span>) &#123;<br><br>  <span class="hljs-comment">// 上传图片</span><br>  router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/manage/img/upload&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">uploadSingle</span>(req, res, <span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123; <span class="hljs-comment">//错误处理</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;上传文件失败, &quot;</span> , err);<br>      <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123;<br>          <span class="hljs-attr">code</span>: <span class="hljs-number">500</span>,<br>          <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;上传文件失败, &#x27;</span> + err<br>        &#125;)<br>      &#125;<br>      <span class="hljs-keyword">var</span> file = req.<span class="hljs-property">file</span><br>      res.<span class="hljs-title function_">send</span>(&#123;<br>        <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,<br>        <span class="hljs-attr">data</span>: &#123;<br>          <span class="hljs-attr">name</span>: file.<span class="hljs-property">filename</span>,<br>          <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:6000/upload/&#x27;</span> + file.<span class="hljs-property">filename</span><br>        &#125;<br>      &#125;)<br><br>    &#125;)<br>  &#125;)<br><br>  <span class="hljs-comment">// 删除图片</span><br>  router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/manage/img/delete&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123;name&#125; = req.<span class="hljs-property">body</span><br>    fs.<span class="hljs-title function_">unlink</span>(path.<span class="hljs-title function_">join</span>(dirPath, name), <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>        res.<span class="hljs-title function_">send</span>(&#123;<br>          <span class="hljs-attr">status</span>: <span class="hljs-number">1</span>,<br>          <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;删除文件失败, &#x27;</span> + err<br>        &#125;)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        res.<span class="hljs-title function_">send</span>(&#123;<br>          <span class="hljs-attr">status</span>: <span class="hljs-number">0</span><br>        &#125;)<br>      &#125;<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Node性能如何进行监控以及优化？"><a href="#Node性能如何进行监控以及优化？" class="headerlink" title="Node性能如何进行监控以及优化？"></a>Node性能如何进行监控以及优化？</h2><p><code>Node</code>作为一门服务端语言，性能方面尤为重要，其衡量指标一般有如下：</p><ul><li>CPU</li><li>内存</li><li>I&#x2F;O</li><li>网络</li></ul><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>主要分成了两部分：</p><ul><li>CPU负载：在某个时间段内，占用以及等待CPU的进程总数</li><li>CPU使用率：CPU时间占用状况，等于 1 - 空闲CPU时间(idle time) &#x2F; CPU总时间</li></ul><p>这两个指标都是用来评估系统当前CPU的繁忙程度的量化指标</p><p><code>Node</code>应用一般不会消耗很多的<code>CPU</code>，如果<code>CPU</code>占用率高，则表明应用存在很多同步操作，导致异步任务回调被阻塞</p><h3 id="内存指标"><a href="#内存指标" class="headerlink" title="内存指标"></a>内存指标</h3><p>内存是一个非常容易量化的指标。 内存占用率是评判一个系统的内存瓶颈的常见指标。 对于Node来说，内部内存堆栈的使用状态也是一个可以量化的指标</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// /app/lib/memory.js</span><br><span class="hljs-keyword">const</span> os = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;os&#x27;</span>);<br><span class="hljs-comment">// 获取当前Node内存堆栈情况</span><br><span class="hljs-keyword">const</span> &#123; rss, heapUsed, heapTotal &#125; = process.<span class="hljs-title function_">memoryUsage</span>();<br><span class="hljs-comment">// 获取系统空闲内存</span><br><span class="hljs-keyword">const</span> sysFree = os.<span class="hljs-title function_">freemem</span>();<br><span class="hljs-comment">// 获取系统总内存</span><br><span class="hljs-keyword">const</span> sysTotal = os.<span class="hljs-title function_">totalmem</span>();<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">memory</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">sys</span>: <span class="hljs-number">1</span> - sysFree / sysTotal,  <span class="hljs-comment">// 系统内存占用率</span><br>      <span class="hljs-attr">heap</span>: heapUsed / headTotal,   <span class="hljs-comment">// Node堆内存占用率</span><br>      <span class="hljs-attr">node</span>: rss / sysTotal,         <span class="hljs-comment">// Node占用系统内存的比例</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>rss：表示node进程占用的内存总量。</li><li>heapTotal：表示堆内存的总量。</li><li>heapUsed：实际堆内存的使用量。</li><li>external ：外部程序的内存使用量，包含Node核心的C++程序的内存使用量</li></ul><p>在<code>Node</code>中，一个进程的最大内存容量为1.5GB。因此我们需要减少内存泄露</p><h3 id="磁盘-I-x2F-O"><a href="#磁盘-I-x2F-O" class="headerlink" title="磁盘 I&#x2F;O"></a>磁盘 I&#x2F;O</h3><p>硬盘的<code>IO</code> 开销是非常昂贵的，硬盘 IO 花费的 CPU 时钟周期是内存的 164000 倍</p><p>内存 <code>IO</code>比磁盘<code>IO</code> 快非常多，所以使用内存缓存数据是有效的优化方法。常用的工具如 <code>redis</code>、<code>memcached</code>等</p><p>并不是所有数据都需要缓存，访问频率高，生成代价比较高的才考虑是否缓存，也就是说影响你性能瓶颈的考虑去缓存，并且而且缓存还有缓存雪崩、缓存穿透等问题要解决</p><h3 id="如何进行监控？"><a href="#如何进行监控？" class="headerlink" title="如何进行监控？"></a>如何进行监控？</h3><p>关于性能方面的监控，一般情况都需要借助工具来实现</p><p>这里采用<code>Easy-Monitor 2.0</code>，其是轻量级的 <code>Node.js</code> 项目内核性能监控 + 分析工具，在默认模式下，只需要在项目入口文件 <code>require</code> 一次，无需改动任何业务代码即可开启内核级别的性能监控分析</p><p>使用方法如下：</p><p>在你的项目入口文件中按照如下方式引入，当然请传入你的项目名称：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> easyMonitor = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;easy-monitor&#x27;</span>);<br><span class="hljs-title function_">easyMonitor</span>(<span class="hljs-string">&#x27;你的项目名称&#x27;</span>);<br></code></pre></td></tr></table></figure><p>打开浏览器，访问 <code>http://localhost:12333</code> ，即可看到进程界面</p><p>关于定制化开发、通用配置项以及如何动态更新配置项详见官方文档</p><h2 id="如何进行优化？"><a href="#如何进行优化？" class="headerlink" title="如何进行优化？"></a>如何进行优化？</h2><p>关于<code>Node</code>的性能优化的方式有：</p><ul><li>使用最新版本Node.js</li><li>正确使用流 Stream</li><li>代码层面优化</li><li>内存管理优化</li></ul><h2 id="为什么选择用Node-js做服务端？"><a href="#为什么选择用Node-js做服务端？" class="headerlink" title="为什么选择用Node.js做服务端？"></a>为什么选择用Node.js做服务端？</h2><p><strong>快速</strong></p><p>Node.js 使用事件驱动和非阻塞I&#x2F;O模型，使得其非常适合处理高并发的请求。这使得响应速度非常快，可以在短时间内处理大量的请求。</p><p><strong>JavaScript</strong></p><p>由于 Node.js 是基于 JavaScript 构建的，因此前端开发者可以在服务端使用同一种语言进行开发，这样可以提高开发效率和便捷性。</p><p><strong>社区</strong></p><p>Node.js 有着庞大而活跃的社区，有许多库和工具可以使用，可以方便的解决常见的问题。</p><p><strong>可扩展性</strong></p><p>Node.js 具有很好的可扩展性，可以通过添加更多的进程和服务器来解决负载问题，同时也支持分布式处理。</p><p><strong>应用场景多样</strong></p><p>Node.js 可以被应用于各种场景，从简单的服务端渲染到实时应用、大规模数据操作等。同时也可以用于移动和桌面应用程序开发。</p><h2 id="Node-js相比Java等后端语言有什么特点？"><a href="#Node-js相比Java等后端语言有什么特点？" class="headerlink" title="Node.js相比Java等后端语言有什么特点？"></a>Node.js相比Java等后端语言有什么特点？</h2><ol><li><p>事件驱动和非阻塞 I&#x2F;O</p><p>Node.js 采用事件驱动和非阻塞 I&#x2F;O 的模式，因此能够处理大量的并发请求，并且响应速度更快。相比之下，Java 等后端语言的线程模型会产生更多的上下文切换和性能损失。</p></li><li><p>JavaScript</p><p>Node.js 使用 JavaScript 作为编程语言，前端开发者可以在服务端使用同一种语言进行开发，允许代码重用和简化学习曲线。</p></li><li><p>较小的模块和包管理器</p><p>Node.js 的模块和包管理器让开发人员可以轻松地共享和重用代码。相比之下，Java 的依赖管理可能相对更为复杂。</p></li><li><p>适合构建实时应用</p><p>Node.js 非常适合构建实时应用程序和基于事件的应用程序，如聊天应用、游戏、推送通知等。Java 等传统后端语言适合于处理更多的简单请求和数据处理。</p></li><li><p>跨平台</p><p>Node.js 是跨平台的，可以在多个操作系统上运行，包括 Windows、MacOS、Linux 等，对于开发人员来说更加方便。</p></li></ol><h2 id="Java和NodeJS的区别？"><a href="#Java和NodeJS的区别？" class="headerlink" title="Java和NodeJS的区别？"></a>Java和NodeJS的区别？</h2><ol><li>语言类型：Java 是一种<strong>静态、面向对象、类型安全</strong>的编程语言，而 Node.js 是一种基<strong>于事件驱动、非阻塞 I&#x2F;O</strong> 的服务器端 JavaScript 运行环境。</li><li>并发处理：Java 有线程的概念，线程可以提供<strong>并发执行</strong>能力，可以同时处理多个请求。而 Node.js 使用单线程，采用了<strong>事件轮询和异步 I&#x2F;O</strong> 的方式来处理并发请求，通常使用非阻塞 I&#x2F;O 模型。</li><li>异步编程：Java 提供了<strong>多线程和同步异步两种编程方式</strong>，但是<strong>在面对高并发请求时，使用多线程会带来线程上下文切换和同步锁等开销，降低性能</strong>。而 Node.js 采用事件驱动的编程方式，<strong>使用回调函数实现异步编程，能更好地支持高并发场景</strong>。</li><li>开发效率：Java 属于较庞大的语言，需要编写大量代码，而 Node.js 的代码相对来说更简洁，具有更快的开发效率，但并不意味着其运行效率就低。</li><li>应用场景：Java 适合用于大规模企业级应用的开发，例如电商系统、金融系统等，这些系统的开发通常需要<strong>处理复杂的业务流程和多种数据源</strong>。而 Node.js 适合用于<strong>高并发、I&#x2F;O 密集型</strong>的应用，例如实时聊天、推送消息、数据分析等。</li></ol><h2 id="NodeJS服务端代码在执行前会进行解析吗？"><a href="#NodeJS服务端代码在执行前会进行解析吗？" class="headerlink" title="NodeJS服务端代码在执行前会进行解析吗？"></a>NodeJS服务端代码在执行前会进行解析吗？</h2><p>Node.js 服务端的代码也是先进行解析，然后再执行。</p><p>Node.js 的执行过程包括三个阶段：解析阶段、编译阶段和执行阶段。在解析阶段，Node.js 将 JavaScript 代码解析为抽象语法树（AST）。在编译阶段，Node.js 将 AST 转换为字节码文件，同时进行一些优化（如 Just-In-Time（JIT）编译），以加快代码的执行速度。在执行阶段，Node.js 执行字节码文件，将其转换为机器码并执行。</p><p>与浏览器不同的是，Node.js 的代码在执行之前不需要对每个 JavaScript 文件进行单独的 HTTP 请求和加载，因为所有的代码都可以在本地磁盘上找到。另外，Node.js 还可以在运行时动态加载和卸载模块，这样可以更灵活地组织代码结构。</p><p>总之，Node.js 和浏览器一样，都需要将 JavaScript 代码解析为可执行的代码，然后才能执行。区别在于 Node.js 的代码是在本地磁盘上直接找到并加载的，而不需要通过网络请求，这使得 Node.js 更加适用于开发后端应用程序。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring Recruitment</tag>
      
      <tag>NodeJS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack，Git打包部署、性能优化、安全相关</title>
    <link href="/2023/04/26/Webpack%EF%BC%8CGit%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%81%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/"/>
    <url>/2023/04/26/Webpack%EF%BC%8CGit%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%81%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="Webpack，Git打包部署、性能优化、安全相关"><a href="#Webpack，Git打包部署、性能优化、安全相关" class="headerlink" title="Webpack，Git打包部署、性能优化、安全相关"></a>Webpack，Git打包部署、性能优化、安全相关</h1><h2 id="Webpack中loader和plugin的区别？⭐"><a href="#Webpack中loader和plugin的区别？⭐" class="headerlink" title="Webpack中loader和plugin的区别？⭐"></a>Webpack中loader和plugin的区别？⭐</h2><ul><li>loader是一种打包方案，对于某一种类型文件它知道如何打包，帮助Webpack完成打包工作。loader就是一个单纯的文件转化过程。</li><li>plugin是一个扩展器，丰富Webpack本身，增强功能，针对的是在loader结束之后，Webpack打包的整个过程。plugin并不直接操作文件，而是基于事件机制工作，会监听Webpack打包过程中的某些事件钩子，执行任务。</li></ul><h2 id="常用的Webpack-Loader有哪些？"><a href="#常用的Webpack-Loader有哪些？" class="headerlink" title="常用的Webpack Loader有哪些？"></a>常用的Webpack Loader有哪些？</h2><ol><li>css-loader：用于加载CSS文件，并解析CSS文件中的@import和url()等语句。</li><li>style-loader：将CSS代码注入到HTML页面中。</li><li>file-loader：用于加载图片等静态资源，并返回资源路径。</li><li>url-loader：根据文件大小，将文件转换成DataURL或者返回文件路径。</li><li>babel-loader：用于转换ES6&#x2F;ES7代码，使其兼容旧版浏览器。</li><li>eslint-loader：用于在Webpack中使用ESLint进行代码规范检查。</li><li>ts-loader：用于将TypeScript代码编译成JavaScript代码。</li><li>vue-loader：用于加载Vue.js单文件组件，并编译成JavaScript代码。</li><li>json-loader：用于加载JSON文件，并返回JSON对象。</li><li>xml-loader：用于加载XML文件，并返回解析后的XML对象。</li></ol><h2 id="常用的Webpack-plugin有哪些？"><a href="#常用的Webpack-plugin有哪些？" class="headerlink" title="常用的Webpack plugin有哪些？"></a>常用的Webpack plugin有哪些？</h2><ol><li>HtmlWebpackPlugin：自动生成HTML文件，包括引入打包后的JS、CSS文件等。</li><li>MiniCssExtractPlugin：将CSS从打包后的JS中分离出来，生成单独的CSS文件。</li><li>CleanWebpackPlugin：在每次打包时清除之前生成的文件。</li><li>CopyWebpackPlugin：将文件从源目录复制到目标目录。</li><li>DefinePlugin：定义全局变量，可以在代码中直接使用。</li><li>UglifyJsPlugin：压缩JS代码，减小文件体积。</li><li>HotModuleReplacementPlugin：实现热更新，修改代码后无需刷新页面即可看到效果。</li><li>ExtractTextWebpackPlugin：将CSS从打包后的JS中分离出来，生成单独的CSS文件。</li><li>ProvidePlugin：自动加载模块，无需import或require。</li><li>BundleAnalyzerPlugin：分析打包后的文件大小，找出体积较大的模块。</li></ol><h2 id="Webpack打包原理"><a href="#Webpack打包原理" class="headerlink" title="Webpack打包原理"></a>Webpack打包原理</h2><p>Webpack处理应用程序时，它会递归的构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle。Webpack的打包原理就是将所有的模块霸道成一个或多个Bundle，以便于在浏览器中加载和使用。</p><p>Webpack就像是一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有当完成当前处理后才能交给下一个流程去处理。而插件就像是插入到生产线中的一个功能，在特定的时机对生产线上的资源进行处理。</p><p>Webpack打包原理：<a href="https://zhuanlan.zhihu.com/p/101541041">https://zhuanlan.zhihu.com/p/101541041</a></p><h2 id="Webpack打包流程？⭐"><a href="#Webpack打包流程？⭐" class="headerlink" title="Webpack打包流程？⭐"></a>Webpack打包流程？⭐</h2><ol><li>解析配置文件：Webpack会读取并解析配置文件(通常为webpack.config.js文件)。并根据配置生成一个Compiler对象。</li><li>读取入口文件：Webpack会根据配置中的入口文件，读取这些文件及其依赖的模块，并将它们组成一个依赖图。</li><li>解析模块依赖：Webpack会根据模块之间的依赖关系，递归的解析它们的依赖。直到所有的依赖都被解析完毕。</li><li>加载模块：Webpack会根据模块的路径，使用相应的Loader加载模块的源代码，并将其转换成Webpack可以处理的形式。</li><li>转换代码：Webpack会根据配置中的插件，对加载的模块进行一系列的转换操作，比如压缩，优化等。</li><li>生成代码：Webpack会将所有模块转换后的代码都合并到一个或多个文件中并输出到指定目录中。</li></ol><p>Webpack打包流程：<a href="https://juejin.cn/post/7210756376309203005">简析Webpack打包流程 - 掘金 (juejin.cn)</a></p><h2 id="Webpack中热更新-HMR-的原理是什么？"><a href="#Webpack中热更新-HMR-的原理是什么？" class="headerlink" title="Webpack中热更新(HMR)的原理是什么？"></a>Webpack中热更新(HMR)的原理是什么？</h2><p><code>HMR</code>全称 <code>Hot Module Replacement</code>，可以理解为模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用。</p><p>开启热更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>)<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-comment">// 开启 HMR 特性</span><br>    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span><br>    <span class="hljs-comment">// hotOnly: true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/1725635059c3e804~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ul><li>Webpack Compile：将 JS 源代码编译成 bundle.js</li><li>HMR Server：用来将热更新的文件输出给 HMR Runtime</li><li>Bundle Server：静态资源文件服务器，提供文件访问路径</li><li>HMR Runtime：socket服务器，会被注入到浏览器，更新文件的变化</li><li>bundle.js：构建输出的文件</li><li>在HMR Runtime 和 HMR Server之间建立 websocket，即图上4号线，用于实时更新文件变化</li></ul><p>热更新的两个过程</p><ul><li><p>启动阶段 1 - 2 - A - B</p><p>首先我们在文件系统便写完代码之后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server，Bundle Server 是一个服务器，这样在浏览器里就可以以服务的方式访问文件。</p></li><li><p>更新阶段 1 - 2 - 3 - 4</p><p>当我们在文件系统更新文件之后，还是会经过 Webpack Compile 的编译，Webpack Compile 会将编译后的结果传递给 HMR Server，HMR Server 会比较哪些文件发生了变化，因为服务端的 HMR Server 会和客户端的 HMR Runtime 建立起一条 websocket 链接，所以 HMR Server 会以 json 的形式通知给 HMR Runtime 文件做出了哪些变化。</p></li></ul><p><strong>总结：</strong></p><ul><li>通过<code>webpack-dev-server</code>创建两个服务器：提供静态资源的服务（express）和Socket服务</li><li>express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）</li><li>socket server 是一个 websocket 的长连接，双方可以通信</li><li>当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）</li><li>通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）</li><li>浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新</li></ul><p>参考：<a href="https://juejin.cn/post/6844904134697549832">https://juejin.cn/post/6844904134697549832</a></p><h2 id="Vite和Webpack的区别？"><a href="#Vite和Webpack的区别？" class="headerlink" title="Vite和Webpack的区别？"></a>Vite和Webpack的区别？</h2><ol><li>构建过程不同：Webpack 是通过一系列 Loader 和插件对代码进行编译和打包，Vite 则是通过浏览器原生支持的 ES Modules（ESM）导入的方式进行实时编译和构建，避免了打包过程中的耗时和资源浪费。</li><li>开发环境启动速度不同：Vite 开发环境的启动速度比 Webpack 快很多，基本上可以做到开发环境立即响应，因为 Vite 不需要进行打包操作，而 Webpack 则需要在每次启动开发环境时进行较为繁琐的构建。</li><li>支持的文件类型不同：Webpack 支持多种文件类型的打包构建，而 Vite 目前只支持 Javascript 和 Vue 单组件。</li><li>热更新实现不同：Webpack 的热更新实现是通过 HMR（Hot Module Replacement）机制，重新加载模块实现快速更新，而 Vite 利用了浏览器中的 ESM 特性，通过一个 WebSocket 服务器实现了模块的实时编译和热更新。</li></ol><p>总而言之，Vite 相较于 Webpack 有着更快的构建速度和更优秀的开发体验，但它的能力没有 Webpack 强大，不支持多种文件类型的打包构建。Vite 使得前端开发者可以更快地进行开发并且代码构建的过程更加高效。</p><h2 id="Vite打包的产物能直接发布吗？"><a href="#Vite打包的产物能直接发布吗？" class="headerlink" title="Vite打包的产物能直接发布吗？"></a>Vite打包的产物能直接发布吗？</h2><p>Vite 打包的产物的确可以直接发布到线上服务器，但需要注意以下几点：</p><ol><li>Vite 打包出来的文件默认不会压缩，需要自行使用类似 UglifyJS，Terser 等工具进行压缩和混淆，以减小文件体积和提高加载速度。</li><li>由于 Vite 采用的是预处理打包方式，打包出来的代码可能会出现一些奇怪的问题，需要在发布前进行全面测试和校验。</li><li>在打包过程中需要注意依赖的引入方式，是否存在跨域访问的问题等，以保证打包产物能够正常运行。</li></ol><p>总之，Vite 打包的产物可以直接发布，但需要注意以上问题以确保生产环境的稳定运行。对于有更严格需求的项目，最好还是通过 CI&#x2F;CD 工具进行自动化构建和部署。</p><h2 id="Vite比Webpack快的原因？"><a href="#Vite比Webpack快的原因？" class="headerlink" title="Vite比Webpack快的原因？"></a>Vite比Webpack快的原因？</h2><p>Vite比Webpack快的原因的因为Vite在开发阶段使用了浏览器原生ES模块导入，而不是想Wepkack一样使用打包后的文件。这使得Vite在开发阶段的热更新速度更快，因为它不需要重新打包整个应用程序，而只需要更新更改的部分。</p><h2 id="还了解过哪些打包工具？"><a href="#还了解过哪些打包工具？" class="headerlink" title="还了解过哪些打包工具？"></a>还了解过哪些打包工具？</h2><ol><li>Parcel Parcel是一个快速、零配置的打包工具，支持JS、CSS、HTML等多种类型文件的打包和编译。与Webpack不同的是，Parcel使用的是多线程打包，具有快速打包的优势。</li><li>Rollup Rollup是一个专门针对JavaScript库和工具的打包器，它使用的是ES6的模块化规范，采用Tree Shaking的方式来对代码进行打包，去除掉未使用的代码。Rollup对于构建JavaScript库、组件和插件等非常有用。</li><li>Gulp Gulp是一个自动化构建工具，它可以帮助开发者自动处理CSS、JS、HTML等文件。它基于流式处理数据的思想，可以实现高效的打包、压缩、合并等功能。Gulp使用JavaScript代码来配置任务，非常易于扩展和使用。</li><li>Grunt Grunt是另一种常用的自动化构建工具，它与Gulp类似，也可以通过插件实现自动化任务。与Gulp不同的是，Grunt更为传统，使用配置文件来描述任务流程。</li><li>Browserify Browserify是一个基于Node.js的模块打包工具，它使开发者可以在浏览器中使用Node.js的模块系统。它采用的是CommonJS的模块化规范。</li></ol><h2 id="Webpack5有哪些新特性？"><a href="#Webpack5有哪些新特性？" class="headerlink" title="Webpack5有哪些新特性？"></a>Webpack5有哪些新特性？</h2><ol><li>支持Module Federation：Module Federation是Webpack5中的一个新特性，它允许多个独立的Webpack构建共享模块，从而实现跨域共享模块的能力。</li><li>支持持久化缓存：Webpack5引入了持久化缓存，可以将编译过程中的中间结果缓存到本地磁盘上，从而提高二次构建的速度。</li><li>支持WebAssembly：Webpack5对WebAssembly提供了原生支持，可以将WebAssembly模块打包为单独的chunk，从而提高应用程序的性能。</li><li>支持Tree Shaking优化：Webpack5对Tree Shaking优化进行了改进，可以更精确地识别和移除无用代码。</li><li>支持Top-level await：Webpack5支持Top-level await，可以在模块顶层使用await关键字，从而简化异步代码的写法。</li></ol><h2 id="Webpack4相比3有哪些新特性？"><a href="#Webpack4相比3有哪些新特性？" class="headerlink" title="Webpack4相比3有哪些新特性？"></a>Webpack4相比3有哪些新特性？</h2><ol><li>Webpack4引入了Mode选项，可以通过设置Mode为development或production来自动启用不同的优化策略。</li><li>Webpack4<strong>对代码分割进行了优化，可以更好地支持动态导入和异步加载</strong>。</li><li>Webpack4<strong>对性能优化进行了改进，可以更快地进行编译和构建</strong>。</li><li>Webpack4支持多种文件格式的导入和导出，如JSON、WebAssembly等。</li><li>Webpack4对API进行了改进，提供了更好的插件和Loader接口。</li></ol><h2 id="Webpack3更新了哪些？"><a href="#Webpack3更新了哪些？" class="headerlink" title="Webpack3更新了哪些？"></a>Webpack3更新了哪些？</h2><ol><li><strong>Scope Hoisting</strong>：Webpack3引入了Scope Hoisting功能，可以将模块的作用域提升，从而减少代码量，提高性能。</li><li>Magic Comments：Webpack3支持Magic Comments，可以通过在代码中添加特殊注释来控制chunk的生成和命名。</li><li><strong>动态import</strong>：Webpack3支持动态import，可以在运行时动态加载模块，从而提高应用程序的性能和灵活性。</li><li>CommonChunkPlugin：Webpack3对CommonChunkPlugin进行了优化，可以更灵活地配置和使用。</li><li>Loader Options：Webpack3引入了Loader Options功能，可以在配置文件中为Loader设置选项，从而更方便地进行定制化配置。</li><li>NamedModulesPlugin：Webpack3引入了NamedModulesPlugin插件，可以为模块和chunk生成可读性更好的名称。</li><li><strong>配置文件优化</strong>：Webpack3对配置文件进行了优化，可以更方便地进行模块解析、路径映射、文件处理等操作。</li></ol><h2 id="Webpack3、4、5版本有哪些差异？"><a href="#Webpack3、4、5版本有哪些差异？" class="headerlink" title="Webpack3、4、5版本有哪些差异？"></a>Webpack3、4、5版本有哪些差异？</h2><ol><li>性能：Webpack4和Webpack5相比于Webpack3，在构建速度和性能优化方面有了很大的提升，尤其是Webpack5更加注重性能优化，引入了持久化缓存和Module Federation等功能。</li><li>模块热替换：Webpack4和Webpack5相比于Webpack3，在模块热替换方面有所改进，提供了更好的开发体验。</li><li>Tree Shaking：Webpack4和Webpack5相比于Webpack3，在Tree Shaking方面有了更好的支持，可以更精确地识别和移除无用代码。</li><li>Mode选项：Webpack4引入了Mode选项，可以通过设置Mode为development或production来自动启用不同的优化策略。</li><li>WebAssembly：Webpack5对WebAssembly提供了原生支持，可以将WebAssembly模块打包为单独的chunk，从而提高应用程序的性能。</li><li>Top-level await：Webpack5支持Top-level await，可以在模块顶层使用await关键字，从而简化异步代码的写法。</li><li>插件和Loader：Webpack4和Webpack5相比于Webpack3，在插件和Loader方面提供了更好的接口和扩展性。</li></ol><h2 id="JS常用的压缩工具？"><a href="#JS常用的压缩工具？" class="headerlink" title="JS常用的压缩工具？"></a>JS常用的压缩工具？</h2><ol><li>UglifyJS：UglifyJS是一个广泛使用的JavaScript压缩工具，它可以将JavaScript代码压缩成更小、更高效的形式，从而提高网页的性能。它支持ES6语法，并且可以在命令行或者作为Gulp、Grunt等构建工具的插件使用。</li><li>Closure Compiler：Closure Compiler是Google开发的JavaScript压缩工具，可以将JavaScript代码压缩成更小的形式，并且可以进行代码优化和错误检查。它支持ES6语法和模块化，并且可以在命令行或者作为Gulp、Grunt等构建工具的插件使用。</li><li>Babel-minify：Babel-minify是一个基于Babel的JavaScript压缩工具，可以将JavaScript代码压缩成更小、更高效的形式。它支持ES6语法和模块化，并且可以在命令行或者作为Gulp、Grunt等构建工具的插件使用。</li><li>Terser：Terser是一个JavaScript压缩工具，可以将JavaScript代码压缩成更小、更高效的形式。它支持ES6语法和模块化，并且可以在命令行或者作为Gulp、Grunt等构建工具的插件使用。</li></ol><h2 id="JS进行压缩的原理是什么？"><a href="#JS进行压缩的原理是什么？" class="headerlink" title="JS进行压缩的原理是什么？"></a>JS进行压缩的原理是什么？</h2><p>JS压缩的原理是通过<strong>删除JavaScript代码中的空格、注释、不必要的分号和换行符等无用字符</strong>，以及<strong>将变量名、函数名等重复的内容替换成更短的名称</strong>来减小文件大小。这样可以<strong>减少文件的加载时间和网络传输的流量，提高网页的性能</strong>。</p><p>JS压缩工具一般分为两种压缩方式：</p><ol><li>基于词法分析的压缩方式：这种方式通过对JavaScript代码进行词法分析，找出其中的关键字、变量名、函数名等，然后将其替换成更短的名称，同时删除无用的字符和注释，从而减小文件大小。常用的JS压缩工具如UglifyJS和Closure Compiler都是基于词法分析的压缩方式。</li><li>基于语法分析的压缩方式：这种方式通过对JavaScript代码进行语法分析，找出其中的无用代码、重复代码等，然后将其删除或合并，同时进行变量名、函数名等的替换和删除无用的字符和注释，从而减小文件大小。常用的JS压缩工具如Babel-minify和Terser都是基于语法分析的压缩方式。</li></ol><h2 id="UglifyJS和Terser的区别？"><a href="#UglifyJS和Terser的区别？" class="headerlink" title="UglifyJS和Terser的区别？"></a>UglifyJS和Terser的区别？</h2><ol><li>压缩效率：Terser相对于UglifyJS来说，能够更好地压缩JavaScript代码，生成的压缩文件体积更小。</li><li>ES6+支持：Terser支持ES6+语法，包括箭头函数、模板字符串、解构赋值等，而UglifyJS只支持ES5语法。</li><li>代码质量：Terser生成的代码质量更高，更容易维护和调试，而UglifyJS在某些情况下可能会生成一些难以阅读的代码。</li><li>插件支持：Terser支持插件机制，可以使用插件对JavaScript代码进行更细致的优化和压缩，而UglifyJS没有插件机制。</li><li>平台支持：Terser支持多种平台，包括Node.js、浏览器、Webpack等，而UglifyJS主要是针对浏览器环境进行优化。</li></ol><h2 id="为什么Terser压缩的代码更小？"><a href="#为什么Terser压缩的代码更小？" class="headerlink" title="为什么Terser压缩的代码更小？"></a>为什么Terser压缩的代码更小？</h2><ol><li>更好的算法：Terser采用了更先进的压缩算法，例如更好的代码分析和优化，更多的死代码消除等，能够更好地识别和删除不必要的代码，从而生成更小的压缩文件。</li><li>ES6+支持：Terser能够支持ES6+语法，包括箭头函数、模板字符串、解构赋值等，能够更好地处理新的语法特性，从而生成更小的压缩文件。</li><li>代码优化：Terser能够对代码进行更深入的优化，例如内联函数、变量重命名、常量替换等，从而进一步减小代码体积。</li></ol><h2 id="git-reset和git-revert的区别？"><a href="#git-reset和git-revert的区别？" class="headerlink" title="git reset和git revert的区别？"></a>git reset和git revert的区别？</h2><ol><li>git reset：这个命令可以<strong>撤销一些已经提交的修改，将目标分支的当前指针重置到指定的提交</strong>，这样可以将历史中的一些提交彻底清除掉。可以使用<code>--hard</code>参数强制清除所有本地修改，但这也会导致本地工作目录中未提交的修改全部消失。使用<code>--soft</code>参数可以清除提交记录，但是会保留所有本地修改，需要手动进行下一步操作。</li><li>git revert：这个命令<strong>用于撤销某个提交，并创建一个新提交</strong>，撤销的过程是使用反向修改，生成一个新的提交来撤销之前的提交。这个命令可以更安全地回滚提交，因为它不会覆盖历史记录（不能删除提交记录），而是创建新的提交记录。可以使用<code>--no-commit</code>参数，让Git只生成撤销记录而不会自动提交，并在必要时手动编辑撤销记录。</li></ol><p>因此，git reset命令可以删除某些提交记录，而git revert命令则可以引入新的提交记录，用于撤销先前的提交。一般来说，git revert更安全，因为它不会破坏代码库的历史，并允许团队协作进行回滚操作。但是，如果需要完全从代码库中删除提交历史，那么就需要使用git reset命令。</p><h2 id="git-amend命令的作用？"><a href="#git-amend命令的作用？" class="headerlink" title="git amend命令的作用？"></a>git amend命令的作用？</h2><p>git amend命令是Git版本控制系统中的一个命令，用于修改最后一次提交的信息或者将缺失的文件添加到最后一次提交中。</p><p>具体来说，git amend命令可以用于以下两种情况：</p><ol><li><p>修改最后一次提交的信息：如果最后一次提交的信息存在错误或者需要进行修改，可以使用git amend命令来修改。具体操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit --amend<br></code></pre></td></tr></table></figure><p>在执行上述命令之后，Git会打开默认编辑器，让你修改最后一次提交的信息。修改完成后，保存并关闭编辑器即可。</p></li><li><p>将缺失的文件添加到最后一次提交中：如果最后一次提交中漏掉了某个文件，可以使用git amend命令将该文件添加到最后一次提交中。具体操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add missed_file<br>$ git commit --amend<br></code></pre></td></tr></table></figure><p>在执行上述命令之后，Git会将missed_file文件添加到最后一次提交中。</p></li></ol><p>需要注意的是，使用git amend命令修改最后一次提交的信息或者添加缺失的文件，会改变Git仓库的历史记录，因此需要谨慎使用。</p><h2 id="git合并commit有哪几种方式？区别是什么？"><a href="#git合并commit有哪几种方式？区别是什么？" class="headerlink" title="git合并commit有哪几种方式？区别是什么？"></a><code>git</code>合并<code>commit</code>有哪几种方式？区别是什么？</h2><p>git merge</p><p>git merge 会新建一个新的 commit 对象，然后两个分支以前的 commit 记录都指向这个新 commit 记录。这种方法会保留之前每个分支的 commit 历史。</p><p>git rebase</p><p>git rebase 会先找到两个分支的第一个共同的 commit 祖先记录，然后将提取当前分支这之后的所有 commit 记录，然后将这个 commit 记录添加到目标分支的最新提交后面。经过这个合并后，两个分支合并后的 commit 记录就变为了线性的记录了。</p><h2 id="Git中如果两个人提交分支冲突怎么办？"><a href="#Git中如果两个人提交分支冲突怎么办？" class="headerlink" title="Git中如果两个人提交分支冲突怎么办？"></a>Git中如果两个人提交分支冲突怎么办？</h2><p>当两个人在Git中提交到相同分支时，Git可能会出现分支冲突（merge conflict）的情况。这种情况通常会出现在两个人在同一个文件的同一个地方进行了修改，Git无法判断应该采用哪个修改。解决冲突的方法如下：</p><ol><li>提交前进行代码协调：在提交代码之前，可以高效地协同工作，以避免出现冲突。</li><li>Pull更新代码：如果两个人在不同的副本上对同一个文件进行了修改，可以使用<code>git pull</code>命令，将两个副本合并到本地仓库中。这样可以避免出现相同代码冲突的情况。</li><li>Merge合并分支：如果两个人对同一个分支进行修改，可以使用<code>git merge</code>命令进行合并。Git会自动检查冲突，并在本地环境中进行解决冲突。</li><li>Rebase重构提交历史：如果两个人在同一个分支上工作，可以使用<code>git rebase</code>命令来重构提交历史以解决冲突。</li></ol><p>在解决冲突时，可以使用Git提供的工具帮助进行冲突解决，并手动解决冲突。最后再提交到版本库中。处理分支冲突需要一定经验和技能，需要仔细分析分支修改的内容，并根据需求灵活采取解决方案。</p><h2 id="git-checkout-HEAD-命令的作用？"><a href="#git-checkout-HEAD-命令的作用？" class="headerlink" title="git checkout HEAD^ 命令的作用？"></a>git checkout HEAD^ 命令的作用？</h2><p>git checkout HEAD^ 命令的作用是将工作区切换到当前分支的父提交（即当前提交的前一个提交）。HEAD^ 是一个指向当前分支最新提交的父提交的引用。</p><p>在这个命令中：</p><ul><li>git checkout：用于切换分支或恢复工作区文件。</li><li>HEAD：一个指向当前分支最新提交的引用。</li><li>^：表示父提交。可以使用 HEAD^、HEAD^^ 等表示当前提交的前一个、前两个提交。也可以使用 HEAD<del>1、HEAD</del>2 等表示相同的意义。</li></ul><p>执行 git checkout HEAD^ 后，工作区的内容将回退到前一个提交的状态。这在需要检查或修改之前提交的代码时非常有用。请注意，这会导致当前工作区的更改丢失，因此在执行此操作之前，请确保已保存或提交所有更改。</p><h2 id="如何将ES6转为ES5？"><a href="#如何将ES6转为ES5？" class="headerlink" title="如何将ES6转为ES5？"></a>如何将ES6转为ES5？</h2><p>babel-loader</p><h2 id="bebel将ES6转换为ES5的流程？"><a href="#bebel将ES6转换为ES5的流程？" class="headerlink" title="bebel将ES6转换为ES5的流程？"></a><code>bebel</code>将<code>ES6</code>转换为<code>ES5</code>的流程？</h2><ol><li>Babel首先读取ES6代码并将其转换为一个字符串。</li><li>然后，Babel使用解析器将字符串转换为AST。</li><li>Babel会遍历AST并应用配置的插件和预设来转换代码。每个插件都会检查AST节点并决定是否需要修改它。如果需要修改，插件会返回新的AST节点以替换原来的节点。</li><li>转换后，Babel会将AST转换回代码字符串。</li><li>最后，Babel会将ES5代码写入文件或输出到控制台。</li></ol><h2 id="前端常见的优化手段？"><a href="#前端常见的优化手段？" class="headerlink" title="前端常见的优化手段？"></a>前端常见的优化手段？</h2><p>常见的前端性能优化手段包括：减少请求数量、减小资源大小、优化网络连接、优化资源加载、减少重绘回流、使用性能更好的API和构建优化等。</p><p>其中，减少请求数量可以通过合并CSS和JS文件、使用CSS Sprites技术、使用字体图标等方式来实现；减小资源大小可以通过压缩CSS、JS和图片等方式来实现；优化网络连接可以通过使用CDN、开启Gzip压缩等方式来实现；优化资源加载可以通过使用预加载、懒加载等方式来实现；减少重绘回流可以通过避免频繁操作DOM、使用CSS3动画等方式来实现；使用性能更好的API可以通过使用requestAnimationFrame代替setTimeout、使用Web Workers等方式来实现；构建优化可以通过使用Webpack等打包工具进行代码分割、按需加载等方式来实现。</p><p>七大优化手段：<a href="https://juejin.cn/post/7016868803069886471">https://juejin.cn/post/7016868803069886471</a></p><h2 id="前端性能优化的过程和具体方法？"><a href="#前端性能优化的过程和具体方法？" class="headerlink" title="前端性能优化的过程和具体方法？"></a>前端性能优化的过程和具体方法？</h2><p>前端性能优化的过程可以分为以下几个步骤：</p><ol><li>分析性能瓶颈：使用浏览器的开发者工具或第三方工具来分析页面性能，例如 Chrome DevTools、Lighthouse、PageSpeed Insights 等。</li><li>识别优化机会：根据分析结果，识别出需要优化的关键资源，例如 JavaScript、CSS、图片等。</li><li>制定优化策略：根据优化机会，制定相应的优化策略，例如缩小文件大小、减少 HTTP 请求、使用缓存等。</li><li>实施优化方案：根据制定的优化策略，实施具体的优化方案。</li><li>测试和监控：对优化后的页面进行测试和监控，确保优化效果。</li></ol><p>具体的优化方法包括：</p><ol><li>压缩代码：使用压缩工具压缩 JavaScript、CSS、HTML 代码，减小文件大小，加快加载速度。</li><li>减少 HTTP 请求：将多个小文件合并为一个大文件，减少 HTTP 请求次数。</li><li>使用缓存：使用浏览器缓存或服务器缓存来减少文件加载时间。</li><li>延迟加载：将不必要的资源延迟加载，例如图片、视频等。</li><li>使用图片压缩：使用图片压缩工具将图片压缩，减小文件大小，加快加载速度。</li><li>使用 CDN：使用 CDN（内容分发网络）来加速文件加载速度。</li><li>使用 Web Workers：使用 Web Workers 来在后台运行 JavaScript 代码，提高页面响应速度。</li><li>避免重排和重绘：避免频繁的 DOM 操作和样式修改，减少浏览器的重排和重绘次数。</li><li>使用异步加载：使用异步加载技术，例如 async 和 defer 属性来加快页面加载速度。</li><li>优化图片大小：使用合适的图片格式和尺寸，减小图片大小，加快加载速度。</li></ol><h2 id="如何监控性能指标？"><a href="#如何监控性能指标？" class="headerlink" title="如何监控性能指标？"></a>如何监控性能指标？</h2><p>前端监控性能指标可以通过以下几种方式实现：</p><ol><li>使用浏览器自带的开发者工具，如Chrome DevTools、Firefox Developer Tools等，通过Performance面板可以监控页面的加载、解析、渲染等过程的性能指标，如网络请求时间、DOMContentLoaded时间、首次渲染时间等。</li><li>使用第三方性能监控工具，如Google Analytics、New Relic、AppDynamics等，这些工具可以在网站代码中嵌入一段JavaScript代码，通过前端代码监控页面的性能指标，并将数据发送到后台进行分析和展示。</li><li>使用性能指标监控库，如Performance.js、Metrics.js等，这些库可以通过JavaScript代码监控页面的性能指标，并提供API接口让开发者可以自定义监控指标和展示方式。</li><li>使用前端性能监控服务，如SpeedCurve、Pingdom等，这些服务可以在多个地点模拟用户访问网站，并监控页面的性能指标，同时提供报告和分析工具，帮助开发者优化页面性能。</li></ol><h2 id="npm包会自己发送请求吗？"><a href="#npm包会自己发送请求吗？" class="headerlink" title="npm包会自己发送请求吗？"></a>npm包会自己发送请求吗？</h2><p>一般而言，npm包本身并不会发送请求。npm包只是一些代码和资源的打包，用于在项目中引用和使用。然而，<u>一些npm包可能会包含与第三方服务进行交互的代码，这些代码可能会发送请求</u>。</p><p>例如，一些npm包可能会包含用于访问API的代码，或包含用于从CDN加载资源的代码。</p><h2 id="执行npm-install后发生了什么？"><a href="#执行npm-install后发生了什么？" class="headerlink" title="执行npm install后发生了什么？"></a>执行npm install后发生了什么？</h2><ol><li>检查package.json文件，确定需要安装的模块和版本号。</li><li>从npm仓库中下载指定版本的模块，并将其存储在本地的node_modules目录中。</li><li>如果package.json文件中定义了依赖关系，npm会递归地安装这些依赖模块，直到所有的依赖关系都被满足。</li><li>如果package.json文件中定义了开发环境依赖关系，npm会将这些模块安装在node_modules&#x2F;.dev目录中，而不是node_modules目录中。</li><li>如果npm在安装过程中发现了与当前包管理器版本不兼容的模块，它会尝试自动修复这些模块。</li><li>安装完成后，npm会在本地生成一个package-lock.json文件，用于记录所有安装的模块及其版本号，以便在以后重新安装时保证一致性。</li></ol><h2 id="执行npm-run-start后发生了什么？"><a href="#执行npm-run-start后发生了什么？" class="headerlink" title="执行npm run start后发生了什么？"></a>执行npm run start后发生了什么？</h2><ol><li>npm会查找package.json文件中scripts对象中名为”start”的脚本，并执行该脚本命令。</li><li>根据scripts对象中的”start”命令，npm会执行相应的命令，如”node server.js”或”webpack-dev-server”等。</li><li>如果”start”命令中包含了其他命令，如”prestart”或”poststart”，npm会先执行这些命令，再执行”start”命令。</li><li>如果”start”命令中包含了环境变量，npm会将这些变量传递给执行的命令。</li><li>如果在执行过程中出现错误，npm会显示相应的错误信息，并停止执行。</li></ol><h2 id="统一包命令和管理，除了npm还有哪些？"><a href="#统一包命令和管理，除了npm还有哪些？" class="headerlink" title="统一包命令和管理，除了npm还有哪些？"></a>统一包命令和管理，除了npm还有哪些？</h2><ol><li>Yarn：由Facebook团队开发的JavaScript包管理器，与npm类似，但具有更好的性能和可靠性。</li><li>Bower：专注于前端库和框架的包管理器，与npm和Yarn不同，它主要面向前端资源。</li><li>NuGet：适用于.NET开发的包管理器，可以用于管理各种类型的.NET组件，包括代码库、NuGet包、MSI文件等。</li><li>Cargo：适用于Rust编程语言的包管理器，与npm和Yarn相似，可以用于安装、更新和卸载Rust包。</li></ol><h2 id="前端如何判断内存泄漏？如何处理？"><a href="#前端如何判断内存泄漏？如何处理？" class="headerlink" title="前端如何判断内存泄漏？如何处理？"></a>前端如何判断内存泄漏？如何处理？</h2><p>检测方法：</p><ul><li><p>使用Chrome的开发者工具profiles来进行快照对比。</p><ul><li>打开Chrome浏览器，进入开发者工具。</li><li>点击Profiles选项卡，选择Take Heap Snapshot或Take Allocation Profile。</li><li>进行操作后，再次点击Profiles选项卡，选择Compare Snapshots或Compare Allocation Profiles。</li><li>选择两个快照进行比较，即可看到两个快照之间的差异。</li></ul></li><li><p>在Node环境下，可以使用Node提供的<code>process.memoryUsage()</code>方法来检查内存泄漏。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">process.<span class="hljs-title function_">memoryUsage</span>();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">res: 2366456,</span><br><span class="hljs-comment">heapTotal: 9232384,</span><br><span class="hljs-comment">heapUsed: 5019712,</span><br><span class="hljs-comment">external: 8776</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li><p>res: (Resident Set Size)操作系统分配给进程的总的内存大小。</p></li><li><p>heapTotal：堆的总大小，包括3个部分，</p><ul><li>已分配的内存，用于对象的创建和存储，对应于heapUsed</li><li>未分配的但可用于分配的内存</li><li>未分配的但不能分配的内存，例如在垃圾收集（GC）之前对象之间的内存碎片</li></ul></li><li><p>heapUsed: 已分配的内存，即堆中所有对象的总大小，是heapTotal的子集</p></li><li><p>external: 进程使用到的系统链接库所占用的内存</p></li></ul><p>判断内存泄漏以heapUsed为准</p></li><li><p>利用Performance录制页面性能变化，若内存下限不断升高，则可能发生了内存泄漏</p></li></ul><p>如何处理内存泄漏？</p><p>变量导致的内存泄漏，将变量清除为null即可</p><p>事件导致的内存泄漏，监听后移除即可。</p><h2 id="Tree-Shaking的实现原理？"><a href="#Tree-Shaking的实现原理？" class="headerlink" title="Tree-Shaking的实现原理？"></a>Tree-Shaking的实现原理？</h2><p>Tree-Shaking是一种基于ES Module规范的Dead Code Elimination技术，它会在运行过程中静态分析模块之间的导入导出，确定ESM模块中的哪些导出值未曾被其他模块使用，并将其删除，以此实现打包产物的优化。</p><ul><li>Make阶段，收集模块导出变量并记录到模块依赖关系图ModuleGraph变量中</li><li>Seal阶段，遍历ModuleGraph标记模块导出变量有没有被使用</li><li>生成产物时，若变量没有被其他模块使用则删除对应的导出语言</li></ul><blockquote><p>标记功能需要配置 <code>optimization.usedExports = true</code> 开启</p></blockquote><h2 id="常见的Web安全问题有哪些？"><a href="#常见的Web安全问题有哪些？" class="headerlink" title="常见的Web安全问题有哪些？"></a>常见的Web安全问题有哪些？</h2><ul><li><p>注入漏洞</p><p>注入漏洞会让攻击者方便将恶意代码植入到目标应用系统(如解析器中)。如果你的Web应用允许用户将其输入的信息插入到后端数据库，或使用shell命令对操作系统进行调用，那么您的应用就可能会受到注入漏洞的影响。</p><p>当然，您可以通过检查应用的源代码，或对应用进行彻底的渗透测试，来发现此类漏洞。注入漏洞最常见的类型是SQL注入。攻击者会在SQL查询中，插入恶意代码，并将其转发到后端数据库服务器上，实施远程盗窃或攻击。</p><p>除常见的SQL注入之外，目前还有LDAP注入、XML注入、XPATH注入、OS命令注入、以及HTML注入。我们通常可以通过适当、及时地检查与清理用户的输入，来防范此类威胁。</p></li><li><p>身份认证失败</p><p>身份验证失败是由身份验证和会话管理控件的实施不当而引起的。如果攻击者能够成功的识别和利用那些与身份验证相关的漏洞，那么他们就能直接访问各种敏感数据和功能。</p><p>为了利用身份验证漏洞，攻击者需要通过采用诸如：凭证填充、会话劫持、密码暴力破解、以及会话ID URL重写等方法，来模拟应用程序的合法用户。</p><p>我们可以通过实施健全的会话管理控制、多因素身份验证、限制和监视失败的登录尝试，来防范此类攻击。</p></li><li><p>敏感数据泄露</p><p>当Web应用不能充分保护诸如：会话ID、密码、财务信息以及客户信息等敏感信息时，数据泄露就会发生。</p><p>此类泄漏的内部原因主要包括：未对敏感数据实施加密，仅采用了弱加密方式，软件应用的本身漏洞，以及操作员将数据上传至错误的数据库等方面。而外部攻击因素则包括：SQL注入、身份验证与访问控制的破坏、网络钓鱼攻击、以及针对明文协议HTTP、FTP和SMTP传输数据等网络级别的攻击。</p><p>为了应对此类泄漏，我们可以采取的主要措施包括：彻底检查应用程序的源代码与IT环境，尤其是正在使用安全密码算法等方面。</p></li><li><p>XML外部实体</p><p>XML外部实体注入(通常被称为XML External Entity，XXE)可以让攻击者通过Web应用的漏洞，干扰应用对于XML数据的处理。此类攻击往往会导致诸如拒绝服务、数据泄露、服务器端请求伪造等问题。</p><p>我们可以通过实施服务器端的输入验证，修补和升级所有XML处理器，以及使用SAST工具来分析源代码等方法，来有效地防止XML外部实体注入。</p></li><li><p>受损的访问控制</p><p>从概念上说，访问控制机制就是要确定用户是否可以执行，与之身份和权限相符的操作。而当用户可以在其预期权限之外执行某项操作时，那么就出现了访问控制的破坏。</p><p>受损的访问控制通常会导致：未经授权的信息泄露、数据被直接修改或破坏、以及业务功能偏离预期用途等情况。我们可以通过在受信任的服务器端代码中、或无服务器的API中，强制使用完备的访问控制机制，来防止攻击者修改元数据(metadata)，或绕过正常的访问控制检查。</p></li></ul><h2 id="如何保护Web应用程序的安全？"><a href="#如何保护Web应用程序的安全？" class="headerlink" title="如何保护Web应用程序的安全？"></a>如何保护Web应用程序的安全？</h2><ul><li>定义并采用合适的网络安全框架</li><li>跟踪资产并进行安全评估</li><li>遵循安全编码标准</li><li>部署企业级安全解决方案</li><li>尽可能自动化</li><li>对数据进行加密</li><li>渗透测试</li></ul><p>Web安全相关：[5大Web应用安全威胁与7大防护措施](<a href="https://zhuanlan.zhihu.com/p/363791438#:~:text=5%E5%A4%A7Web%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81%E4%B8%8E7%E5%A4%A7%E9%98%B2%E6%8A%A4%E6%8E%AA%E6%96%BD">https://zhuanlan.zhihu.com/p/363791438#:~:text=5大Web应用安全威胁与7大防护措施</a> 1 1.注入漏洞 2 2.身份验证失败 3 3.敏感数据泄漏 4,5.受损的访问控制 6 1.定义并采用合适的网络安全框架 7 2.跟踪您的资产并进行威胁评估 8 3.遵守安全编码标准 更多项目)</p><h2 id="什么是前端工程化？"><a href="#什么是前端工程化？" class="headerlink" title="什么是前端工程化？"></a>什么是前端工程化？</h2><p>对前端进行一些流程的标准化，让开发变得更有效率，且更好的做产品交付。前端工程化是使用软件工程的技术和方法来进行前端的开发流程、技术、工具、经验等规范化、标准化，其主要目的是为了提高效率和降低成本，即提高开发过程中的开发效率，减少不必要的重复工作时间。</p><p><a href="https://zhuanlan.zhihu.com/p/588483704">前端工程化指的是什么？</a></p><h2 id="如何实现模块懒加载？"><a href="#如何实现模块懒加载？" class="headerlink" title="如何实现模块懒加载？"></a>如何实现模块懒加载？</h2><p>模块懒加载是指在需要模块的时候才进行加载，而不是在应用启动时就加载所有的模块，这样可以提高应用的启动速度与性能。实现模块懒加载的方法由很多，比如：</p><ul><li>Webpack实现</li><li>ES6 import()</li></ul><h2 id="前端常见的安全问题？"><a href="#前端常见的安全问题？" class="headerlink" title="前端常见的安全问题？"></a>前端常见的安全问题？</h2><ul><li>跨站脚本攻击(XSS)</li><li>跨站请求伪造(CSRF)</li><li>点击劫持(Click Jacking)</li><li>HTTP严格传输安全(HSTS)</li><li>CDN劫持</li><li>SQL注入攻击</li></ul><h2 id="如何进行防范？"><a href="#如何进行防范？" class="headerlink" title="如何进行防范？"></a>如何进行防范？</h2><ul><li>输入检查：对用户输入的数据进行检查和过滤，防止XSS和SQL注入等攻击。</li><li>输出攻击：对输出到页面上的数据进行检查和过滤，防止XSS攻击。</li><li>防范CSRF攻击：在请求中添加随机数或者验证码。</li><li>防止点击劫持：使用X-FRAME-OPTIONS头部或者JS脚本防止点击劫持</li><li>防止HTTP劫持：使用HTTPS协议或HTTP严格传输安全(HSTS)协议防范HTTP劫持</li><li>防止CDN劫持：使用SRI，为了防止校验资源完整性来判断是否被篡改。它通过验证文件的哈希值是否与你提供的哈希值一样来判断资源是否被篡改。</li></ul><h2 id="XSS与CSRF的攻击场景？"><a href="#XSS与CSRF的攻击场景？" class="headerlink" title="XSS与CSRF的攻击场景？"></a>XSS与CSRF的攻击场景？</h2><p>XSS：跨站脚本攻击，攻击者将恶意脚本嵌入到被攻击网站中，当用户访问该网站时，恶意脚本会被执行，从而达到获取用户信息、窃取Cookie等目的。</p><p>攻击场景：评论区、搜索框、留言板、聊天室。</p><p>CSRF：跨站请求伪造。攻击者通过某种方法诱导用户访问被攻击网站，从而在用户不知情的情况下发起恶意请求，如转账、修改密码等。</p><p>攻击场景：点击链接、打开图片、访问网页等。</p><h2 id="如果通过-html-标签内的-src-属性攻击-只能攻击到-GET-请求-如何攻击到-POST-请求？"><a href="#如果通过-html-标签内的-src-属性攻击-只能攻击到-GET-请求-如何攻击到-POST-请求？" class="headerlink" title="如果通过 html 标签内的 src 属性攻击, 只能攻击到 GET 请求, 如何攻击到 POST 请求？"></a>如果通过 html 标签内的 src 属性攻击, 只能攻击到 GET 请求, 如何攻击到 POST 请求？</h2><p>如果攻击者想要攻击POST请求，可以使用类似XSS攻击的方式，即通过在HTML标签内嵌入恶意代码，从而实现攻击。例如，攻击者在一个表单中插入一个隐藏的iframe，然后将表单的提交地址修改为攻击者的服务器地址，当用户提交表单的时候，iframe自动向被攻击网站发起POST请求，从而实现CSRF攻击。</p><h2 id="localStorage和Cookie存储如果不注意的话，会有什么安全问题？"><a href="#localStorage和Cookie存储如果不注意的话，会有什么安全问题？" class="headerlink" title="localStorage和Cookie存储如果不注意的话，会有什么安全问题？"></a>localStorage和Cookie存储如果不注意的话，会有什么安全问题？</h2><p>Cookie容易受到跨站脚本攻击(XSS)和跨站请求伪造(CSRF)的攻击；而localStorage容易受到跨站脚本攻击(XSS)的攻击。</p><ul><li>对于Cookie，可以使用HttpOnly标志来防止XSS攻击，使其无法通过JS进行访问；使用SameSite标志来防止CSRF攻击。</li><li>对于localStorage，尽量不要存储敏感信息，或者使用sessionStorage进行替代。</li></ul><h2 id="首屏加载、白屏时间长可能是哪些原因导致的？"><a href="#首屏加载、白屏时间长可能是哪些原因导致的？" class="headerlink" title="首屏加载、白屏时间长可能是哪些原因导致的？"></a>首屏加载、白屏时间长可能是哪些原因导致的？</h2><ul><li>打包后的js和css文件过大，浏览器初始访问网站时，会先加载该项目的js和css文件，加载完成后才会进行页面渲染。如果打包的文件过大，加载时间就会变长，出现视觉上的页面白屏，可以使用webpack进行代码分割、懒加载等优化，减小入口文件体积。</li><li>网络延迟：网络延迟是影响首屏加载速度的主要因素之一。可以通过使用CDN、DNS预解析等方式来减少网络延迟时间。</li><li>资源重复请求加载：可以使用Webpack的splitChunks进行公共代码抽离，避免重复请求。</li><li>加载脚本的过程中，渲染堵塞：可以使用defer、async等属性来异步加载脚本，避免渲染堵塞。</li></ul><h2 id="长列表进行性能优化？可以通过哪些指标进行优化？"><a href="#长列表进行性能优化？可以通过哪些指标进行优化？" class="headerlink" title="长列表进行性能优化？可以通过哪些指标进行优化？"></a>长列表进行性能优化？可以通过哪些指标进行优化？</h2><ol><li>合理使用虚拟滚动和无限滚动等技术，减少 DOM 元素的数量和页面渲染的时间。</li><li>尽量减小每个列表项的渲染时间，如通过性能优化的 JavaScript 引擎、使用优化的 CSS 属性等方式来提高性能。</li><li>合理使用懒加载技术，延迟加载非必要的列表项。</li><li>对于大型的列表数据，可以使用分页或者增量加载方式，即每次只加载部分数据而不是一次性加载整个列表。</li><li>避免不必要的更新，在数据更新时，可以使用 shouldComponentUpdate 方法来优化更新，减少不必要的 DOM 操作。</li><li>对于复杂的列表项，可以使用 React 的 PureComponents，减少渲染时间。</li><li>对于列表中图片等资源，可以合理使用缓存技术，减少网络请求和提高加载速度。</li></ol><h2 id="什么是混入？"><a href="#什么是混入？" class="headerlink" title="什么是混入？"></a>什么是混入？</h2><p>混入（Mixin）是一种在面向对象编程中，通过将多个类的属性和方法“混合”到一个类中来扩展该类功能的方式。</p><p>混入可以在不修改原有类的情况下，为该类添加新的功能。在JavaScript中，混入可以通过对象的复制、原型继承、类继承等方式来实现。</p><p>具体来说，混入可以通过以下几个步骤来实现：</p><ol><li>定义一个混入对象，该对象包含要混入的属性和方法。</li><li>在需要混入的类中，通过复制、继承等方式将混入对象的属性和方法“混合”到该类中。</li><li>使用混入后的类，即可享受到混入对象中扩展的功能。</li></ol><p>混入可以使代码更加模块化、灵活，可以避免代码冗余和重复。但是，在使用混入时，需要注意命名冲突和属性覆盖等问题，避免出现不必要的错误和bug。</p><h2 id="什么是SSR？"><a href="#什么是SSR？" class="headerlink" title="什么是SSR？"></a>什么是SSR？</h2><p>SSR，全称为Server Side Rendering，即服务器端渲染。它是指在<strong>服务器端生成HTML代码，然后将其发送到浏览器端进行展示</strong>的一种技术。</p><p>在传统的前端开发中，所有的HTML、CSS和JavaScript代码都是在浏览器端进行渲染的，这种方式被称作客户端渲染（CSR）。但是，随着Web应用程序的复杂性不断增加，客户端渲染会带来一些问题，例如：</p><ol><li>首屏加载慢：因为需要等待所有的JavaScript代码加载完成后才能进行页面渲染，用户需要等待较长时间才能看到页面内容。</li><li>SEO不友好：由于搜索引擎爬虫无法执行JavaScript代码，因此客户端渲染的页面对SEO不友好。</li><li>用户体验差：由于需要等待JavaScript代码加载完成后才能进行页面渲染，因此会出现白屏或者Loading页面，用户体验较差。</li></ol><p>SSR技术就是为了解决这些问题而提出的。通过在服务器端生成HTML代码，可以<strong>大大缩短首屏加载时间，提高SEO友好性，改善用户体验</strong>。同时，由于服务器端生成的HTML代码已经包含了页面内容，因此<strong>不需要等待JavaScript代码加载完成，可以直接展示给用户</strong>。</p><h2 id="什么是SEO？"><a href="#什么是SEO？" class="headerlink" title="什么是SEO？"></a>什么是SEO？</h2><p>SEO（Search Engine Optimization）是指通过各种技术手段，优化网站结构、内容、外部链接等因素，提高网站在搜索引擎中的排名，从而获得更多的有机流量和用户。SEO主要分为以下几个方面：</p><ol><li>网站结构优化：包括网站的URL结构、页面标题、Meta标签、HTML标签等的优化，以便搜索引擎更好地理解和抓取网站内容。</li><li>内容优化：包括网站内容的质量、关键词密度、标题、描述、图片等的优化，以提高网站的相关性和权威性。</li><li>外部链接优化：包括外部链接的质量、数量、来源、锚文本等的优化，以提高网站的权重和流量。</li><li>移动端优化：包括网站的响应式设计、页面加载速度、移动端友好性等的优化，以适应移动互联网时代的需求。</li><li>社交媒体优化：包括网站在社交媒体上的活跃度、分享度、关注度等的优化，以提高网站的曝光度和口碑效应。</li></ol><p>SEO的优化需要综合考虑多个因素，包括用户体验、搜索引擎算法、竞争对手等，需要长期持续地进行优化和调整。</p><h2 id="SEO的优化有哪些方法？"><a href="#SEO的优化有哪些方法？" class="headerlink" title="SEO的优化有哪些方法？"></a>SEO的优化有哪些方法？</h2><ol><li>关键词优化：通过研究用户搜索行为和竞争对手情况，确定关键词，并将其合理地分布在网站的标题、内容、Meta标签等位置，以提高网站的相关性和排名。</li><li>内容优化：通过提高网站内容的质量和原创性，增加关键词密度和标题、描述等元素的优化，以提高网站的权威性和吸引力。</li><li>网站结构优化：通过优化网站的URL、HTML标签、网站结构等，使搜索引擎更好地识别和抓取网站内容，提高网站的可访问性和相关性。</li><li>外部链接优化：通过获取高质量的外部链接，提高网站的权重和流量，并避免使用无效或违规的链接方式。</li><li>移动端优化：通过响应式设计、页面加载速度、移动端友好性等方式，提高移动端用户的体验和访问量。</li><li>社交媒体优化：通过在社交媒体上活跃、分享、关注等方式，提高网站的曝光度和口碑效应。</li></ol><h2 id="项目上线部署流程？"><a href="#项目上线部署流程？" class="headerlink" title="项目上线部署流程？"></a>项目上线部署流程？</h2><ol><li>打包：将前端项目打包成静态资源文件，例如 HTML、CSS、JavaScript、图片等。可以使用 Webpack、Gulp、Grunt 等工具进行打包。</li><li>上传到服务器：将打包好的静态资源文件上传到服务器上，可以使用 FTP、SFTP、SCP、rsync 等工具进行上传。</li><li>配置服务器：根据项目需要，对服务器进行配置，例如安装 Web 服务器、配置域名、SSL 证书、反向代理等。</li><li>启动服务：启动 Web 服务器并将静态资源文件部署到 Web 服务器上，例如使用 Nginx、Apache 等 Web 服务器。</li><li>测试和验证：测试和验证部署的 Web 服务器是否正常工作，例如访问网站、检查日志、排除错误等。</li><li>监控和维护：监控部署的 Web 服务器，确保其稳定运行，并及时处理出现的异常问题。</li></ol><h2 id="写项目的时候有没有用到哪些设计模式使得代码更加利于修改？"><a href="#写项目的时候有没有用到哪些设计模式使得代码更加利于修改？" class="headerlink" title="写项目的时候有没有用到哪些设计模式使得代码更加利于修改？"></a>写项目的时候有没有用到哪些设计模式使得代码更加利于修改？</h2><ol><li><p>MVC（Model-View-Controller）模式</p><p>MVC模式是一种将应用程序分成三个核心部分的设计模式：模型（Model）、视图（View）和控制器（Controller）。这种模式可以使得代码更加清晰、易于维护和修改，也可以提高代码的重用性和可扩展性。</p></li><li><p>MVVM（Model-View-ViewModel）模式</p><p>MVVM模式是一种MVC模式的变体，它将控制器（Controller）替换为视图模型（ViewModel）。视图模型负责将模型数据转换为视图可以使用的数据，并且可以通过双向绑定来实现数据的自动更新，从而减少了手动操作DOM的代码量。</p></li><li><p>单例模式</p><p>单例模式是一种保证一个类只有一个实例的设计模式。在前端开发中，常用于管理全局状态或资源，例如全局配置、全局事件管理等。</p></li><li><p>装饰者模式</p><p>装饰者模式是一种在不改变原有对象的基础上，动态地给对象增加新的功能的设计模式。在前端开发中，常用于对原有组件进行功能扩展或增强。</p></li><li><p>观察者模式</p><p>观察者模式是一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖它的对象都会得到通知并自动更新。在前端开发中，常用于实现事件监听和发布-订阅模式。</p></li></ol><p>使用这些设计模式可以使前端项目的代码更加易于维护和修改，提高代码的重用性和可扩展性。但是，过度使用设计模式也会增加代码的复杂度，所以需要根据实际情况选择合适的设计模式。</p><h2 id="有没有使用过单元测试工具或代码检查？"><a href="#有没有使用过单元测试工具或代码检查？" class="headerlink" title="有没有使用过单元测试工具或代码检查？"></a>有没有使用过单元测试工具或代码检查？</h2><ol><li>Jest：Facebook 开源的 JavaScript 测试框架，支持单元测试、集成测试和快照测试等。</li><li>Mocha：一个功能丰富的 JavaScript 测试框架，支持异步测试、前端和后端测试，以及 BDD 和 TDD 等测试风格。</li><li>Jasmine：一个行为驱动开发（BDD）框架，支持浏览器和 Node.js 等环境，可以进行单元测试、集成测试和端到端测试。</li><li>Karma：一个测试运行器，可以在多个浏览器和平台上运行测试，并支持与其他测试框架集成。</li><li>Enzyme：一个 React 组件测试工具，可以方便地进行组件渲染、事件模拟和快照测试等。</li><li>Ava：一个快速、轻量级的测试框架，支持并行测试和异步测试，可以在浏览器和 Node.js 等环境下运行。</li><li>Puppeteer：一个由 Google 开发的自动化测试工具，可以模拟用户操作和浏览器环境，用于进行端到端测试。</li><li>Cypress：一个端到端测试工具，具有自动重试、实时重载和可视化测试等功能，可以在浏览器中运行测试。</li></ol><h2 id="ESLint代码检查原理？"><a href="#ESLint代码检查原理？" class="headerlink" title="ESLint代码检查原理？"></a>ESLint代码检查原理？</h2><p>ESLint是一个开源的JavaScript代码检查工具，它可以检查代码的语法错误、代码风格、潜在的错误等。ESLint的核心原理是基于抽象语法树（AST）来检查代码。</p><p>ESLint会将代码解析成AST，然后通过遍历AST节点来检查代码，检查的规则由配置文件中的规则集合定义。ESLint的规则集合包括官方规则和第三方规则，可以根据需要自定义规则。</p><p>在检查代码时，ESLint会根据规则集合中的规则来判断代码是否符合规范，如果不符合则输出错误或警告信息。ESLint还支持自动修复代码中的一些问题，可以通过–fix选项来修复代码中的问题。</p><p>ESLint的检查原理可以总结为以下几个步骤：</p><ol><li>将代码解析成AST。</li><li>遍历AST节点，根据规则集合中的规则判断代码是否符合规范。</li><li>如果代码不符合规范，则输出错误或警告信息。</li><li>如果需要，可以通过–fix选项来自动修复代码中的问题。</li></ol><p>总之，ESLint的检查原理基于抽象语法树（AST）来检查代码，可以根据规则集合中的规则来判断代码是否符合规范。</p><h2 id="ESLint如何进行配置？常见的配置有哪些？"><a href="#ESLint如何进行配置？常见的配置有哪些？" class="headerlink" title="ESLint如何进行配置？常见的配置有哪些？"></a>ESLint如何进行配置？常见的配置有哪些？</h2><p>ESLint的配置文件可以使用JS、JSON、YAML、XML格式的文件进行配置。通常将配置文件命名为<code>.eslintrc.js</code>、<code>.eslintrc.json</code>、<code>.eslintrc.yaml</code>、<code>.eslintrc.yml</code>、<code>.eslintrc.xml</code>中的一种，放置于项目的根目录下。</p><p>ESLint的配置文件可以使用JS、JSON、YAML、XML格式的文件进行配置。通常我们将配置文件命名为<code>.eslintrc.js</code>、<code>.eslintrc.json</code>、<code>.eslintrc.yaml</code>、<code>.eslintrc.yml</code>、<code>.eslintrc.xml</code>中的一种，放置于项目的根目录下。</p><p>常见的ESLint配置有以下几项：</p><ol><li><code>env</code>: 指定应用程序的运行环境，一般是浏览器或Node.js环境</li><li><code>extends</code>: 指定要扩展的 ESLint 配置文件</li><li><code>rules</code>: 配置规则，可以禁用或启用规则，以及覆盖默认规则或扩展规则重载规则、覆盖提示程度等</li><li><code>globals</code>: 在代码中定义全局变量，防止报未定义错误</li><li><code>parserOptions</code>: 配置ESLint的解析器，如支持ECMAScript的版本等</li><li><code>plugins</code>: 通过ESLint插件扩展规则，可以开启或关闭插件</li><li><code>ignore</code>: 跳过某些文件或文件夹</li></ol><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">env</span>: &#123;<br>    <span class="hljs-attr">browser</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">es6</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">node</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  <span class="hljs-attr">extends</span>: [<span class="hljs-string">&#x27;eslint:recommended&#x27;</span>, <span class="hljs-string">&#x27;plugin:react/recommended&#x27;</span>],<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-string">&#x27;react&#x27;</span>],<br>  <span class="hljs-attr">parserOptions</span>: &#123;<br>    <span class="hljs-attr">ecmaVersion</span>: <span class="hljs-number">2018</span>,<br>    <span class="hljs-attr">sourceType</span>: <span class="hljs-string">&#x27;module&#x27;</span>,<br>    <span class="hljs-attr">ecmaFeatures</span>: &#123;<br>      <span class="hljs-attr">jsx</span>: <span class="hljs-literal">true</span>,<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-attr">rules</span>: &#123;<br>    <span class="hljs-string">&#x27;react/prop-types&#x27;</span>: <span class="hljs-string">&#x27;off&#x27;</span>,<br>    <span class="hljs-string">&#x27;no-unused-vars&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>该配置使用了ESLint默认的<code>recommended</code>规则和<code>react/recommended</code>规则，指定了环境为浏览器、ES6和Node.js环境，启用了React插件，禁用了对于React中props的类型检查，开启了对于未使用变量的警告。</p><p>需要注意的是，ESLint的配置可以进行优先级继承，通常情况下，更具体、具有更小范围的文件配置优先级更高，在不同目录下的配置文件可以进行覆盖和继承。</p><h2 id="Chrome开发者工具中Elements主要用来做什么？"><a href="#Chrome开发者工具中Elements主要用来做什么？" class="headerlink" title="Chrome开发者工具中Elements主要用来做什么？"></a>Chrome开发者工具中Elements主要用来做什么？</h2><p>Chrome开发者工具中Elements主要用来查看和编辑网页的DOM结构和样式。具体的使用如下：</p><ol><li>查看DOM结构：在Elements面板中，可以看到网页中所有的HTML元素及其嵌套关系。可以通过点击元素来快速定位到特定的元素，并查看其属性值、样式、事件等信息。</li><li>编辑DOM结构：在Elements面板中，可以直接编辑网页的HTML和CSS代码，实时预览编辑结果。可添加、删除、修改网页中的元素和样式，便于前端开发和调试。</li><li>查看计算样式：在Elements面板中，可以查看指定元素的样式属性及其来源。还可以查看元素的盒模型大小、外边距、内边距等信息，方便排版和布局。</li><li>调试JavaScript：在Elements面板中，可以调试JavaScript代码。可以在控制台中输入命令、设置断点，查看变量、堆栈、网络请求等信息。</li></ol><h2 id="Chrome开发者工具中Sources的作用？如何调试代码？"><a href="#Chrome开发者工具中Sources的作用？如何调试代码？" class="headerlink" title="Chrome开发者工具中Sources的作用？如何调试代码？"></a>Chrome开发者工具中Sources的作用？如何调试代码？</h2><p>Chrome开发者工具中Sources主要用于调试JavaScript代码和查看相关资源，具体的作用有：</p><ol><li>查看页面中的JavaScript文件：在Sources面板中，可以查看当前页面中加载的JavaScript文件，包括内联、外链文件和异步加载文件等。</li><li>编辑和调试JavaScript代码：在Sources面板中，可以直接在浏览器中编辑JavaScript代码，并实时预览效果。还可以设置断点、单步调试、查看变量、堆栈、网络请求等信息，帮助开发人员快速定位和解决代码错误。</li><li>查看网页的CSS和资源：在Sources中，还可以查看网页的CSS样式及其相关资源，例如图片、字体、音频、视频等等。</li></ol><p>调试代码的步骤如下：</p><ol><li>打开Chrome浏览器，在需要调试的页面上右键选择“检查”或快捷键“ctrl + shift + I”打开开发者工具。</li><li>在Sources面板中选择需要调试的JavaScript文件，点击行号左边的标记来设置断点。</li><li>执行页面操作，例如点击按钮、输入内容等等，查看代码执行过程中的变量值、堆栈等信息。</li><li>在Console中输入指令，例如console.log()打印变量信息。</li><li>如果需要单步调试，可以点击面板上的“单步执行”按钮，一步一步执行代码。</li></ol><h2 id="Chrome开发者工具中NetWorks中一般会关注哪些东西？"><a href="#Chrome开发者工具中NetWorks中一般会关注哪些东西？" class="headerlink" title="Chrome开发者工具中NetWorks中一般会关注哪些东西？"></a>Chrome开发者工具中NetWorks中一般会关注哪些东西？</h2><p>在Chrome开发者工具中，NetWork面板主要用于<strong>分析和监控网站的网络请求</strong>。一般需要关注以下几个方面：</p><ol><li>请求类型：网络请求分为GET、POST、PUT、DELETE等，需要关注请求类型是否正确。</li><li>请求的URL和状态码：查看请求的URL和状态码，可以获取请求是否成功以及返回的内容。</li><li>请求和响应的头信息：请求和响应的头信息中包含了很多重要的信息，例如Cookie、User-Agent、Referer、Cache-Control等等。</li><li>请求和响应的内容：在NetWork面板中，可以通过点击请求和响应的内容查看详细信息，例如请求和响应的参数、JSON数据、HTML代码等等。</li><li>请求和响应时间：了解请求和响应时间可以帮助我们优化网站的性能。</li><li>缓存信息：在NetWork面板中可以查看是否启用了缓存，并了解缓存的过期时间等。</li><li>XHR请求：如果网站使用了XHR请求，可以通过NetWork面板中的XHR过滤器查看和分析这些请求。</li></ol><h2 id="Chrome开发者工具中Performance的作用？"><a href="#Chrome开发者工具中Performance的作用？" class="headerlink" title="Chrome开发者工具中Performance的作用？"></a>Chrome开发者工具中Performance的作用？</h2><p>Chrome开发者工具中的Performance（性能）标签页可以用于分析网页的性能问题，包括CPU占用、网络请求、JavaScript执行等方面。其主要作用如下：</p><ol><li>分析加载时间：可以使用Performance标签页来分析网页的加载时间，找出网页加载过程中的瓶颈，优化网页的性能表现。</li><li>分析性能问题：性能标签页中提供了CPU和内存使用率、网络传输、JavaScript执行和渲染等方面的数据，可以帮助开发者发现性能问题。</li><li>记录用户交互：Performance标签页可以记录用户的操作和交互行为，开发者可以借此了解用户体验，优化网站设计。</li><li>模拟设备模式：Performance标签页中提供模拟设备模式，可以模拟不同设备下的网站运行情况，帮助开发者优化响应式设计。</li></ol><h2 id="Chrome开发者工具中Application中主要管理的是什么样的工作？"><a href="#Chrome开发者工具中Application中主要管理的是什么样的工作？" class="headerlink" title="Chrome开发者工具中Application中主要管理的是什么样的工作？"></a>Chrome开发者工具中Application中主要管理的是什么样的工作？</h2><p>Chrome开发者工具中的Application（应用程序）标签页主要管理网页应用程序的缓存、存储、数据库、Service Worker等内容。其主要功能如下：</p><ol><li>缓存管理：Application标签页中可以查看网页应用程序的缓存资源，包括HTTP缓存、Service Worker缓存等，并可以手动清除缓存。</li><li>存储管理：可以查看网页应用程序使用的本地存储（localStorage、sessionStorage）等方式，也可以在此处清除这些数据。</li><li>数据库管理：可以查看网页应用程序使用的Web SQL和IndexedDB数据库，并且可以在此处查看、修改、删除数据库中的数据。</li><li>Service Worker管理：可以注册和注销Service Worker，查看当前Service Worker的状态，并手动刷新缓存等。</li></ol><p>通过使用Application标签页，开发者可以更好地管理和调试网页应用程序的缓存、存储、数据库和Service Worker等内容，提高开发效率和用户体验。</p><h2 id="Application-Service-Workers是用来做什么的？"><a href="#Application-Service-Workers是用来做什么的？" class="headerlink" title="Application Service Workers是用来做什么的？"></a>Application Service Workers是用来做什么的？</h2><p>Chrome开发者工具中的Application Service Workers选项是用来查看和调试网页应用程序中的Service Workers的。</p><p>通过该选项，可以查看当前网页应用程序所使用的Service Workers，包括其版本，以及缓存的资源和数据。此外，还可以手动更新和刷新Service Workers，以确保网页应用程序始终使用最新的版本。还可以改变Service Workers的状态，来测试网页应用程序在不同状态下的行为，例如离线模式、在线模式、更新中等等。</p><p>在开发网页应用程序时，Service Workers可以提供许多便利的工具和功能。使用Chrome开发者工具中的Application Service Workers选项，开发人员可以快速地调试和测试Service Workers，并优化网页应用程序的性能和体验。</p><p>Application Service Workers是一种浏览器特性，用于在后台运行脚本，以提供离线体验、消息推送和更高性能等功能。与传统的JavaScript脚本不同，Service Workers运行在单独的线程中，不会因为页面加载或关闭而终止，可以在多个页面或应用程序之间共享状态和资源。</p><p>Service Workers可以缓存应用程序的资源（如HTML、CSS、JavaScript、图像和API响应等），使应用程序能够在没有网络连接的情况下仍能够正常运行。当应用程序需要更新或升级资源时，Service Workers会自动更新缓存中的内容，以确保应用程序保持最新的版本。</p><p>此外，Service Workers还可以推送消息通知，以提供更好的用户体验。例如，当应用程序的新内容可用时，Service Workers可以发送消息通知给用户，以便用户及时查看内容。</p><p>总之，Application Service Workers是一种强大的浏览器特性，能够为网页应用程序提供离线、推送和更高性能等功能，在现代网页应用程序的开发中起着越来越重要的作用。</p><h2 id="npm-i时-D，-g，-s有什么区别？"><a href="#npm-i时-D，-g，-s有什么区别？" class="headerlink" title="npm i时 -D，-g，-s有什么区别？"></a>npm i时 -D，-g，-s有什么区别？</h2><ol><li><code>-D</code> 或 <code>--save-dev</code>: 表示将依赖项保存在<code>devDependencies</code>节点下。<code>devDependency</code>表示本地开发环境所需要的依赖项，如测试库等，这些依赖项不会放到生产环境中，而是在开发和测试中使用。在项目中执行<code>npm install</code>时，这些依赖项不会被下载。</li><li><code>-g</code> 或 <code>--global</code>: 表示将模块安装为全局模块，只需要在第一次安装时执行一次即可，以后在任意位置执行该模块时都会被引用。通常用于全局的命令行工具，例如<code>gulp-cli</code>。</li><li><code>-S</code> 或 <code>--save</code>: 表示将依赖项保存在<code>dependencies</code>节点下。<code>dependency</code>表示运行时需要的依赖项。在项目中执行<code>npm install</code>时，这些依赖项会被下载到本地并保存在<code>node_modules</code>目录下，可以被应用程序或项目引用。</li></ol><p>默认使用的是<code>-s</code></p><h2 id="前端项目工程初始化，package-json文件主要是什么样的作用？"><a href="#前端项目工程初始化，package-json文件主要是什么样的作用？" class="headerlink" title="前端项目工程初始化，package.json文件主要是什么样的作用？"></a>前端项目工程初始化，package.json文件主要是什么样的作用？</h2><ol><li>管理项目依赖：在package.json文件中，可以定义项目所需要的依赖包及其版本号，以便管理和安装项目所需的npm包。</li><li>配置项目：在package.json文件中还可以定义项目的一些基本配置信息，如项目名称、版本号、作者、许可证等，也可以定义脚本命令，例如：启动项目、打包构建等等。</li><li>版本控制：package.json中还包含了项目的版本信息，可以在版本升级或更新时及时更新版本信息。</li><li>社区交流：在开源社区中，人们可以通过查看项目的package.json文件快速了解项目的基本信息和相关依赖，从而更好地参与到项目的开发、交流与协作中。</li></ol><h2 id="dependencies和DevDependencies的区别？"><a href="#dependencies和DevDependencies的区别？" class="headerlink" title="dependencies和DevDependencies的区别？"></a>dependencies和DevDependencies的区别？</h2><p>devDependencies是项目生产环境中所依赖的工具包</p><p>dependencies是项目正常运行时所依赖的工具包</p><ol><li>dependencies是指项目运行时必须要依赖的包，例如React、Vue、jQuery等等，这些包是直接影响到项目的运行，因此一定要安装并引入它们才能使项目正常运行。</li><li>DevDependencies是指开发过程中需要依赖的包，例如Babel、Webpack等等，这些包通常用于打包构建代码、测试、格式化等开发环境中的工作，它们不会直接影响到项目的运行，只是在开发过程中需要用到它们进行开发。</li><li>在npm install命令中，如果不指定参数，则会同时安装dependencies和DevDependencies中的所有包，如果只想安装dependencies中的包，可以使用npm install –production参数。</li></ol><h2 id="在项目的什么环节二者会出现差异？"><a href="#在项目的什么环节二者会出现差异？" class="headerlink" title="在项目的什么环节二者会出现差异？"></a>在项目的什么环节二者会出现差异？</h2><p>在项目开发过程中dependencies和DevDependencies可能会出现差异。在开发项目时，需要依赖各种开发工具和测试框架来进行代码编写和测试。这些工具和框架通常作为开发人员的开发环境，它们的作用是协助开发人员进行代码编写和测试，但是在项目运行时并不需要它们。</p><p>当开发人员将项目发布到生产环境中时，只需要安装dependencies中的依赖即可。而DevDependencies中的依赖包只需要在开发和测试过程中使用，发布时可以不安装它们。</p><p>因此，在开发一个项目时，我们需要清楚的区分哪些依赖包是生产环境必需的，哪些是开发环境必需的。这样可以减小项目的体积，并减少不必要的依赖。</p><h2 id="dependencies的依赖中，版本号中的-代表什么含义？"><a href="#dependencies的依赖中，版本号中的-代表什么含义？" class="headerlink" title="dependencies的依赖中，版本号中的^代表什么含义？"></a>dependencies的依赖中，版本号中的<code>^</code>代表什么含义？</h2><p>在package.json文件中，^符号代表允许自动更新的版本号，即只要版本号的最左边的非零数字不变，就允许自动更新版本号。例如，^16.8.0表示允许更新到16.x.x的任何版本，但不允许更新到17.x.x及以上的版本。这意味着只有当React的主要版本号（即16）变化时，才需要手动更新项目中的React版本号。</p><h2 id="开发依赖和上线依赖有什么，代码层面如何体现的？"><a href="#开发依赖和上线依赖有什么，代码层面如何体现的？" class="headerlink" title="开发依赖和上线依赖有什么，代码层面如何体现的？"></a>开发依赖和上线依赖有什么，代码层面如何体现的？</h2><p>开发依赖和生产依赖的主要区别在于它们所处的上下文环境不同。开发依赖是在在开发过程中使用的依赖项，而生产依赖是在发布后运行时需要的依赖项。</p><p>在代码层面，可以通过修改 <code>package.json</code> 文件来区分开发依赖和生产依赖。<code>package.json</code> 文件是一个描述 <code>Node.js</code> 模块的文件，它包含了模块名称、版本、作者、许可证等一系列的信息，同时还包含了 <code>dependencies</code> 和 <code>devDependencies</code> 两个节点，分别用于描述生产依赖和开发依赖。</p><p>举个例子，我们在开发过程中使用了 <code>babel</code> 和 <code>webpack</code>，但是生产环境中并不需要它们，那么在 <code>package.json</code> 文件中我们可以这样写：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my-app&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;express&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.16.4&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;babel-core&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^6.26.0&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;babel-loader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^7.1.5&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;webpack&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.39.1&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>express</code> 被声明为生产依赖项，而 <code>babel-core</code>、<code>babel-loader</code> 和 <code>webpack</code> 被声明为开发依赖项。开发依赖项一般不会被发布到生产环境中，而生产环境中只会安装相应的生产依赖项。</p><h2 id="页面和页面之间如何进行通信？"><a href="#页面和页面之间如何进行通信？" class="headerlink" title="页面和页面之间如何进行通信？"></a>页面和页面之间如何进行通信？</h2><ol><li>URL参数传递：通过URL的参数来传递数据，一般用于简单的数据传递，如跳转页面时带上一个ID或者其他参数。</li><li>LocalStorage：可以将数据存储在本地，然后在另外一个页面中通过读取LocalStorage来获得数据。</li><li>Cookies：也可以使用Cookie来传递数据，在另一个页面中读取Cookie来获得数据。</li><li>消息总线（Message Bus）：使用消息总线（Message Bus）来实现不同页面之间的通信，比如使用Vue.js框架中的vuex状态管理工具。</li><li>WebSocket： 使用WebSocket可以在多个页面之间建立长连接，实现实时通信。</li></ol><h2 id="不同域名下的页面进行通信？"><a href="#不同域名下的页面进行通信？" class="headerlink" title="不同域名下的页面进行通信？"></a>不同域名下的页面进行通信？</h2><ol><li><p>跨文档消息传输（Cross-document messaging）：通过JavaScript API从一个窗口向另一个窗口发送消息，使用postMessage方法。</p></li><li><p>JSONP：在页面中嵌入一个外部脚本文件，将数据封装在回调函数中，以JSONP格式传递。</p></li><li><p>服务器代理（Server proxy）：通过一个中间代理服务器，让服务器将请求发送至目标域名，在服务器端进行处理，返回结果。</p></li><li><p>iframe：利用iframe加载一个与目标域名下的页面通信的iframe，通过JavaScript API跨域访问iframe的内容。</p></li><li><p>WebSocket：一种支持浏览器和服务器间实时、双向通信的协议，可用于不同域名下的页面进行通信</p></li></ol><h2 id="浏览器中多个tab页面如何进行通信？"><a href="#浏览器中多个tab页面如何进行通信？" class="headerlink" title="浏览器中多个tab页面如何进行通信？"></a>浏览器中多个tab页面如何进行通信？</h2><p>在浏览器中，多个tab页面之间可以通过以下方式进行通信：</p><p>localStorage: localStorage是HTML5提供的一种本地存储机制，它可以将数据存储在浏览器中，而不<br>需要向服务器发送请求。同源的多个tab页面可以通过共享localStorage的方式实现通信，通过约定<br>localstorage的某一个itemName，基于该key值的内容作为“共享硬盘”方式通信。</p><p>SharedWorker: SharedWorker是HTML5提供的一种JavaScript多线程解决方案，它可以让多个tab页<br>JavaScript代码，这样就可以在多个tab页面之间共享数据和状态。</p><p>WebSocket: Websocket是HTML5提供的一种新协议，它可以在客户端和服务器之间建立一个持久性<br>的连接，从而实现双向通信。Websocket协议可以让服务器主动向客户端推送数据，而不需要客户端<br>发起请求。多个tab页面之间可以通过WebSocket协议进行通信。</p><p>BroadcastChannel: BroadcastChannel是HTML5提供的一种新API，它可以让多人tab页面之间建门<br>个广播通道，从而实现跨页面通信。BroadcastChannel可以让一个页面向其他所有页面广播消息。</p><p>postMessage: postMessage是HTML5提供的一种新API，它可以让多个tab页面之间建立一个消息通<br>道，从而实现跨页面通信。postMessage可以让一个页面向其他所有页面发送消息。</p><h2 id="对微前端和小程序的理解？"><a href="#对微前端和小程序的理解？" class="headerlink" title="对微前端和小程序的理解？"></a>对微前端和小程序的理解？</h2><p>微前端和小程序是两种不同的架构模式。</p><p>微前端是一种将前端应用程序拆分为多个较小、独立的部分，每个部分都可以独立构建、部署，跨团队共同开发，最终组合成完整的前端应用程序的架构风格。微前端可以将一个复杂的前端应用拆解成多个更易于理解、维护和开发的小应用，可以极大提高应用的可维护性、扩展性和可复用性。</p><p>小程序则是一种轻量、低耦合的应用形态。它与普通的网页应用不同，是运行在一个独立的、受限的执行环境中的，可以通过微信、支付宝等应用平台下载和运行。小程序具有轻便、快速、便捷等特点，并且具有开发门槛低、维护简单等优势。</p><p>在微前端中，每个小应用可以看作一个完整的应用，可以使用不同的框架、技术栈来开发。小程序则是一个更加轻量、特殊的应用类型，其开发也需要遵循一定的规范和限制。微前端和小程序都能够极大地提高应用的灵活性、可维护性、可扩展性，但适用的场景、开发方式、技术栈以及运行时环境等方面都存在差异。</p><p>需要注意的是，微前端是一种架构风格，而不是具体实现。在实施微前端时，需要结合具体的业务需求和技术栈，选择适合自己的微前端实现方式。常见的微前端实现方式有：Web Components、IFrame、Javascript Integration等。</p><h2 id="什么是并发池？"><a href="#什么是并发池？" class="headerlink" title="什么是并发池？"></a>什么是并发池？</h2><p>并发池（Concurrent Pool）是指一组线程处理任务的资源池，它用于控制并发任务的数量，以及线程的数量和调度。并发池是提高多线程效率的一种常见方式。由于创建线程是一项昂贵的操作，在有限的 CPU 资源下，任务多线程执行时有时会导致性能下降。为了提高线程处理任务的效率，可以将并发任务扔到并发池中，使其可以更高效地利用有限的 CPU 资源。</p><p>在并发池中，当有任务需要执行时，会从池中取出一个线程，线程会负责处理任务。如果任务较多，而线程数不够，可以根据需要创建新的线程来处理，但这种操作需要消耗系统的资源，因此需要进行一定的控制和限制。</p><p>并发池还可以设置任务队列和线程池的最大大小等参数，以调整整个系统的负载和性能。增加并发池的大小或者增强并发能力可以提高任务处理的速度，但是会增加系统的开销和调度的复杂度，需要进行合理的调整和平衡。</p><p>并发池是基于多线程技术的一种高效的任务调度方案，在并发编程中被广泛应用，例如，Java中的ThreadPoolExecutor就是一个大家熟知的并发池实现。</p><h2 id="手写并发池？"><a href="#手写并发池？" class="headerlink" title="手写并发池？"></a>手写并发池？</h2><p>JavaScript 实现并发池的思路一般可以分为以下几个步骤：</p><ol><li>创建一个任务队列，用于存储待执行的任务。</li><li>创建一个线程池，用于并发执行任务。线程池中可以维护一个可用线程的队列，新任务需要执行时，从队列中获取一个线程进行执行。</li><li>在执行任务时，线程需要从任务队列中取出一个待执行的任务进行处理。处理完成后，将线程回收到线程池中，等待下一个任务。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 任务队列</span><br><span class="hljs-keyword">const</span> taskQueue = [];<br><br><span class="hljs-comment">// 线程池</span><br><span class="hljs-keyword">const</span> threadPool = [];<br><br><span class="hljs-comment">// 初始化线程池，创建可用线程</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initThreadPool</span>(<span class="hljs-params">num</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>    threadPool.<span class="hljs-title function_">push</span>(&#123;<br>      <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;available&#x27;</span><br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 执行任务</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">executeTask</span>(<span class="hljs-params">task</span>) &#123;<br>  <span class="hljs-comment">// 检查是否有可用线程</span><br>  <span class="hljs-keyword">let</span> idleThread = threadPool.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">thread</span> =&gt;</span> thread.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;available&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (idleThread) &#123;<br>    <span class="hljs-comment">// 将线程状态设置为“忙碌”</span><br>    idleThread.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;busy&#x27;</span>;<br>    <span class="hljs-comment">// 执行任务</span><br>    <span class="hljs-title function_">task</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 任务执行结束，将线程状态设置为“可用”</span><br>      idleThread.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;available&#x27;</span>;<br>      <span class="hljs-comment">// 处理下一个任务</span><br>      <span class="hljs-title function_">processTask</span>();<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 等待空闲线程</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">executeTask</span>(task);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 处理任务</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processTask</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (taskQueue.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">let</span> task = taskQueue.<span class="hljs-title function_">shift</span>();<br>    <span class="hljs-title function_">executeTask</span>(task);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 添加任务到队列</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addTask</span>(<span class="hljs-params">task</span>) &#123;<br>  taskQueue.<span class="hljs-title function_">push</span>(task);<br>  <span class="hljs-title function_">processTask</span>();<br>&#125;<br><br><span class="hljs-comment">// 初始化线程池</span><br><span class="hljs-title function_">initThreadPool</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 添加任务到队列</span><br><span class="hljs-title function_">addTask</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Task 1 completed!&#x27;</span>);<br>    <span class="hljs-title function_">callback</span>();<br>  &#125;, <span class="hljs-number">3000</span>);<br>&#125;);<br><br><span class="hljs-title function_">addTask</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Task 2 completed!&#x27;</span>);<br>    <span class="hljs-title function_">callback</span>();<br>  &#125;, <span class="hljs-number">2000</span>);<br>&#125;);<br><br><span class="hljs-title function_">addTask</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Task 3 completed!&#x27;</span>);<br>    <span class="hljs-title function_">callback</span>();<br>  &#125;, <span class="hljs-number">4000</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>以上代码中，我们定义了一个任务队列 <code>taskQueue</code> 和一个线程池 <code>threadPool</code>。在 <code>initThreadPool</code> 函数中，我们创建了一定数量的线程并添加到线程池中。</p><p>在 <code>executeTask</code> 函数中，我们检查线程池中是否有可用线程，如果有可用线程则从任务队列中取出一个任务并将其交给线程执行。任务执行完成后，我们将线程状态设置为“可用”，并继续处理下一个任务。</p><p>在 <code>addTask</code> 函数中，我们将新任务添加到任务队列中，在有可用线程时自动开始执行。我们也可以手动调用 <code>processTask</code> 函数开始执行任务。</p><h2 id="什么是异步池？"><a href="#什么是异步池？" class="headerlink" title="什么是异步池？"></a>什么是异步池？</h2><p>异步池是一种用于控制并发异步操作的机制。它通过限制异步操作的并发数量，避免过多的异步操作导致系统资源紧张、性能下降或者甚至崩溃的情况发生。</p><p>在异步编程模型中，异步操作常常需要消耗大量的系统资源，例如网络 IO、磁盘 IO、CPU 等。如果同时启动过多的异步操作，系统资源就会被耗尽，导致性能下降或者崩溃。因此，为了更好地控制异步操作的并发数量，提高系统的稳定性和性能，通常会采用异步池的机制。</p><p>异步池的实现一般使用任务队列来控制异步操作的并发数量。当有任务需要执行时，先将任务添加到队列中，然后从池中取出一个空闲的线程进行执行，执行完成后再将线程回收到池中等待下一个任务。</p><p>异步池具有以下优点：</p><ol><li>可以避免过多异步操作导致系统性能下降或者崩溃。</li><li>可以提高异步操作的执行效率和响应速度。</li><li>可以提高系统的稳定性和可靠性。</li></ol><p>异步池的应用场景非常广泛，例如网络通信、数据处理、图片处理、音视频处理等领域都会用到异步池的技术。</p><h2 id="什么是Nginx的负载均衡？"><a href="#什么是Nginx的负载均衡？" class="headerlink" title="什么是Nginx的负载均衡？"></a>什么是Nginx的负载均衡？</h2><p>Nginx的负载均衡是一种分发网络负载的技术，它能够将请求分发到不同的服务器上，以达到提高应用程序可用性、可伸缩性和容错性的效果。</p><p>Nginx 的负载均衡通过对请求进行分发，把负载均衡器作为客户端，把服务器作为后端，当客户端发送请求后，负载均衡器根据某种算法，将请求转发到不同的服务器上，分散了服务器的压力，实现了资源的共享。</p><p>Nginx 的负载均衡有四种模式：轮询模式、IP哈希模式、最少连接模式和加权轮询模式。其中，</p><ol><li>轮询模式：按照每一次的连接顺序，在后端服务器间进行轮询；</li><li>IP哈希模式：通过对每一个请求连接的IP地址进行哈希计算，来决定调度的服务器；</li><li>最少连接模式：根据当前所有已连接的客户端数来判断应该将请求发送到哪个服务器上；</li><li>加权轮询模式：根据服务器的性能指标给不同的服务器分配不同的权值，来决定应该将连接转发到哪个服务器上。</li></ol><p>通过Nginx的负载均衡，可以减小单台服务器的压力，提高应用程序的效率和负载能力，从而更好地满足用户需求。</p><h2 id="如果一个项目上线后，用户反映白屏了，但是开发者这边没有问题，可能是哪些原因造成的？"><a href="#如果一个项目上线后，用户反映白屏了，但是开发者这边没有问题，可能是哪些原因造成的？" class="headerlink" title="如果一个项目上线后，用户反映白屏了，但是开发者这边没有问题，可能是哪些原因造成的？"></a>如果一个项目上线后，用户反映白屏了，但是开发者这边没有问题，可能是哪些原因造成的？</h2><p>白屏问题可能由以下原因造成：</p><ol><li>浏览器缓存问题：用户使用的浏览器可能存在缓存，而此次更新的文件或资源未被缓存或缓存已经过期，导致浏览器无法正确加载页面资源。</li><li>CDN缓存问题：网站可能使用了CDN进行资源加速，如果CDN缓存未及时更新或者缓存中的页面资源损坏，也会导致白屏问题。</li><li>代码问题：可能出现了未捕获的程序错误，导致代码无法正常执行，例如语法错误，异常等。在开发环境中由于代码基本经过了调试，因此没有出现问题，但在生产环境中出现问题。</li><li>服务器配置问题：服务器可能配置有错误，例如PHP的错误配置、内存限制等，导致网站无法正常运行或仅显示部分内容。</li><li>网络问题：由于网络连接不佳或者服务器承受的请求太多，导致服务返回数据受阻或丢失，从而出现白屏问题。</li></ol><p>解决方法：</p><ol><li>用户清除浏览器缓存与Cookie缓存。</li><li>检查CDN缓存状态，尝试清除CDN缓存。</li><li>检查代码的错误日志，运行调试工具进行问题定位。同时，在代码中加上错误日志，能帮助开发者更好的了解问题的具体情况。</li><li>检查服务器配置是否正确，并优化服务器配置。</li><li>检查网络连接、服务器负载情况，尝试优化服务器性能。</li></ol><p>通过以上方法，可以排除上述可能造成白屏的原因，逐一解决白屏问题。同时，在项目上线之前，要进行全方位的测试，确保项目稳定性和可靠性。</p><h2 id="前端新旧浏览器如何兼容？"><a href="#前端新旧浏览器如何兼容？" class="headerlink" title="前端新旧浏览器如何兼容？"></a>前端新旧浏览器如何兼容？</h2><ol><li>根据浏览器类型增加前缀和补丁：在CSS、JS、HTML等文件中，可以根据不同浏览器类型增加前缀和补丁。例如CSS中可以使用<code>-webkit-</code>、<code>-moz-</code>、<code>-o-</code>等前缀来解决浏览器兼容性问题。</li><li>使用指针事件代替手势事件：在IE浏览器中，没有支持手势事件的API，可以使用指针事件代替手势事件。指针事件可以在IE11及以上版本的浏览器中获得支持。</li><li>使用Polyfill填充开发者的API：Polyfill是一种库，可以在不支持新API的浏览器中通过JavaScript代码使用类似的API实现相同的功能。它可以使用JavaScript来抹平不同浏览器之间的差异，帮助开发人员开发跨浏览器的Web应用程序。</li><li>使用媒体查询和弹性布局：在设计响应式布局的时候，可以使用媒体查询（Media Query）和弹性布局（Flexbox）来实现响应式设计，从而适应不同的屏幕大小和浏览器类型。</li><li>采用替代方案或设计逐渐降级：如果在旧浏览器中无法实现新的特性，也可以选择采用替代的方案或者设计逐渐降级的方案，保证在旧浏览器上的用户也能够正常访问和使用。</li></ol><h2 id="单页应用与多页应用的区别？"><a href="#单页应用与多页应用的区别？" class="headerlink" title="单页应用与多页应用的区别？"></a>单页应用与多页应用的区别？</h2><p>单页应用（Single Page Application，SPA）和多页应用（Multiple Page Application，MPA）是常见的两种 Web 应用程序结构。</p><p>单页应用是一种<strong>动态加载内容</strong>的方式，它仅仅<strong>在浏览器对服务器发起请求时加载必要的 HTML、CSS 和 JavaScript 文件，并通过 AJAX 技术从服务器获取新内容</strong>。用户在一个页面上进行所有的交互，而页面的更新和内容的变化则是由 JavaScript 控制的。单页应用可以<strong>提高网站的响应速度和用户体验，并且可以适应各种设备和屏幕尺寸</strong>。</p><p>相比之下，多页应用是一种传统的 Web 应用程序结构，<strong>浏览器在用户导航时每次向服务器请求新页面，服务器再返回一个全新的 HTML 文档</strong>。在多页应用中，<strong>每个页面都有自己的 URL，并且需要通过浏览器的后退功能进行导航</strong>。</p><p>SPA 和 MPA 的最主要区别在于其数据的加载方式。<strong>SPA 通常会在页面初始化的时候加载所有必要的组件和数据，而 MPA 则是在每次进行页面跳转的时候重新加载页面和数据</strong>。SPA 通过 AJAX 技术实现快速的页面局部更新，而 MPA 则需要向服务器请求完整的 HTML 文档。</p><p>另外，SPA 的优点还包括<strong>更流畅、更快的用户体验、可复用性更高、开发成本更低</strong>，而 MPA 的优点则包括 <strong>SEO 更加友好、实现简单易懂，适合传统的 Web 应用程序</strong>。</p><h2 id="对后端的理解？"><a href="#对后端的理解？" class="headerlink" title="对后端的理解？"></a>对后端的理解？</h2><p>后端是指Web应用程序中的服务器端（Server-Side）部分，主要负责处理客户端（Front-End）请求、数据库交互及业务逻辑处理等。后端通常是由Web框架、服务器、数据库等技术组成的，比如常用的Java后端主要基于Spring&#x2F;Spring Boot、MyBatis等技术架构来实现。</p><p>后端主要任务之一是<strong>将前端用户请求转化为后端业务逻辑，将处理结果返回给前端</strong>，因此后端需要实现一些接口，以供前端调用。同时，后端还需要负责<strong>与数据库进行交互，如响应前端的请求，查询数据库中的数据并返回结果，将前端提交的数据写入数据库等</strong>。此外，后端还需要实现一些<strong>系统基础服务</strong>，如身份认证、日志输出、缓存等。</p><p>为了保证后端的稳定性和高效性，后端需要考虑编码规范、安全性、性能优化等方面的问题。另外，随着Web技术的发展，后端还需要考虑如微服务、云计算等新技术的应用及其实现，以支持更好的系统架构和运行效率。</p><h2 id="如何管理线程池？"><a href="#如何管理线程池？" class="headerlink" title="如何管理线程池？"></a>如何管理线程池？</h2><p>线程池是一种可以重复利用的线程集合，它可以减少线程的创建和销毁次数，提高应用程序的性能。为了有效地管理线程池，我们需要考虑以下几个方面：</p><ol><li>线程池大小：线程池大小的配置需要根据应用程序的性质、系统硬件环境和其他因素进行合理的配置。如果线程池大小过小，则可能导致应用程序响应变慢，如果线程池过大，则会消耗大量系统资源，降低系统性能。</li><li>线程池任务队列：线程池任务队列可以缓存等待处理的任务，以便线程池中的线程可以及时处理。在实际应用中，我们需要根据实际情况来选择使用有界队列还是无界队列，以及队列的大小。</li><li>线程池任务拒绝策略：当线程池中的线程和任务队列都已满时，可以采用不同的任务拒绝策略，例如直接丢弃任务、抛出异常、调用者运行等。</li><li>线程池监控与日志：需要针对线程池进行监控和日志记录，以便及时发现并解决线程池性能问题。</li><li>线程池关闭：在应用程序退出或者不再需要线程池时，需要正确地关闭线程池，并释放所有的资源。</li></ol><p>总之，线程池的管理需要根据实际情况进行灵活配置和优化，以保证线程池能够高效地运行并且不会导致内存泄露等问题。</p><h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><ul><li>封装：将客观事物抽象成类，并将自己的属性和方法让可信的类或对象操作，对不可信的隐藏</li><li>继承：可以使用现有类的所有共鞥你，并在无需重新编写原来的类的情况下对这些功能进行拓展</li><li>多态：允许将父对象设置成为和一个或更多它的子对象相等的技术，赋值之后，父对象可以根据当前赋值给它的子对象的特性以不同的方式运作。虽然针对不同对象的具体操作不同，但通过一个公共的类，他们可以通过相同的方式予以调用。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Spring Recruitment</tag>
      
      <tag>Webpack</tag>
      
      <tag>Git</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器、进程和线程、计算机网络、数据库相关</title>
    <link href="/2023/04/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
    <url>/2023/04/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器、进程和线程、计算机网络、数据库相关"><a href="#浏览器、进程和线程、计算机网络、数据库相关" class="headerlink" title="浏览器、进程和线程、计算机网络、数据库相关"></a>浏览器、进程和线程、计算机网络、数据库相关</h1><h2 id="进程和线程的概念及区别？"><a href="#进程和线程的概念及区别？" class="headerlink" title="进程和线程的概念及区别？"></a>进程和线程的概念及区别？</h2><p>进程是对正在运行中的程序的一个抽象，是系统进行资源分配和调度的基本单位。</p><p>线程是CPU任务调度和执行的基本单位。</p><p>区别：</p><ul><li>进程可以看作是一个独立应用，而线程不能。</li><li>进行是CPU进行资源分配的最小单位，而线程是CPU调度的最小单位。</li><li>线程间可以直接共享同一进程中的资源，而进程通信需要借助<strong>进程间通信</strong>。</li><li>进行切换的开销比线程切换的开销要大。线程的切换不会引起进程的切换，但某个进程中的线程切换到另一个进程中的线程会引起进程的切换。</li><li>撤销或创建进程的时候，系统要为之分配或回收资源，开销远大于创建或撤销线程时的开销。同样，进程切换的时候涉及到<strong>当前进程的CPU环境还有各种各样状态的保存及新调度进程状态的设置</strong>，而线程切换只需要保存和设置少量的寄存器内容，开销较小。</li></ul><h2 id="为什么有了进程还要有线程"><a href="#为什么有了进程还要有线程" class="headerlink" title="为什么有了进程还要有线程?"></a>为什么有了进程还要有线程?</h2><p>在计算机操作系统中，进程是程序的基本执行单元，而线程是进程内的一个单独执行流，共享进程的资源和空间。虽然进程可以通过多个线程实现并发，但也有很多情况下需要使用线程，具体原因有以下几点：</p><ol><li>资源共享：进程间的资源必须通过进程间通信（IPC）进行传递，而线程可以直接共享进程的资源，包括内存空间、打开的文件、信号处理器等，因此线程的通信代价低于进程的通信。</li><li>轻量级：线程比进程更轻量级，创建和销毁线程的代价远远小于创建和销毁进程的代价。多个线程可以在同一个进程内并发执行，从而提高整个系统的执行效率。</li><li>可以利用多核心：一个进程在单个CPU上只能并发执行一个线程，而一个多线程的进程可以同时在多个CPU内进行并发执行，提高执行效率。</li><li>更灵活：线程之间的切换代价要比进程之间的切换少，因此可以更灵活地控制代码的执行流程。线程还可以对代码的并发性进行更精细的控制，比如通过锁、信号量等机制控制对共享资源的访问。</li></ol><p>综上所述，线程虽然比进程更轻量级，但在实际应用中具有不可替代的优势，可以更高效地实现并发，提高系统的执行效率和灵活性。</p><h2 id="进程间通信的方式有哪些？"><a href="#进程间通信的方式有哪些？" class="headerlink" title="进程间通信的方式有哪些？"></a>进程间通信的方式有哪些？</h2><ul><li><p>管道通信</p><p>操作系统在内核中开辟一段缓冲区，进程A可以将需要交互的数据拷贝到这段缓冲区中，进程B就可以读取了。(只能单向通信，并只能在有血缘关系的进程间通信)</p></li><li><p>消息队列队列通信</p><p>消息队列就是一个消息的列表，用户可以在消息队列中添加消息、读取消息等。它提供了一种从一个进程向另一个进程发送数据块的方法。每个数据块都被认为含有一个类型，接收进程可以独立的接受含有不同类型的数据结构。但消息队列与命名管道一样，每个数据块都有一个<strong>最大长度的限制</strong>。</p></li><li><p>共享内存通信</p><p>共享内存就是映射了一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问(使多个进程可以访问同一块内存空间)。</p></li><li><p>信号量通信</p><p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。</p></li><li><p>信号通信</p><p>Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件(一组事件中的一个)，它也是用户进程间通信和同步的一种原始机制。</p></li><li><p>套接字通信</p><p>是计算机之间进行通信的一种约定或一种方式。</p></li></ul><h2 id="进程共享内存通信具体是怎样实现的？"><a href="#进程共享内存通信具体是怎样实现的？" class="headerlink" title="进程共享内存通信具体是怎样实现的？"></a>进程共享内存通信具体是怎样实现的？</h2><ol><li>创建共享内存：需要调用操作系统提供的函数，例如shmget()，创建一个共享内存区域并返回一个共享内存标识符。</li><li>将共享内存附加到进程地址空间：使用shmat()函数将共享内存附加到进程的地址空间。该函数会返回一个指向共享内存区域的指针。这一步相当于将共享内存映射到进程的地址空间中。</li><li>进程间读写共享内存：多个进程可以直接通过指针操作共享内存区域进行数据的读写。需要注意的是，在读写数据时，需要通过信号量等机制进行进程同步，避免多个进程同时修改同一段内存区域，导致数据冲突。</li><li>分离共享内存：当进程不再需要使用共享内存时，需要调用shmdt()函数将它从进程地址空间中分离，这一步相当于解除共享内存和进程地址空间的映射关系。</li><li>删除共享内存：当所有使用该共享内存的进程都调用了shmdt()进行分离后，需要调用shmctl()函数删除共享内存。</li></ol><p>需要注意的是，在使用共享内存进行进程间通信时，需要保证多个进程对数据的读写操作是原子性的，避免出现数据冲突等问题。因此，通常使用信号量等同步机制进行进程间同步。</p><h2 id="共享内存通信的好处是什么？"><a href="#共享内存通信的好处是什么？" class="headerlink" title="共享内存通信的好处是什么？"></a>共享内存通信的好处是什么？</h2><ol><li>高效性：共享内存通信是一种高效的进程间通信机制。由于多个进程可以直接访问同一块物理内存，因此数据的传递速度很快，可以实现高速的数据交换。</li><li>灵活性：共享内存通信可以传递任意类型的数据，包括结构体、数组、指针等多种数据类型。而其他进程间通信机制（如管道、消息队列等）则往往需要数据进行序列化和反序列化，传递数据时需要额外的处理，增加了通信的复杂度。</li><li>容量大：共享内存通信可以很容易地传输大量的数据，因为共享内存区域的容量可以在创建时进行指定，从而满足不同应用的实际需求。</li><li>维护方便：共享内存通信的使用和管理比较简单，只需创建、附加、使用、分离和删除几个步骤，对于多进程间共享数据的应用场景，可以提供简单有效的通信方案。</li></ol><h2 id="为什么管道通信和消息队列通信会存在资源大小的限制？"><a href="#为什么管道通信和消息队列通信会存在资源大小的限制？" class="headerlink" title="为什么管道通信和消息队列通信会存在资源大小的限制？"></a>为什么管道通信和消息队列通信会存在资源大小的限制？</h2><p>管道通信和消息队列通信会存在资源大小的限制，主要是由于它们使用的内核缓冲区大小有限，而且这些内核缓冲区是由操作系统分配的。</p><p>具体来说，管道通信和消息队列通信使用的内核缓冲区大小是固定的，而且通常比较小（例如Linux中管道的缓冲区大小为4KB，消息队列缓冲区默认大小为16KB）。因此，当需要传输的数据量超过内核缓冲区大小时，就会出现资源大小的限制。这时，要么数据无法传输，要么就需要分多次传输或者使用其他进程间通信方式。</p><p>此外，由于管道和消息队列都是一种面向字节流的通信方式，因此在传输结构体、对象、数组等复杂的数据类型时，需要进行序列化和反序列化处理。这种处理会带来额外的开销和复杂性，进一步限制了通信的资源和效率。</p><p>综上所述，管道通信和消息队列通信存在资源大小的限制，这是因为它们使用的内核缓冲区大小有限，并且数据类型限制较多，不能很好地支持大数据量和复杂数据类型的通信。</p><h2 id="如果没有共享内存通信会导致什么问题？"><a href="#如果没有共享内存通信会导致什么问题？" class="headerlink" title="如果没有共享内存通信会导致什么问题？"></a>如果没有共享内存通信会导致什么问题？</h2><ol><li>低效率：使用进程间通信(IPC)方式进行数据交换消耗的时间和资源比较大。常用的IPC方式包括管道、消息队列、信号量等，这些方式都需要用到中间缓冲区、系统调用等，这些操作耗费了很多时间和系统资源。</li><li>程序设计复杂：采用IPC方式进行通信，需要对通信方式的技术细节进行了解和掌握，需要考虑数据格式、传输方式、同步方式、异常处理等问题，程序设计复杂度相对高。</li><li>难以建立复杂数据结构：使用IPC方式进行通信，不同进程需要采用不同的数据结构进行数据交换，相互之间不太容易建立复杂的数据结构，例如链表或树。</li><li>容易出错：使用IPC方式进行通信，需要进行同步操作，否则可能会发生死锁或者忙等等问题，这些问题难以排除。</li></ol><p>如果进程没有共享内存通信，则会导致进程间通信的效率变得低下，设计难度加大，难以建立复杂的数据结构，而且容易出现错误，降低了程序可维护性和可靠性，也使得应用程序性能不尽如人意。</p><h2 id="进程的状态有哪些？"><a href="#进程的状态有哪些？" class="headerlink" title="进程的状态有哪些？"></a>进程的状态有哪些？</h2><p>进程的状态通常分为五种基本状态：创建态、就绪态、运行态、阻塞态和终止态。</p><ul><li>创建态：进程刚被创建，但是还没有被操作系统调度执行。</li><li>就绪态：进程已经准备好运行，但是还没有被操作系统调度执行。</li><li>运行态：进程正在被操作系统调度执行。</li><li>阻塞态：进程因为某些原因而暂停执行，等待外部事件的发生。</li><li>终止态：进程已经完成了它的任务，或者因为某些原因被操作系统强制终止。</li></ul><h2 id="线程有哪几种状态？"><a href="#线程有哪几种状态？" class="headerlink" title="线程有哪几种状态？"></a>线程有哪几种状态？</h2><ol><li>新建状态（New）：当线程对象被创建时，它就处于新建状态，此时它还没有被启动。</li><li>就绪状态（Runnable）：当线程被调用start()方法后，它进入就绪状态，表示它已经准备好运行，等待系统分配资源。</li><li>运行状态（Running）：当系统分配到资源后，线程就进入运行状态，开始执行run()方法中的代码。</li><li>阻塞状态（Blocked）：当线程等待某个操作完成或等待某个资源时，它进入阻塞状态，暂时停止执行。</li><li>等待状态（Waiting）：当线程执行某个操作后，需要等待另一个线程或操作完成时，它进入等待状态，调用wait()或join()方法时，线程就会进入等待状态。</li><li>超时等待状态（Timed Waiting）：当线程执行某个操作后，需要等待一段时间后再继续执行时，它进入超时等待状态，调用sleep()、wait(long)或join(long)等方法时，线程就会进入超时等待状态。</li><li>终止状态（Terminated）：当线程执行完run()方法后，它就进入终止状态，线程执行结束，不再继续执行。</li></ol><h2 id="匿名通信与命名通信的区别？"><a href="#匿名通信与命名通信的区别？" class="headerlink" title="匿名通信与命名通信的区别？"></a>匿名通信与命名通信的区别？</h2><p>匿名通信和命名通信是通信方式的不同方式。匿名通信是发送者和接收者都是匿名的方式，不会透露身份信息，保护隐私和安全。而命名通信是使用实名或者昵称方式进行通信，对身份信息没有保护作用。</p><p>具体区别如下：</p><ol><li><p>匿名通信只能是据有血缘关系的进程之间进行通信，只能半双工通信；命名通信可以在任意两个进程之间进行通讯，可以全双工通信，命名管道提供了一个路径名与之关联，以FIFO文件的形式存储于文件系统中，能够实现任意两个进程之间通信。</p></li><li><p>匿名通信只需要发送者和接收者拥有匿名身份，通信过程中不需要透露身份信息，保护隐私和安全。而命名通信需要使用实名或昵称等方式进行通信，会透露身份信息。</p></li><li><p>匿名通信可以避免被窃听、篡改、攻击等威胁，因为使用匿名身份进行通信。命名通信可能容易被攻击者获取身份信息进行攻击。</p></li><li><p>匿名通信的验证和监管比较困难，因为发送者和接收者都是匿名的。命名通信可以更容易地监管和验证通信过程。</p></li><li><p>匿名通信常常被用在各种机密通信、点对点通信和加密通信中。命名通信通常是为了建立信任关系和社交沟通而使用的。</p></li></ol><h2 id="操作系统的进程调度算法有哪几种？"><a href="#操作系统的进程调度算法有哪几种？" class="headerlink" title="操作系统的进程调度算法有哪几种？"></a>操作系统的进程调度算法有哪几种？</h2><p>操作系统的进程调度的常见策略：</p><ul><li>先来先服务调度算法(FCFS)：按照进程到达的先后顺序进行调度，先到达的进程限制性，后到达的进程后执行。</li><li>短作业优先调度算法(SJF)：按照进程需要的CPU时间长短进行调度，即需要CPU时间最短的进程先执行。</li><li>优先级调度算法：按照进程的优先级进行调度，即优先级高的进程先执行。</li><li>时间片轮转调度算法：按照时间片轮流分配CPU时间进行调度，即每个进程分配一个时间片，当时间片用完后，该进程被挂起，等到下一次轮到它的时候再继续执行。</li><li>多级反馈队列算法：将就绪队列分成多个队列，每个队列有不同的优先级，每个队列采用不同的调度算法。新到达的进程首先放在第一级队列，如果该队列中没有可执行的进程，则将该队列放入第二级队列中等待执行。如果第一级队列中有可执行的进程，则按照时间片轮转调度算法去进行调度。如果一个进程再第一级队列中运行了一段时间仍然没有完成，则将其移动到第二级队列中等待执行，以此类推，直到该进程完成或被强制终止。</li></ul><h2 id="多进程编程的难点和解决方案？"><a href="#多进程编程的难点和解决方案？" class="headerlink" title="多进程编程的难点和解决方案？"></a>多进程编程的难点和解决方案？</h2><p>多线程编程的难点主要有以下几个方面：线程安全、死锁、资源竞争、线程间通信等。</p><p>其中，线程安全是多线程编程中最重要的问题之一，它涉及到<strong>多个线程同时访问同一个共享资源时的数据一致性问题</strong>。</p><p>死锁是指两个或多个进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法继续执行下去。</p><p>资源竞争是指多个线程同时访问同一个共享资源时，由于访<strong>问顺序不当而导致程序出现错误</strong>。</p><p>线程间通信是指多个线程之间相互协作完成任务的过程，包括等待通知机制、管道机制、信号量机制等。</p><h2 id="在多线程的情况下如何保证线程安全？"><a href="#在多线程的情况下如何保证线程安全？" class="headerlink" title="在多线程的情况下如何保证线程安全？"></a>在多线程的情况下如何保证线程安全？</h2><ol><li>加锁：使用锁机制来保护共享资源，确保同一时间只有一个线程可以访问共享资源，其他线程需要等待锁释放后才能访问。</li><li>使用原子操作：原子操作是不可被中断的操作，可以保证多线程访问共享资源时的原子性，避免数据不一致的问题。</li><li>使用线程安全的数据结构：如ConcurrentHashMap、CopyOnWriteArrayList等，这些数据结构是线程安全的，多个线程可以同时访问并修改其中的元素，不需要加锁。</li><li>使用volatile关键字：volatile关键字可以保证变量在多线程中的可见性，即一个线程修改了变量的值，其他线程可以立即看到修改后的值。</li><li>避免共享资源：尽量避免多个线程访问共享资源，可以采用线程本地存储（ThreadLocal）等方式来避免共享资源的访问冲突。</li></ol><h2 id="并发和并行的区别？"><a href="#并发和并行的区别？" class="headerlink" title="并发和并行的区别？"></a>并发和并行的区别？</h2><p>并发和并行都是多任务处理的概念，但是它们的含义不同。</p><p>并发是指在同一时间段内，有多个任务在交替执行，这些任务可能在同一个处理器上交替执行，也可能在多个处理器上并行执行。在并发执行中，每个任务都会分配一定的时间片，轮流执行，但是在任意时刻只有一个任务在执行。</p><p>并行是指在同一时刻，有多个任务在同时执行，这些任务可以在多个处理器上并行执行，也可以在同一处理器上通过多核心并行执行。在并行执行中，多个任务同时执行，每个任务都能够分配到独立的处理器或处理器核心。</p><p>简单来说，如果是在同一个处理器上，任务是交替执行的，就是并发；如果是在多个处理器上或者是多核心并行执行，就是并行。</p><p>总之，并发和并行都是提高计算机系统效率的重要手段，但是它们的实现方式和效果不同。在实际应用中，需要根据具体情况选择并发或并行的方式来处理任务。</p><h2 id="什么是全双工通信？"><a href="#什么是全双工通信？" class="headerlink" title="什么是全双工通信？"></a>什么是全双工通信？</h2><p>全双工通信是指在通信的两端，数据可以同时双向传输，即两端都可以同时发送和接收数据。全双工通信可以实现双向通信，通信效率高，通信质量稳定。与半双工通信和单工通信相比，全双工通信具有更高的带宽利用率和更快的数据传输速度。</p><p>在全双工通信中，通信双方可以同时发送和接收数据，而且在发送和接收数据时不需要等待对方的响应。这种通信方式可以在同一信道上实现双向通信，例如电话通信、视频会议、网络通信等都可以采用全双工通信方式。</p><p>在全双工通信中，通信双方需要使用专门的设备进行通信，例如全双工电缆、全双工网卡等。这些设备可以同时进行发送和接收数据，并且能够处理来自对方的数据，从而实现双向通信。</p><p>因此，全双工通信可以提高通信效率和通信质量，广泛应用于各种通信场景中。</p><h2 id="操作系统的功能有哪些？"><a href="#操作系统的功能有哪些？" class="headerlink" title="操作系统的功能有哪些？"></a>操作系统的功能有哪些？</h2><ol><li><p>进程管理：操作系统管理计算机上运行的所有进程，包括进程的创建、调度、终止、通信等。</p></li><li><p>内存管理：操作系统管理计算机内存的分配和释放，确保程序能够访问到所需的内存空间。</p></li><li><p>文件系统：操作系统管理计算机上的文件和目录，包括文件的创建、读取、写入、复制、删除等。</p></li><li><p>设备管理：操作系统管理计算机上的各种设备，包括输入输出设备、存储设备、网络设备等。</p></li><li><p>用户接口：操作系统提供了用户与计算机交互的接口，包括命令行接口、图形用户界面等。</p></li><li><p>安全性管理：操作系统确保计算机系统的安全性，包括用户身份验证、访问控制、病毒防护等。</p></li><li><p>网络管理：操作系统提供了网络通信的支持，包括TCP&#x2F;IP协议栈、网络驱动程序等。</p></li></ol><h2 id="什么是操作系统的堆区和栈区？"><a href="#什么是操作系统的堆区和栈区？" class="headerlink" title="什么是操作系统的堆区和栈区？"></a>什么是操作系统的堆区和栈区？</h2><p>操作系统中的堆和栈都是指内存空间，不同的是堆为按需申请、动态分配，例如 C 中的 malloc 函数和 C++ 中的 new 操作。而栈是由编译器自动分配释放，存放函数的参数值，局部变量的值等。<br>堆和栈之间的区别主要有以下几点：</p><ul><li>分配方式：堆是动态分配的，而栈是静态分配的。</li><li>空间大小：堆的空间大小不确定，而栈的空间大小固定。</li><li>空间分配方式：堆是由程序员手动申请和释放，而栈是由编译器自动分配和释放。</li><li>空间使用方式：堆的空间可以随时申请和释放，而栈的空间只能在函数调用时申请，在函数返回时释放。</li></ul><h2 id="堆和栈，哪个操作系统处理起来会更快？"><a href="#堆和栈，哪个操作系统处理起来会更快？" class="headerlink" title="堆和栈，哪个操作系统处理起来会更快？"></a>堆和栈，哪个操作系统处理起来会更快？</h2><p>一般来说，栈的处理速度比堆更快，这是因为<strong>栈的内存分配和释放是由编译器自动完成的，不需要进行复杂的内存管理操作，而且它的数据结构相对简单，访问速度更快</strong>。而堆在内存分配和释放时需要进行一些额外的操作，例如寻找可用内存，管理内存分配器等，因此操作系统在处理堆时需要花费更多的时间。</p><p>但是，在实际应用中，我们往往需要使用堆空间来存储动态数据结构，例如动态数组、链表、堆等。这些数据结构使用栈空间无法实现，只能使用堆空间。因此，在程序设计时需要根据实际需求合理使用栈和堆，以取得更好的性能和效率。</p><h2 id="OSI七层网络协议"><a href="#OSI七层网络协议" class="headerlink" title="OSI七层网络协议"></a>OSI七层网络协议</h2><p>OSI七层网络协议是一种通信协议的标准，它将计算机网络体系结构分为七个层次，每个层次都有自己的功能和任务。这些层次分别是：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p><p>物理层：负责传输比特流，即由1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换。<br>数据链路层：在计算机网络中由于各种干扰的存在，物理链路是不可靠的。该层的主要功能就是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。<br>网络层：负责数据包从源到宿的传递和网际互连。<br>传输层：负责向两台主机进程之间提供端到端的可靠数据传输服务。<br>会话层：负责建立、管理和终止会话。<br>表示层：负责数据格式转换、加密解密等。<br>应用层：为用户提供各种应用服务。</p><h2 id="常见的应用层协议有哪些？"><a href="#常见的应用层协议有哪些？" class="headerlink" title="常见的应用层协议有哪些？"></a>常见的应用层协议有哪些？</h2><ol><li><strong>HTTP：超文本传输协议，用于浏览器和服务器之间的数据传输。</strong></li><li><strong>FTP：文件传输协议，用于在远程计算机之间传输文件。</strong></li><li>SMTP：简单邮件传输协议，用于电子邮件传输。</li><li>POP3：邮局协议版本3，用于电子邮件客户端从邮件服务器接收邮件。</li><li>IMAP：互联网消息访问协议，用于电子邮件客户端从邮件服务器接收邮件。</li><li>DNS：域名系统，用于将域名（例如<a href="http://www.baidu.com)和ip地址进行映射./">www.baidu.com）和IP地址进行映射。</a></li><li>Telnet：远程终端协议，用于在计算机之间进行远程控制。</li><li>SSH：安全外壳协议，用于在计算机之间进行加密控制。</li><li>SNMP：简单网络管理协议，用于在网络中对设备进行管理和监控。</li></ol><h2 id="常见的传输层协议有哪些？"><a href="#常见的传输层协议有哪些？" class="headerlink" title="常见的传输层协议有哪些？"></a>常见的传输层协议有哪些？</h2><ol><li><strong>TCP：传输控制协议，提供可靠的、面向连接的数据传输，在网络不可靠的情况下，TCP可以保证数据的可靠传输。</strong></li><li><strong>UDP：用户数据报协议，提供不可靠的、无连接的数据传输。相比TCP，UDP传输速度更快，但不保证数据的可靠传输，适合于实时传输、网络游戏等应用场景。</strong></li><li>SCTP：流控制传输协议，提供可靠的、面向连接的数据传输，支持多条独立的数据流，适合于多媒体传输和VoIP（Voice over IP）等应用场景。</li></ol><p>传输层协议是在网络中负责应用程序之间数据的可靠传输和错误控制的协议，不同的传输层协议有不同的特点和适用场景。TCP是常用的传输层协议，提供可靠的、面向连接的数据传输，适合数据传输要求较高的应用场景；UDP则是提供不可靠的、无连接的数据传输，适合实时传输、网络游戏等应用场景。同时，SCTP相比TCP具备更好的抗攻击能力，因此也得到了广泛应用。</p><h2 id="网络层的协议有哪些？"><a href="#网络层的协议有哪些？" class="headerlink" title="网络层的协议有哪些？"></a>网络层的协议有哪些？</h2><ol><li>IP协议（Internet Protocol）：IP是互联网中最重要的协议之一，负责将数据包从源地址传输到目的地址，并通过路由选择算法选择最优路径。IPv4和IPv6是最常用的IP协议版本。</li><li>ICMP协议（Internet Control Message Protocol）：ICMP是IP协议的附属协议，用于传输网络控制信息和错误报文。常用的功能包括ping命令和traceroute命令。</li><li>ARP协议（Address Resolution Protocol）：ARP是用于将IP地址转换为MAC地址的协议，通过查询本地网络中的ARP缓存表或广播ARP请求来查找目标MAC地址。</li><li>RARP协议（Reverse Address Resolution Protocol）：RARP是ARP的反向协议，用于将MAC地址转换为IP地址。现在已经很少使用。</li><li>OSPF协议（Open Shortest Path First）：OSPF是一种开放的链路状态路由协议，用于在局域网和广域网中选择最短路径，实现路由的自适应和动态变化。</li><li>BGP协议（Border Gateway Protocol）：BGP是一种自治系统间的路由协议，用于在不同自治系统之间传输路由信息，实现互联网中的全球路由选择。</li><li>RIP协议（Routing Information Protocol）：RIP是一种基于距离向量的内部网关协议，用于在小型网络中选择最短路径，实现路由的自适应和动态变化。</li></ol><h2 id="TCP和UDP的区别？⭐"><a href="#TCP和UDP的区别？⭐" class="headerlink" title="TCP和UDP的区别？⭐"></a>TCP和UDP的区别？⭐</h2><p>TCP和UDP的区别如下:</p><ul><li>TCP是面向连接的，UDP是无连接的</li><li>TCP提供可靠的服务，UDP则不保证可靠交付数据</li><li>TCP是一对一的两点服务，即一条连接只有两个端点。UDP支持一对一、一对多、多对多的交互通信</li><li>TCP有拥塞控制和流量控制机制，保证数据传输的安全性。UDP则没有，即使网络非常拥堵了，也不会影响UDP的发送速率</li><li>TCP首部长度较长，会有一定的开销，首部在没有使用[选项，字段时是20个字节，如果使用了[选项]字段则会变长。UDP首部只有8个字节，并且是固定不变的，开销较小。</li></ul><h2 id="TCP和UDP的应用场景？⭐"><a href="#TCP和UDP的应用场景？⭐" class="headerlink" title="TCP和UDP的应用场景？⭐"></a>TCP和UDP的应用场景？⭐</h2><p>TCP和UDP是两种不同的传输协议。TCP是面向连接的协议，而UDP是无连接的协议。TCP提供交付保证，这意味着一个使用TCP协议发送的消息是保证交付给客户端的，如果消息在传输过程中丢失，那么它将重发。而UDP不提供这种保证。因此，<strong>TCP适用于对准确性要求相对高的场景，如文件传输、发送或接收邮件、远程登录等，而UDP适用于对准确性要求相对低但速度要求相对高的场景，如即时通信、在线视频、网络语音电话等。</strong></p><h2 id="Websocket使用的是TCP还是UDP协议？为什么？"><a href="#Websocket使用的是TCP还是UDP协议？为什么？" class="headerlink" title="Websocket使用的是TCP还是UDP协议？为什么？"></a>Websocket使用的是TCP还是UDP协议？为什么？</h2><p>Websocket使用的是TCP协议，而不是UDP协议。</p><p>TCP协议是一种面向连接的、可靠的、有序的协议，它在数据传输过程中提供了数据完整性、可靠性和有序性的保证。Websocket需要<strong>保证数据的可靠性和有序性</strong>，因此选择了TCP协议作为底层传输协议。</p><p>相比之下，UDP协议是一种无连接的、不可靠的、无序的协议，它不提供数据的可靠性和有序性保证，适合于一些实时性要求高、数据量小、可丢失的应用，如在线游戏、音视频传输等。但是Websocket需要保证数据的可靠性和有序性，因此不适合使用UDP协议作为底层传输协议。</p><p>综上所述，Websocket使用TCP协议作为底层传输协议，可以保证数据的可靠性和有序性，适用于需要保证数据完整性和可靠性的应用。</p><h2 id="TCP的三次挥手"><a href="#TCP的三次挥手" class="headerlink" title="TCP的三次挥手"></a>TCP的三次挥手</h2><p>TCP三次握手是TCP协议中用于在客户端和服务器之间建立连接的过程。三次握手的过程如下：</p><ol><li>客户端向服务器发送一个SYN包，其中标志位为SYN，表示请求建立连接，序号为Seq&#x3D;x(一般取随机数)。</li><li>服务器接收到客户端发来的SYN包后，对该包进行确认后结束LISTEN阶段，并返回一段TCP报文，其中标志位为SYN和ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接，序号为Seq&#x3D;y。</li><li>客户端接收到服务器发来的TCP报文后，对该报文进行确认，其中标志位为ACK，表示确认服务器的报文Seq序号有效，客户端能正常接收服务器发送的数据，并向服务器发送一段TCP报文，其中标志位为ACK，表示确认服务器的报文Seq序号有效。</li></ol><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/9/d8bf92c7906718271fdb8b0d2d5fe5b4~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><h2 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h2><p>TCP四次挥手是TCP协议中用于在客户端和服务器之间断开连接的过程。四次挥手的过程如下：</p><ol><li>客户端向服务器发送一个FIN包，其中标志位为FIN，表示请求断开连接，序号为Seq&#x3D;u。</li><li>服务器接收到客户端发来的FIN包后，对该包进行确认后结束ESTABLISHED阶段，并返回一段TCP抵文，其中标志位为ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并告诉客户端：我知道你想断开连接的请求了。</li><li>服务器向客户端发送一个FIN包，其中标志位为FIN，表示请求断开连接，序号为Seq&#x3D;V。</li><li>客户端接收到服务器发来的TCP报文后，对该报文进行确认，其中标志位为ACK，表示确认服务器的报文Seq序号有效，客户端能正常接收服务器发送的数据，并向服务器发送一段TCP报文，其中标志位为ACK，表示确认服务器的报文Seq序号有效。</li></ol><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/9/8c7874fafe233c9278509e40e906055c~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><h2 id="TCP的三次握手为什么不能改成两次？"><a href="#TCP的三次握手为什么不能改成两次？" class="headerlink" title="TCP的三次握手为什么不能改成两次？"></a>TCP的三次握手为什么不能改成两次？</h2><p>TCP三次握手是TCP协议中用于在客户端和服务器之间建立连接的过程。其中，第一次握手是客户端向服务器发送一个SYN包，其中标志位为SYN，表示请求建立连接，序号为Seq&#x3D;x；</p><p>第二次握手是服务器接收到客户端发来的SYN包后，对该包进行确认后结束SYN_RECEIVED阶段，并返回一段TCP报文，其中标志位为SYN&#x2F;ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并告诉客户端:我知道你想建立连接的请求了，我的序号是Seq&#x3D;y；</p><p>第三次握手是客户端接收到服务器发来的TCP报文后，对该报文进行确认，其中标志位为ACK，表示确认服务器的报文Seq序号有效，客户端能正常接收服务器发送的数据，并告诉服务器:我知道你想建立连接的请求了，我的序号是Seq&#x3D;x+1。这样就完成了TCP三次握手过程。</p><p>如果采用两次握手，则<strong>只能确定从客户端到服务端的网络是可达的，但无法保证从服务端到客户端的网络是可达的</strong>。</p><p>此外，在采用两次握手时，如果已失效的连接请求报文段突然又传到了服务端，则会导致双方不一致，造成资源浪费。</p><h2 id="TCP客户端和服务端同时发出断开请求后续会怎么样？"><a href="#TCP客户端和服务端同时发出断开请求后续会怎么样？" class="headerlink" title="TCP客户端和服务端同时发出断开请求后续会怎么样？"></a>TCP客户端和服务端同时发出断开请求后续会怎么样？</h2><p>在 TCP 连接中，当客户端和服务端都发出断开请求时，会发生以下情况：</p><ol><li>服务端先收到断开请求：服务端会发送一个 ACK 确认客户端的断开请求，并关闭连接。此时客户端还没有收到服务端的 ACK，仍然处于等待状态。</li><li>客户端先收到断开请求：客户端会发送一个 ACK 确认服务端的断开请求，并关闭连接。此时服务端还没有收到客户端的 ACK，仍然处于等待状态。</li><li>客户端和服务端同时收到断开请求：客户端和服务端都会发送一个 ACK 确认对方的断开请求，并关闭连接。此时连接会立即断开，双方都不会处于等待状态。</li></ol><p>总之，在 TCP 连接中，任何一方发送断开请求后，都需要等待对方的确认，才能真正关闭连接。如果双方同时发出断开请求，则连接会立即断开，否则需要等待对方的确认。</p><h2 id="TCP可靠的原因是什么？依靠了哪些机制？"><a href="#TCP可靠的原因是什么？依靠了哪些机制？" class="headerlink" title="TCP可靠的原因是什么？依靠了哪些机制？"></a>TCP可靠的原因是什么？依靠了哪些机制？</h2><ol><li>应答机制：TCP在发送数据之后，会等待接收方的应答，以确认数据是否已经到达。如果接收方未能及时应答，TCP会进行重传，直到接收到应答为止。</li><li>序列号和确认应答：TCP会为每个数据包分配一个序列号，用于标识数据包的顺序和完整性。接收方在收到数据包后，会发送一个确认应答，其中包含期望接收的下一个序列号，用于告诉发送方哪些数据已经接收到了。</li><li>数据包校验和：TCP会对每个数据包进行校验和计算，以检测数据在传输过程中是否发生了损坏或丢失。如果校验和不匹配，TCP会进行重传，以确保数据的完整性。</li><li>滑动窗口：TCP使用滑动窗口机制来控制数据流量，以避免网络拥塞。发送方和接收方都有一个窗口大小，用于控制发送和接收的数据量。发送方会根据接收方的窗口大小来控制发送的数据量，以避免数据包的丢失或拥塞。</li></ol><h2 id="TCP在连接时会出现拥塞和粘包的问题，要怎么解决粘包的问题？"><a href="#TCP在连接时会出现拥塞和粘包的问题，要怎么解决粘包的问题？" class="headerlink" title="TCP在连接时会出现拥塞和粘包的问题，要怎么解决粘包的问题？"></a>TCP在连接时会出现拥塞和粘包的问题，要怎么解决粘包的问题？</h2><p>TCP协议在传输过程中会出现拥塞和粘包的问题，其中粘包问题是由于<strong>发送端发送的数据大小与接收端接收的数据大小不一致，导致多个数据包被粘在一起，从而造成接收端解析数据时出现错误</strong>。解决粘包问题的方法如下：</p><ol><li>使用消息定长：在发送端每次发送固定长度的数据，接收端每次接收相同长度的数据，这样就能避免粘包问题。</li><li>使用消息分隔符：在发送端每次发送数据时，在每个数据包的末尾添加一个特定的分隔符，接收端根据分隔符将数据包分开处理。</li><li>使用消息长度：在发送端每次发送数据时，在数据包的头部添加一个表示数据长度的字段，接收端根据字段的值来判断每个数据包的长度。</li><li>应用层协议处理：在应用层协议中定义数据格式和处理方式，例如HTTP协议中使用头部信息和分隔符来处理请求和响应数据。</li></ol><p>综上所述，通过使用消息定长、消息分隔符、消息长度和应用层协议处理等方法，可以有效解决TCP协议中的粘包问题。</p><h2 id="TCP的发送速度是如何得到控制的？"><a href="#TCP的发送速度是如何得到控制的？" class="headerlink" title="TCP的发送速度是如何得到控制的？"></a>TCP的发送速度是如何得到控制的？</h2><ol><li>慢启动算法（Slow Start）：发送方刚开始发送数据时，先发送一小部分数据，然后根据收到的确认消息逐渐增加发送的数据量，以逐渐探测网络的拥塞情况。</li><li>拥塞避免算法（Congestion Avoidance）：当发现网络拥塞时，发送方就会进入拥塞避免阶段，此时发送方会将发送窗口的大小限制在一个较小的值范围内，以避免网络拥塞。</li><li>快重传算法（Fast Retransmit）：当发送方连续发送多个数据包时，如果接收方收到其中一个数据包有丢失或损坏，就会立即发送一个重复确认消息，告诉发送方需要重传该数据包。发送方收到这个重复确认消息后，就会立即重传该数据包，而不是等到超时后再重传，从而加快数据传输速度。</li><li>快恢复算法（Fast Recovery）：当发送方收到重复确认消息时，就会进入快恢复阶段，此时发送方会将发送窗口的大小减半，并重传丢失的数据包，以避免网络拥塞。</li><li>拥塞控制算法（Congestion Control）：TCP中还有一种全局的拥塞控制算法，它通过计算网络的拥塞程度来动态调整发送方的发送速度，以避免网络拥塞。常用的拥塞控制算法有TCP Reno、TCP Vegas、TCP New Reno等。</li></ol><h2 id="在TCP中有keep-alive，Vue也有keep-alive，Http也有keep-alive，它们都是指什么？"><a href="#在TCP中有keep-alive，Vue也有keep-alive，Http也有keep-alive，它们都是指什么？" class="headerlink" title="在TCP中有keep-alive，Vue也有keep-alive，Http也有keep-alive，它们都是指什么？"></a>在TCP中有keep-alive，Vue也有keep-alive，Http也有keep-alive，它们都是指什么？</h2><ol><li>在TCP协议中，keep-alive是一种保持连接的机制，可以在客户端和服务器之间保持长时间的空闲连接。当客户端和服务器之间没有数据传输时，keep-alive机制会发送一些探测包来检测对方是否还活着，从而确保连接的有效性。这个机制在一些长连接场景下比较常见，例如HTTP长连接、FTP数据传输等。</li><li>在Vue中，keep-alive是一个组件，可以将动态组件进行缓存，以便在切换时可以保留它们的状态或避免重新渲染。这个组件在一些需要频繁切换的场景下比较常见，例如Tab切换、路由切换等。</li><li>在HTTP协议中，keep-alive是一种持久连接机制，可以在客户端和服务器之间保持一个TCP连接，从而避免在每个HTTP请求之间重新建立TCP连接。这个机制可以减少连接建立和关闭的开销，提高HTTP请求的效率，尤其是在一些高并发的Web应用中。</li></ol><h2 id="Http-keep-alive会引起其他的什么问题？"><a href="#Http-keep-alive会引起其他的什么问题？" class="headerlink" title="Http keep-alive会引起其他的什么问题？"></a>Http keep-alive会引起其他的什么问题？</h2><p>HTTP Keep-Alive 是一种 HTTP&#x2F;1.1 中的持久连接技术，可以使客户端和服务器在同一个 TCP 连接上发送多个 HTTP 请求和响应，从而减少连接建立和关闭的开销，提高性能。</p><p>然而，HTTP Keep-Alive 也可能引起以下问题：</p><ol><li>服务器资源占用：当客户端和服务器之间的连接不关闭时，服务器需要一直维护这个连接，占用一定的资源。如果同时有大量客户端连接服务器，会导致服务器资源占用过多，影响服务器的性能。</li><li>网络拥塞：当客户端和服务器之间的连接不关闭时，会占用网络带宽，可能导致网络拥塞，影响网络性能。</li><li>安全性问题：HTTP Keep-Alive 可能会导致安全性问题，例如，当客户端和服务器之间的连接不关闭时，可能会被黑客利用进行攻击，例如，利用长连接进行 DoS 攻击或者发送恶意请求等。</li></ol><p>因此，在使用 HTTP Keep-Alive 技术时，需要合理设置连接的超时时间，以及采取一定的安全措施，避免出现以上问题。</p><h2 id="不同域名指向同一个ip是否是同源的？"><a href="#不同域名指向同一个ip是否是同源的？" class="headerlink" title="不同域名指向同一个ip是否是同源的？"></a>不同域名指向同一个ip是否是同源的？</h2><p>不同域名指向同一个IP地址并不一定是同源的。同源策略是浏览器的一种安全策略，它是指只有当两个页面具有相同的协议、域名和端口号时，才允许这两个页面之间进行交互（例如访问彼此的DOM、Cookie等）。因此，如果两个页面的域名不同，即使它们指向同一个IP地址，也不会被认为是同源的。</p><p>但是，如果在同一个域名下使用不同的子域名（例如a.example.com和b.example.com）指向同一个IP地址，这种情况下它们被认为是同源的，因为它们具有相同的主域名。</p><p>总之，同源策略是根据协议、域名和端口号来判断是否允许跨域访问，而IP地址并不是同源策略的判断依据。</p><h2 id="Http1-0时候发起一个http请求会开启一个TCP连接吗？"><a href="#Http1-0时候发起一个http请求会开启一个TCP连接吗？" class="headerlink" title="Http1.0时候发起一个http请求会开启一个TCP连接吗？"></a>Http1.0时候发起一个http请求会开启一个TCP连接吗？</h2><p>在 HTTP&#x2F;1.0 中，每次发起 HTTP 请求都会建立一个新的 TCP 连接。这是因为 HTTP&#x2F;1.0 中每个请求和响应都是独立的，没有复用连接的机制。</p><p>在 HTTP&#x2F;1.0 中，每个 TCP 连接只能处理一个请求和响应，因此在处理多个请求和响应时，需要建立多个 TCP 连接。这样会导致建立和关闭连接的开销比较大，影响了 HTTP 请求的性能。</p><p>为了解决这个问题，HTTP&#x2F;1.1 引入了持久连接，允许在同一个 TCP 连接上发送多个请求和响应。这样可以减少建立和关闭连接的开销，提高 HTTP 请求的性能。</p><h2 id="一般的发Http请求的流程是什么样的？"><a href="#一般的发Http请求的流程是什么样的？" class="headerlink" title="一般的发Http请求的流程是什么样的？"></a>一般的发Http请求的流程是什么样的？</h2><p>一般的发 Http 请求的流程如下：</p><ol><li>构建请求：构建 HTTP 请求报文，包括请求方法、请求 URL、请求头以及请求体等信息。</li><li>建立连接：通过 TCP 协议与服务器建立连接，可以使用 HTTP&#x2F;1.0 中的短连接或者 HTTP&#x2F;1.1 中的长连接。</li><li>发送请求：将构建好的 HTTP 请求报文发送给服务器。</li><li>接收响应：等待服务器返回响应报文，接收响应数据。</li><li>处理响应：对服务器返回的响应数据进行处理，包括状态码、响应头以及响应体等信息。</li><li>断开连接：根据 HTTP&#x2F;1.0 或者 HTTP&#x2F;1.1 的规定，关闭 TCP 连接。</li></ol><p>其中，建立连接和断开连接的过程是比较耗时的，影响了 HTTP 请求的性能。因此，为了提高 HTTP 请求的性能，可以使用 HTTP&#x2F;1.1 中的持久连接或者 HTTP&#x2F;2 中的多路复用等技术。</p><h2 id="浏览器中输入网址并发起网络请求后都经历了什么？⭐"><a href="#浏览器中输入网址并发起网络请求后都经历了什么？⭐" class="headerlink" title="浏览器中输入网址并发起网络请求后都经历了什么？⭐"></a>浏览器中输入网址并发起网络请求后都经历了什么？⭐</h2><ol><li>首先判断输入的内容是否为合法的域名，如果不是则作为关键字交给搜索引擎进行处理；如果域名中有非法字符则进行转义。</li><li>首先判断浏览器中是否有所需资源的缓存，如果有则直接使用，否则进行DNS查询获取域名对应的IP地址。</li><li>DNS查询<ol><li>判断本地的DNS缓存中是否有该IP地址，如果命中则返回</li><li>如果还是没有命中，则将域名发送到本地域名服务器，本地域名服务器采用递归查询自己的DNS服务器，查找成功则返回。</li><li>如果本地域名服务器的DNS缓存没有命中，则向上级域名服务器进行迭代查询<ul><li>首先本地域名服务器向根域名服务器进行请求，获取顶级域名服务器的地址给本地服务器。</li><li>本地域名服务器拿到这个顶级域名服务器后就想起发送请求，获取权威域名服务器的地址。</li><li>本地域名服务器向权威域名服务器发送请求，获取域名对应的IP地址。</li></ul></li><li>本地域名服务器将得到的IP地址发送给操作系统，同时自己将IP地址缓存起来。</li><li>操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来。</li><li>至此，浏览器得到了域名对应的IP地址，并将IP地址缓存起来。</li></ol></li><li>通过IP地址与本地的子网掩码相与，判断是否与请求主机在一个子网中，如果在一个子网中，则使用ARP协议获取目标主机的MAC地址，如果不在一个子网中，那么请求应该转发给网关，由它代为转发，此时同样可以通过ARP协议获取网关MAC地址，此时目的主机的MAC地址应该为网关地址。</li><li>进行TCP的三次握手</li><li>进行HTTPS握手</li><li><strong>返回数据</strong>：将网页请求发送至服务器端，服务器端返回一个html文件作为响应。浏览器接受响应后，开始对html文件进行解析并开始页面的渲染过程。</li><li><strong>页面渲染</strong>：根据html文件构建DOM树，根据解析到的css构建CSSOM树，如果遇到script标签，则判断有无async和defer属性，否则script的加载和执行会造成页面渲染的阻塞。当DOM树和CSSOM树建立好后，根据他们构建渲染树。渲染树构建好后，根据渲染树进行布局，然后使用浏览器的UI接口对页面进行绘制。此时整个页面就显示出来了。</li><li>TCP四次挥手</li></ol><h2 id="数据-HTML、CSS和JS等资源-返回到浏览器后的详细渲染过程？"><a href="#数据-HTML、CSS和JS等资源-返回到浏览器后的详细渲染过程？" class="headerlink" title="数据(HTML、CSS和JS等资源)返回到浏览器后的详细渲染过程？"></a>数据(<code>HTML</code>、<code>CSS</code>和<code>JS</code>等资源)返回到浏览器后的详细渲染过程？</h2><p>当浏览器收到HTML、CSS和JS等资源后，会进行以下渲染过程：</p><ol><li>解析HTML：浏览器会根据HTML文档的结构解析出文档树（DOM树），同时也会解析出CSS文档的样式规则（CSSOM树）。</li><li>构建渲染树：浏览器会将DOM树和CSSOM树结合起来构建渲染树（Render Tree），渲染树只包含需要显示的节点和样式信息。</li><li>布局：浏览器会根据渲染树中每个节点的布局信息（包括位置、大小等）计算出每个节点在屏幕上的位置。</li><li>绘制：浏览器会将渲染树中的每个节点绘制到屏幕上，形成最终的页面展示效果。</li><li>JS执行：如果HTML中包含了JS代码，浏览器会执行这些代码，可能会修改DOM树、CSSOM树以及渲染树等。</li></ol><h2 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>Cache-Control &#x2F; Expires</p><p>expires <code>http1.0</code>控制网页缓存的字段，其值为服务器返回该请求结果的到期时间，即再次发送请求，如果客户端的时间小于expires的值时，直接使用缓存结果</p><p>cache-control(优先级更大) http1.1中控制网页缓存，是最重要的规则</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>Etag If-None-Match &#x2F; Last-Midified If-Midified-Since</p><p><code>Last-Modified / If-Modified-Since</code> 和 <code>Etag / If-None-Match</code> (后者优先级更高)</p><p>Last-Modified 服务器响应请求时，返回该文件资源在服务器内最后被修改的时间</p><p>If-Modified-Since 客户端再次发起请求时，携带上次请求返回的Last-Modified值，通过此字段告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据此字段值与该资源在服务器的最后被修改的时间做对比，若服务器的资源最后被修改的时间大于If-Modified-Since字段值，则重新返回资源，状态码为200；否则返回304，代表资源无更新，可继续使用缓存文件</p><p>Etag 是服务区响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)</p><p>If-None-Match 服务器再次发起请求时，携带上次请求返回的唯一标识Etag，通过此字段告诉服务器该资源上次请求返回的唯一标识，服务器收到该请求后，发现请求头中含有If-None-Match的字段与该资源在服务器的Etag值进行比对，<strong>一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码200</strong></p><h2 id="HTTP中常见的请求头有哪些？"><a href="#HTTP中常见的请求头有哪些？" class="headerlink" title="HTTP中常见的请求头有哪些？"></a>HTTP中常见的请求头有哪些？</h2><ol><li><strong>Accept</strong>：指定客户端接受的MIME类型。如果服务器无法返回指定类型的数据，则返回406错误状态码。</li><li>User-Agent：指定请求的客户端代理名称和版本号。这个请求头可以被用于浏览器嗅探，从而让服务器返回针对特定浏览器的响应。</li><li><strong>Host</strong>：指定请求的主机名，包括端口号。在多虚拟主机环境下，服务器可以通过该头部来判断客户端所请求的主机名和端口号。</li><li>Accept-Language：指定客户端语言环境，告诉服务器可以接受哪些语言的资源。</li><li>Accept-Encoding：指定客户端可以支持的内容编码方式，如Gzip、Deflate等，告诉服务器哪种压缩格式可以被客户端处理。</li><li><strong>Connection</strong>：控制HTTP连接的行为，如关闭连接、保持连接等。</li><li><strong>If-Modified-Since</strong>：告诉服务器如果请求资源自指定日期以来没有被修改过，那么只返回304状态码，不返回资源本身，减少了网络数据传输的开销。</li><li>Authorization：用于客户端想要访问需要授权的资源，包含授权类型和凭证信息（通常是用户名密码）。</li><li><strong>Cache-Control</strong>：用于控制客户端或缓存是否可以缓存该响应，可以通过设置max-age和no-store等参数来控制缓存行为。</li><li><strong>Cookie</strong>：用于在客户端和服务端之间传递状态信息，可以通过设置cookie来实现“记住我”等功能。</li><li>Range：指定请求的范围，可以用于断点续传等场景。</li><li><strong>Content-Type</strong>：指定请求体的MIME类型，在POST请求中常被用到。</li><li><strong>Content-Length</strong>：指定请求体的长度，用于解析请求体。</li><li>Transfer-Encoding：指定分块传输编码方式，可以被用于实现长连接。</li></ol><h2 id="国内网站一般用的是哪个版本的http协议"><a href="#国内网站一般用的是哪个版本的http协议" class="headerlink" title="国内网站一般用的是哪个版本的http协议?"></a>国内网站一般用的是哪个版本的http协议?</h2><p>目前主流还是http1.1</p><h2 id="HTTP和HTTPS的区别？⭐"><a href="#HTTP和HTTPS的区别？⭐" class="headerlink" title="HTTP和HTTPS的区别？⭐"></a>HTTP和HTTPS的区别？⭐</h2><ul><li>HTTP是超文本传输协议，采用明文传输，而HTTPS采用SSL进行了数据加密，保证了数据的安全性</li><li>HTTP使用的是80端口，HTTPS是443端口</li><li>HTTPS需要数字证书，用于验证服务器身份和保证通信安全性</li><li>HTTPS加密和解密过程需要消耗更多计算资源，更加消耗性能</li><li>HTTPS的数据不容易被存储，因为每个请求和响应都需要加密和解密，而HTTP的数据易于被存储，可以提高访问速度。</li></ul><h2 id="HTTPS的加密过程？⭐"><a href="#HTTPS的加密过程？⭐" class="headerlink" title="HTTPS的加密过程？⭐"></a>HTTPS的加密过程？⭐</h2><ol><li>客户端向服务器发送HTTPS请求。请求中包含了客户端支持的加密算法列表和随机数（ClientHello）。</li><li>服务器从客户端发送的加密算法列表中选择一种加密算法，并向客户端发送服务器的证书，证书中包含了服务器的公钥和证书的签名（ServerHello）。</li><li>客户端验证服务器的证书是否有效，包括证书是否过期、证书是否被吊销、证书中的域名是否和服务器的域名匹配等。如果验证通过，客户端生成一个随机数，并使用服务器的公钥加密这个随机数（ClientKeyExchange）。</li><li>服务器使用自己的私钥解密客户端发送的随机数，并使用这个随机数生成对称密钥（ServerKeyExchange）。</li><li>客户端和服务器使用这个对称密钥进行通信，将通信内容加密后发送给对方。</li></ol><p>在这个过程中，客户端和服务器使用非对称加密算法（如RSA）来完成证书的验证和随机数的加密，使用对称加密算法（如AES）来加密通信内容。这样可以保证通信过程中传输的数据是加密的，同时也保证了通信双方的身份和数据的完整性，防止数据被篡改或窃取。</p><h2 id="TLS是如何保证可靠传输的？"><a href="#TLS是如何保证可靠传输的？" class="headerlink" title="TLS是如何保证可靠传输的？"></a>TLS是如何保证可靠传输的？</h2><blockquote><p>TLS（Transport Layer Security）是一种加密协议，用于保护网络通信中的数据安全性和完整性。它是SSL（Secure Sockets Layer）协议的继任者。</p></blockquote><p>TLS使用公钥加密技术和数字证书来确保通信的安全性。它采用了对称加密和非对称加密的组合方式来保护通信的内容和身份验证。通信双方首先通过握手协议交换密钥，然后使用这些密钥对数据进行加密和解密。</p><ol><li>加密通信：TLS使用对称加密算法来加密通信内容，保护数据的机密性。</li><li>数据完整性：TLS使用消息认证码（MAC）来保证数据的完整性，防止数据被篡改或损坏。</li><li>身份验证：TLS使用数字证书来进行身份验证，确保通信双方的身份是合法的。</li><li>防止重放攻击：TLS使用时间戳和随机数来防止重放攻击，确保通信的实时性。</li></ol><h2 id="HTTPS中的数字证书是哪一方发送的？"><a href="#HTTPS中的数字证书是哪一方发送的？" class="headerlink" title="HTTPS中的数字证书是哪一方发送的？"></a>HTTPS中的数字证书是哪一方发送的？</h2><p>在HTTPS通信中，数字证书是由服务器端发送给客户端的。</p><p>当客户端首次访问使用HTTPS协议的网站时，服务器会向客户端发送数字证书。客户端接收到数字证书后，会进行数字证书的验证过程，验证证书是否有效、证书颁发机构是否可信等。如果数字证书验证通过，客户端会生成会话密钥并使用证书中的公钥对该密钥进行加密，然后将加密后的密钥发送给服务器端。服务器端使用自己的私钥对密钥进行解密，然后双方就可以使用该密钥进行加密通信。</p><p>因此，在HTTPS协议中，数字证书是由服务器端发送给客户端的，客户端通过验证数字证书的有效性，并使用其公钥加密会话密钥，从而确保双方的通信是加密的、安全的。</p><h2 id="Http的报文格式？"><a href="#Http的报文格式？" class="headerlink" title="Http的报文格式？"></a>Http的报文格式？</h2><p>HTTP（超文本传输协议）的报文格式分为请求报文和响应报文两种类型。</p><p><strong>请求报文格式</strong></p><p>请求报文由三个部分组成：请求行、请求头和请求体。</p><p>请求行格式：METHOD URL HTTP&#x2F;版本号</p><p>例如：GET &#x2F;index.html HTTP&#x2F;1.1</p><p>请求头格式：键值对，每个键值对用冒号分隔，每个键值对占一行，最后一行用空行表示请求头结束。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Host</span>: www.<span class="hljs-property">example</span>.<span class="hljs-property">com</span> <span class="hljs-title class_">User</span>-<span class="hljs-title class_">Agent</span>: <span class="hljs-title class_">Mozilla</span>/<span class="hljs-number">5.0</span> (<span class="hljs-title class_">Windows</span> <span class="hljs-variable constant_">NT</span> <span class="hljs-number">10.0</span>; <span class="hljs-title class_">Win64</span>; x64) <span class="hljs-title class_">AppleWebKit</span>/<span class="hljs-number">537.36</span> (<span class="hljs-variable constant_">KHTML</span>, like <span class="hljs-title class_">Gecko</span>) <span class="hljs-title class_">Chrome</span>/<span class="hljs-number">58.0</span><span class="hljs-number">.3029</span><span class="hljs-number">.110</span> <span class="hljs-title class_">Safari</span>/<span class="hljs-number">537.36</span> <span class="hljs-title class_">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0.9</span>,image/webp,*<span class="hljs-comment">/*;q=0.8</span><br></code></pre></td></tr></table></figure><p>请求体格式：用于传输数据，可以为空。</p><p><strong>响应报文格式</strong></p><p>响应报文也由三个部分组成：状态行、响应头和响应体。</p><p>状态行格式：HTTP&#x2F;版本号 状态码 状态码的原因短语</p><p>例如：HTTP&#x2F;1.1 200 OK</p><p>响应头格式：键值对，每个键值对用冒号分隔，每个键值对占一行，最后一行用空行表示响应头结束。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Type</span>: text/html; charset=utf-<span class="hljs-number">8</span> <span class="hljs-title class_">Server</span>: <span class="hljs-title class_">Apache</span>/<span class="hljs-number">2.4</span><span class="hljs-number">.18</span> (<span class="hljs-title class_">Ubuntu</span>) <span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Length</span>: <span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><p>响应体格式：用于传输数据，可以为空。</p><h2 id="HTTP2-0更新了哪些内容？"><a href="#HTTP2-0更新了哪些内容？" class="headerlink" title="HTTP2.0更新了哪些内容？"></a>HTTP2.0更新了哪些内容？</h2><ol><li>二进制格式：HTTP&#x2F;2在传输数据时采用二进制格式，而非HTTP&#x2F;1.x的文本格式，这使得解析和传输更加高效。</li><li>多路复用：HTTP&#x2F;2允许客户端和服务器之间同时保持多个请求和响应连接，这使得客户端可以发送多个请求，而无需等待每个响应，从而提高了数据传输的效率。</li><li>头部压缩：HTTP&#x2F;2使用HPACK算法对头部字段进行压缩，减少了头部发送的数据量，提高了传输速度。</li><li>服务器推送：HTTP&#x2F;2允许服务器在客户端请求之前发送额外的响应数据，从而可以提前获取客户端需要的资源并缓存起来，减少了客户端请求的次数和等待时间。</li><li>流量控制：HTTP&#x2F;2允许客户端和服务器之间进行流量控制，可以根据实际情况来分配网络带宽，以避免网络拥塞和延迟。</li></ol><h2 id="HTTP2-0头部压缩的比例是怎样的？"><a href="#HTTP2-0头部压缩的比例是怎样的？" class="headerlink" title="HTTP2.0头部压缩的比例是怎样的？"></a>HTTP2.0头部压缩的比例是怎样的？</h2><p>HTTP&#x2F;2使用HPACK算法进行头部压缩，可以将HTTP头部字段中的冗余数据删除，从而减少传输的数据量，提高传输速度。</p><p>具体来说，HTTP&#x2F;2的头部压缩可以做到80%~90%的压缩比率，这对移动网络等带宽有限的环境来说非常有利。因为HTTP头部中的很多字段是重复的，并且头部压缩只需要在建立连接时进行，减少了后续请求的数据量，同时还减少了数据传输过程中的网络阻塞。</p><p>此外，虽然HTTP&#x2F;2使用了头部压缩技术，在传输效率上得到了极大提高，但是在实际使用时，掌握合适的压缩策略非常重要，否则就会带来安全问题，比如攻击者通过伪造头部字段来欺骗服务器，破坏数据传输的完整性。</p><h2 id="Http3-0更新了什么？"><a href="#Http3-0更新了什么？" class="headerlink" title="Http3.0更新了什么？"></a>Http3.0更新了什么？</h2><ul><li><p><strong>使用UDP代替TCP，不需要复杂的创建连接和关闭连接的成本</strong></p></li><li><p><strong>基于传输层的多路复用，避免队头阻塞</strong></p></li><li><p><strong>向前纠错</strong> (每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传)</p><p>向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间（包括确认数据包丢失、请求重传、等待新数据包等步骤的时间消耗）。</p></li><li><p><strong>加密认证的报文</strong></p><p>TCP协议头部没有经过任何加密和认证，所以在传输的过程中很容易被中间网络设备篡改、注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也可能是主动攻击。</p><p>但是QUIC的packet除了个别报文比如说PUBLIC_RESET和CHLO，所有的报文头部都是经过认证的，报文体都是经过加密的。</p><p>这样只要对QUIC报文进行任何修改，接收端都能够及时发现，有效地降低了安全风险。</p></li></ul><p>参考：<a href="https://limeii.github.io/2019/06/http2-http3/">Http3.0更新了什么</a></p><h2 id="Http3用UDP如何避免队头阻塞"><a href="#Http3用UDP如何避免队头阻塞" class="headerlink" title="Http3用UDP如何避免队头阻塞?"></a>Http3用UDP如何避免队头阻塞?</h2><p>HTTP&#x2F;3使用的是基于UDP协议的QUIC传输协议，相对于传统TCP协议，QUIC可以避免队头阻塞（head-of-line blocking）的问题。</p><p>队头阻塞问题指的是当一个数据包在网络传输中出现丢包或延迟时，后续的数据包被迫等待，导致整个数据传输被阻塞。这种情况在TCP协议中比较常见。</p><p>而QUIC协议可以通过以下措施来避免队头阻塞问题：</p><ol><li>使用基于多路复用的流控制（flow control）技术，将数据拆分为多个小型帧，对于每个帧进行单独的传输和确认，从而避免了数据包因为前面的数据包被丢弃而被阻塞的情况。</li><li>使用QUIC协议的拥塞控制机制，对网络拥塞做出反应，根据网络负载的情况调整传输速率，避免了TCP协议中因为网络拥塞而导致的队头阻塞。</li></ol><p>总的来说，HTTP&#x2F;3通过QUIC协议的流控制和拥塞控制机制，有效地避免了队头阻塞问题，提升了网络传输的性能和稳定性。</p><h2 id="超时重传机制的原理？"><a href="#超时重传机制的原理？" class="headerlink" title="超时重传机制的原理？"></a>超时重传机制的原理？</h2><blockquote><p>超时重传机制是指在网络通信中，当发送方发送数据后，如果没有收到确认应答或者收到了错误的应答，就会触发超时重传机制，重新发送数据。</p></blockquote><ol><li>发送数据：发送方将数据发送给接收方，并启动计时器，等待接收方的应答。</li><li>接收应答：接收方接收到数据后，向发送方发送应答信息，表示已经收到数据。</li><li>超时计时器：发送方启动一个计时器，等待接收方的应答。如果在规定的时间内没有收到应答，就认为数据丢失或超时，触发超时重传机制。</li><li>重传数据：发送方重新发送数据，等待接收方的应答。</li><li>停止计时器：当发送方收到接收方的应答后，停止计时器，表示数据已经成功发送。如果在规定的时间内没有收到应答，就会重新触发超时重传机制。</li></ol><h2 id="针对弱网环境如何从Http的角度去做前端优化？"><a href="#针对弱网环境如何从Http的角度去做前端优化？" class="headerlink" title="针对弱网环境如何从Http的角度去做前端优化？"></a>针对弱网环境如何从Http的角度去做前端优化？</h2><ul><li>使用CDN加速，避免弱网环境下资源加载过慢</li><li>使用HTTP Cache、Service Worker和Cache Storage API等技术进行缓存资源，避免重复请求</li><li>对于移动端，可以使用SSR、CSR、预渲染等技术，提升网页首帧优化，从而优化白屏问题，提升用户体验</li></ul><h2 id="浏览器的存储方案？"><a href="#浏览器的存储方案？" class="headerlink" title="浏览器的存储方案？"></a>浏览器的存储方案？</h2><p>Cookie</p><p>Cookie 是在客户端存储的文本文件，用于存储网站的状态信息，如用户登录状态、购物车内容等。它的大小有一定限制，一般为 4KB 左右，并且会在过期时间之后自动删除。</p><p>Web Storage</p><p>Web Storage 包括 localStorage 和 sessionStorage。localStorage 存储的数据可以在同一域名下的所有页面共享，且存储容量很大，一般为 5 MB 左右；而 sessionStorage 存储的数据只能在当前会话中共享，关闭浏览器后会自动删除。</p><p>IndexedDB</p><p>IndexedDB 是一种本地的数据库，用于存储大量结构化数据，支持事务和索引功能，可进行高效的数据查询和操作。</p><p>Cache Storage</p><p>Cache Storage 用于存储网络请求的响应，能够提高 Web 应用的加载速度和并发性能。它支持缓存的添加、查询、删除、更新等操作。</p><p>File API</p><p>File API 允许 Web 应用访问本地文件系统，可以在本地文件系统中读取和写入文件，也可以将文件发送到服务器。但是，File API 只能在获得用户授权的情况下使用，且不同浏览器的实现存在差异。</p><h2 id="cookie的特点？"><a href="#cookie的特点？" class="headerlink" title="cookie的特点？"></a>cookie的特点？</h2><p>Cookie是一种存储在客户端的小型文本文件，由一个名称、一个值和其他几个用于控制Cookie有效期<br>安全性、使用范围的可选属性组成。Cookie的特点如下：</p><ul><li>存储位置: Cookie存储在浏览器里面。</li><li>存储大小: Cookie的大小在4KB左右，数量在50个左右。</li><li>存储时间: Cookie的存储时间非常灵活。</li><li>安全性: 通过加密和安全传输技术 (SSL) ，减少Cookie被破解的可能性。</li></ul><h2 id="cookie有哪些属性？"><a href="#cookie有哪些属性？" class="headerlink" title="cookie有哪些属性？"></a>cookie有哪些属性？</h2><ul><li>Name: cookie的名称。</li><li>Value: cookie的值。</li><li>Domain: cookie所属的域名</li><li>Path: cookie所属的路径。</li><li>Expires&#x2F;Max-age: cookie的过期时间或存活时间。</li><li>Size: cookie的大小。</li><li>HttpOnly: 设置为true，表示只能通过HTTP或HTTPS访问，不能通过JavaScript访问。</li><li>Secure: 设置为true，表示只能通过HTTPS访问。</li><li>SameSite: 设置为Strict，表示浏览器不会在跨站点请求中发送Cookie；设置为Lax，表示浏览器只会在第三方站点的GET请求中发送Cookie；设置为None，表示浏览器会在所有跨站点请求中发送Cookie。</li><li>Priority: 设置为High，表示浏览器会优先发送该Cookie。</li></ul><h2 id="cookie和session的区别？"><a href="#cookie和session的区别？" class="headerlink" title="cookie和session的区别？"></a>cookie和session的区别？</h2><ul><li>Cookie数据存放在客户的浏览器上，session数据放在服务器上。</li><li>Cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，如果主要考虑到安全应当使用Session。</li><li>Session会在一定时间内保存在服务器上。</li><li>Cookie会在一定时间内保存在客户端上。</li><li>Session可以存储任何类型的对象，而Cookie只能存储字符串类型的数据.</li><li>Session依赖于Cookie，即Session ID存储在Cookie中。</li></ul><h2 id="常见的HTTP状态码及其含义？"><a href="#常见的HTTP状态码及其含义？" class="headerlink" title="常见的HTTP状态码及其含义？"></a>常见的HTTP状态码及其含义？</h2><p>1xx 接收到请求并继续(不常见)</p><p>2xx 请求成功</p><ul><li><p>200 请求成功</p></li><li><p>204 请求已处理但是没有返回内容</p></li><li><p>206 客户端进行了范围请求，服务器端执行了这部分GET请求，响应报文中包含由Content-Range指定范围的实体内容</p></li></ul><p>3xx 重定向状态码</p><ul><li><p>301 永久重定向</p></li><li><p>302 临时重定向</p></li><li><p>303 所请求的资源存在另一个URI，应使用GET方法定向获取请求资源</p></li><li><p>304 缓存中有需要的数据，无须进行请求</p></li><li><p>307 临时重定向，不会从POST变成GET</p></li></ul><p>4xx 客户端错误</p><ul><li><p>400 请求报文存在语法错误</p></li><li><p>401 请求须通过HTTP认证</p></li><li><p>403 请求资源被服务器拒绝</p></li><li><p>404 找不到资源</p></li><li><p>405 方法被识别但禁止使用</p></li></ul><p>5xx 服务器端发生错误</p><ul><li><p>500 服务器端在执行请求时发生错误</p></li><li><p>502 服务器接收到的响应无效</p></li><li><p>503 服务器暂时超负载or停机维护</p></li><li><p>504 超时</p></li></ul><h2 id="302状态码是什么意思？和301有什么区别？⭐"><a href="#302状态码是什么意思？和301有什么区别？⭐" class="headerlink" title="302状态码是什么意思？和301有什么区别？⭐"></a>302状态码是什么意思？和301有什么区别？⭐</h2><p>302表示临时重定向，表示所请求的资源临时转移到了另一个URL上面。</p><p>301状态码表示永久重定向，告诉客户端所请求的资源已经被永久移动到了新的位置，以后应该使用新的URL访问，它会在响应头的Location字段中存储新的URL，浏览器收到后会对新的URL进行缓存，在以后的请求中会自动使用新的URL而不是旧的URL。</p><p>302状态码表示临时重定向，告诉客户端所请求的资源已经被临时移动到了新的位置，但以后还是应该使用原来的URL访问，浏览器在以后的请求中仍然会使用原来的URL，需要再次请求服务器获取新的URL。</p><h2 id="在触发301状态码的时候，浏览器会把更新的url存放在何处？"><a href="#在触发301状态码的时候，浏览器会把更新的url存放在何处？" class="headerlink" title="在触发301状态码的时候，浏览器会把更新的url存放在何处？"></a>在触发301状态码的时候，浏览器会把更新的url存放在何处？</h2><p>当浏览器收到301状态码时，会把更新的URL存放在响应头的Location字段中，浏览器会自动重定向到该URL，301状态码表示永久性转移，所以浏览器会记住这个URL，下次访问该URL，浏览器会直接访问新的URL，不再请求旧的URL。</p><h2 id="返回304状态码的时候响应体里的内容？"><a href="#返回304状态码的时候响应体里的内容？" class="headerlink" title="返回304状态码的时候响应体里的内容？"></a>返回304状态码的时候响应体里的内容？</h2><p>返回304状态码时，响应体是没有内容的，因为浏览器可以直接从本地缓存中获取资源。当请求命中缓存，且服务器判断资源没有更新时，就会返回304响应状态码，告知浏览器可以使用本地缓存，而不需要重新下载资源。此时服务器只需在响应头中包含<code>ETag</code>或<code>Last-Modified</code>等响应头字段，告诉浏览器缓存的版本信息。因此，304响应状态码不会包含响应体，只会包含响应头。</p><h2 id="命中本地强缓存的时候状态码是多少？"><a href="#命中本地强缓存的时候状态码是多少？" class="headerlink" title="命中本地强缓存的时候状态码是多少？"></a>命中本地强缓存的时候状态码是多少？</h2><p>当命中本地强缓存时，状态码是<strong>200 OK</strong>。因为浏览器直接从本地缓存中获取了资源，并且确认缓存未过期或者协商缓存未失效，因此服务器不需要再次返回资源，而是直接返回200状态码表示请求成功。此时响应头中会包含相应的缓存控制信息，例如<code>Cache-Control</code>、<code>Expires</code>等字段，用来告诉浏览器如何缓存该资源以及缓存有效期等信息。</p><h2 id="强缓存的资源存储在本地的什么位置？"><a href="#强缓存的资源存储在本地的什么位置？" class="headerlink" title="强缓存的资源存储在本地的什么位置？"></a>强缓存的资源存储在本地的什么位置？</h2><p>浏览器会将强缓存的资源存储在浏览器的缓存中，也就是本地磁盘或内存中。具体来说，对于不同类型的资源，浏览器对其的缓存位置可能有所不同：</p><ol><li>对于HTML文档，通常会被缓存到内存中，因为HTML文档相对较小，频繁的请求也不会导致内存占用过高。</li><li>对于CSS、JavaScript、图片等静态资源，则会被缓存到本地磁盘中，因为这些资源相对较大，频繁加载会占用大量内存，并且缓存在本地磁盘中可以加快下一次访问时的加载速度。</li></ol><p>但无论是缓存到内存还是本地磁盘中，浏览器都会根据缓存策略规则来管理缓存，并在缓存过期或失效时进行更新或重新加载。</p><h2 id="Etag里面的文本结构是怎样的？"><a href="#Etag里面的文本结构是怎样的？" class="headerlink" title="Etag里面的文本结构是怎样的？"></a>Etag里面的文本结构是怎样的？</h2><p>Etag（实体标记）是 HTTP 协议头中的一种机制，用于<strong>标识资源是否被修改过</strong>。Etag 的文本结构通常是<strong>一个由双引号包围的字符串</strong>，如下所示：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">ETag:</span> <span class="hljs-string">&quot;686897696a7c876b7e&quot;</span><br></code></pre></td></tr></table></figure><p><strong><code>ETag</code>没有指定生成值的方法。通常，使用内容的散列，最后修改时间戳的散列或仅修订版本号。</strong></p><p>实体标记通常是<strong>由服务器生成的标识符</strong>，而这个标识符可以根据服务器的算法和资源内容计算出来，只有当资源内容发生改变时，Etag 值才会发生变化。</p><p>当客户端请求同一资源时，客户端会向服务器发送 “If-None-Match” 的请求头，这个请求头包含上次请求获得的 Etag 值，如果服务器发现该资源的 Etag 值仍然匹配，则会返回 HTTP 304 Not Modified 状态码，告诉客户端可以直接使用缓存中的资源。如果 Etag 值不匹配，则服务器会返回新的资源给客户端。</p><p>因此 Etag 的作用是<strong>减少了无效的带宽消耗，增加了缓存的命中率</strong>。</p><h2 id="如果HTTP响应头中ETag值改变了，是否意味着文件内容一定已经更改？"><a href="#如果HTTP响应头中ETag值改变了，是否意味着文件内容一定已经更改？" class="headerlink" title="如果HTTP响应头中ETag值改变了，是否意味着文件内容一定已经更改？"></a>如果HTTP响应头中ETag值改变了，是否意味着文件内容一定已经更改？</h2><p>不一定。虽然 ETag 值是用于标识 HTTP 协议中一个特定的资源的版本号，但它不一定是由文件内容决定的，而是由服务器生成的。服务器可以采用不同的算法生成 ETag 值，例如将文件最后修改时间和文件大小作为参数来计算 ETag 值，而并没有考虑文件内容是否有变化。</p><p>因此，如果服务器端修改了 ETag 值，不一定意味着文件内容一定已经更改。在实际应用中，更准确的判断资源是否改变的方法是将 ETag 值与实际文件内容的哈希值比较。只有当 ETag 值与实际哈希值不一致时，才能判断文件内容发生了变更。</p><h2 id="GET请求在body设置数据是否会传递？"><a href="#GET请求在body设置数据是否会传递？" class="headerlink" title="GET请求在body设置数据是否会传递？"></a>GET请求在body设置数据是否会传递？</h2><p>按照HTTP协议规范，GET请求的参数应该放在URL的查询参数部分，而不是请求体中。因此，即使在请求体中设置了数据，这些数据也不会被传递，而是会被忽略。</p><p>需要注意的是，虽然不建议在GET请求中使用请求体来传递参数，但是HTTP协议规范并未禁止这种行为。某些特定的服务端框架和应用程序可能会对此进行支持，但是这种行为并不常见，因此不推荐使用。</p><h2 id="使用第三方富文本编译器可能会遇到哪些安全问题？"><a href="#使用第三方富文本编译器可能会遇到哪些安全问题？" class="headerlink" title="使用第三方富文本编译器可能会遇到哪些安全问题？"></a>使用第三方富文本编译器可能会遇到哪些安全问题？</h2><p>使用第三方富文本编辑器时可能会存在以下安全问题：</p><ol><li>跨站脚本攻击(XSS)：富文本编辑器中允许用户对文本进行格式化、插入图片或其他媒体，而这些内容很容易被植入恶意脚本，从而造成XSS攻击。</li><li>文件上传漏洞：富文本编辑器中可以上传图片或其他媒体文件，如果没有进行严格的文件类型、大小、后缀等限制，攻击者就可以上传恶意文件到服务器上，从而控制整个系统。</li><li>恶意插件：一些恶意插件可能会通过富文本编辑器中的API和DOM接口，访问用户的浏览器、cookie等敏感信息。</li><li>版权问题：某些富文本编辑器可能没有经过合法授权，使用这些编辑器就可能会涉及到版权问题。</li></ol><p>为了保障安全，使用第三方富文本编辑器时应该注意以下几点：</p><ol><li>选择可信赖的编辑器：使用知名厂商或有良好口碑的第三方富文本编辑器，可以降低发生安全问题的概率。</li><li>进行数据过滤：在服务端对用户上传的内容进行过滤和验证，处理恶意标签、注入代码等攻击。</li><li>对上传文件进行严格限制：在服务端对上传文件的类型、大小、后缀等进行限制，并进行文件内容安全检查。</li><li>最小化API权限：在使用富文本编辑器的API和DOM接口时，尽可能限制其权限，减少恶意插件访问浏览器等敏感信息的风险。</li><li>授权审查：确保所采用的富文本编辑器源代码是来自授权渠道或已购买授权，以避免版权问题。</li></ol><h2 id="对XSS攻击的理解？"><a href="#对XSS攻击的理解？" class="headerlink" title="对XSS攻击的理解？"></a>对XSS攻击的理解？</h2><p>XSS（Cross Site Scripting）攻击，即跨站脚本攻击，是一种常见的Web攻击方式之一，其特点就是攻击者通过在目标网站上注入恶意脚本，使得受害者用户在访问该网站时执行攻击者所编写的恶意脚本，从而达到攻击的目的。</p><p>XSS攻击的危害有以下几点：</p><ol><li>盗取用户隐私数据：攻击者可以使用恶意脚本窃取用户密码、会话Cookie等隐私数据，从而进一步攻击用户的账号和个人信息。</li><li>篡改页面内容：攻击者可以通过在页面中注入恶意脚本来实现篡改页面内容，包括添加广告、假冒登录页面、弹出广告窗口等。</li><li>利用网站漏洞：攻击者可以利用漏洞进行攻击，比如通过XSS攻击利用网站上的漏洞向其他网站发送请求，从而在不知情的情况下进行攻击。</li><li>DDos攻击：攻击者可以利用XSS漏洞进行DDos攻击，向目标网站发送大量请求，从而占用网站的带宽以及服务器资源。</li></ol><p>为了防范XSS攻击，我们可以采取以下措施：</p><ol><li>对用户输入的数据进行过滤和验证，避免恶意脚本的注入。</li><li>对敏感信息进行加密传输和存储，避免信息泄露。</li><li>使用HttpOnly和secure标签设置Cookie属性，在一定程度上防止Cookie被窃取和篡改。</li><li>对Web应用程序进行漏洞扫描，及时发现漏洞并进行修复。</li><li>对网站访问日志进行监控和分析，及时发现异常IP和嫌疑用户。</li></ol><h2 id="什么是CDN-内容分发网络-？"><a href="#什么是CDN-内容分发网络-？" class="headerlink" title="什么是CDN (内容分发网络) ？"></a>什么是CDN (内容分发网络) ？</h2><p>CDN即内容分发网络（Content Delivery Network），是一种<strong>利用多台服务器分别支持在线业务的网络架构</strong>，也可以理解为一种加速数据传输的技术服务。</p><p>CDN的基本原理是，将网站的内容（如文本、图片、视频等）复制到分布在全国乃至全球各地的CDN节点上，当用户需要访问网站的内容时，可以从距离其最近的CDN节点上获取所需内容，降低了网站访问延迟和拥堵，提高了用户访问速度和稳定性。</p><p>CDN服务提供商会从中心节点向全球建立多个缓存节点，使得用户的请求可以从离自己最近的节点获取数据，因而避免了传统的以中心节点为中心的单点故障和网络拥堵问题，同时也减轻了源站的压力，提高了数据传输的效率和可靠性。</p><p>CDN技术的应用广泛，比如可以用于优化网站速度，提高用户访问体验，降低视频播放卡顿率，减轻服务器负载，提高网站的安全性等等。</p><h2 id="CDN会改变IP地址吗？"><a href="#CDN会改变IP地址吗？" class="headerlink" title="CDN会改变IP地址吗？"></a>CDN会改变IP地址吗？</h2><p>CDN（内容分发网络）会改变IP地址。</p><p>CDN是一种优化网站性能和提高速度的技术，通过缓存和加速来将网站的内容分发到不同位置的节点，然后根据用户的请求 location 来返回最近节点的缓存内容，从而提高用户访问网站时的响应速度和体验。这些节点就是由 CDN 服务提供商部署在不同地点的服务器，也就是 CDN 边缘节点，它们是用户和网站源服务器之间的中转节点。</p><p>当用户请求网站内容时，CDN 会将请求重定向到距离用户最近的边缘节点，并将缓存的内容发送回用户所在的位置。边缘节点会运行一些特性（例如 NAT 网络地址转换），这些特性常常具有重写 IP 地址的功能，从而实现通过动态网络地址转换技术（NAT）进行 IP 地址的变更。</p><p>所以，请求经过 CDN 后，用户的请求 IP 地址将会变为节点 IP 地址，而非用户的真实 IP 地址。如果需要获取用户的真实IP地址，可以使用一些特殊的技术来绕过CDN，或者将CDN配置为在HTTP请求头中传递真实IP地址。</p><h2 id="硬链接和软链接的区别？"><a href="#硬链接和软链接的区别？" class="headerlink" title="硬链接和软链接的区别？"></a>硬链接和软链接的区别？</h2><ul><li>硬链接指向一个inode节点，可以跨目录，但是不能跨文件系统</li><li>软链接存放另一个文件的路径的形式存在，可以跨文件，但是不能跨分区。</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="什么是数据库的索引？"><a href="#什么是数据库的索引？" class="headerlink" title="什么是数据库的索引？"></a>什么是数据库的索引？</h3><p>数据库索引是一种数据结构，用于提高数据库表中数据的查询效率。索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。</p><p>在数据库中，索引类似于书籍的目录。如果您想查找书籍中的某个主题，您可以查找目录以找到该主题的页码，而不必翻阅整本书。同样，如果您想查找数据库表中的某个值，则可以使用索引来快速查找该值所在的行，而不必扫描整个表。</p><p>索引可以大大提高查询效率，但也会增加写入操作的时间和空间开销。因此，在设计数据库时，需要权衡查询效率和写入效率之间的平衡。</p><h3 id="数据库的索引有哪几种类型？"><a href="#数据库的索引有哪几种类型？" class="headerlink" title="数据库的索引有哪几种类型？"></a>数据库的索引有哪几种类型？</h3><p>数据库索引有多种类型，包括: 普通索引、唯一索引、主键索引、组合索引和全文索引等。</p><ul><li>普通索引：基本的索引类型，没有唯一性的限制，允许为NULL值。</li><li>唯一索引：数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</li><li>主键索引：主键是一种特殊的唯一索引，不允许为NULL值，一个表只能有一个主键</li><li>组合索引：将多个列作为一个索引建立，可以提高查询效率。</li><li>全文索引：用于全文搜索的特殊类型的索引。</li></ul><h3 id="什么是MySQL关联查询？"><a href="#什么是MySQL关联查询？" class="headerlink" title="什么是MySQL关联查询？"></a>什么是MySQL关联查询？</h3><p>MySQL关联查询是指在MySQL中，通过<strong>将两个或多个表的行按照指定的条件进行连接，返回一个包含有这些行的关联结果集，以使用户能够以一种更加灵活的方式查询和组装表中的数据</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span> name(s)<br><span class="hljs-keyword">FROM</span> tablel<br><span class="hljs-keyword">JOIN</span> table2<br><span class="hljs-keyword">ON</span> table1.column_name <span class="hljs-operator">=</span> table2.column_name;<br></code></pre></td></tr></table></figure><p>在MySQL关联查询中，使用”JOIN”关键字连接两个或多个表，可以根据条件进行对应行的匹配，匹配成功的行会合并到一起，生成关联结果集。其中，JOIN操作基于列之间的关系进行表的连接，包括INNER JOIN（内连接）、LEFT JOIN（左连接）、RIGHT JOIN（右连接）等类型。</p><p>MySQL关联查询通常通过联结两个或多个数据表，以便可以检索多个表中的数据，并将这些表的数据连接起来以生成一个更具关联性和完整性的数据集。当然，关联查询可能会涉及到一些复杂的SQL语句和表之间的数据关系，因此需要学习和熟练使用MySQL语言编写进行精确查询。</p><h3 id="关系型数据库和非关系型数据库的区别？"><a href="#关系型数据库和非关系型数据库的区别？" class="headerlink" title="关系型数据库和非关系型数据库的区别？"></a>关系型数据库和非关系型数据库的区别？</h3><p>关系型数据库和非关系型数据库的区别在于，关系型数据库一般都是有固定的表结构，并且需要通知DDL语句来修改表结构，不是很容易进行扩展</p><p>而非关系型数据库的存储机制就有很多了，比如基于文档的，K-V键值对的，还有基于图的等，对于数据的格式十分灵活没有固定的表结构，方便扩展。</p><p>因此<strong>如果业务的数据结构并不是固定的或者经常变动比较大的，那么非关系型数据库是个好的选择</strong>。</p><h3 id="关系型数据库与文档型数据库的区别？"><a href="#关系型数据库与文档型数据库的区别？" class="headerlink" title="关系型数据库与文档型数据库的区别？"></a>关系型数据库与文档型数据库的区别？</h3><p>关系型数据库（Relational Database）是建立在关系模型基础上的数据库，借助于几何代数等数学概念和方法来处理数据库中的数据。所谓关系模型是一对一、一对多或者多对多等关系，常见的关系型数据库有Oracle、SQL Server、DB2、MySQL等。</p><p>而文档型数据库是一种非关系型数据库，非关系型数据库（Not Only SQL，NoSQL）正好与关系型数据库相反，它不是建立在“关系模型”上的数据库。文档型数据库的典型代表是MongoDB。</p><h3 id="MongoDB和MySQL的区别"><a href="#MongoDB和MySQL的区别" class="headerlink" title="MongoDB和MySQL的区别"></a>MongoDB和MySQL的区别</h3><p>MongoDB是一种文档型数据库，而MySQL是一种关系型数据库。</p><p>MongoDB可以处理大量和非结构化数据量，而MySQL则<strong>缺乏处理大数据量的速度</strong>。因此，对于拥有较小数据库并寻求更通用解决方案的公司来说，MySQL可以胜任。</p><p>另外，MongoDB以一种直观文档的方式来完成数据的存储，它很像JavaScript中定义的JSON格式，不过数据在存储的时候MongoDB数据库为文档增加了序列化的操作，最终存进磁盘的其实是一种叫做BSON的格式，即Binary-JSON。</p><p>MySQL在<strong>处理关系数据方面具有更好的优势</strong>，而MongoDB则更能满足现代应用程序的需求。</p><h3 id="数据库三大范式是什么？"><a href="#数据库三大范式是什么？" class="headerlink" title="数据库三大范式是什么？"></a>数据库三大范式是什么？</h3><p>数据库三大范式（Normal Forms）指的是在关系数据库中，设计数据表时需要满足的规范。这些规范确保了数据库的数据结构与操作的可靠性、一致性和可维护性。</p><p>第一范式（1NF）要求记录（行）不可再分，即每个属性（列）都是原子的、不可再分的数据项。</p><p>第二范式（2NF）要求每个非主属性必须完全依赖于主键（即没有部分依赖关系）。如果存在部分依赖，应该将主键分解成更小的部分，以消除部分依赖。</p><p>第三范式（3NF）要求在关系表中，不存在非主键列对于其他非主键列的传递函数依赖关系。如果存在传递函数依赖，应该将其分解成两个关系表，以消除传递函数依赖。</p><p>需要注意的是，严格地符合三大范式并不一定就是最优的设计，某些情况下还需要根据数据的实际情况进行灵活设计，以达到更好的性能和维护效果。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring Recruitment</tag>
      
      <tag>进程与线程</tag>
      
      <tag>HTTP</tag>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构相关总结</title>
    <link href="/2023/04/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构相关"><a href="#数据结构相关" class="headerlink" title="数据结构相关"></a>数据结构相关</h1><h2 id="常见的数据结构有哪些？"><a href="#常见的数据结构有哪些？" class="headerlink" title="常见的数据结构有哪些？"></a>常见的数据结构有哪些？</h2><ul><li>数组 (Array)</li><li>队列 (Queue)</li><li>链表 (Linked List)</li><li>栈 (Stack)</li><li>树 (Tree)</li><li>散列表(Hash)</li><li>堆(Heap)</li><li>图 (Graph)</li></ul><h2 id="数组和链表有什么区别？"><a href="#数组和链表有什么区别？" class="headerlink" title="数组和链表有什么区别？"></a>数组和链表有什么区别？</h2><p>数组和链表是两种常见的数据结构。数组是一种线性数据结构，它在内存中占用一段连续的空间，每个元素都可以通过下标来访问。而链表则是一种非线性数据结构，它的元素在内存中不一定是连续的，每个元素都包含了指向下一个元素的指针。</p><p>因此，数组和链表有以下区别：</p><ul><li>数组在内存中占用一段连续的空间，而链表的元素在内存中不一定是连续的。</li><li>数组的元素可以通过下标来访问，而链表的元素只能通过指针来访问。</li><li>数组的大小是固定的，而链表的大小可以动态改变。</li><li>数组的插入和删除操作需要移动其他元素，时间复杂度为O(n)，而链表只需要改变指针指向，时间复杂度为O(1)。</li></ul><h2 id="数组和链表在内存分配上的区别？"><a href="#数组和链表在内存分配上的区别？" class="headerlink" title="数组和链表在内存分配上的区别？"></a>数组和链表在内存分配上的区别？</h2><p>数组和链表在内存分配上的区别是：</p><p>数组静态分配内存，链表动态分配内存；数组在内存中连续，链表不连续；数组元素在栈区，链表元素在堆区。此外，数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)； 数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。</p><h2 id="在使用JS进行开发的时候，什么情况下用数组存储数据-什么情况下用链表存储数据？"><a href="#在使用JS进行开发的时候，什么情况下用数组存储数据-什么情况下用链表存储数据？" class="headerlink" title="在使用JS进行开发的时候，什么情况下用数组存储数据? 什么情况下用链表存储数据？"></a>在使用JS进行开发的时候，什么情况下用数组存储数据? 什么情况下用链表存储数据？</h2><p>在使用JS进行开发时</p><p>使用数组存储数据的情况包括：需要快速访问元素，需要按照顺序存储元素，需要对元素进行排序或者操作，需要在数组中存储不同类型的数据等。</p><p>使用链表存储据的情况包括：需要动态添加或删除元素，不需要按照顺序存储元素，不需要快速访问元素等。</p><h2 id="JS中二叉树通过什么数据结构进行实现？"><a href="#JS中二叉树通过什么数据结构进行实现？" class="headerlink" title="JS中二叉树通过什么数据结构进行实现？"></a>JS中二叉树通过什么数据结构进行实现？</h2><p>在实现二叉树时，采用的存储结构为链式存储结构，链式结构的意思是采用一个链表来存储一颗二叉树，二叉树中每一个节点用链表的一个节点来存储，在二叉树中，节点结构至少有三个域：数据域data，左指针域left，右指针域right。</p><h2 id="栈和队列的特点及区别"><a href="#栈和队列的特点及区别" class="headerlink" title="栈和队列的特点及区别?"></a>栈和队列的特点及区别?</h2><p>栈和队列都是线性结构，但它们的特点和应用场景不同。栈是一种后进先出(LIFO)的数据结构，而队列是一种先进先出 (FIFO) 的数据结构。</p><p>栈和队列的区别在于它们的出入方式不同。<strong>栈是后进先出，队列是先进先出</strong>。在具体实现的时候操作的位置也不同：<strong>因为栈是后进先出，它在一端进行操作；而队列是先进先出，实现的时候在两端进行操作。</strong></p><h2 id="如何实现图结构？"><a href="#如何实现图结构？" class="headerlink" title="如何实现图结构？"></a>如何实现图结构？</h2><p>在JavaScript中，可以使用邻接表或邻接矩阵来实现图结构。其中，邻接表是一种链式存储方式，它将每个顶点的所有邻居顶点都存储在一个链表中。而邻接矩阵则是一个二维数组，其中每个元素表示两个顶点之间是否有边。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span> = []；<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()；<br>  &#125;<br><br>  <span class="hljs-title function_">addVertex</span>(<span class="hljs-params">v</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-title function_">push</span>(v)；<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">set</span>(v, [])；<br>  &#125;<br><br>  <span class="hljs-title function_">addEdge</span>(<span class="hljs-params">v, w</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(v).<span class="hljs-title function_">push</span>(w)；<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(w).<span class="hljs-title function_">push</span>(v)；<br>  &#125;<br><br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;&#x27;</span>；<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>； i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-property">length</span>； i++) &#123;<br>      s += <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.vertices[i]&#125;</span> -&gt; `</span>；<br>      <span class="hljs-keyword">const</span> neighbors = <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>[i])；<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>； j &lt; neighbors.<span class="hljs-property">length</span>； j++) &#123;<br>        s += <span class="hljs-string">`<span class="hljs-subst">$&#123;neighbors[j]&#125;</span> `</span>；<br>      &#125;<br>      s += <span class="hljs-string">&#x27;\n&#x27;</span>；<br>    &#125;<br>    <span class="hljs-keyword">return</span> s；<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Graph</span>()；<br><span class="hljs-keyword">const</span> vertices = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>]；<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>； i &lt; vertices.<span class="hljs-property">length</span>； i++) &#123;<br>  graph.<span class="hljs-title function_">addVertex</span>(vertices[i])；<br>&#125;<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;H&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>)；<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(graph.<span class="hljs-title function_">toString</span>())；<br></code></pre></td></tr></table></figure><h2 id="什么是哈希冲突？"><a href="#什么是哈希冲突？" class="headerlink" title="什么是哈希冲突？"></a>什么是哈希冲突？</h2><p>哈希冲突是指，<strong>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象</strong>。在哈希表中，每个关键字都对应一个位置，但是不同的关键字可能会对应到相同的位置，这就是哈希冲突。哈希冲突的解决方法有很多种，其中比较常见的有<strong>链地址法</strong>和开放地址法。链地址法是将相同hash值的对象组织成一个链表放在hash值对应的槽位；开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。</p><h2 id="JS-DOM树用什么数据结构进行存储？"><a href="#JS-DOM树用什么数据结构进行存储？" class="headerlink" title="JS DOM树用什么数据结构进行存储？"></a>JS DOM树用什么数据结构进行存储？</h2><p>JavaScript的DOM树是以多叉树的形式存储的。DOM模型用一个逻辑树来表示一个文档，树的每个分支的终点都是一个节点(node)，每人节点都包含着对象(Obiects)。</p><h2 id="递归有什么缺陷？"><a href="#递归有什么缺陷？" class="headerlink" title="递归有什么缺陷？"></a>递归有什么缺陷？</h2><ol><li>内存消耗大：递归需要在执行过程中不断地压入和弹出栈帧，这会消耗大量的内存空间。如果递归层数过多，可能会导致栈溢出。</li><li>性能低下：递归需要不断地进行函数调用和返回，这会消耗大量的CPU时间。如果递归次数过多，可能会导致程序运行缓慢。</li><li>可读性差：递归算法通常比较难理解和调试，代码可读性较差。</li><li>可能导致死循环：如果递归函数没有正确地终止条件，可能会导致死循环，使程序无法正常运行。</li></ol><h2 id="如何解决递归的缺陷？"><a href="#如何解决递归的缺陷？" class="headerlink" title="如何解决递归的缺陷？"></a>如何解决递归的缺陷？</h2><ol><li>限制递归深度：通过限制递归深度，可以避免栈溢出的问题。可以在递归函数中加入一个计数器或者设置一个最大深度，当达到指定深度时，停止递归。</li><li>尾递归优化：尾递归是一种特殊的递归形式，在尾递归中，递归调用是函数体中的最后一条语句。尾递归可以通过将当前状态作为参数传递给递归函数，从而避免不必要的栈帧压入和弹出操作，从而提高了效率。</li><li>使用迭代代替递归：在某些情况下，可以使用循环等其他算法代替递归，从而提高效率和可读性。</li><li>优化递归算法：对递归算法进行优化，如使用记忆化搜索等技术，可以大幅提高递归算法的效率。</li></ol><h2 id="DFS和BFS的使用场景？"><a href="#DFS和BFS的使用场景？" class="headerlink" title="DFS和BFS的使用场景？"></a>DFS和BFS的使用场景？</h2><p>DFS（深度优先搜索）和BFS（广度优先搜索）都是图遍历算法，它们的使用场景如下：</p><p>DFS使用场景：</p><ul><li>求解连通块问题</li><li>求解迷宫问题</li><li>求解拓扑排序问题</li><li>求解生成树问题</li><li>求解二叉树的遍历问题</li></ul><p>BFS使用场景：</p><ul><li>求解最短路径问题</li><li>求解连通块问题</li><li>求解迷宫问题</li><li>求解拓扑排序问题</li><li>求解生成树问题</li></ul><p>总的来说，DFS更适合解决深度优先的问题，BFS更适合解决广度优先的问题。在实际应用中，需要根据具体问题的特点选择合适的算法。</p><h2 id="小根堆的概念？作用？"><a href="#小根堆的概念？作用？" class="headerlink" title="小根堆的概念？作用？"></a>小根堆的概念？作用？</h2><p>小根堆（Min Heap）是一种基于树形结构的数据结构，它满足以下两个条件：</p><ol><li>堆中每个节点的值都小于或等于其子节点的值。</li><li>堆是一棵完全二叉树。</li></ol><p>小根堆的作用：</p><ol><li>堆排序：小根堆可以用来进行堆排序，堆排序是一种高效的排序算法，时间复杂度为O(nlogn)。</li><li>优先队列：小根堆可以用来实现优先队列，优先队列是一种数据结构，它可以按照优先级来处理元素，小根堆可以实现按照元素值的大小来进行优先级排序。</li><li>最小值查询：小根堆可以用来查询最小值，由于小根堆的性质，堆顶元素始终是堆中的最小值。</li><li>贪心算法：小根堆可以用来实现贪心算法，贪心算法是一种基于贪心思想的算法，它每次选择当前最优的方案，小根堆可以用来找到当前最优的方案。</li></ol><p>总之，小根堆是一种非常实用的数据结构，它可以用来实现堆排序、优先队列、最小值查询和贪心算法等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring Recruitment</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React知识点总结</title>
    <link href="/2023/04/25/React%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/25/React%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="为什么要使用类似React这种MVVM框架？为什么不直接使用原生前端开发？"><a href="#为什么要使用类似React这种MVVM框架？为什么不直接使用原生前端开发？" class="headerlink" title="为什么要使用类似React这种MVVM框架？为什么不直接使用原生前端开发？"></a>为什么要使用类似<code>React</code>这种<code>MVVM</code>框架？为什么不直接使用原生前端开发？</h2><p>使用类似 <code>React</code> 这种 <code>MVVM</code> 框架的主要原因是可以提高前端开发的效率和可维护性。以下是具体的原因：</p><ol><li>组件化开发：<code>React</code> 将页面拆分成多个组件，每个组件负责一部分功能，通过组合和嵌套组件来实现整个页面的功能。这样可以使代码更加模块化和可复用，提高开发效率和代码质量。</li><li>虚拟 DOM：<code>React</code> 使用虚拟 DOM 来代替直接操作 DOM，这样可以避免频繁的 DOM 操作，提高页面性能。</li><li>单向数据流：<code>React</code> 的数据流是单向的，从父组件传递到子组件，这样可以避免数据混乱和难以维护的问题。</li><li>模板语法：<code>React</code> 使用 JSX 语法，可以将组件和数据混合在一起，提高代码可读性和可维护性。</li><li>多平台支持：<code>React</code> 可以用于 Web 开发、移动端开发和桌面端开发，可以实现多平台的代码复用。</li></ol><h2 id="React和Vue有哪些区别？"><a href="#React和Vue有哪些区别？" class="headerlink" title="React和Vue有哪些区别？"></a>React和Vue有哪些区别？</h2><ol><li>语言：React是使用JavaScript语言编写的，而Vue是使用JavaScript和模板语言编写的。</li><li>数据绑定：React通常使用单向数据流（父组件向子组件传递数据，子组件可更改该数据），Vue则提供了双向数据绑定。</li><li>组件通信：React使用props和回调函数来实现组件之间的通信，而Vue使用props，事件总线，Vuex等来实现组件之间的通信。</li><li>模板：React使用JSX语法编写组件，而Vue使用模板语言编写组件。</li><li>性能：React在大型组件和动态数据渲染时性能优于Vue，但是Vue在小型组件和静态数据渲染时性能优于React。</li><li>学习曲线：Vue相比于React有着更低的学习曲线，因为Vue提供了更直观和简洁的API，而React则更加灵活但需要一些额外的学习。</li></ol><h2 id="React函数组件的优势？"><a href="#React函数组件的优势？" class="headerlink" title="React函数组件的优势？"></a>React函数组件的优势？</h2><ul><li>函数式组件没有this困扰且代码简洁</li><li>不涉及到复杂的state和生命周期</li><li>类组件过于冗余不宜拆分</li></ul><h2 id="为什么推荐使用React-Hooks而不是类组件？"><a href="#为什么推荐使用React-Hooks而不是类组件？" class="headerlink" title="为什么推荐使用React Hooks而不是类组件？"></a>为什么推荐使用React Hooks而不是类组件？</h2><p>生命周期不利于逻辑相关的状态的管理。</p><p>side effect相关逻辑被分散到不同的函数中可能会导致bug的出现和产生数据不一致的情况；我们也可能会在组件的同一生命周期中放很多不相关的side effect逻辑。</p><p>使用Hook可以将某个side effect相关的逻辑都放在同一个函数中，方便代码的维护，方便组件的复用。</p><p>使用函数组件的优点如下：</p><ol><li>避免使用类组件繁琐的语法：使用Hooks可以让代码更简洁，并且在进行状态管理时，不需要像类组件一样显式地声明state，我们可以通过useState Hook更方便地管理组件的状态。</li><li>可以更灵活地组织代码：使用Hooks可以让我们更灵活地组织代码，我们可以把逻辑划分到不同的 Hook 中，并根据需要进行复用。这样使得代码更加清晰、简洁和易于维护。</li><li>便于测试：使用Hooks可以更容易地进行单元测试。我们可以通过传递不同的props和状态值来测试组件的逻辑，并且Hooks更加容易使用和测试。</li><li>Hooks 可以减少代码量和提高性能：在 Hooks 之前，我们经常需要使用高阶组件（Higher Order Components）和 Render Props 等技术来进行代码的复用，从而导致代码更加复杂，而且这些方法也会影响性能。而 Hooks 可以帮助我们在一个函数内共享逻辑，从而减少代码量并提高性能。</li></ol><h2 id="React为什么要引入Hooks？Hooks的优势和劣势？⭐"><a href="#React为什么要引入Hooks？Hooks的优势和劣势？⭐" class="headerlink" title="React为什么要引入Hooks？Hooks的优势和劣势？⭐"></a>React为什么要引入Hooks？Hooks的优势和劣势？⭐</h2><p>React引入Hooks的主要原因是为了解决<strong>组件之间复用状态逻辑</strong>的问题。</p><p>在React之前，组件之间复用状态逻辑通常需要使用高阶组件、render props等技术，这些技术增加了组件的复杂性和理解难度，同时也不够直观和自然。而Hooks可以让组件之间复用状态逻辑变得更加简单和直观，同时可以提高代码的重用性和可读性。</p><p>优势：</p><ol><li>更少的代码量：使用Hooks可以<strong>减少组件之间的重复代码，提高代码的重用性</strong>，同时也可以提高代码的可读性和可维护性。</li><li>更好的逻辑复用：使用Hooks可以将状态逻辑从组件中抽离出来，使得逻辑复用更加自然和简单。</li><li>更好的测试性：使用Hooks可以更容易地编写和执行单元测试，以保证代码的质量和稳定性。</li></ol><p>劣势：</p><ol><li>学习曲线：使用Hooks需要掌握一些新的概念和用法，对于初学者来说可能需要一定的学习曲线。</li><li>兼容性问题：Hooks是在React v16.8中引入的，需要React 16.8或更高版本才能使用，如果项目中使用的是旧版本的React，需要升级React版本才能使用Hooks。</li></ol><h2 id="React-Hooks在使用上有什么限制？"><a href="#React-Hooks在使用上有什么限制？" class="headerlink" title="React Hooks在使用上有什么限制？"></a>React Hooks在使用上有什么限制？</h2><ol><li>只能在函数组件中使用：React Hooks 只能在函数组件中使用，无法在类组件中使用。</li><li>不能在循环、条件语句中使用：React Hooks 必须按照固定的顺序调用，不能在循环、条件语句中使用。</li><li>使用时必须按照约定命名：使用 useState、useEffect 等 React Hooks 时必须按照约定命名，否则会导致无法正常使用。</li><li>不能在普通函数中使用：React Hooks 只能在函数组件中使用，不能在普通函数中使用。</li><li>不能在嵌套组件中使用：React Hooks 只能在最顶层的函数组件中使用，不能在嵌套组件中使用。</li><li>不能在条件渲染的分支中使用：React Hooks 必须在每次渲染时都按照相同的顺序调用，不能在条件渲染的分支中使用。</li><li>不能在 useEffect 中使用 async&#x2F;await：在 useEffect 中使用 async&#x2F;await 会导致一些问题，应该使用 Promise.then()。</li></ol><h2 id="为什么不能在-useEffect-中使用-async-x2F-await？"><a href="#为什么不能在-useEffect-中使用-async-x2F-await？" class="headerlink" title="为什么不能在 useEffect 中使用 async&#x2F;await？"></a>为什么不能在 useEffect 中使用 async&#x2F;await？</h2><p>在 <code>useEffect</code> 或 <code>componentDidMount</code> 中使用 <code>async/await</code> 会导致问题。原因是 <code>async</code> 函数返回的是一个 Promise 对象, 而 <code>useEffect</code> 需要的是一个清除函数（cleanup function）或者 <code>undefined</code>。如果你在 <code>useEffect</code> 函数中使用 <code>async</code> 关键字，那么返回的这个Promise对象将被视为 <code>useEffect</code> 的返回值，并且不会执行清除函数。</p><p>换句话说，<code>useEffect</code> 在渲染完成后执行，而 <code>async</code> 函数需要更多的时间来执行，因此它不能直接与 <code>useEffect</code> 一起使用。相反，你可以在 <code>useEffect</code> 函数本地定义异步函数，并在函数中调用 <code>await</code>，以此来避免这个问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>);<br>    <span class="hljs-title function_">setData</span>(result.<span class="hljs-property">data</span>);<br>  &#125;<br>  <span class="hljs-title function_">fetchData</span>();<br>&#125;, []);<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了 <code>fetchData</code> 函数，这个函数是异步的，我们在函数中调用了 <code>await</code>。然后我们在 <code>useEffect</code> 中调用 <code>fetchData</code>，并确保它的依赖项数组是一个空数组。这就确保了 <code>fetchData</code> 函数只会在组件挂载时运行一次。</p><h2 id="React函数组件和类组件的区别？"><a href="#React函数组件和类组件的区别？" class="headerlink" title="React函数组件和类组件的区别？"></a>React函数组件和类组件的区别？</h2><ul><li>类组件有生命周期，函数组件无生命周期</li><li>类组件调用setStatet管理state状态，函数组件使用useState</li><li>函数组件调用即是执行函数，类组件需要先将组件实例化，再调用实例对象的render方法</li><li>函数组件更加简洁易懂，容易被开发、理解和测试。</li></ul><h2 id="类组件和函数组件在渲染和性能方面有什么区别？"><a href="#类组件和函数组件在渲染和性能方面有什么区别？" class="headerlink" title="类组件和函数组件在渲染和性能方面有什么区别？"></a>类组件和函数组件在渲染和性能方面有什么区别？</h2><p><strong>渲染方式</strong></p><p>类组件使用 <code>render()</code> 方法来渲染 DOM，需要继承自 <code>React.Component</code> 或 <code>React.PureComponent</code>，并且需要实现一些必要的生命周期方法。</p><p>函数组件是一个简单的 JavaScript 函数，通过返回一个 JSX 元素来表示要渲染的 DOM，不需要继承任何类或实现生命周期方法。</p><p><strong>渲染性能</strong></p><p>由于类组件存在生命周期方法和状态，每次渲染都需要进行完整的生命周期流程，从而使得渲染性能较低。</p><p>函数组件由于不需要进行生命周期的处理和状态的维护，每次渲染只需要简单地执行函数体，从而使得渲染性能较高。此外，React 还引入了 Hooks，使得函数组件在处理状态和副作用时可以与类组件一样方便。</p><p><strong>用法和场景</strong></p><p>类组件通常用于实现比较复杂的交互逻辑和组件状态。例如，当一个组件需要在生命周期中进行一些异步请求，或者需要在组件更新时进行一些状态同步时，类组件就比较合适。</p><p>函数组件通常用于实现简单的 UI 和逻辑，例如展示列表、根据数据渲染不同的组件等。此外，函数组件通常比较易于编写和维护，可以提高开发效率。</p><h2 id="React单向数据流？"><a href="#React单向数据流？" class="headerlink" title="React单向数据流？"></a>React单向数据流？</h2><p>React的单向数据流是指数据的流动方向是单向的，从父组件流向子组件。父组件通过props将数据传递给子组件，子组件不能直接修改父组件传递过来的数据，只能通过触发事件或调用父组件传递过来的回调函数来修改数据。这样做的好处是保证了数据的一致性，<strong>避免了组件之间的相互影响，提高了应用的可维护性</strong>。</p><p>React的单向数据流也是React的核心思想之一，它使得组件之间的数据传递变得简单明了，也方便了组件的重用和组合。在React应用中，每个组件都是一个独立的单元，它只关心自己的数据和UI展示，而不需要考虑其他组件的状态和行为。这种组件化的思想也是React的另一个重要特点。</p><h2 id="React组件通信方式？"><a href="#React组件通信方式？" class="headerlink" title="React组件通信方式？"></a>React组件通信方式？</h2><ol><li>父子组件通过props传递数据: 父组件可以通过props向子组件传递数据和回调函数，子组件则可以通过调用父组件传递的回调函数，将数据传递回父组件；</li><li>Context方式: 通过Context可以在组件树中向多层嵌套的子组件传递数据，避免了props跨层级传递的繁琐过程；</li><li>全局状态管理工具: 如Redux，Mobx等，可以将共享状态提升到全局，通过订阅和发布的方式实现组件间的通信；</li><li>通过组件引用方式： 在某一个组件需要调用另一个组件的方法时，可以通过对该组件的引用，来调用该组件的方法。</li></ol><h2 id="如果需要发送请求，在React生命周期的什么阶段进行发送合适？原因是什么？"><a href="#如果需要发送请求，在React生命周期的什么阶段进行发送合适？原因是什么？" class="headerlink" title="如果需要发送请求，在React生命周期的什么阶段进行发送合适？原因是什么？"></a>如果需要发送请求，在React生命周期的什么阶段进行发送合适？原因是什么？</h2><p>通常，发送请求可以放在React组件的生命周期的某些阶段中，具体要看数据流动的方式和实现需求。</p><p>一般来说，最常见的阶段是componentDidMount。这是因为<strong>在组件渲染完成后，DOM已经被渲染，可以正常地发送请求获取数据，然后更新组件状态，最后重新渲染组件</strong>。</p><p><strong>如果在组件挂载前就发送请求，可能会导致无法获取到需要的DOM元素</strong>，因此不适合在组件其他生命周期中发送请求。另外，如果请求放在组件的渲染方法中，则可能会导致在每次重新渲染组件时都发送多次请求，增加不必要的网络负载，影响性能。</p><p>当然，具体实现还需要考虑更多因素，比如数据流的复杂度、数据的实时性要求、组件的复用性等等。但是，通常情况下，在componentDidMount这个生命周期阶段发送请求是可行的，并且也是较为常见的做法。</p><h2 id="jsx在react中起什么作用？"><a href="#jsx在react中起什么作用？" class="headerlink" title="jsx在react中起什么作用？"></a>jsx在react中起什么作用？</h2><p>React中使用<code>.jsx</code>后缀表示这个文件包含JSX语法。JSX是一种类似于HTML的JS语法扩展，用于描述应用程序的用户界面。在React中，组件的UI通常以JSX的形式定义。</p><p>JSX的目的是提高React组件的代码可读性和易维护性。在React中使用JSX可以将组件的UI模板和JavaScript逻辑代码合在一起，从而提高React应用程序的开发效率。</p><p>同时，<code>.jsx</code>后缀还可以方便代码编辑器和其他工具根据文件类型来识别React组件代码，提供针对性的编辑体验和功能，如语法高亮、代码补全等。</p><p>需要注意的是，虽然React推荐使用JSX来定义组件的UI，但JSX并不是React的必须要求，React同样支持使用纯JavaScript来编写组件的UI。</p><h2 id="常见的React-Hooks？"><a href="#常见的React-Hooks？" class="headerlink" title="常见的React Hooks？"></a>常见的React Hooks？</h2><blockquote><p>Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数</p><p>Hook使用规则：</p><ul><li>只能在<strong>函数最外层</strong>调用Hook。不能在循环、条件判断或子函数中调用。</li><li>只能在React的<strong>函数组件</strong>中调用Hook。不能在其他JavaScript函数中调用。</li></ul></blockquote><ul><li><p>useState</p></li><li><p>useEffect</p></li><li><p>useLayoutEffect</p></li><li><p>useContext</p><p>不使用组件嵌套就可以订阅React的Context</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; createContext, useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-comment">// 创建一个Context对象</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserContext</span> = <span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">// 在App组件中提供用户信息</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;user&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 在需要使用用户信息的地方调用useContext</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">UserContext</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Child组件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名：&#123;user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：&#123;user.age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure></li><li><p>useReducer</p><p>useReducer是React提供的一种状态管理方案，可以在组件中使用它来管理复杂的状态逻辑，避免组件过于庞大和难以维护。相对于useState，useReducer更适合用于多个状态之间存在复杂依赖的情况，或者需要执行多个连续状态操作的情况。</p><p>假设我们有一个计数器组件，可以进行加和减计算，并且可以指定增加或减少的值。我们可以使用useReducer来实现它。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-comment">// reducer函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">counterReducer</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;INCREMENT&quot;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + action.<span class="hljs-property">payload</span> &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;DECREMENT&quot;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - action.<span class="hljs-property">payload</span> &#125;;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 计数器组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(counterReducer, &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onIncrement</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;INCREMENT&quot;</span>, <span class="hljs-attr">payload</span>: <span class="hljs-number">1</span> &#125;);<br>  &#125;;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onDecrement</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;DECREMENT&quot;</span>, <span class="hljs-attr">payload</span>: <span class="hljs-number">1</span> &#125;);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>计数器：&#123;state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onIncrement&#125;</span>&gt;</span>加1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onDecrement&#125;</span>&gt;</span>减1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Counter</span>;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们首先定义了一个counterReducer函数，用于更新计数器的状态。这个函数接受两个参数：state和action。state表示当前的状态，action是一个对象，其中包括type和payload两个属性。type表示更新状态的行为类型，payload表示更新状态时的附加参数。</p><p>接着，在计数器组件中，我们调用useReducer函数，传入参数counterReducer和当前状态。useReducer会返回一个数组，第一个元素是当前的状态信息，第二个元素是一个dispatch函数，用于触发更新状态的行为。我们在组件中使用dispatch函数，传递一个包含type和payload属性的对象，触发特定的状态更新行为。</p><p>最后，在组件中展示当前状态信息，并提供增加和减少计数的按钮。点击按钮时，触发对应的行为，并通过dispatch函数提交给reducer函数进行操作。</p></li><li><p>useMemo</p></li><li><p>useCallback</p></li><li><p>自定义Hook</p><p>例如：自定义一个订阅好友在线状态的Hook</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useEffect, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useFriendStatus</span>(<span class="hljs-params">friendID</span>) &#123;<br>    <span class="hljs-keyword">const</span> [isOnline, setIsOnlone] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleStatusChange</span> = (<span class="hljs-params">status</span>) =&gt; &#123;<br>        <span class="hljs-title function_">setIsOnline</span>(status);<br>    &#125;<br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">subscribeToFriendStatus</span>(friendId, handleStatusChange); <span class="hljs-comment">// 订阅好友在线状态</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">unsubscribeToFriend</span>(friendId, handleStatusChange); <span class="hljs-comment">// 解绑对好友在线状态的订阅</span><br>        &#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> isOnline;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们可以在别的组件中使用它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FriendStatus</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">const</span> isOnline = <span class="hljs-title function_">useFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>);<br>    <span class="hljs-keyword">if</span>(isOnline === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Loading...&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> isOnline ? <span class="hljs-string">&quot;onLine&quot;</span> : <span class="hljs-string">&quot;OffLine&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="为什么不能在循环、条件或嵌套函数中调用React-Hook？"><a href="#为什么不能在循环、条件或嵌套函数中调用React-Hook？" class="headerlink" title="为什么不能在循环、条件或嵌套函数中调用React Hook？"></a>为什么不能在循环、条件或嵌套函数中调用React Hook？</h2><p>React是使用类似于链表的结构来存储Hook的，每次Hook的调用都对应着一个全局的index索引，通过这个索引运行当前组件上的_hooks数组查找保存的值，也就是Hook返回的<code>[state, useState]</code></p><p>假设在下面代码中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [state1, setState1] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> [state2, setState2] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">const</span> [state3, setState3] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/5/166e20d92aa52108~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="react-hooks"></p><p>在执行函数组件的时候，第一次执行<code>useState</code>是时候，它会对应Fiber对象上的<code>memoizedState</code>，这个属性原来是设计来存储类组件的state的，因为在类组件中state是一整个对象，所以可以和<code>memoizedState</code>一一对应。</p><p>但是在Hooks中，React并不知道我们调用了几次<code>useState</code>，所以在保存state这件事上，React提出了另一种解决方案，即调用<code>useState</code>之后在<code>memoizedState</code>上的对象设计成如下样式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    baseState<span class="hljs-punctuation">,</span><br>    next<span class="hljs-punctuation">,</span><br>    baseUpdate<span class="hljs-punctuation">,</span><br>    queue<span class="hljs-punctuation">,</span><br>    memoizedState<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>我们将其称为Hook对象。这里最需要关心的是<code>memoizedState</code>和<code>next</code>，<code>memoizedState</code>用来记录该<code>useState</code>应该返回的结果，而<code>next</code>指向下一次<code>useState</code>对应的Hook对象。</p><p>即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">hook1 =&gt; <span class="hljs-title class_">Fiber</span>.<span class="hljs-property">memoizedState</span><br>state1 === hook1.<span class="hljs-property">memoizedState</span><br>hook1.<span class="hljs-property">next</span> =&gt; hook2<br>state2 === hook2.<span class="hljs-property">memoizedState</span><br>hook2.<span class="hljs-property">next</span> =&gt; hook3<br>state3 === hook3.<span class="hljs-property">memoizedState</span><br></code></pre></td></tr></table></figure><p>React按照执行顺序以类似链表的数据格式存放在<code>Fiber.memoizedState</code>上</p><p>由于按照这种方式存储state，因此<code>useState</code>(包括其他Hooks)都必须在函数组件的根作用域声明，而不能再条件或循环中声明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(something) &#123;<br>    <span class="hljs-keyword">const</span> [state1] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// or</span><br><span class="hljs-keyword">for</span>(something) &#123;<br>    <span class="hljs-keyword">const</span> [state2] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们无法保证条件语句每次执行的次数是一样的，也就是说如果第一次render创建了<code>state1 =&gt; hook1, state2 =&gt; hook2, state3 =&gt; hook3</code>这样的对应关系，再次render的时候因为<code>something</code>未达成，导致<code>useState(1)</code>没有执行的话，那么执行<code>useState(2)</code>的时候，拿到的hook对象是<code>state1</code>的，那么逻辑就会混乱，因此该条件必须遵守。</p><p>更新state的时候，调用<code>useState</code>的返回方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> dispatch = queue.<span class="hljs-property">dispatch</span> = dispatchAction.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, currentlyRenderingFiber$1, queue);<br><span class="hljs-keyword">return</span> [workInProgressHook.<span class="hljs-property">memoizedState</span>, dispatch];<br></code></pre></td></tr></table></figure><p>调用该方法会创建一个update</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> update = &#123;<br>  <span class="hljs-attr">expirationTime</span>: _expirationTime,<br>  <span class="hljs-attr">action</span>: action,<br>  <span class="hljs-attr">callback</span>: callback !== <span class="hljs-literal">undefined</span> ? callback : <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的action是调用<code>setState(1)</code>传入的值，而这个update会被加入到queue上，因此可能存在一次性调用多次setState1的情况。</p><p>在收集完这所有<code>update</code>之后，会调度一次<code>React</code>的更新，在更新的过程中，肯定会执行到函数组件，那么就会执行到对应的<code>useState</code>，然后就拿到了<code>Hook</code>对象，它保存了<code>queue</code>对象表示有哪些更新存在，然后依次进行更新，拿到最新的<code>state</code>保存在<code>memoizedState</code>上，并且返回，最终达到了<code>setState</code>的效果。</p><p>参考文档：<a href="https://juejin.cn/post/6844903704437456909">https://juejin.cn/post/6844903704437456909</a></p><h2 id="useMemo和useCallback的区别⭐"><a href="#useMemo和useCallback的区别⭐" class="headerlink" title="useMemo和useCallback的区别⭐"></a>useMemo和useCallback的区别⭐</h2><p>二者都是用于缓存数据，优化性能的，它们接受到的参数是一样的，第一个参数表示回调函数，第二个参数表示依赖的数据。</p><p>共同作用：在依赖数据发生变化的时候，才会调用传进去的回调函数去重新计算结果，起到缓冲的作用。</p><p>区别：</p><ul><li><strong><code>useMemo</code>缓存的结果是回调函数中return回来的值</strong>，主要用于缓存计算结果的值，应用场景如需要计算的状态。</li><li><code>useCallback</code>缓存的结果是函数，主要用于<strong>缓存函数</strong>，应用场景如需要缓存的函数，因为函数式组件每次任何一个state发生变化都会触发整个组件更新，一些函数是没有必要更新的，此时就应该缓存起来，<strong>提高性能，减少对资源的浪费</strong>。<code>useCallback</code>应该和<code>React.memo</code>配套使用，缺少一个可能会导致性能不升反降。</li></ul><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useState, useMemo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Info</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">const</span> [info, setInfo] = <span class="hljs-title function_">useState</span>(&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;LiHua&quot;</span>,<br>        <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;male&quot;</span><br>    &#125;);<br>    <span class="hljs-comment">// 翻译性别的函数</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">formatGender</span> = (<span class="hljs-params">gender</span>) =&gt; &#123;<br>        <span class="hljs-keyword">return</span> gender === <span class="hljs-string">&quot;male&quot;</span> ? <span class="hljs-string">&quot;男&quot;</span> : <span class="hljs-string">&quot;女&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果不使用useMemo,修改其他属性，也会导致formatGender方法的调用，浪费计算资源</span><br>    <span class="hljs-comment">// const gender = formatGender(info.gender);</span><br>    <span class="hljs-comment">// 仅当info.gender发生变化的时候才调用formatGender</span><br>    <span class="hljs-keyword">const</span> gender = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">formatGender</span>(info.<span class="hljs-property">gender</span>);<br>    &#125;, [info.<span class="hljs-property">gender</span>]);<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        姓名：&#123;info.name&#125; - 性别：&#123;gender&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onClick</span> = <span class="hljs-string">&#123;()</span> =&gt;</span> setInfo(...info, name: &quot;XiaoMing&quot;)&#125;</span><br><span class="language-xml">        &gt;点击修改姓名<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>useCallback是设计初衷是为了<strong>减少子组件的不必要重读渲染</strong>，优化思路主要有以下两种：</p><ul><li>减少render的次数</li><li>减少计算量</li></ul><p>在如下场景中</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-comment">// 不使用useCallback和memo的时候</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Comp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [dataA, setDataA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> [dataB, setDataB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickA</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataA</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickB</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataB</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Cheap</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickA&#125;</span>&gt;</span>组件Cheap: &#123;dataA&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Cheap</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Expensive</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickB&#125;</span>&gt;</span>组件Expensive: &#123;dataB&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Expensive</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述组件中，每当点击Cheap组件的时候，Expensive组件也会重新渲染，即使dataB没有发生变化，原因就是onClickB被重新定义，导致React在diff新旧组件的时候判定了组件发生了变化。</p><p>此时，useCallback和memo就发挥作用了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useCallback, useState, memo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Expensive</span>(<span class="hljs-params">&#123;onClick, name&#125;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Expensive渲染&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><span class="hljs-keyword">const</span> memoExpensive = <span class="hljs-title function_">memo</span>(<span class="hljs-title class_">Expensive</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cheap</span>(<span class="hljs-params">&#123;onClick, name&#125;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Cheap渲染&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Comp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [dataA, setDataA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> [dataB, setDataB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickA</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataA</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> onClickB = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">setDataB</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;, [])<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Cheap</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickA&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">组件Cheap:</span> $&#123;<span class="hljs-attr">dataA</span>&#125;`&#125; /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Expensive</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickB&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">组件Expensive:</span> $&#123;<span class="hljs-attr">data</span>&#125;`&#125; /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>memo与PureComponent类似，对传入组件的新旧数据进行浅比较，如果相同则不会触发渲染。</p><p>useCallback保证onClickB不会发生变化，此时点击Cheap组件不会触发Expensive组件的刷新，只有点击Expensive组件才会触发。在实现减少不必要渲染的优化过程中，useCallback和memo是一对利器。</p><h2 id="useMemo相当于是对状态进行了一次缓存吗？"><a href="#useMemo相当于是对状态进行了一次缓存吗？" class="headerlink" title="useMemo相当于是对状态进行了一次缓存吗？"></a>useMemo相当于是对状态进行了一次缓存吗？</h2><p>是的，useMemo 可以看作是对计算结果进行缓存，仅在依赖项发生变化时才会重新计算。</p><p>useMemo 接收两个参数：一个是计算函数，另一个是依赖项数组。当依赖项数组中的任意一个依赖项发生变化时，useMemo 会重新计算计算函数的结果。如果依赖项数组中的依赖项没有发生变化，则 useMemo 返回上一次缓存的结果。</p><p>通过使用 useMemo，可以避免在每次渲染时都进行昂贵的计算，提高组件的性能。在某些情况下，如果没有使用 useMemo，组件可能会进行大量的重复计算，导致性能下降。</p><p>此外，虽然 useMemo 可以优化组件的性能，但是过度使用 useMemo 也会带来一些问题，如增加内存占用和代码复杂度等。因此，在使用 useMemo 时需要根据实际情况进行权衡和调整。</p><h2 id="useEffect和useLayoutEffect的区别？"><a href="#useEffect和useLayoutEffect的区别？" class="headerlink" title="useEffect和useLayoutEffect的区别？"></a>useEffect和useLayoutEffect的区别？</h2><p>useEffect 和 useLayoutEffect 都是 React 的 Hooks API，它们的主要区别在于执行的时机和是否会阻塞浏览器渲染。</p><ol><li>执行时机：useEffect 是<strong>在组件渲染完成后、在浏览器完成布局和绘制之后异步执行的</strong>，而 useLayoutEffect 是在<strong>组件渲染完成后、页面绘制和布局前同步执行的</strong>。因此，useLayoutEffect 的执行优先级更高。</li><li>是否阻塞浏览器渲染：<strong>useEffect 不会阻塞浏览器渲染，而 useLayoutEffect 会阻塞浏览器渲染</strong>。因此，在使用 useLayoutEffect 时要注意避免长时间的计算和操作，以免影响用户体验。</li><li>使用场景：useEffect 适合处理副作用，如数据获取、订阅事件等。而 useLayoutEffect 适合处理需要同步更新 DOM 的操作，如计算 DOM 元素的大小和位置等。</li></ol><p>综上所述，useEffect 和 useLayoutEffect 在执行时机和是否阻塞浏览器渲染方面有所不同，需要根据实际情况选择使用。一般来说，如果需要同步更新 DOM，可以使用 useLayoutEffect，否则可以使用 useEffect。</p><h2 id="useRef有哪些作用？"><a href="#useRef有哪些作用？" class="headerlink" title="useRef有哪些作用？"></a>useRef有哪些作用？</h2><p>React中的useRef是一个Hook，它返回一个可变的ref对象，它的<code>.current</code>属性被初始化为传入的参数(initialValue)。useRef可以用来存储任何可变值，就像在类数组中使用实例属性一样。</p><p>useRef返回的对象在组件的整个生命周期中保持不变，因此可以用来存储哪些 不需要触发重新渲染的值，例如定时器或其他引用类型的值。另外，useRef还可以用来获取DOM元素或者其他组件的实例。</p><p>作用：</p><ul><li>存储状态</li><li>获取DOM元素或其他组件实例</li></ul><h2 id="useRef的返回值是什么？"><a href="#useRef的返回值是什么？" class="headerlink" title="useRef的返回值是什么？"></a>useRef的返回值是什么？</h2><p><code>useRef</code>的返回值是一个可变的<code>ref</code>对象，且只有一个current属性，其中 <code>current</code> 属性指向一个可变的值。可以通过修改 <code>current</code> 属性来更新这个值，而不会触发组件的重新渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>Focus<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="用useState可以实现useRef的效果吗？"><a href="#用useState可以实现useRef的效果吗？" class="headerlink" title="用useState可以实现useRef的效果吗？"></a>用useState可以实现useRef的效果吗？</h2><p>不能。</p><p>虽然 <code>useState</code> 和 <code>useRef</code> 都可以用来存储组件中的数据，但是它们的实现方式不同，因此不能完全替代彼此。</p><p><code>useState</code> 用于存储组件的状态，每次更新状态都会触发组件的重新渲染。而 <code>useRef</code> 用于存储组件中的数据，不会触发组件的重新渲染。</p><p>虽然 <code>useState</code> 可以用来存储组件中的数据，但是每次更新状态都会触发组件的重新渲染，这可能会导致性能问题。而 <code>useRef</code> 可以在不触发组件重新渲染的情况下存储数据，因此更适合用来存储不需要触发重新渲染的数据。</p><p>例如，<code>useRef</code> 可以用来存储 DOM 元素的引用，而 <code>useState</code> 则不适合用来存储 DOM 元素的引用，因为每次更新状态都会触发组件的重新渲染，从而导致 DOM 元素的重新创建和销毁。</p><h2 id="函数组件如何模拟生命周期？"><a href="#函数组件如何模拟生命周期？" class="headerlink" title="函数组件如何模拟生命周期？"></a>函数组件如何模拟生命周期？</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 模拟componentDidMount</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>   <span class="hljs-comment">// 第一次渲染时调用 </span><br>&#125;, [])<br><br><span class="hljs-comment">// 模拟componentDidUpdate</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 任意属性发生改变该属性就会改变</span><br>&#125;)<br><br><span class="hljs-comment">// 模拟componentWillUnmount useEffect会在状态变化的时候进行解绑</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;, <span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 返回的函数是用于清除副作用的</span><br>        <span class="hljs-comment">// 执行卸载操作</span><br>        <span class="hljs-built_in">clearInterval</span>(timer);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="React-state更新机制"><a href="#React-state更新机制" class="headerlink" title="React state更新机制"></a>React state更新机制</h2><p>React中类组件的state是通过setState()方法来更新的。当执行setState()时，会将需要更新的state合并后放入状态队列，不会立即更新。React也正是通过状态队列实现了setState的异步更新，避免频繁的重复更新state。当React需要更新组件时，会将状态队列中的state合并后一次性更新组件，这样可以提高性能。</p><p>React函数组件中的state是通过useState()方法来更新的。useState()方法返回一个数组，第一个元素是当前state的值，第二个元素是更新state的函数。当执行更新state的函数时，会将需要更新的state合并后放入状态队列，不会立即更新。React也正是通过状态队列实现了useState的异步更新，避免频繁的重复更新state。当React需要更新组件时，会将状态队列中的state合并后一次性更新组件，这样可以提高性能。</p><p>在React18优化了批处理之后，state的更新都表现为异步的。</p><h2 id="React如何减少渲染次数？"><a href="#React如何减少渲染次数？" class="headerlink" title="React如何减少渲染次数？"></a>React如何减少渲染次数？</h2><ol><li>使用 <code>React.memo</code> 或 <code>PureComponent</code>：这些方法可以帮助组件实现浅比较，当组件的 props 没有发生变化时，避免不必要的重新渲染。</li><li>使用 <code>useCallback</code>：当需要将函数作为 props 传递给子组件时，可以使用 <code>useCallback</code> 缓存函数，避免在每次重新渲染时都创建新的函数。</li><li>尽可能地将组件拆分成更小的组件：这样可以避免不必要的重新渲染，提高组件的复用性。</li><li>避免在 <code>render</code> 方法中执行复杂的计算或操作：将复杂的计算或操作移到组件外部，或者使用 <code>useMemo</code> 或 <code>useEffect</code> 缓存计算结果。</li><li>避免在 <code>render</code> 方法中使用匿名函数：使用匿名函数会导致组件的重新渲染，因此尽可能地避免在 <code>render</code> 方法中使用匿名函数。</li></ol><h2 id="有哪些Hooks可以减少渲染次数？"><a href="#有哪些Hooks可以减少渲染次数？" class="headerlink" title="有哪些Hooks可以减少渲染次数？"></a>有哪些Hooks可以减少渲染次数？</h2><ol><li><code>React.memo</code>：这个 Hook 可以帮助函数组件进行浅比较，避免不必要的重新渲染。它接受一个组件作为参数，并返回一个新的组件，新组件会对原组件的 props 进行浅比较，当 props 没有发生变化时，避免不必要的重新渲染。</li><li><code>useCallback</code>：这个 Hook 可以缓存函数，避免在每次重新渲染时都创建新的函数。它接受一个函数和依赖项列表作为参数，并返回一个新的函数。当依赖项的值没有发生变化时，返回缓存的函数，否则返回新的函数。</li><li><code>useMemo</code>：这个 Hook 可以缓存计算结果，避免在每次重新渲染时都重新计算。它接受一个计算函数和依赖项列表作为参数，并返回计算结果。当依赖项的值没有发生变化时，返回缓存的计算结果，否则重新计算并返回新的结果。</li><li><code>useReducer</code>：这个 Hook 可以帮助管理组件的状态，并避免不必要的重新渲染。它接受一个 reducer 函数、初始状态和一个初始化函数作为参数，并返回一个包含状态和 dispatch 函数的数组。当状态发生变化时，只会重新渲染与状态相关的部分。</li><li><code>useMemoOne</code>：这个 Hook 可以缓存计算结果，避免在每次重新渲染时都重新计算。它类似于 <code>useMemo</code>，但是可以在渲染期间多次调用计算函数，并缓存计算结果。它接受一个计算函数和依赖项列表作为参数，并返回计算结果。</li></ol><h2 id="React的高阶组件是如何实现的？"><a href="#React的高阶组件是如何实现的？" class="headerlink" title="React的高阶组件是如何实现的？"></a>React的高阶组件是如何实现的？</h2><p>React高阶组件（Higher-Order Components，HOC）是一个函数，接收一个组件并返回一个增强版本的组件。它用于复用组件逻辑，可以用来实现代码复用、逻辑封装等。</p><p>React高阶组件的实现方式如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">higherOrderComponent</span>(<span class="hljs-params">WrappedComponent</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">React</span>.<span class="hljs-property">Component</span> &#123;<br>    <span class="hljs-comment">// 这里可以定义一些通用的逻辑</span><br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 在这里渲染被包裹的组件，并注入一些 props</span><br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> &#123;<span class="hljs-attr">...this.props</span>&#125; /&gt;</span></span>;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个例子演示了一个最基础的高阶组件实现方式。当组件使用这个高阶组件时，它将被包裹在高阶组件返回的类组件中。</p><p>使用这个高阶组件的方式如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EnhancedComponent</span> = <span class="hljs-title function_">higherOrderComponent</span>(<span class="hljs-title class_">BaseComponent</span>);<br></code></pre></td></tr></table></figure><p>这样，<code>EnhancedComponent</code> 就变成了增强版的 <code>BaseComponent</code>。</p><p>React高阶组件的应用有很多，例如：</p><ul><li>控制组件渲染</li><li>访问 React 组件的生命周期方法</li><li>将通用逻辑抽象为一个公共组件</li></ul><p>需要注意的是，使用高阶组件将会导致一些性能问题。因为每次渲染时，都可能会创建一个新的组件实例。为了解决这个问题，我们可以使用 <code>React.memo</code> 高阶函数对组件进行优化，使其只在依赖项发生变化时才进行更新，避免不必要的渲染。</p><h2 id="什么是React-Fiber？"><a href="#什么是React-Fiber？" class="headerlink" title="什么是React Fiber？"></a>什么是React Fiber？</h2><p>React Fiber是React v16中引入的一种新的协调引擎，用于重新设计和实现React的核心算法。它的目标是提高React的性能、灵活性和可扩展性。</p><p>React v15在渲染时,会递归比对 VirtualDOM树，找出需要变动的节点步更新它过程期间， React会占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，导致用户感觉到卡顿。</p><p>为了给用户制造一种应用很快的”假象”，不能让一个任务长期霸占着资源。可以将浏览器的渲染、布局、绘制、资源载、事件响应、脚本执行视作操作系统的”进程”，需要通过某些调策略合理地分配CPU资源，从而提高浏览器的用户响应速率，同时兼顾任务执行效率。</p><p>React通过Fiber架构，让这个执行过程变得可中断。适时的让出CPU执行权，除了可以让浏览器及时的响应用户的交互，还有一些好处：</p><ul><li>分批延时的对DOM进行操作，避免一次性操作大量DOM节点，可以获得更好的用户体验。</li><li>给浏览器一些喘息的机会，它会对代码进行编译优化 ( JIT ) 及热代码优化，或对 reflow 进行修正。</li></ul><p>React Fiber的主要特点包括：</p><ol><li>可中断的渲染：React Fiber可以在渲染过程中暂停、中断和恢复渲染，以支持更高优先级的任务，如动画和用户输入。</li><li>渐进式渲染：React Fiber可以将渲染过程分为多个阶段，并在每个阶段中执行一部分工作，以避免长时间的阻塞，提高用户体验。</li><li>异步渲染：React Fiber可以在不同的时间段内执行渲染，以支持异步渲染和服务器端渲染等场景。</li><li>更好的错误处理：React Fiber可以更好地捕获和处理错误，以提高应用程序的健壮性和可靠性。</li></ol><h2 id="hash路由和history路由的区别？"><a href="#hash路由和history路由的区别？" class="headerlink" title="hash路由和history路由的区别？"></a>hash路由和history路由的区别？</h2><ul><li><p>hash路由是通过触发并监听hashChange事件来实现前端路由的，改变hash可以直接通过location.hash &#x3D; xxx来改变；而history路由是通过history的各种API (history.pushState、history.replaceState) 等实现url的改变的，监听url的变化可以通过自定义事件触发实现。</p></li><li><p>hash路由兼容性好，支持所有的浏览器，而且可以实现前端路由的核心功能 (IE8以上)，但是ur不够美观；history路由url美观，可以利用浏览器的前进、后退等基本功能，但是兼容性不好(IE10以上)，需要浏览器支持HTML5的history API，同时需要服务器端支持，否则刷新页面会出现404错误。</p></li><li><p>history pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中。</p></li><li><p>history 进行刷新页面时，无法找到url对应的页面，会出现 404 问题。因为域名后面的路由是由前端控制的，后端只能保留域名部分，所以就会造成页面丢失的问题。</p></li></ul><h2 id="React中什么时候用history路由，什么时候用hash路由？"><a href="#React中什么时候用history路由，什么时候用hash路由？" class="headerlink" title="React中什么时候用history路由，什么时候用hash路由？"></a>React中什么时候用history路由，什么时候用hash路由？</h2><ul><li>如果需要兼容更老的路由，建议使用hash路由，history的兼容性较差。</li><li>如果希望url看起来更美观，建议使用history路由，不会在url中添加#字符。</li><li>如果需要更好的SEO(搜索引擎优化)，建议使用history路由，因为搜索引擎对hash路由中的#字符处理不太友好。</li><li>服务端渲染：如果需要在服务端渲染应用程序，建议使用history路由，因为服务端渲染需要在服务器上匹配URL。</li><li>前进&#x2F;后退：如果需要利用浏览器的前进&#x2F;后退等基本功能，建议使用history路由，因为hash路由中的#字符不会被浏览器记录到历史记录中。</li></ul><h2 id="React中hash路由与history路由的实现原理？"><a href="#React中hash路由与history路由的实现原理？" class="headerlink" title="React中hash路由与history路由的实现原理？"></a>React中hash路由与history路由的实现原理？</h2><p>Hash路由：通过监听<code>hashChange</code>事件，感知hash的变化，改变hash可以直接通过<code>location.hash = xxx</code>进行改变。</p><p>History路由：改变url需要通过<code>history.pushState</code>和<code>history.replaceState</code>等，会将url压入堆栈，同时能够适应<code>history.go()</code>等API，监听url的改变可以通过自定义事件触发实现。</p><h2 id="为什么history模式会出现404的情况？"><a href="#为什么history模式会出现404的情况？" class="headerlink" title="为什么history模式会出现404的情况？"></a>为什么history模式会出现404的情况？</h2><p>在使用 HTML5 History API 中的 history 模式时，如果不正确地设置服务器配置，就有可能出现 404 错误。<strong>这是因为在 history 模式下，浏览器的 URL 地址与后端服务器的路由地址是不同的，此时需要后端服务器做出相应的配置</strong>。</p><p>在 history 模式中，URL 会随着页面的跳转而发生变化，但实际上服务器只会返回同一个 HTML 文件，因此如果没有正确地配置服务器，当用户在浏览器中直接输入 URL 或者刷新浏览器时，服务器会根据该路径去查找对应的文件，但是由于该文件不存在于服务器中，所以就会返回 404 错误。</p><p>为了解决这个问题，我们需要在服务器端进行以下配置：</p><ol><li><p>配置重定向：在任何非文件资源请求的情况下，将所有请求都重定向到 index.html 文件上。这可以通过在服务器上设置一个统配符来完成。例如，如果使用 Apache 服务器，可以在 .htaccess 文件中添加以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs htaccess">&lt;IfModule mod_rewrite.c&gt;<br>  RewriteEngine On<br>  RewriteBase /<br>  RewriteRule ^index\.html$ - [L]<br>  RewriteCond %&#123;REQUEST_FILENAME&#125; !-f<br>  RewriteCond %&#123;REQUEST_FILENAME&#125; !-d<br>  RewriteRule . /index.html [L]<br>&lt;/IfModule&gt;<br></code></pre></td></tr></table></figure></li><li><p>配置404.html文件：将服务器上的默认错误页面更改为自定义的错误页面。在这个自定义的错误页面中，我们可以在页面中使用 JavaScript 来动态获取页面路径并重定向到正确的路径上。</p></li></ol><p>以上两种配置方式可以解决 history 模式中出现 404 错误的问题，确保每个路由的请求都被正确地处理。</p><h2 id="什么是虚拟DOM？"><a href="#什么是虚拟DOM？" class="headerlink" title="什么是虚拟DOM？"></a>什么是虚拟DOM？</h2><p>虚拟DOM（Virtual DOM）是指一种构建在内存中的、轻量级的虚拟节点树。在React等某些JavaScript框架中，组件经常被定义为一个虚拟的数据结构，它们包含了组件的状态和属性，但是没有DOM元素。当一个组件的状态发生改变时，虚拟DOM会在内存中重新构建一棵树，然后与之前的树进行比较，找出两棵树中不同的部分并更新到实际的DOM上，从而实现了页面内容的更新。</p><p>虚拟DOM的优点在于：</p><ol><li>减少DOM操作次数：通过计算前后两次虚拟DOM树的差异，只更新差异的部分，而不是整个页面都进行重绘，从而避免了一些性能上的浪费。</li><li>提高渲染效率：虚拟DOM可以根据需要进行分类，一个虚拟节点上所包含的真实节点也只会在其附近需要更新的时候才会被添加到真实的DOM树中。</li><li>更好地实现跨平台：虚拟DOM的本质是一个跨平台的数据结构，可以轻松地在不同平台和环境中实现页面的构建和渲染，例如React Native就是利用虚拟DOM实现的。</li></ol><p>虚拟DOM的实现过程一般包括三个步骤：生成虚拟DOM树、对比新旧虚拟DOM树、更新真实DOM树。虽然虚拟DOM有些许性能上的消耗，但是在复杂的应用场景下，它还是展现出了出色的性能优势。</p><h2 id="React为什么要使用虚拟DOM？"><a href="#React为什么要使用虚拟DOM？" class="headerlink" title="React为什么要使用虚拟DOM？"></a>React为什么要使用虚拟DOM？</h2><p>提高性能和开发效率。</p><p>传统的DOM操作是非常耗费性能的，因为每次更新DOM都需要重新计算布局、绘制等操作，而且频繁的DOM操作会导致页面卡顿和性能下降。而虚拟DOM是在内存中维护一个虚拟的DOM树，通过对比新旧虚拟DOM树的差异，最终只更新需要更新的部分，从而减少DOM操作次数，提高性能。</p><p>此外，使用虚拟DOM还可以提高开发效率。开发者可以通过JSX语法编写组件，将组件的状态和属性传递给虚拟DOM，React会根据虚拟DOM自动更新组件的状态，从而减少了手动操作DOM的代码量，提高了开发效率。</p><h2 id="React的diffing算法-比如从ABCD变为BADC，具体是移动还是销毁？"><a href="#React的diffing算法-比如从ABCD变为BADC，具体是移动还是销毁？" class="headerlink" title="React的diffing算法 比如从ABCD变为BADC，具体是移动还是销毁？"></a>React的diffing算法 比如从ABCD变为BADC，具体是移动还是销毁？</h2><p>如果节点没有发生变化，只是位置发生了变化，会对它们进行移动而不是销毁。</p><p><strong>React允许开发者对同一层级的同组子节点，添加唯一 key 进行区分。</strong></p><p>当同一层级的某个节点添加了对于其他同级节点唯一的key属性，当它在<strong>当前层级</strong>的位置发生了变化后。react diff算法通过新旧节点比较后，<strong>如果发现了key值相同的新旧节点，就会执行移动操作（然后依然按原策略深入节点内部的差异对比更新），而不会执行原策略的删除旧节点，创建新节点的操作。</strong>这无疑大大提高了React性能和渲染效率。</p><p>在具体的执行过程中，首先会对新集合中的节点进行遍历循环，通过唯一的key判断新旧节点中是否存在相同的节点，如果存在则进行移动操作，但是在移动操作之前需要将当前节点在旧几个中的位置与lastIndex进行比较 <code>if(child._mountIndex &lt; lastIndex)</code>，否则不执行该操作。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe044edaaf28439c9d4afba753690eb9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="同一层级中所有节点只发生了位置变化"></p><p>按新集合中顺序开始遍历</p><ol><li>B在新集合中 lastIndex(类似浮标) &#x3D; 0, 在旧集合中 index &#x3D; 1，index &gt; lastIndex 就认为 B 对于集合中其他元素位置无影响，不进行移动，之后lastIndex &#x3D; max(index, lastIndex) &#x3D; 1</li><li>A在旧集合中 index &#x3D; 0， 此时 lastIndex &#x3D; 1, 满足 index &lt; lastIndex, 则对A进行移动操作，此时lastIndex &#x3D; max(Index, lastIndex) &#x3D; 1</li><li>D和B操作相同，同(1)，不进行移动，此时lastIndex&#x3D;max(index, lastIndex) &#x3D; 3</li><li>C和A操作相同，同(2)，进行移动，此时lastIndex &#x3D; max(index, lastIndex) &#x3D; 3</li></ol><p>如果同一层级中的节点不仅发生了位置变化，还发生了节点增删：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83a71d590dce4999a0320e7d7ba7bacd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="不仅发生了位置变化，还发生了节点增删"></p><ol><li>同上面那种情形，B不进行移动，lastIndex&#x3D;1</li><li>新集合中取得E,发现旧中不存在E，在 lastIndex处<strong>创建</strong>E，lastIndex++</li><li>在旧集合中取到C，C不移动，lastIndex&#x3D;2</li><li>在旧集合中取到A，A移动到新集合中的位置，lastIndex&#x3D;2</li><li>完成新集合中所有节点diff后，对旧集合进行循环遍历，寻找新集合中不存在但就集合中的节点(此例中为D)，删除D节点。</li></ol><p><strong>是否推荐使用遍历时的index作为key属性值？</strong></p><p>React官方建议不要用遍历的index作为这种场景下的节点的key属性值。比如当前遍历的所有节点类型都相同，其内部文本不同，在用index作key的情况下，当我们对原始的数据list进行了某些元素的顺序改变操作，导致了新旧集合中在进行diff比较时，相同index所对应的新旧的节点其文本不一致了，就会出现一些节点需要更新渲染文本，而如果用了其他稳定的唯一标识符作为key，则只会发生位置顺序变化，无需更新渲染文本，提升了性能。</p><p><strong>key机制的缺陷：</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce6eb05a24674c51943127fcde856d34~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="只有D节点位置变化"></p><p>如图 所示，若新集合的节点更新为 D、A、 B、C，与旧集合相比只有 D 节点移动，而 A、B、C 仍然保持原有的顺序，理论上 diff 应该只需对 D 执行移动操作，然而由于 D 在旧集合中的位置是最大的，导致其他节点的 _mountIndex &lt;lastIndex，造成 D 没有执行移动操作，而是 A、B、C 全部移动到 D 节点后面的现象。</p><p><strong>在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作。当节点数量过大或更新操作过于频繁时，这在一定程度上会影响 React 的渲染性能。</strong></p><p><strong>key使用注意事项：</strong></p><ol><li>如果遍历的列表子节是作为纯展示，而不涉及到列表元素顺序的动态变更，那使用index作为key还是没有问题的。</li><li>key只是针对同一层级的节点进行了diff比较优化，而跨层级的节点互相之间的key值没有影响</li><li>大部分情况下，通过遍历的同一层级的使用了key属性的元素节点其节点类型是相同的（比如都是span元素或者同一个组件）。如果存在新旧集合中，相同的key值所对应的节点类型不同（比如从span变成div），这相当于完全替换了旧节点，删除了旧节点，创建了新节点。</li><li>如果新集合中，出现了旧集合没有存在过的key值。例如某个节点的key之前为1，现在为100，但旧集合中其他节点也没有使用100这个key值。说明没发生过移动操作，此时diff算法会对对应的节点进行销毁并重新创建。这在一些场景中会比较有用（比如重置某个组件的状态）</li><li>key值在比较之前都会被执行toString()操作，所以尽量不要使用object类型的值作为key，会导致同一层级出现key值相同的节点。key值重复的同一类型的节点或组件很可能出现拷贝重复内部子元素的问题。</li></ol><p>参考：[React虚拟DOM、Diff算法与Key机制](</p><h2 id="React虚拟DOM的Diff算法？"><a href="#React虚拟DOM的Diff算法？" class="headerlink" title="React虚拟DOM的Diff算法？"></a>React虚拟DOM的Diff算法？</h2><p>React中的虚拟DOM和diff算法是为了提高渲染效率而设计的。虚拟DOM是一种编程概念，UI以一种理想化的、或者说“虚拟的”表现形式存在于内存中，而不是真实的DOM树。当状态发生变化时，React会通过diff算法比较新旧虚拟DOM树的差异，然后只更新需要更新的部分，从而避免了全量渲染，提高了渲染效率。</p><p>React中的diff算法是通过比较新旧虚拟DOM树的差异来确定需要更新的节点。diff算法会遍历新旧虚拟DOM树，对比它们的节点，然后根据节点的变化情况来更新真实DOM。React中的diff算法是基于两个假设：同一层级的两个节点可以通过唯一的id进行区分；同一层级的节点可以通过位置进行区分。React中的diff算法是一个递归算法，它会递归遍历新旧虚拟DOM树，对比它们的节点，然后根据节点的变化情况来更新真实DOM。如果两个节点不同，则会直接替换掉旧节点，如果两个节点相同，则会更新该节点。</p><p><strong>查找需要更新的节点是从尾节点找还是头节点找还是中间二分择半？</strong></p><p>React的Diff算法进行虚拟节点比较是从头部开始，然后依次向后比较，直到找到不同的节点位置。如果新旧虚拟节点的数量不同，则从尾部开始比较，直到找到不同的节点为止。</p><h2 id="React-Diff算法的实现细节？"><a href="#React-Diff算法的实现细节？" class="headerlink" title="React Diff算法的实现细节？"></a>React Diff算法的实现细节？</h2><p>React Diff算法是指React通过比较前后两次的虚拟DOM树来计算出真实DOM树中需要更新的节点，从而提高渲染性能的算法。</p><p>React Diff算法的实现细节如下：</p><ol><li>只会在同一个节点（即相同的组件）之间进行比较：React会判断新旧两个节点是否相同，如果不同，则直接暴力删除旧节点，新增一个新节点，重新创建所有子节点，这时会丢失所有DOM节点上的状态。如果相同，则继续下一步比较。</li><li>对属性进行比较：React比较前后两次虚拟DOM节点的属性，只更新有改变的属性，提高渲染效率。</li><li>采用“key”进行优化：在对列表进行Diff算法时，通过给每一个单独的列表项加上唯一的“key”属性，可以更快速精准地找出需要更新的节点。</li><li>对子节点进行递归比较：当两个节点的属性相同且节点类型相同时，React会对它们的子节点进行递归比较，找出需要更新的子节点。</li><li>按顺序更新子节点：React将之前生成的虚拟DOM节点数组与新的虚拟DOM节点数组进行比较，找出需要更新、新增和删除的节点，并按顺序更新节点。</li></ol><h2 id="React过期闭包了解过吗？"><a href="#React过期闭包了解过吗？" class="headerlink" title="React过期闭包了解过吗？"></a>React过期闭包了解过吗？</h2><p>React过期闭包是指在使用React Hook时，由于函数组件多次render之间，函数的闭包可能会包住过期的上下文，也就是之前render时的上下文。这个问题在应用Hooks更突出。</p><p>React解决过期闭包问题的方法是依赖数组。针对过期state，可以使用函数的方法更新值。React确保通过更新函数可以得到最新的state值。</p><h2 id="React中父组件如何向子孙组件传值？"><a href="#React中父组件如何向子孙组件传值？" class="headerlink" title="React中父组件如何向子孙组件传值？"></a>React中父组件如何向子孙组件传值？</h2><ul><li>props</li><li>useContext</li></ul><h2 id="子孙组件如何修改通过useContext获取到的值？"><a href="#子孙组件如何修改通过useContext获取到的值？" class="headerlink" title="子孙组件如何修改通过useContext获取到的值？"></a>子孙组件如何修改通过useContext获取到的值？</h2><p>在父组件中定义一个state，然后将state和其更新方法一起传递给context对象，然后再需要的时候调用该函数修改state。</p><p>例如：在App.jsx中定义count，并将其传递给Context</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; createContext, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Father</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Father&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> C = <span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">C.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;count,</span> <span class="hljs-attr">setCount</span>&#125;&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Father</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">C.Provider</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在Father组件中引用Son组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../Son&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Son</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Son</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>最终在子组件中展示count以及修改count</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; C &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../App&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;count, setCount&#125; = <span class="hljs-title function_">useContext</span>(C);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>count的值为&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count+1)&#125;&gt;点我+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="context封装的值改变了，会触发组件的重新渲染吗？"><a href="#context封装的值改变了，会触发组件的重新渲染吗？" class="headerlink" title="context封装的值改变了，会触发组件的重新渲染吗？"></a>context封装的值改变了，会触发组件的重新渲染吗？</h2><p>在 React 中，当一个组件被包裹在一个 Context Provider 中时，只有当该组件<strong>直接依赖于该 Context 数据</strong>时，才会在 Context 数据发生变化时重新渲染。</p><p>如果一个组件被包裹在一个 Context Provider 中，但是它并没有使用该 Context 数据，那么该组件不会在 Context 数据发生变化时重新渲染。</p><p>这是因为 React 使用了优化算法来避免不必要的重新渲染，也就是说，只有当组件的 props 或者 state 发生变化时，才会触发重新渲染。而对于 Context 数据的变化，只有当该 Context 数据被使用的组件才会重新渲染。</p><h2 id="假如在某个子孙组件中-使用了-useEffect-其依赖项中记录了某个-context-当-context-值变了-会触发-useEffect-内包裹的函数执行吗-会触发该组件的重新渲染吗"><a href="#假如在某个子孙组件中-使用了-useEffect-其依赖项中记录了某个-context-当-context-值变了-会触发-useEffect-内包裹的函数执行吗-会触发该组件的重新渲染吗" class="headerlink" title="假如在某个子孙组件中, 使用了 useEffect, 其依赖项中记录了某个 context, 当 context 值变了, 会触发 useEffect 内包裹的函数执行吗? 会触发该组件的重新渲染吗?"></a>假如在某个子孙组件中, 使用了 useEffect, 其依赖项中记录了某个 context, 当 context 值变了, 会触发 useEffect 内包裹的函数执行吗? 会触发该组件的重新渲染吗?</h2><p>使用useEffect包裹context的值，当context的值发生变化会触发useEffect包裹的函数执行，即使props和state没有发生变化，也会导致该组件的重新渲染，但是如果使用React.memo包裹就不会导致组件重新渲染了。</p><h2 id="为什么使用Redux进行状态管理？"><a href="#为什么使用Redux进行状态管理？" class="headerlink" title="为什么使用Redux进行状态管理？"></a>为什么使用Redux进行状态管理？</h2><ul><li><strong>Redux使状态可预测。</strong>传递相同的状态和动作传递给减速器，总会产生相同的结果，因为减速器是纯函数。</li><li><strong>Redux方便维护。</strong>Redux对代码的组织方式很严格，结构更容易理解，维护更加方便。同时有利于用户将业务逻辑与组件树分离。</li><li><strong>Redux调试简单。</strong>Redux使调试程序变得简单，通过记录操作和状态，很容易理解编码错误、网络错误和生产过程中出现的其他形式的错误。</li><li><strong>Redux有性能优势。</strong>Redux内部实现了很多优化，因此我们自己的连接组件仅在实际需要时才重新渲染。</li><li><strong>数据持久化。</strong></li><li><strong>Redux还能用于服务端渲染。</strong>我们可以通过将应用程序的状态连同它对服务器请求的响应发送到服务器来处理应用程序的初始呈现，然后所需组件以HTML格式呈现并发送到客户端。</li></ul><h2 id="Redux一般用于存储哪些数据？"><a href="#Redux一般用于存储哪些数据？" class="headerlink" title="Redux一般用于存储哪些数据？"></a>Redux一般用于存储哪些数据？</h2><p>全局公共数据用Redux进行管理，局部状态用state和props即可。</p><ol><li>全局状态数据：如果一个状态数据<strong>需要在多个组件中共享并且需要管理其生命周期</strong>，那么这个状态数据则适合使用 Redux 进行存储。</li><li>非父子组件之间共享的状态数据：如果一个状态数据需要<strong>在非父子关系的组件之间共享</strong>，也可以考虑使用 Redux 进行存储。</li><li>异步数据：如果一个数据需要进行异步操作（如网络请求），那么使用 Redux 可以<strong>更好地管理请求的状态和结果</strong>。</li><li>路由状态：如果需要<strong>在应用程序的路由之间共享状态</strong>，那么 Redux 也是一个不错的选择。</li><li>调试信息：Redux 提供了强大的时间旅行调试工具，可以记录和回放应用程序状态的变化，帮助我们更好地调试应用程序。</li></ol><h2 id="Redux使用流程及场景？"><a href="#Redux使用流程及场景？" class="headerlink" title="Redux使用流程及场景？"></a>Redux使用流程及场景？</h2><ol><li>安装Redux。</li><li>创建一个store，store是一个对象，它有四个方法：dispatch、subscribe、getState和replaceReducer。</li><li>定义action，action是一个普通的JavaScript对象，用来描述发生了什么。</li><li>定义reducer，reducer是一个纯函数，接收旧的state和action，返回新的state。</li><li>使用combineReducers将多个reducer合并成一个根reducer。</li><li>使用Provider组件将store传递给子组件。</li><li>在组件中使用connect函数连接store和组件。</li></ol><h2 id="Redux的实现原理？"><a href="#Redux的实现原理？" class="headerlink" title="Redux的实现原理？"></a>Redux的实现原理？</h2><p><code>Redux</code> 的实现原理可以概括为：单一数据源、状态不可变、纯函数更新状态。</p><p>具体来说，<code>Redux</code> 将应用程序的状态存储在一个单一的对象中，称为<code>store</code>。这个<code>store</code>对象是只读的，应用程序的状态只能通过派发“action”来改变。每个“action”描述了应用程序中发生的某个事件，它包含一个类型和一些数据。当派发一个<code>action</code>时，<code>Redux</code> 会将当前的状态和“action”一起传递给一个“reducer”函数，这个函数根据“action”的类型来更新状态，并返回一个新的状态对象。<code>Redux</code> 的状态更新是纯函数式的，它不会直接修改原来的状态，而是返回一个新的状态对象，从而保证了状态的不可变性。</p><p><code>Redux</code> 还提供了一些辅助函数，如<code>connect</code>和<code>mapStateToProps</code>，用于将<code>store</code>中的状态映射到组件的属性中，并在状态变化时自动更新组件。这些函数也是基于纯函数的原理实现的。</p><h2 id="为什么Redux要设计action等工具，而不是允许用户直接进行修改？"><a href="#为什么Redux要设计action等工具，而不是允许用户直接进行修改？" class="headerlink" title="为什么Redux要设计action等工具，而不是允许用户直接进行修改？"></a>为什么Redux要设计action等工具，而不是允许用户直接进行修改？</h2><p>设计action等工具是为了更好的管理状态。通过使用action，可以确保状态的变化是可预测的，因为它们只能通过dispatch函数进行更改，这样可以避免在应用程序中出现意外的状态变化，从而使代码更具有可维护性和可测试性。此外，使用action还可以使我们更好的跟踪应用程序中发生的事情，因为每个action都有唯一的标识符，可以轻松跟踪它们。</p><h2 id="组件库是如何实现让用户按需加载的？"><a href="#组件库是如何实现让用户按需加载的？" class="headerlink" title="组件库是如何实现让用户按需加载的？"></a>组件库是如何实现让用户按需加载的？</h2><p>通过支持基于ES模块的tree shaking来实现按需加载。只需要直接引入需要的组件，就可以实现按需加载的效果。</p><h2 id="为什么要设计ElementUI、Ant-Design等组件库？"><a href="#为什么要设计ElementUI、Ant-Design等组件库？" class="headerlink" title="为什么要设计ElementUI、Ant Design等组件库？"></a>为什么要设计ElementUI、Ant Design等组件库？</h2><ol><li><p>提高开发效率：组件库的设计和开发是为了解决重复工作，使用现有组件能够<strong>加快开发速度，减少重复工作量，提高开发效率</strong>。</p></li><li><p>提高代码可维护性：组件库的使用能够<strong>使得代码更加规范化，便于维护</strong>，同时也避免了代码重复，减轻了开发人员负担。</p></li><li><p>优化用户体验：设计的组件库对UI、交互、动效等方面进行了深入优化，可以帮助开发人员打造出<strong>更好的用户体验</strong>。</p></li><li><p>响应式设计：组件库<strong>具有响应式的特性，能够满足不同尺寸和设备的适配需求</strong>，提高网站或应用的可用性。</p></li><li><p>节省开发成本：使用现成组件库可以<strong>节省开发成本和人力成本</strong>，既可以降低开发难度和技术门槛，也可以降低公司的开发成本。</p></li></ol><h2 id="设计组件库有哪些注意事项？"><a href="#设计组件库有哪些注意事项？" class="headerlink" title="设计组件库有哪些注意事项？"></a>设计组件库有哪些注意事项？</h2><ol><li>UI和交互设计：组件库的设计需要遵循良好的UI设计和交互设计原则，提供<strong>良好的用户体验，包括直观的视觉指引、简单易懂的界面、良好的交互反馈</strong>等。</li><li>组件设计：在设计组件时，需要考虑组件的基础特性、定位、使用场景、可扩展性、可定制性等，同时要有充分的用户体验测试。</li><li>兼容性：组件库要考虑到<strong>各种浏览器和设备的兼容性</strong>，建议采用<strong>响应式设计和渐进增强</strong>的设计策略。</li><li>文档和示例：组件库需要完善的文档和示例，<strong>方便开发人员使用和调试</strong>，避免不必要的耗时。</li><li>维护和更新：组件库需要持续的维护和更新，包括bug修复、功能增强、安全性更新等，保证组件库的<strong>稳定性和可靠性</strong>。</li><li>样式管理：组件库的样式需要考虑到<strong>全局样式管理和组件内部样式的优化</strong>，防止出现样式冲突和不必要的CSS代码重复。</li><li>可重用性：组件库的组件应尽可能保持独立性，便于<strong>在不同的应用中重复使用</strong>。</li></ol><h2 id="开发组件库的过程中有什么难点？"><a href="#开发组件库的过程中有什么难点？" class="headerlink" title="开发组件库的过程中有什么难点？"></a>开发组件库的过程中有什么难点？</h2><ol><li>设计阶段：在组件库的设计阶段，需要考虑到组件的<strong>丰富性和可用性</strong>，以及<strong>组件间的协调和统一性</strong>，需要在设计和开发之前进行充分的需求分析和用户调研。</li><li>兼容性：组件库需要考虑到各<strong>种浏览器和设备的兼容性</strong>，包括浏览器的版本不同、设备分辨率不同等，需要进行多个平台的测试。</li><li>在多个项目中使用：组件库的组件需要在多个项目中使用，因此需要满足<strong>通用性</strong>的需求，同时需要保证可维护性，以便在多个项目中进行更新和升级。</li><li>长期维护：组件库需要考虑到长期维护的需求，需要进行<strong>稳定性的测试和更新</strong>。</li><li>性能优化：组件库需要考虑到性能优化的问题，<strong>避免在页面中渲染过多的组件和数据</strong>，同时需要对组件库进行<strong>代码分离和按需加载</strong>等优化。</li><li>API的设计：组件库的API设计需要充分考虑到<strong>不同需求下的定制性和扩展性</strong>，同时需要保证API的易用性和一致性。</li><li>文档和示例：组件库需要考虑到文档和示例的编写和更新，以便开发者能够快速地掌握组件库的使用方法。</li></ol><h2 id="Ant-Design组件库是怎么实现的？"><a href="#Ant-Design组件库是怎么实现的？" class="headerlink" title="Ant Design组件库是怎么实现的？"></a>Ant Design组件库是怎么实现的？</h2><ol><li>核心代码实现：Ant Design的核心代码实现是基于React框架，使用TypeScript语言编写，使用webpack进行打包。代码中主要包含了不同组件的实现，包括表单、按钮、导航、布局等。</li><li>样式实现：Ant Design的样式实现主要是基于Less预处理器进行开发，使用了变量、混入、嵌套等功能。通过变量的定义和使用，实现了全局的样式风格的统一。同时，还使用一些第三方的CSS库，如Normalize.css和iconfont等。</li><li>工具库：Ant Design中有一个封装了常用工具函数的utility库，此库包括类型检测、数据处理、字符串处理、时间处理等常用方法，并对一些方法进行了二次封装，方便调用。</li><li>国际化实现：Ant Design支持多语言和多区域的国际化，其实现基于react-intl库，通过对不同语言的国际化配置，实现组件中文本的切换。</li><li>文档和示例：Ant Design的文档和示例基于dumi库进行生成，同时还有一个在线的交互式示例网站Ant Design Pro，用户可以通过此网站直接预览和体验各个组件。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Spring Recruitment</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript知识点总结</title>
    <link href="/2023/04/25/JavaScript%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/25/JavaScript%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript相关"><a href="#JavaScript相关" class="headerlink" title="JavaScript相关"></a>JavaScript相关</h1><h2 id="JS的数据类型有哪些？"><a href="#JS的数据类型有哪些？" class="headerlink" title="JS的数据类型有哪些？"></a>JS的数据类型有哪些？</h2><p>Null、Undefined、Number、String、Boolean、Symbol、BigInt、Object。</p><h2 id="JS的引用数据类型有哪些？"><a href="#JS的引用数据类型有哪些？" class="headerlink" title="JS的引用数据类型有哪些？"></a>JS的引用数据类型有哪些？</h2><p>对象(Object)、数组(Array)和函数(Function)</p><h2 id="JS中Number的最大值返回的是什么？"><a href="#JS中Number的最大值返回的是什么？" class="headerlink" title="JS中Number的最大值返回的是什么？"></a>JS中Number的最大值返回的是什么？</h2><p>Number类型的最大值可以通过Number.MAX_VALUE常量获取，该常量的值接近于1.79e+308。超过这个值的数值将被表示为Infinity（正无穷）。</p><p>例如，可以使用以下代码来检查Number类型的最大值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span>); <span class="hljs-comment">// 输出1.7976931348623157e+308</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 输出Infinity</span><br></code></pre></td></tr></table></figure><p>需要注意的是，JavaScript中的Number类型是一种双精度浮点数，它的表示范围和精度是有限的，不能精确表示所有的数值。在进行数值计算时，需要特别注意数值的精度和范围，避免出现不必要的错误。</p><h2 id="什么是JS的包装类型？"><a href="#什么是JS的包装类型？" class="headerlink" title="什么是JS的包装类型？"></a>什么是JS的包装类型？</h2><p>JavaScript的包装类型（Wrapping Objects）指的是将基本数据类型（例如字符串、数字、布尔值等）通过包装类（String、Number、Boolean）转换为对象。这样，我们就可以使用对象的方法和属性来操作基本数据类型。</p><p>Number包装类型有哪些方法？</p><ol><li>toExponential(): 将数字转换为指数计数形式的字符串。</li><li>toFixed(): 将数字转换为字符串，保留指定位数的小数。</li><li>toLocaleString(): 将数字转换为指定地区的格式化字符串。</li><li>toPrecision(): 将数字转换为字符串，将字符串中数字的总位数限制为指定的数字。</li><li>toString(): 将数字转换为字符串。</li><li>valueOf(): 返回数字的原始值。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//定义一个数字</span><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">123.456</span>;<br><br><span class="hljs-comment">// toExponential()</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toExponential</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// &quot;1.23e+2&quot;</span><br><br><span class="hljs-comment">// toFixed()</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// &quot;123.46&quot;</span><br><br><span class="hljs-comment">// toLocaleString()</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">&#x27;en-US&#x27;</span>)); <span class="hljs-comment">// &quot;123.456&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">&#x27;de-DE&#x27;</span>)); <span class="hljs-comment">// &quot;123,456&quot;</span><br><br><span class="hljs-comment">// toPrecision()</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toPrecision</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// &quot;123.46&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toPrecision</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// &quot;1.2e+2&quot;</span><br><br><span class="hljs-comment">// toString()</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// &quot;123.456&quot;</span><br><br><span class="hljs-comment">// valueOf()</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">valueOf</span>()); <span class="hljs-comment">// 123.456</span><br></code></pre></td></tr></table></figure><h2 id="类方法和实例方法有什么不同？"><a href="#类方法和实例方法有什么不同？" class="headerlink" title="类方法和实例方法有什么不同？"></a>类方法和实例方法有什么不同？</h2><ol><li>对象与类的调用方式不同：实例方法是对象调用的，类方法是类直接调用的。</li><li>实例方法与类方法的传参不同：实例方法通常至少有一个self参数，表示实例本身，可以访问实例的属性和方法；而类方法通常至少有一个cls参数，表示类本身，可以访问类的属性和方法。</li><li>实例方法执行的上下文不同：实例方法的执行上下文是实例对象，可以在执行过程中修改实例对象的属性和方法；而类方法的执行上下文是类对象，而不是实例对象，所以无法在执行过程中修改实例对象的属性和方法。</li></ol><h2 id="判断数据类型的方式有哪些？"><a href="#判断数据类型的方式有哪些？" class="headerlink" title="判断数据类型的方式有哪些？"></a>判断数据类型的方式有哪些？</h2><ul><li>typeof</li><li>constructor</li><li>instanceof</li><li>Object.prototype.toString.call</li></ul><h2 id="instanceof有什么缺点？"><a href="#instanceof有什么缺点？" class="headerlink" title="instanceof有什么缺点？"></a>instanceof有什么缺点？</h2><ol><li>instanceof无法检测基本数据类型：instanceof只能检测对象类型，对于基本数据类型（如number、string、boolean等）无法进行检测。</li><li>instanceof无法检测null和undefined：当使用instanceof检测null或undefined时，会抛出TypeError错误。</li><li>instanceof无法检测继承自同一父类的对象：如果两个不同的对象继承自同一个父类，那么使用instanceof检测时会返回true，这可能会导致一些问题。</li><li>instanceof无法检测跨iframe的对象：当对象跨越不同的iframe时，使用instanceof检测时会返回false，这是因为不同的iframe拥有不同的全局环境。</li><li>instanceof无法检测自定义对象：如果没有正确地实现对象的原型链，那么使用instanceof检测时可能会出现错误的结果。</li></ol><h2 id="为什么typeof返回的是Number"><a href="#为什么typeof返回的是Number" class="headerlink" title="为什么typeof返回的是Number?"></a>为什么typeof返回的是Number?</h2><p>因为NaN是一种特殊的数值，它表示一个非数值的数值（Not-a-Number）。虽然NaN不是一个有效的数值，但它仍然属于数值类型，因此typeof NaN返回的是Number。</p><p>需要注意的是，虽然NaN属于数值类型，但它与任何值都不相等，包括它本身。这是因为NaN与任何值都不相等的特殊规定。因此，在比较值是否相等时，需要特别注意NaN的情况。可以使用isNaN函数来判断一个值是否为NaN。</p><h2 id="JS常见的定义变量的方式有哪些？"><a href="#JS常见的定义变量的方式有哪些？" class="headerlink" title="JS常见的定义变量的方式有哪些？"></a>JS常见的定义变量的方式有哪些？</h2><ul><li>let</li><li>const </li><li>var</li><li>function</li><li>class</li></ul><h2 id="var、let和const的区别？"><a href="#var、let和const的区别？" class="headerlink" title="var、let和const的区别？"></a>var、let和const的区别？</h2><ol><li><p>变量作用域</p><p>var会有变量提升的问题，即变量可以在代码块之外进行访问。而let和const都是块级作用域的，只能在相应的代码块内部使用。</p></li><li><p>变量的赋值</p><p>var和let都支持对变量进行重新赋值，而const定义的变量是不允许重新赋值的，赋值会导致 SyntaxError 错误。</p></li><li><p>声明的变量是否具有初始值</p><p>var 和 let 可以在声明的时候不赋初值，在需要的时候赋值。而 const 声明的常量必须在声明时赋初值，不然会导致 SyntaxError 错误。</p></li><li><p>作用域提升</p><p>由于变量提升，使用 var 声明的变量可以在声明之前使用。而使用 let 和 const 的变量不会有这种情况，如果在声明之前使用会导致 ReferenceError 错误。</p></li></ol><p>在开发中，建议优先使用 let 和 const 关键字来定义变量，因为它们具备严格的作用域和赋值规则，利于编写可维护和可读性高的代码。只有在需要兼容较老版本的浏览器或在需要变量提升的特殊情况下，才考虑使用 var 关键字。</p><h2 id="对JS中继承的理解？"><a href="#对JS中继承的理解？" class="headerlink" title="对JS中继承的理解？"></a>对JS中继承的理解？</h2><p>一个对象（子类）可以从另一个对象（父类）继承属性和方法。子类可以使用父类的方法和属性，也可以添加自己的方法和属性。JS中的继承可以通过原型链实现，子类的原型指向父类的实例，这样子类就可以继承父类的属性和方法。另外，ES6中也提供了class关键字来实现继承。子类通过extends关键字继承父类，并可以使用super关键字来调用父类的方法和属性。继承在JS中是非常常见的概念，它可以提高代码的复用性和可维护性。</p><h2 id="实现继承有哪些方式？"><a href="#实现继承有哪些方式？" class="headerlink" title="实现继承有哪些方式？"></a>实现继承有哪些方式？</h2><ol><li><p>原型链继承</p><p>原型链继承是通过将父类的实例作为子类的原型来实现继承。这种方法的缺点是子类实例共享父类实例的属性和方法，无法实现多继承。</p></li><li><p>借用构造函数继承</p><p>借用构造函数继承是通过在子类构造函数中调用父类构造函数来实现继承。这种方法的缺点是无法继承父类原型上的属性和方法。</p></li><li><p>组合继承</p><p>组合继承是通过将原型链继承和借用构造函数继承结合起来实现继承。这种方法的缺点是在创建子类实例时会调用两次父类构造函数，造成一定的性能浪费。</p></li><li><p>原型式继承</p><p>原型式继承是通过创建一个临时的构造函数，将父类实例作为该构造函数的原型，然后返回该构造函数的实例来实现继承。这种方法的缺点是无法传递参数，无法实现多继承。</p></li><li><p>寄生式继承</p><p>寄生式继承是通过在原型式继承的基础上，对实例进行扩展来实现继承。这种方法的缺点也是无法传递参数，无法实现多继承。</p></li><li><p>寄生组合式继承</p><p>寄生组合式继承是通过在组合继承的基础上，优化父类构造函数的调用，来实现继承。这种方法的优点是既能够继承父类原型上的属性和方法，又能够避免调用两次父类构造函数，性能更优。</p></li></ol><h2 id="在给DOM元素做事件委托的时候，如何判断要对哪个子元素进行操作处理？"><a href="#在给DOM元素做事件委托的时候，如何判断要对哪个子元素进行操作处理？" class="headerlink" title="在给DOM元素做事件委托的时候，如何判断要对哪个子元素进行操作处理？"></a>在给DOM元素做事件委托的时候，如何判断要对哪个子元素进行操作处理？</h2><p>通过event.target实时获取到用户点击的子元素，并对该子元素进行操作处理。</p><h2 id="操作DOM的时候，如何给节点添加兄弟节点？"><a href="#操作DOM的时候，如何给节点添加兄弟节点？" class="headerlink" title="操作DOM的时候，如何给节点添加兄弟节点？"></a>操作DOM的时候，如何给节点添加兄弟节点？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取当前元素</span><br><span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;box&quot;</span>);<br><span class="hljs-comment">// 创建新元素</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;a&quot;</span>);<br><span class="hljs-comment">// 设置元素内容</span><br>a.<span class="hljs-property">href</span> = <span class="hljs-string">&quot;www.abc.com&quot;</span>;<br>a.<span class="hljs-property">innerText</span> = <span class="hljs-string">&quot;ABC&quot;</span>;<br><span class="hljs-comment">// 添加元素到box中</span><br>box.<span class="hljs-title function_">appendChildren</span>(a); <span class="hljs-comment">// 给父元素添加子元素</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;p&quot;</span>);<br>box.<span class="hljs-title function_">insertBefore</span>(p, a); <span class="hljs-comment">// 假设box中存在p元素，在p元素前面插入a元素</span><br><span class="hljs-comment">// 获取克隆元素</span><br><span class="hljs-keyword">const</span> cloneP = p.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 默认参数为false,是狗采用深度克隆</span><br>box.<span class="hljs-title function_">appendChild</span>(cloneP);<br></code></pre></td></tr></table></figure><h2 id="appendChild的实现原理？"><a href="#appendChild的实现原理？" class="headerlink" title="appendChild的实现原理？"></a>appendChild的实现原理？</h2><ol><li>首先，检查要添加的子节点是否是一个DOM节点，如果不是则抛出一个错误。</li><li>然后，检查要添加的子节点是否已经是一个父节点的子节点，如果是则将子节点从原来的父节点中移除。</li><li>最后，将子节点添加到指定的父节点的子节点列表的末尾。</li></ol><p>在添加子节点的过程中，<strong>appendChild()方法会自动更新父节点、子节点和兄弟节点的引用关系。同时，appendChild()方法也会自动更新文档的布局和渲染</strong>，因此需要谨慎使用，以避免频繁的DOM操作导致性能下降。</p><p>appendChild()方法只能将一个节点添加到一个父节点中，如果要添加多个节点，需要多次调用appendChild()方法。</p><p>在插入子节点的过程中，insertBefore()方法会自动更新父节点、子节点和兄弟节点的引用关系。同时，insertBefore()方法也会自动更新文档的布局和渲染，因此需要谨慎使用，以避免频繁的DOM操作导致性能下降。</p><p>需要注意的是，如果要将一个节点插入到一个父节点的子节点列表的末尾，可以使用appendChild()方法。如果要将一个节点插入到指定位置，可以使用insertBefore()方法。</p><ol><li>首先，检查要插入的子节点是否是一个DOM节点，如果不是则抛出一个错误。</li><li>然后，检查要插入的参考节点是否是一个子节点，如果不是则抛出一个错误。</li><li>接着，检查要插入的子节点是否已经是一个父节点的子节点，如果是则将子节点从原来的父节点中移除。</li><li>最后，将子节点插入到指定的位置，即参考节点的前面。</li></ol><p>在插入子节点的过程中，insertBefore()方法会自动更新父节点、子节点和兄弟节点的引用关系。同时，insertBefore()方法也会自动更新文档的布局和渲染，因此需要谨慎使用，以避免频繁的DOM操作导致性能下降。</p><p>如果要将一个节点插入到一个父节点的子节点列表的末尾，可以使用appendChild()方法。如果要将一个节点插入到指定位置，可以使用insertBefore()方法。</p><h2 id="如何实现深拷贝？"><a href="#如何实现深拷贝？" class="headerlink" title="如何实现深拷贝？"></a>如何实现深拷贝？</h2><ul><li><p>使用JSON.stringify和JSON.parse实现</p></li><li><p>for…in + Object.assign</p></li><li><p>for…in + 拓展运算符</p></li><li><p><strong>Object.create</strong></p></li><li><p><strong>jQuery.extend(deep, target, obj1, …)</strong></p></li><li><p>函数库lodash</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;lodash&quot;</span>;<br><span class="hljs-keyword">const</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;;<br><span class="hljs-keyword">const</span> deep = _.<span class="hljs-title function_">cloneDeep</span>(obj);<br></code></pre></td></tr></table></figure></li></ul><h2 id="script的引入方式有哪些？"><a href="#script的引入方式有哪些？" class="headerlink" title="script的引入方式有哪些？"></a>script的引入方式有哪些？</h2><p>script的引入方式有三种：行内式、嵌入式和外链式。</p><ul><li>行内式是将JavaScript代码作为HTML标签的属性值使用。</li><li>嵌入式使用<code>&lt;script&gt;</code>标签包裹JavaScript代码，直接编写到HTML文件中，通常将其放到<code>&lt;head&gt;</code>标签或<code>&lt;body&gt;</code>标签中。</li><li>外链式是将JavaScript代码写在一个单独的文件中，一般使用<code>.js</code>作为文件的扩展名，在HTML页面中使用<code>&lt;script&gt;</code>标签的<code>src</code>属性引入<code>.js</code>文件。外链式适合<code>JS</code>代码量较多的情况。</li></ul><h2 id="什么是防抖和节流？"><a href="#什么是防抖和节流？" class="headerlink" title="什么是防抖和节流？"></a>什么是防抖和节流？</h2><p>防抖：一个事件在触发n秒之后再进行执行，如果重复进行请求则重新进行计时。</p><p>节流：一个事件在一段时间内只能执行一次，如果多次触发也只会执行一次。</p><h2 id="什么是原型？"><a href="#什么是原型？" class="headerlink" title="什么是原型？"></a>什么是原型？</h2><p>在JavaScript中，每个对象都有一个原型。原型是一个对象，它包含着对象的属性和方法。当我们访问一个对象的属性或方法时，如果该对象本身没有该属性或方法，JavaScript引擎会沿着对象的原型链查找，直到找到该属性或方法为止。原型是JavaScript实现继承的基础，可以通过原型链实现属性和方法的继承。</p><h2 id="如何理解原型链？"><a href="#如何理解原型链？" class="headerlink" title="如何理解原型链？"></a>如何理解原型链？</h2><p>JS中的原型链是一种基于对象继承的机制。每个对象都有一个内部属性[[Prototype]]，它指向另一个对象，即其原型对象。原型对象也有自己的原型对象，这样就形成了一个“链”，即原型链。</p><p>当我们访问一个对象的属性或方法时，JavaScript 引擎会先查找该对象自身是否有该属性或方法，如果不存在，就会到该对象的原型对象中查找，如果原型对象中仍然不存在，则会继续查找原型对象的原型对象，直到最终找到 Object.prototype 中为止。</p><p>可以通过对象的 <strong>proto</strong> 或 Object.getPrototypeOf() 方法来获取对象的原型（也就是该对象的 [[Prototype]] 引用）。通过给某个对象的原型对象添加属性或方法，可以实现对象之间的共享。</p><h2 id="原型链和ES6的Class有什么关系？底层实现上有什么关联吗？"><a href="#原型链和ES6的Class有什么关系？底层实现上有什么关联吗？" class="headerlink" title="原型链和ES6的Class有什么关系？底层实现上有什么关联吗？"></a>原型链和ES6的Class有什么关系？底层实现上有什么关联吗？</h2><p>ES6 的 class 关键字是基于原型链的封装，其底层实现和原型链是密切相关的。</p><p>在 ES6 中创建一个 class，实际上是创建了一个构造函数和其原型对象。该构造函数的原型对象会指向内置的 Object.prototype 对象，而该构造函数会作为其他对象的原型对象。</p><p>当使用 class 实现继承时，其本质是利用了原型链的机制。子类可以通过关键字 extends 继承父类，这样就会创建一个子类的构造函数和其原型对象，而子类的原型对象会指向父类的原型对象，从而实现了属性和方法的继承。</p><p>此外，子类的 constructor 方法会重写父类的 constructor 方法，通过在子类的 constructor 方法中使用 super()，可以在子类中调用父类的 constructor 方法，从而继承父类的属性和方法。这一机制也是基于原型链实现的。</p><h2 id="new一个对象发生了什么？"><a href="#new一个对象发生了什么？" class="headerlink" title="new一个对象发生了什么？"></a>new一个对象发生了什么？</h2><ol><li>首先创建一个空的对象</li><li>将该对象的原型指向构造函数的prototype属性</li><li>将构造函数的this指向该对象并执行构造函数</li><li>如果构造函数返回一个基本数据类型，则返回这个对象，否则返回构造函数返回的引用数据类型对象。</li></ol><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="作用域是什么时候创建的？"><a href="#作用域是什么时候创建的？" class="headerlink" title="作用域是什么时候创建的？"></a>作用域是什么时候创建的？</h3><p>全局作用域在window对象创建的时候产生。</p><p>局部作用域在函数执行时产生，函数执行完毕后，如果子作用域不需要使用它声明的变量就销毁，如果使用就形成闭包保存下来。</p><h3 id="改变作用域的方法？"><a href="#改变作用域的方法？" class="headerlink" title="改变作用域的方法？"></a>改变作用域的方法？</h3><ul><li>call、apply、bind</li><li>箭头函数</li></ul><h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>闭包是指一个函数能够访问其他函数内部变量的函数。在JavaScript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数”。</p><p>闭包的优点是可以保护变量不被污染，同时也可以实现数据私有化。缺点是会占用更多的内存空间，同时也会增加代码的复杂度。</p><h2 id="闭包有哪些优点？可以做哪些事情？"><a href="#闭包有哪些优点？可以做哪些事情？" class="headerlink" title="闭包有哪些优点？可以做哪些事情？"></a>闭包有哪些优点？可以做哪些事情？</h2><p>闭包是指一个函数可以访问其父作用域的变量，即使父作用域已经结束执行，这些变量仍然可以被访问。闭包有如下优点：</p><ol><li>保护变量：由于闭包的函数可以访问其父作用域的变量，因此可以将一些变量私有化，避免在全局范围内被访问和修改，从而增强程序的安全性。</li><li>延长变量寿命：通过闭包，可以将变量的生命周期延长至其内部函数执行结束之后，这样可以避免变量在外部被提前销毁。</li><li>保存状态：闭包可以记住函数执行时的状态，也就是函数执行环境中的变量值。这使得下次再次访问该函数时，可以使用上次保存的状态继续进行操作。</li><li>可以做柯里化：类似于函数式编程语言中的柯里化，通过闭包，可以将一个函数转化为另一个函数，使得该函数的某些参数被预先设置，并返回一个接受剩余参数的新函数。这个特性可以帮助我们创建更加灵活的函数。</li></ol><p>闭包可以做如下事情：</p><ol><li>实现模块化：通过使用闭包将一些变量、方法封装在模块内，提高代码的可复用性和可维护性。</li><li>实现缓存机制：闭包可以实现一些缓存机制，避免频繁的计算和请求，提高程序的执行效率。</li><li>实现事件绑定：由于闭包可以保存状态，并且可以访问函数外部的变量，因此可以在事件绑定的过程中保存一些状态，比如记录用户的点击次数等。</li><li>传递变量：由于闭包可以将函数内部的变量保留在内存中，因此可以在不同的执行环境中传递变量的值。</li></ol><h2 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h2><p>JavaScript 是单线程执行的语言，而事件循环机制 (Event Loop) 是其编程模型的核心。事件循环机制负责监听调用栈和消息队列，以保证异步和回调函数的正确执行。</p><p>当 JavaScript 代码运行时，所有的同步任务都会按照代码的先后顺序放入调用栈中执行，调用栈则会按照后进先出的规则执行其中的任务。而异步任务则不会马上执行，而是在满足某些条件（如网络请求返回结果）时，将任务放入消息队列中，等待调用栈中的任务执行完毕后，再将消息队列中的任务按照顺序放入调用栈中执行。</p><p>在事件循环中，调用栈中的任务执行完毕后，会先检查消息队列中是否有任务需要执行，如果有则按照顺序依次取出执行，否则继续等待新的异步任务被加入消息队列。</p><p>总结起来，事件循环机制保证了 JavaScript 代码的异步执行，让它可以处理各种待定操作，避免了等待和阻塞。</p><h3 id="宏任务和微任务有哪些？"><a href="#宏任务和微任务有哪些？" class="headerlink" title="宏任务和微任务有哪些？"></a>宏任务和微任务有哪些？</h3><p>宏任务一般是：整体代码script、setTimeout、setInterval、I&#x2F;O、UI render</p><p>微任务主要是：Promise、Object.observe、MutationObserver</p><p>二者都是异步。</p><h2 id="什么是JS的事件机制"><a href="#什么是JS的事件机制" class="headerlink" title="什么是JS的事件机制"></a>什么是JS的事件机制</h2><p>JavaScript 事件机制描述的是事件在 DOM 里面的传递顺序，以及我们可以对这些事件做出如何的响应。</p><p>DOM事件流（event flow ）存在三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。</p><p>事件捕获（event capturing）： 通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始<strong>由外到内</strong>进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。</p><p>事件冒泡（dubbed bubbling）： 与事件捕获恰恰相反，事件冒泡顺序是<strong>由内到外</strong>进行事件传播，直到根节点。无论是事件捕获还是事件冒泡，它们都有一个共同的行为，就是事件传播，它就像一跟引线，只有通过引线才能将绑在引线上的鞭炮（事件监听器）引爆。</p><p>DOM标准事件流的触发的先后顺序为 ：<strong>先捕获再冒泡，即当触发dom事件时，会先进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡</strong>。</p><h2 id="为元素绑定事件有哪些方案呢？有什么区别？"><a href="#为元素绑定事件有哪些方案呢？有什么区别？" class="headerlink" title="为元素绑定事件有哪些方案呢？有什么区别？"></a>为元素绑定事件有哪些方案呢？有什么区别？</h2><p>在 JavaScript 中，为元素绑定事件的方案有以下几种：</p><ol><li><p>HTML事件处理程序：即在 HTML 标签中通过写入事件属性的方式绑定事件，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;myFunction()&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这种方式比较简单，但是不太灵活，且需要将 JavaScript 代码写在 HTML 中，不利于代码的维护和升级。</p></li><li><p>DOM0级事件处理程序：通过在 JS 代码中以元素对象的属性方式给元素绑定事件处理程序，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>);<br>btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br> <span class="hljs-comment">//处理点击事件的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式比较简单，且支持事件的取消绑定（即将该属性设置为 null 即可），但是同一元素只能绑定一种事件处理程序，无法实现多个事件的同时绑定。</p></li><li><p>DOM2级事件处理程序：通过 addEventListener() 方法和 removeEventListener() 方法绑定和解绑事件处理程序，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>);<br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br> <span class="hljs-comment">//处理点击事件的代码</span><br>&#125;, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>这种方式可以同时为同一个元素的同一种事件绑定多个事件处理程序，且支持事件捕获和冒泡，灵活性更高。</p></li></ol><p>这三种方式的主要区别在于绑定事件处理程序的方法不同，前两种方式是将 JS 代码直接写在 HTML 或 JS 文件中的，而第三种方式则直接将 JS 代码绑定到了 DOM 元素上，无需将代码写在 HTML 中，使得代码更加有组织性、可维护性和可重用性。另外，第三种方式还支持为同一元素的同一种事件绑定多个处理程序，并可以进行事件捕获和冒泡。</p><h2 id="addEventListener的三个参数分别是什么？"><a href="#addEventListener的三个参数分别是什么？" class="headerlink" title="addEventListener的三个参数分别是什么？"></a>addEventListener的三个参数分别是什么？</h2><p>addEventListener 的三个参数分别为：事件类型（字符串）、事件处理函数（函数）、是否在捕获阶段捕获事件（布尔值，默认为 false）。例如：element.addEventListener(‘click’, handleClick, false); 其中，’click’ 是事件类型，handleClick 是事件处理函数，false 表示在冒泡阶段捕获事件（默认情况下）。</p><h2 id="JS如何阻止冒泡？"><a href="#JS如何阻止冒泡？" class="headerlink" title="JS如何阻止冒泡？"></a>JS如何阻止冒泡？</h2><p>在JS中，可以使用<code>event.stopPropagation()</code>方法来阻止事件冒泡。</p><p>事件冒泡是指当一个元素上的事件被触发时，该事件会向上冒泡到父元素，直到冒泡到文档根节点为止。如果希望阻止事件冒泡，可以在事件处理函数中使用<code>event.stopPropagation()</code>方法来阻止事件继续向上冒泡。</p><p>例如，以下代码可以阻止按钮点击事件冒泡到父元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.parent&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Parent element clicked.&#x27;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.child&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Child element clicked.&#x27;</span>);<br>  event.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// 阻止事件冒泡</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>在上面的代码中，当点击子元素时，<code>event.stopPropagation()</code>方法会阻止事件继续向上冒泡到父元素，因此只会触发子元素的点击事件处理函数，而不会触发父元素的点击事件处理函数。</p><h2 id="浏览器的垃圾回收机制"><a href="#浏览器的垃圾回收机制" class="headerlink" title="浏览器的垃圾回收机制"></a>浏览器的垃圾回收机制</h2><p>JS代码运行时，需要分配内存空间来存储变量和值。当变量不再参与运行时，就需要回收被占用的空间，这就是垃圾回收。</p><p><strong>垃圾回收的方式</strong></p><ul><li><p><strong>标记清除</strong></p><p>当变量进入执行环境时，标记该变量”进入幻境”，此时变量不能回收。当变量离开环境的时候，就会被标记为”离开环境”，会被内存释放</p></li><li><p><strong>引用计数</strong></p><p>跟踪每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量的时候，这个值的引用次数就是1。当包含对该值引用的变量指向另一个值的时候，引用次数减1。当引用次数变为0的时候，说明该值已经没有利用价值，这个变量占用的内存空间就会被释放出来。</p><p>弊端：可能会引起<strong>循环引用</strong>的问题，例如：obj1和obj2通过属性互相进行引用，那么二者的引用次数永远不会归零，函数执行完结束后，两个变量仍然会继续存在，引用次数永远不为0，会引起循环引用。</p></li></ul><p><strong>减少垃圾回收的方式</strong></p><ul><li>对数组进行优化：清空一个数组的时候将其长度设为0</li><li>对对象进行优化：不再使用的时候将其设置为null</li><li>对函数进行优化：在循环中的函数表达式，如果可以复用则尽量放在外面</li></ul><h2 id="JS针对内存泄漏的处理机制？"><a href="#JS针对内存泄漏的处理机制？" class="headerlink" title="JS针对内存泄漏的处理机制？"></a>JS针对内存泄漏的处理机制？</h2><p>内存泄漏（Memory leak）指的是应用程序中已经无法使用的内存仍然被占用，导致内存空间不足，程序出现异常或崩溃。在 JavaScript 中，常见的内存泄漏情况包括：意外的全局变量、被遗忘的定时器或回调函数、闭包、循环引用等。为了避免这些情况发生，可以采取以下措施：</p><ol><li>及时释放引用：手动解除引用时可以使用 null 将对象赋值为空，让对象成为垃圾，但这种方法并不总是有效。</li><li>避免不必要的全局变量：全局变量会一直存在于整个应用中，如果定义了太多的全局变量，会导致内存大量占用。</li><li>使用闭包时注意内存泄漏：虽然闭包可以让函数在其定义域之外访问变量，但必须小心处理该函数中使用的变量引用，以确保它们在不再需要时被正确地解引用。</li><li>避免循环引用：在创建对象之间的引用时，确保它们不会形成循环引用，否则垃圾回收器无法清除它们。</li><li>及时清除定时器和回调函数：在使用定时器和回调函数时，注意及时清除已经不需要使用的定时器和回调函数，因为这些对象将一直驻留在内存中，直到它们被清除为止。</li><li>使用对象池：使用对象池可以复用已有的对象，减少内存的使用。</li></ol><p>除了以上措施，还可以使用一些内存管理工具和框架来避免内存泄漏，例如 Chrome 开发者工具（Chrome DevTools）、Heap Snapshots、Memory Profiling 等。</p><h2 id="什么是变量提升？原理是什么？"><a href="#什么是变量提升？原理是什么？" class="headerlink" title="什么是变量提升？原理是什么？"></a>什么是变量提升？原理是什么？</h2><p>在JavaScript中，变量提升是指变量和函数的声明会被提升到作用域的顶部，无论实际声明的位置在哪里，这也被称为“提升到顶部”。也就是说，在执行代码之前，JavaScript引擎会扫描整个作用域，找出所有的变量和函数声明，并将它们提升到作用域的顶部，这样在代码执行时就可以访问它们了。</p><p>变量提升的原理是JavaScript引擎在解析代码时，会先处理变量和函数的声明，将它们存储在内存中，然后再执行代码。这样就可以让变量和函数在声明之前就可以被使用了。但是需要注意的是，只有声明会被提升，而不是赋值。因此，如果一个变量在声明之前被使用，它的值将为undefined。</p><h2 id="产生变量提升的原因？"><a href="#产生变量提升的原因？" class="headerlink" title="产生变量提升的原因？"></a>产生变量提升的原因？</h2><p>产生变量提升的原因是JavaScript引擎在解析代码时，会先处理变量和函数的声明，将它们存储在内存中，然后再执行代码。这是由于JavaScript的执行顺序是自上而下的，而变量和函数的声明在代码中可能出现在后面的位置。如果不进行变量提升，那么在使用变量或函数之前必须要先声明，否则会报错。通过变量提升，JavaScript引擎可以在代码执行之前就将变量和函数的声明提前到作用域的顶部，从而让变量和函数在声明之前就可以被使用了。</p><h2 id="JS中定义函数的function-fun-和var-fun-x3D-function-两种方法有什么区别？"><a href="#JS中定义函数的function-fun-和var-fun-x3D-function-两种方法有什么区别？" class="headerlink" title="JS中定义函数的function fun(){}和var fun &#x3D; function(){}两种方法有什么区别？"></a>JS中定义函数的function fun(){}和var fun &#x3D; function(){}两种方法有什么区别？</h2><ol><li>函数声明语法具有变量提升的特性，可以在函数定义之前进行调用，而函数表达式语法在变量初始化之前调用会报错。</li><li>函数声明语法在函数名后面加上了圆括号和花括号，是一种<strong>声明式</strong>的方式，而函数表达式语法是将一个<strong>匿名函数</strong>通过变量赋值进行定义，是一种<strong>表达式式</strong>的方式。</li><li>函数声明语法可以用于在全局作用域或函数作用域内定义函数，而函数表达式语法一般用于在函数作用域内定义函数，但也可以在全局作用域内使用，只需要将函数表达式赋值给一个全局变量即可。</li><li>函数表达式可以作为参数传递到其他函数中，或者作为返回值返回到其他函数中，更加灵活，而函数声明语法就没有这种灵活性。</li></ol><h2 id="什么是执行上下文？"><a href="#什么是执行上下文？" class="headerlink" title="什么是执行上下文？"></a>什么是执行上下文？</h2><p>JavaScript执行上下文是指JavaScript代码在执行时所处的环境，包括变量、函数声明、作用域链、this指向等。每当JavaScript代码开始执行时，都会创建一个新的执行上下文，并将其压入执行上下文栈（Execution Context Stack）中。当代码执行完成后，该执行上下文会被弹出栈并销毁。</p><p>执行上下文包括三种类型：</p><ol><li>全局执行上下文：在代码执行之前就会被创建，它是默认的最外层的执行上下文。</li><li>函数执行上下文：每当一个函数被调用时，都会创建一个新的函数执行上下文。</li><li>Eval执行上下文：eval()函数会在当前作用域中创建一个新的执行上下文。</li></ol><p>执行上下文中包含了当前代码所处的作用域链、变量对象、this指向等信息，这些信息会在代码执行时被用到，从而影响到代码的执行结果。</p><h2 id="bind、call和apply的区别？"><a href="#bind、call和apply的区别？" class="headerlink" title="bind、call和apply的区别？"></a>bind、call和apply的区别？</h2><ul><li><code>apply</code>接受两个参数，第一个参数是<code>this</code>的指向，第二个参数是函数接受的参数，以数组的形式传入，改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次。</li><li><code>call</code>方法的第一个参数也是<code>this</code>的指向，后面传入的是一个参数列表，跟<code>apply</code>一样，改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次。</li><li>bind方法和call很相似，第一参数也是<code>this</code>的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)，改变<code>this</code>指向后不会立即执行，而是返回一个永久改变<code>this</code>指向的函数。</li></ul><h2 id="JS中数组可以调用的方法有哪些？"><a href="#JS中数组可以调用的方法有哪些？" class="headerlink" title="JS中数组可以调用的方法有哪些？"></a>JS中数组可以调用的方法有哪些？</h2><ol><li>push()：向数组末尾添加一个或多个元素，返回新的数组长度</li><li>pop()：删除数组的最后一个元素并返回该元素</li><li>shift()：删除数组的第一个元素并返回该元素</li><li>unshift()：向数组开头添加一个或多个元素，返回新的数组长度</li><li>splice()：删除或替换数组的某个或某些元素，或向指定位置插入元素</li><li>slice()：截取数组的一部分，不会改变原数组，返回截取的新数组</li><li>concat()：连接两个或多个数组，返回连接后的新数组</li><li>join()：将数组中所有元素转换成字符串，并使用指定的分隔符连接起来</li><li>reverse()：颠倒数组中元素的顺序，改变原数组，返回改变后的数组</li><li>sort()：按照字母表顺序对数组中元素进行排序，改变原数组，返回改变后的数组</li><li>map()：对数组中每个元素执行指定的操作并返回操作后的新数组</li><li>filter()：返回数组中符合指定条件的所有元素组成的新数组</li><li>reduce()：使数组中每个元素执行指定操作，返回最终结果</li><li>forEach()：对数组中每个元素执行指定的操作，没有返回值</li><li>indexOf()：返回指定元素在数组中的位置，如果不存在则返回 -1</li><li>lastIndexOf()：返回指定元素在数组中最后出现的位置，如果不存在则返回 -1</li></ol><h2 id="数组方法map、some和filter的区别？"><a href="#数组方法map、some和filter的区别？" class="headerlink" title="数组方法map、some和filter的区别？"></a>数组方法map、some和filter的区别？</h2><ul><li><p><code>map</code> 方法会对原数组中的每个元素都执行一次给定的函数，并将执行结果存储到新数组中返回。这个过程不会改变原来的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> newArr = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num * <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr); <span class="hljs-comment">// [2, 4, 6, 8]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure></li><li><p><code>some</code> 方法会对原数组中的每个元素都执行一次给定的函数，如果有任意一个元素执行后返回的是真值，则返回 <code>true</code>，否则返回 <code>false</code>。这个过程不会改变原来的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">isEven</span> = num =&gt; num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">some</span>(isEven)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p><code>filter</code> 方法会对原数组中的每个元素都执行一次给定的函数，并将执行结果为真值的元素存储到一个新数组中返回。这个过程不会改变原来的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> evenNums = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(evenNums); <span class="hljs-comment">// [2, 4]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="forEach和map的区别？"><a href="#forEach和map的区别？" class="headerlink" title="forEach和map的区别？"></a>forEach和map的区别？</h2><p>forEach会针对每个元素执行提供的数组，该方法没有返回值。</p><p>如果对数据进行操作，如果是基础数据类型，不会有效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    item *= <span class="hljs-number">2</span>;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1,2,3,4,5]</span><br></code></pre></td></tr></table></figure><p>但如果是引用数据类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<br>    &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;001&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;LiHua&quot;</span><br>    &#125;, <br>    &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;002&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;XiaoMei&quot;</span><br>    &#125;<br>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(item.<span class="hljs-property">id</span> === <span class="hljs-string">&quot;001&quot;</span>) &#123;<br>        item.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;LiQiang&quot;</span>;<br>    &#125;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [ &#123; id: &#x27;001&#x27;, name: &#x27;LiQiang&#x27; &#125;, &#123; id: &#x27;002&#x27;, name: &#x27;XiaoMei&#x27; &#125; ]</span><br></code></pre></td></tr></table></figure><p>这是因为forEach中的item并不是真正的数组中的项，而是对数组中项的复制，因此如果是原始数据类型，修改它的复制元素并不会影响到它本身，而对于引用数据类型，复制的是对数据的引用，<strong>因此修改item的属性，对应的原始值的属性也会变化</strong>，但是直接修改item，将其指向另一个数据的话也不行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<br>    &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;001&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;LiHua&quot;</span><br>    &#125;, <br>    &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;002&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;XiaoMei&quot;</span><br>    &#125;<br>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(item.<span class="hljs-property">id</span> === <span class="hljs-string">&quot;001&quot;</span>) &#123;<br>        item = &#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&quot;003&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;XiaoMei&quot;</span>&#125;;<br>    &#125;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [ &#123; id: &#x27;001&#x27;, name: &#x27;LiHua&#x27; &#125;, &#123; id: &#x27;002&#x27;, name: &#x27;XiaoMei&#x27; &#125; ]</span><br></code></pre></td></tr></table></figure><p>而如果是下面的方法，原始数据类型和引用数据类型都能被修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>    arr[index] = item * <span class="hljs-number">2</span>;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [2,4,6,8,10]</span><br></code></pre></td></tr></table></figure><p>forEach使用return方法只能跳出本次循环，要想跳出整个循环需要抛出错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(item === <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-comment">// return;</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;你好&quot;</span>)<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>&#125;)<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * forEach跳出循环：抛出错误</span><br><span class="hljs-comment"> * 跳出本次循环：return</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>map方法会改变原数组的值，返回一个新的数组，新数组中的值为原数组调用函数处理后的值。</p><h2 id="for…in和for…of的区别？"><a href="#for…in和for…of的区别？" class="headerlink" title="for…in和for…of的区别？"></a>for…in和for…of的区别？</h2><p>for…of是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构(对象、数组等)并返回各项的值，二者区别如下：</p><ul><li>for…of遍历获取的是对象的键值，而for…in获取的是对象的键名</li><li>for…in会遍历对象的整个原型链，性能非常差不推荐使用，而for…of只会遍历当前对象不会遍历原型链</li><li>对数组的遍历，for…in会返回数组中所有可枚举对象(包括原型链上的可枚举对象)，for…of只返回数组下标对应的属性值。</li></ul><h2 id="如何使用for…of遍历对象？"><a href="#如何使用for…of遍历对象？" class="headerlink" title="如何使用for…of遍历对象？"></a>如何使用for…of遍历对象？</h2><ul><li>如果是类数组对象，使用Array.from进行转换</li><li>如果不是，添加[Symbol.iterator]属性，并指向一个迭代器即可 (yield进行添加) 。</li></ul><h2 id="代码懒加载的实现原理？"><a href="#代码懒加载的实现原理？" class="headerlink" title="代码懒加载的实现原理？"></a>代码懒加载的实现原理？</h2><blockquote><p>代码懒加载（Code Splitting）是一种优化网页性能的技术，它的原理是将网页的代码分割成多个小块，只在需要时才加载这些小块，从而提高网页的加载速度和性能。</p></blockquote><p>代码懒加载的实现原理如下：</p><ol><li>将网页的代码分割成多个小块，每个小块对应一个模块或页面组件。</li><li>在网页加载时，只加载必要的代码块，其他代码块暂时不加载。</li><li>当用户访问到需要使用某个模块或组件时，再动态加载对应的代码块。</li><li>加载完成后，将新的模块或组件插入到网页中，从而实现懒加载效果。</li></ol><p>代码懒加载可以使用Webpack等工具来实现。Webpack可以将网页的代码分割成多个小块，并使用动态import()语法来实现懒加载。当Webpack打包代码时，会将代码分割成多个小块，并生成多个独立的文件。在网页加载时，只加载必要的代码块，其他代码块暂时不加载。当用户需要访问某个模块或组件时，再动态加载对应的代码块，并将它插入到网页中。</p><p>代码懒加载可以大大提高网页的性能和用户体验，特别是在移动设备等网络环境不佳的情况下。</p><h2 id="如何根据元素的class提取元素？"><a href="#如何根据元素的class提取元素？" class="headerlink" title="如何根据元素的class提取元素？"></a>如何根据元素的class提取元素？</h2><ol><li><p>getElementByClassName方法：这个方法可以通过class名称获取一组元素，返回的是一个类数组对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;class-name&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>querySelectorAll方法：这个方法可以通过CSS选择器获取一组元素，返回的是一个NodeList对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.class-name&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>getElementsByTagname方法结合class属性：这个方法可以通过标签名获取一组元素，然后结合class属性进行筛选。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-keyword">var</span> result = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; elements.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-keyword">if</span> (elements[i].<span class="hljs-property">className</span> === <span class="hljs-string">&#x27;class-name&#x27;</span>) &#123;<br>    result.<span class="hljs-title function_">push</span>(elements[i]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="ES6相关"><a href="#ES6相关" class="headerlink" title="ES6相关"></a>ES6相关</h2><h3 id="ES6有哪些新特性？"><a href="#ES6有哪些新特性？" class="headerlink" title="ES6有哪些新特性？"></a>ES6有哪些新特性？</h3><ul><li><p>块级作用域：let和const</p></li><li><p>箭头函数</p></li><li><p>模板字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;XiaoMing&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`My name is <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br></code></pre></td></tr></table></figure></li><li><p>拓展运算符</p></li><li><p>类和继承 (<code>class</code>)</p></li><li><p>模块化：<code>import</code>和<code>export</code></p></li><li><p>Promise和async&#x2F;await</p></li><li><p>Symbol、BigInt</p></li><li><p>数组新增方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>() <span class="hljs-comment">// 将类数组对象or可迭代对象转换为数组</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>() <span class="hljs-comment">// 根据传入的参数创建一个数组</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">find</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">findIndex</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">fill</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">keys</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">values</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">includes</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">copyWithin</span>() <span class="hljs-comment">// 将数组的一部分复制到另一部分</span><br></code></pre></td></tr></table></figure></li><li><p>对象新增方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>()<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>()<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>()<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entires</span>() <span class="hljs-comment">// 返回一个数组，包含自身所有可枚举属性的键值对</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>() <span class="hljs-comment">// 返回一个对象，包含指定对象所有属性的描述符</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>() <span class="hljs-comment">// 冻结对象，使其属性不可修改、添加或删除</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">seal</span>() <span class="hljs-comment">// 封闭对象，使其属性不可添加或删除，但是可以修改</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>() <span class="hljs-comment">// 用于比较两个值是否完全相同</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="箭头函数和普通函数的区别？"><a href="#箭头函数和普通函数的区别？" class="headerlink" title="箭头函数和普通函数的区别？"></a>箭头函数和普通函数的区别？</h3><ul><li>箭头函数不绑定this，会捕获其所在上下文的this作为自己的this。</li><li>箭头函数没有arguments对象，只能通过rest参数获取参数。</li><li>箭头函数不能使用yield命令，不能用作Generator函数。</li><li>箭头函数是匿名函数，不能用作构造函数，不可以使用new命令。</li></ul><h3 id="箭头函数的指向？"><a href="#箭头函数的指向？" class="headerlink" title="箭头函数的指向？"></a>箭头函数的指向？</h3><p>箭头函数中的 this 是继承自外层作用域，也就是说箭头函数没有自己的 this，它内部的 this 指向的是定义它时所处的环境中的 this (从所处上下文中捕获的)。</p><h3 id="匿名函数和普通函数的区别？"><a href="#匿名函数和普通函数的区别？" class="headerlink" title="匿名函数和普通函数的区别？"></a>匿名函数和普通函数的区别？</h3><p>匿名函数没有函数名称，而普通函数具有名称。</p><p>普通函数声明方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">functionName</span>(<span class="hljs-params">args</span>) &#123;<br>    <span class="hljs-comment">// function body</span><br>&#125;<br></code></pre></td></tr></table></figure><p>匿名函数的生命和调用有两种：</p><ul><li><p>函数表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> functionName = <span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) &#123;<br>    <span class="hljs-comment">// function body</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自执行函数 (IIFE)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) &#123;<br>    <span class="hljs-comment">// function body</span><br>&#125;)(args);<br></code></pre></td></tr></table></figure><p>这也是一个匿名函数，它在声明时被包裹在一对括号中，并紧随一对括号进行自执行。这样执行后，匿名函数不会再被保存在内存中，因此它常用于一些初始化工作。</p></li></ul><h3 id="立即执行函数和普通函数的区别？"><a href="#立即执行函数和普通函数的区别？" class="headerlink" title="立即执行函数和普通函数的区别？"></a>立即执行函数和普通函数的区别？</h3><ol><li>定义：立即执行函数是一个匿名函数，在声明之后立即执行；而普通函数可以根据需要来声明和调用。</li><li>作用域：立即执行函数可以创建一个新的作用域，避免变量污染；而普通函数的作用域由声明位置和调用方式所决定。</li><li>调用：立即执行函数的调用是紧随函数定义之后立即进行，而普通函数的调用则是在需要时通过函数名调用。</li></ol><p>立即执行函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 1</span><br>&#125;)()<br></code></pre></td></tr></table></figure><p>普通函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 1</span><br>&#125;<br><span class="hljs-title function_">myFunction</span>();<br></code></pre></td></tr></table></figure><p>可以看到，立即执行函数是通过将匿名函数声明后紧随一对括号，将函数定义包含在括号内，再在末尾加上一对括号来立即执行的。而普通函数则需要在需要时通过函数名来调用。</p><p>值得注意的是，立即执行函数的主要作用在于<strong>创建一个新的作用域，避免变量污染</strong>。<strong>在立即执行函数内定义的变量只在该函数内部可见，在函数外部是不可访问的</strong>。而普通函数则不具有这个特点，它的作用域由声明位置和调用方式所决定。</p><h3 id="引入模块的两种方式？"><a href="#引入模块的两种方式？" class="headerlink" title="引入模块的两种方式？"></a>引入模块的两种方式？</h3><ul><li><p>ES6导入导出模块方式：<code>import</code>和<code>export</code>。</p><ul><li><p><code>import</code>：在一个模块中引入另一个模块的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> defaultExport <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> name <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; export1 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; export1 <span class="hljs-keyword">as</span> alias1 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; export1 , export2 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; export1 , export2 <span class="hljs-keyword">as</span> alias2 , [...] &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> defaultExport, &#123; export1 [ , [...] ] &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> defaultExport, * <span class="hljs-keyword">as</span> name <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li><code>defaultExport</code>表示模块的默认输出</li><li><code>name</code>表示模块的命名输出</li><li><code>export1</code>表示模块的具名输出</li></ul></li><li><p><code>export</code>：用于在一个模块中导出内容，让其他模块可以引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> expression;<br><span class="hljs-keyword">export</span> &#123; name1, name2, …, nameN &#125;;<br><span class="hljs-keyword">export</span> &#123; variable1 <span class="hljs-keyword">as</span> name1, variable2 <span class="hljs-keyword">as</span> name2, …, nameN &#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> name1, name2, …, nameN; <span class="hljs-comment">// also var</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> name1 = value1, name2 = value2, …, nameN = valueN;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span> &#123;...&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">FunctionName</span>(<span class="hljs-params"></span>)&#123;...&#125;<br></code></pre></td></tr></table></figure><ul><li><code>defalut</code>表示模块的默认输出</li><li><code>name</code>等表示模块的具名输出</li></ul></li></ul></li><li><p>CommonJS主要用于服务端的JS编程，<code>require()</code>导入模块，<code>module.exports</code>或<code>exports</code>导出模块。</p><ul><li><p><code>require()</code>导入模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;module-name&quot;</span>);<br></code></pre></td></tr></table></figure><p><code>module-name</code>为要导出的模块名</p></li><li><p><code>module.exports</code>或<code>exports</code>导出模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = value;<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">name</span> = values;<br></code></pre></td></tr></table></figure><p>其中<code>value</code>为要导出的值，可以是任意类型的值，包括对象、函数、字符串、数字等。</p></li></ul><p>需要注意的是，<code>module.exports</code>是直接将一个对象赋值给<code>exports</code>，而<code>exports</code>只是对<code>module.exports</code>的一个引用，因此可以使用<code>exports</code>导出多个属性，但不能使用<code>exports</code>直接覆盖<code>module.exports</code>。</p></li></ul><h3 id="ES6和CommonJS引入模块的区别？"><a href="#ES6和CommonJS引入模块的区别？" class="headerlink" title="ES6和CommonJS引入模块的区别？"></a>ES6和CommonJS引入模块的区别？</h3><ol><li><p>语法不同：</p><p>ES6使用<code>import</code>和<code>export</code>来导入和导出模块，而CommonJS使用<code>require()</code>和<code>module.exports</code>或<code>exports</code>来导入和导出模块。</p></li><li><p>加载方式不同：</p><p>ES6采用静态编译方式，在编译时就确定模块的依赖关系，然后再进行模块的加载。而CommonJS采用动态加载方式，在运行时根据代码需要动态加载模块。</p></li><li><p>可以导出的内容不同：</p><p>ES6中可以导出的内容包括变量、函数、类等，而CommonJS中只能导出对象。</p></li><li><p>作用域不同：</p><p>ES6中的模块是静态的，每个模块都有自己的作用域，不会污染全局作用域，而CommonJS中的模块是动态的，导出的对象是引用类型，会污染全局作用域。</p></li></ol><h3 id="Set和Map的用法和特点？"><a href="#Set和Map的用法和特点？" class="headerlink" title="Set和Map的用法和特点？"></a>Set和Map的用法和特点？</h3><h4 id="Set-的用法和特点"><a href="#Set-的用法和特点" class="headerlink" title="Set 的用法和特点"></a>Set 的用法和特点</h4><p>Set 是一种类似于数组的数据结构，它可以存储任意类型的唯一值。Set 中不允许出现重复的元素，因此可以用来实现数组去重。</p><p>Set 的常用方法包括：</p><ul><li>add(value)：往 Set 中添加一个值。</li><li>delete(value)：从 Set 中删除一个值。</li><li>has(value)：判断 Set 中是否存在某个值。</li><li>clear()：清空 Set 中的所有元素。</li><li>size：获取 Set 中元素的个数。</li></ul><p>Set 的特点包括：</p><ul><li>Set 中的元素是唯一的，不会出现重复的值。</li><li>Set 中的元素是无序的，即元素排列的顺序不是添加的顺序。</li><li>Set 的性能比数组要好一些，尤其是在大量元素判断是否存在时。</li></ul><h4 id="Map-的用法和特点"><a href="#Map-的用法和特点" class="headerlink" title="Map 的用法和特点"></a>Map 的用法和特点</h4><p>Map 是一种键值对的数据结构，它可以存储任意类型的键和值。Map 中的元素是唯一的，而且键和值可以是任意类型，包括对象和函数。</p><p>Map 的常用方法包括：</p><ul><li>set(key, value)：向 Map 中添加一个键值对。</li><li>get(key)：获取 Map 中指定键对应的值。</li><li>has(key)：判断 Map 中是否存在指定键。</li><li>delete(key)：删除 Map 中指定键的值。</li><li>clear()：清空 Map 中的所有键值对。</li><li>size：获取 Map 中键值对的个数。</li></ul><p>Map 的特点包括：</p><ul><li>Map 中的键是唯一的，且值可以是任意类型。</li><li>Map 中的键值对是有序的，即元素排列的顺序是添加的顺序。</li><li>Map 的性能比对象要好一些，尤其是在大量元素判断是否存在时。</li></ul><p>总的来说，Set 和 Map 都可以用来存储数据，但是应用场景不同。当需要存储唯一值时，可以使用 Set，而当需要存储键值对时，可以使用 Map。</p><h3 id="Map和WeakMap的区别？"><a href="#Map和WeakMap的区别？" class="headerlink" title="Map和WeakMap的区别？"></a><code>Map</code>和<code>WeakMap</code>的区别？</h3><p><code>Map</code>和<code>WeakMap</code>的主要区别在于键的引用类型和引用方式、键值对的垃圾回收机制、以及性能特点方面。</p><ol><li><p>键的引用类型和引用方式</p><p><code>Map</code>的键可以是任意类型的数据，包括基础数据类型和对象。而<code>WeakMap</code>的键必须是对象类型。由于<code>Map</code>的键是强引用的，所以即使键所对应的对象被删除，键值对依然存在。而<code>WeakMap</code>的键是弱引用的，当键所对应的对象被垃圾回收时，键值对也会自动被删除。</p></li><li><p>键值对的垃圾回收机制</p><p><code>Map</code>中的键值对不会被自动删除，只有在手动删除或<code>Map</code>对象被销毁时才会被清空。而<code>WeakMap</code>中的键值对会在键所对应的对象被垃圾回收时自动删除。</p></li><li><p>性能特点</p><p>由于<code>Map</code>的键是强引用的，所以<code>Map</code>的性能相对较高，但是在大量数据存储时，可能会占用较多的内存。而<code>WeakMap</code>的键是弱引用的，所以<code>WeakMap</code>的性能相对较低，但是可以更有效地管理内存，避免内存泄漏。</p></li></ol><p>综上所述，<code>Map</code>适用于需要长期存储大量数据的场景，而<code>WeakMap</code>适用于临时存储数据或需要更有效地管理内存的场景。</p><h3 id="weakMap使用场景？"><a href="#weakMap使用场景？" class="headerlink" title="weakMap使用场景？"></a>weakMap使用场景？</h3><ol><li><p>保护私有属性</p><p>在JavaScript中，对象的属性都是公开的，可以被其他代码访问和修改。但有时我们需要保护一些属性，使其不被外界访问和修改。使用WeakMap可以实现这个目的，因为WeakMap中的数据只能通过键访问，而且键是弱引用，不能被外界访问。</p></li><li><p>避免内存泄漏</p><p>使用WeakMap可以避免内存泄漏，因为WeakMap中的键是弱引用，当键所引用的对象被垃圾回收时，键也会被自动删除，从而避免内存泄漏。</p></li></ol><h3 id="ES6中的Class是怎样定义的？"><a href="#ES6中的Class是怎样定义的？" class="headerlink" title="ES6中的Class是怎样定义的？"></a>ES6中的Class是怎样定义的？</h3><p>ES6 中的 Class 是一种语法糖，它可以更方便地定义JS中的构造函数，从而实现面向对象编程。Class 的定义方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-comment">// 类的构造函数</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">prop</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">prop</span> = prop;<br>  &#125;<br><br>  <span class="hljs-comment">// 类的方法</span><br>  <span class="hljs-title function_">myMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码定义了一个名为 MyClass 的类，它的构造函数为 constructor，接收一个参数 prop，将其赋值给实例的属性 this.prop。类中的方法可以直接定义在类体内。</p><p>使用 Class 来创建实例时，需要使用 <code>new</code> 关键字，给构造函数传递参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>(<span class="hljs-string">&#x27;myProp&#x27;</span>);<br></code></pre></td></tr></table></figure><p>上述代码创建了一个新的 MyClass 实例，并将 ‘myProp’ 传递给构造函数。</p><p>使用 Class 定义类时，可以继承自其他类，实现类的继承：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ParentClass</span> &#123;<br>  <span class="hljs-comment">// 子类的构造函数</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">prop1, prop2</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(prop1); <span class="hljs-comment">// 调用父类的构造函数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">prop2</span> = prop2;<br>  &#125;<br><br>  <span class="hljs-comment">// 子类的方法</span><br>  <span class="hljs-title function_">childMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码定义了一个名为 ChildClass 的类，它继承于 ParentClass，拥有自己的构造函数和方法。在子类的构造函数中，需要调用 <code>super</code> 方法，以调用父类的构造函数。</p><p>Class 的定义使得 JS 中的面向对象编程变得更加易于理解和使用。</p><h3 id="类中的方法是用逗号隔开、分号隔开还是不需要写？"><a href="#类中的方法是用逗号隔开、分号隔开还是不需要写？" class="headerlink" title="类中的方法是用逗号隔开、分号隔开还是不需要写？"></a>类中的方法是用逗号隔开、分号隔开还是不需要写？</h3><p>在类中定义方法的时候，并不需要使用逗号或分号来隔开各个方法。在类的定义中，方法之间使用换行符隔开即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greetings</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span> = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">sayBye</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Goodbye&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在类中定义方法的时候，不需要使用 function 关键字。</p><h3 id="Symbol-for和Sumbol-keyFor的区别？"><a href="#Symbol-for和Sumbol-keyFor的区别？" class="headerlink" title="Symbol.for和Sumbol.keyFor的区别？"></a>Symbol.for和Sumbol.keyFor的区别？</h3><p>Symbol.for方法接受一个字符串参数，如果全局没有以该参数作为名称的Symbol值，则会创建一个新的Symbol值并注册到全局Symbol注册表中，返回该Symbol值。如果全局已经有该名称的Symbol值，则直接返回该Symbol值。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1 === s2); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>Symbol.keyFor方法用于获取Symbol注册表中与某个Symbol值关联的键名。只能用于全局环境，即在同一个realm的不同Script运行时返回相同的结果。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(s1)); <span class="hljs-comment">// foo</span><br><br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(s2)); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>需要注意的是，Symbol.for创建的Symbol值会被注册到全局注册表中，如果不小心使用了相同的名称，则容易冲突，可能会造成潜在的问题。因此，建议只在确实需要在不同的模块或Script之间共享Symbol值时使用Symbol.for方法。</p><h2 id="弱引用的好处？使用场景？"><a href="#弱引用的好处？使用场景？" class="headerlink" title="弱引用的好处？使用场景？"></a>弱引用的好处？使用场景？</h2><h3 id="弱引用的优点"><a href="#弱引用的优点" class="headerlink" title="弱引用的优点"></a>弱引用的优点</h3><ol><li><p>避免内存泄漏</p><p>使用弱引用可以避免因为对象之间的循环引用而导致的内存泄漏。当一个对象不再被其他对象引用时，它会被垃圾回收器回收。如果一个对象被其他对象循环引用，即使它们都不再被程序使用，也不会被垃圾回收器回收，从而导致内存泄漏。使用弱引用可以避免这种情况。</p></li><li><p>优化性能</p><p>使用弱引用可以避免过度缓存，优化程序的性能。如果一个对象被缓存起来，但是在程序执行过程中很少被使用，却一直占用内存，会影响程序的性能。使用弱引用可以让缓存的对象在不使用时被垃圾回收器回收，避免浪费内存。</p></li><li><p>简化代码</p><p>使用弱引用可以简化代码，避免手动管理对象的生命周期。弱引用可以让程序自动管理对象的生命周期，减少代码的复杂度和出错的可能性。</p></li></ol><p>总之，弱引用是一种优化程序性能和避免内存泄漏的有效手段，它可以让程序更加健壮、高效和易于维护。</p><h3 id="弱引用使用场景"><a href="#弱引用使用场景" class="headerlink" title="弱引用使用场景"></a>弱引用使用场景</h3><ol><li><p>缓存</p><p>使用弱引用可以避免过度缓存，优化程序的性能。如果一个对象被缓存起来，但是在程序执行过程中很少被使用，却一直占用内存，会影响程序的性能。使用弱引用可以让缓存的对象在不使用时被垃圾回收器回收，避免浪费内存。</p></li><li><p>监听事件</p><p>使用弱引用可以避免因为监听事件而导致的内存泄漏。例如，当一个对象监听了另一个对象的事件，如果不及时取消监听，会导致对象之间的循环引用，从而导致内存泄漏。使用弱引用可以避免这种情况。</p></li><li><p>缓存DOM元素</p><p>在Web开发中，经常需要缓存DOM元素，以避免重复查询。但是，如果缓存的DOM元素不及时释放，会导致内存泄漏。使用弱引用可以避免这种情况，当DOM元素不再被使用时，会被自动释放。</p></li></ol><h2 id="Promise、异步、跨域相关"><a href="#Promise、异步、跨域相关" class="headerlink" title="Promise、异步、跨域相关"></a>Promise、异步、跨域相关</h2><h3 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h3><p>在浏览器中，同源策略限制着从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。同源是指协议、域名、端口号均相同。当我们在浏览器向一个不同源的服务器请求资源时，浏览器会限制这个请求，不允许跨域请求。这就是跨域问题。</p><h3 id="前端如何解决跨域？⭐"><a href="#前端如何解决跨域？⭐" class="headerlink" title="前端如何解决跨域？⭐"></a>前端如何解决跨域？⭐</h3><ol><li><p>JSONP</p><p>JSONP是一种跨域解决方案，它利用了script标签的跨域特性来实现。</p></li><li><p>CORS</p><p>CORS是一种新的跨域解决方案，它需要服务器端进行配置。通过在响应头中添加Access-Control-Allow-Origin字段，允许指定的域名跨域访问。</p></li><li><p>代理</p><p>通过在服务器端设置代理，将前端请求发送到后端服务器，然后由后端服务器发送请求到目标服务器，最后将结果返回给前端。</p></li></ol><h2 id="cors实现跨域要设置哪些请求头？分别代表什么含义？"><a href="#cors实现跨域要设置哪些请求头？分别代表什么含义？" class="headerlink" title="cors实现跨域要设置哪些请求头？分别代表什么含义？"></a>cors实现跨域要设置哪些请求头？分别代表什么含义？</h2><ol><li><p><code>Access-Control-Allow-Origin</code></p><p>该字段是必须的。它的值是指定允许哪些域名的请求可以通过。可以使用通配符表示允许来自任何域的请求（不建议在生产环境中使用）。例如：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Access</span>-Control-Allow-Origin: *<br></code></pre></td></tr></table></figure><p>or</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">Access-Control-Allow-Origin: https:<span class="hljs-regexp">//</span>example.com<br></code></pre></td></tr></table></figure><p>第一种情况允许来自所有域的请求，第二种情况仅允许来自<code>https://example.com</code>域的请求。</p></li><li><p><code>Access-Control-Allow-Methods</code></p><p>该字段指示在预检请求中允许的 HTTP 方法。例如，对于一个 <code>POST</code> 请求，服务器可以返回以下头部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hson">Access-Control-Allow-Methods: POST<br></code></pre></td></tr></table></figure></li><li><p><code>Access-Control-Allow-Credentials</code></p><p>该字段设置为<code>true</code>时，表示允许发送Cookie和认证信息（如HTTP认证、客户端证书等）到跨域的服务器。默认值为<code>false</code>。如果不需要发送Cookie，则不需要设置此字段。例如：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Access</span>-Control-Allow-Credentials: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p><code>Access-Control-Expose-Headers</code></p><p>该字段指定哪些HTTP头部字段可以在跨域响应中暴露给浏览器 JavaScript 代码访问。例如，如果想让浏览器可以访问 Response 的自定义头部字段，则需要将其加入到该字段中。例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Access</span>-Control-Expose-Headers: X-My-Custom-<span class="hljs-keyword">Header</span>, X-Another-Custom-<span class="hljs-keyword">Header</span><br></code></pre></td></tr></table></figure></li></ol><p>额外说明：</p><p>跨域是指两个域名（协议 + 域名 + 端口号）不相同的情况。在前端，跨域通常指从一个网站的前端代码去访问另一个网站的接口数据。涉及跨域的请求会被浏览器做检查，如果检测到不符合安全机制的操作，就会阻拦这个请求。为了处理跨域问题，通常使用 CORS（跨源资源分享）方式。通过设置请求头中的CORS相关字段，服务器就可以将特定资源分享给指定的域名，从而解决跨域问题。</p><h3 id="跨域相关的HTTP请求头有哪些？⭐"><a href="#跨域相关的HTTP请求头有哪些？⭐" class="headerlink" title="跨域相关的HTTP请求头有哪些？⭐"></a>跨域相关的HTTP请求头有哪些？⭐</h3><ol><li><p>Access-Control-Allow-Origin</p><p>该字段用于允许哪些域名可以跨域访问资源。可以设置为*，表示允许所有域名访问。</p></li><li><p>Access-Control-Allow-Methods</p><p>该字段用于允许哪些HTTP方法可以跨域访问资源。例如GET、POST、PUT、DELETE等。</p></li><li><p>Access-Control-Allow-Headers</p><p>该字段用于允许哪些HTTP头可以跨域访问资源。例如Content-Type、Authorization等。</p></li></ol><h3 id="什么是Promise？"><a href="#什么是Promise？" class="headerlink" title="什么是Promise？"></a>什么是Promise？</h3><p>Promise是一种异步编程的解决方案，它可以将回调函数的嵌套层级降低，使异步操作的代码更易于理解和维护。对于一些需要等待异步操作完成后才能进行接下来的操作的场景，Promise可以帮助我们处理这种异步操作。</p><p>Promise可以理解为一个容器，其中保存了异步操作的结果。在Promise执行过程中，可以分为三种状态：</p><ol><li>Pending状态：Promise对象创建时处于Pending状态，表示异步操作正在执行。</li><li>Resolved状态：异步操作成功时，Promise对象的状态变为Resolved（也称作Fulfilled）状态，并且保存异步操作的结果，可以通过Promise的then方法获取。</li><li>Rejected状态：异步操作失败时，Promise对象的状态变为Rejected状态，并保存异步操作的错误信息，可以通过Promise的catch方法获取错误信息。</li></ol><p>Promise对象一旦进入Resolved或者Rejected状态，就不会再改变状态。所以在Promise对象创建后，可以通过then方法添加回调函数，当异步操作成功时调用该回调函数，如果异步操作失败则可以通过catch方法添加回调函数，当异步操作失败时调用该回调函数，在回调函数中对异步操作的结果进行处理。</p><p>Promise还具有链式调用的特点。当异步操作需要串联多个异步操作时，可以通过then方法将多个异步操作串联起来，然后在最后一个异步操作返回结果时，可以通过resolve方法返回结果，从而触发then方法中的回调函数进行处理。</p><h3 id="回调地狱是什么概念？"><a href="#回调地狱是什么概念？" class="headerlink" title="回调地狱是什么概念？"></a>回调地狱是什么概念？</h3><p>回调地狱是指在异步编程中，由于回调函数与回调函数的嵌套过于深入，导致代码难以维护和理解的情况。回调地狱通常出现在多个异步操作依次执行的场景中，每个异步操作完成后需要执行下一个异步操作。</p><p>例如，链式的 ajax 请求、多个文件的读取或写入等等。在回调地狱中，每个异步操作的回调函数都需要嵌套在前一个操作的回调函数中，导致代码逻辑混乱、难以维护和理解。</p><p>代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getData</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) &#123;<br>  <span class="hljs-title function_">parseData</span>(response, <span class="hljs-keyword">function</span>(<span class="hljs-params">parsedData</span>) &#123;<br>    <span class="hljs-title function_">validateData</span>(parsedData, <span class="hljs-keyword">function</span>(<span class="hljs-params">validatedData</span>) &#123;<br>      <span class="hljs-title function_">saveData</span>(validatedData, <span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>      &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>为解决回调地狱带来的问题，ES6 引入了 Promise 以及 async&#x2F;await 等语法规范，可以让异步操作更加简洁、可读性更高。</p><h3 id="Promise内部是如何实现的？"><a href="#Promise内部是如何实现的？" class="headerlink" title="Promise内部是如何实现的？"></a>Promise内部是如何实现的？</h3><p><code>Promise</code> 是基于 <strong>观察者的设计模式</strong> 实现的，<code>then</code> 函数要执行的函数会被塞入观察者数组中，当 <code>Promise</code> 状态变化的时候，就去执行观察组数组中的所有函数。</p><blockquote><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。</p></blockquote><p><code>Promise</code> 有三个状态：</p><ul><li><code>pending</code>：等待中</li><li><code>resolved</code>：已成功</li><li><code>rejected</code>：已失败</li></ul><p>在 <code>Promise</code> 的状态改变只有两种可能：从 <code>pending</code> 变为 <code>resolved</code> 或者从 <code>pending</code> 变为 <code>rejected</code>。</p><p><img src="D:\Users\HP\Pictures\Typora\promise-states.png" alt="promise-states"></p><p>每一个 <code>promise</code> 都一个 <code>then</code> 方法，这个是当 <code>promise</code> 返回结果之后，需要执行的回调函数，他有两个可选参数：</p><ul><li><code>onFulfilled</code>：成功的回调；</li><li><code>onRejected</code>：失败的回调；</li></ul><p><img src="http://liubin.org/promises-book/Ch2_HowToWrite/img/then_catch.png" alt="Then Catch flow"></p><h3 id="Promise的优点和缺点？"><a href="#Promise的优点和缺点？" class="headerlink" title="Promise的优点和缺点？"></a>Promise的优点和缺点？</h3><p>优点：</p><p>将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数，提供了统一的接口，使得控制异步操作更加容易。</p><p>缺点：</p><p>无法取消Promise，一旦新建后它就会立即执行，无法中途取消；如果不设置回调函数，Promise内部抛出错误不会反应到外部；当处于Pending状态时，无法得知现在处于哪个阶段(刚刚开始还是即将完成)。</p><h3 id="callback、Promise和async-x2F-await三者间的区别？"><a href="#callback、Promise和async-x2F-await三者间的区别？" class="headerlink" title="callback、Promise和async&#x2F;await三者间的区别？"></a>callback、Promise和async&#x2F;await三者间的区别？</h3><ol><li>callback是一种传统的处理异步操作的方式，通过将一个函数作为参数传递给另一个函数，在异步操作完成后调用该函数来处理异步操作的结果。callback的缺点是，<strong>如果嵌套过多，会形成回调地狱，代码难以维护</strong>。</li><li>Promise是ES6中提出的一种处理异步操作的方式，它可以更好地处理异步操作的结果。Promise可以链式调用，避免了回调地狱的问题，同时还可以更好地处理错误。Promise有三种状态：pending、fulfilled和rejected，可以通过then()和catch()方法来处理异步操作的结果。</li><li>async&#x2F;await是ES8中提出的一种基于Promise的异步编程方式。async函数返回一个Promise对象，可以使用await关键字来等待异步操作的结果，使得异步代码看起来更像同步代码。async&#x2F;await通过将异步操作转换为同步操作来实现异步编程的效果。</li></ol><h3 id="Promise常用的API？"><a href="#Promise常用的API？" class="headerlink" title="Promise常用的API？"></a>Promise常用的API？</h3><p>Promise.then、Promise.catch、Promise.finally、Promise.all、Promise.race</p><h3 id="Promise-all和Promise-race的区别？"><a href="#Promise-all和Promise-race的区别？" class="headerlink" title="Promise.all和Promise.race的区别？"></a>Promise.all和Promise.race的区别？</h3><p>Promise.all()和Promise.race()都是Promise的静态方法，用于处理多个Promise对象。它们的区别在于：</p><ul><li>Promise.all()会在多个promise全部resolve之后执行.then，而Promise.race()会在任何一个promise resolve后就会执行.then。</li><li>Promise.all()会等待所有的promise对象都resolve或有一个reject后才会执行.then，而Promise.race()只要有一个promise对象resolve或reject就会执行.then。</li><li>Promise.all()会返回所有Promise resolved后的结果数组或第一个rejected的Promise对象的报错信息。</li></ul><h3 id="Promise的错误在哪里进行捕捉"><a href="#Promise的错误在哪里进行捕捉" class="headerlink" title="Promise的错误在哪里进行捕捉?"></a>Promise的错误在哪里进行捕捉?</h3><p>Promise发生的错误可以在try…catch中捕获，也可以在.catch()中捕获。如果在try…catch中捕获，需要在Promise对象前加await关键字，否则无法捕获异步错误。如果在.catch()中捕获，需要在Promise对象后加.catch()方法。</p><h3 id="假设一个function中有多个Promise任务，然后有某个Promise发生了异常，如何准确判断是哪个Promise发生了异常？"><a href="#假设一个function中有多个Promise任务，然后有某个Promise发生了异常，如何准确判断是哪个Promise发生了异常？" class="headerlink" title="假设一个function中有多个Promise任务，然后有某个Promise发生了异常，如何准确判断是哪个Promise发生了异常？"></a>假设一个function中有多个Promise任务，然后有某个Promise发生了异常，如何准确判断是哪个Promise发生了异常？</h3><p>在reject()中进行处理</p><h3 id="axios的二次封装一般封装了什么？"><a href="#axios的二次封装一般封装了什么？" class="headerlink" title="axios的二次封装一般封装了什么？"></a>axios的二次封装一般封装了什么？</h3><p>设置超时事件、请求头、请求方法、错误处理，请求拦截器和响应拦截器等操作，如果重复进行劳动会浪费时间并使得代码变得冗余难以维护。</p><p>在请求拦截器中可以统一添加超时处理或取消请求等需要在请求前执行的事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 每次发送请求之前判断是否存在token</span><br>    <span class="hljs-comment">// 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况，此处token一般是用户完成登录后储存到localstorage里的</span><br>    token &amp;&amp; (config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = token)<br>    <span class="hljs-keyword">return</span> config<br>  &#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>&#125;)<br></code></pre></td></tr></table></figure><p>响应拦截器可以在接收到响应后先做一层操作，如根据状态码判断登陆状态、授权等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 响应拦截器</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据</span><br>  <span class="hljs-comment">// 否则的话抛出错误</span><br>  <span class="hljs-keyword">if</span> (response.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-keyword">if</span> (response.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> === <span class="hljs-number">511</span>) &#123;<br>      <span class="hljs-comment">// 未授权调取授权接口</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (response.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> === <span class="hljs-number">510</span>) &#123;<br>      <span class="hljs-comment">// 未登录跳转登录页</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(response)<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(response)<br>  &#125;<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 我们可以在这里对异常状态作统一处理</span><br>  <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span>) &#123;<br>    <span class="hljs-comment">// 处理请求失败的情况</span><br>    <span class="hljs-comment">// 对不同返回码对相应处理</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error.<span class="hljs-property">response</span>)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="前端如何实现多个接口并发请求，并按照顺序返回结果？"><a href="#前端如何实现多个接口并发请求，并按照顺序返回结果？" class="headerlink" title="前端如何实现多个接口并发请求，并按照顺序返回结果？"></a>前端如何实现多个接口并发请求，并按照顺序返回结果？</h3><p>在前端中，我们可以使用 <code>Promise.all()</code> 来实现多个接口的并发请求，并按照顺序返回结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> api1Promise = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/api1&#x27;</span>);<br><span class="hljs-keyword">const</span> api2Promise = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/api2&#x27;</span>);<br><span class="hljs-keyword">const</span> api3Promise = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/api3&#x27;</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([api1Promise, api2Promise, api3Promise])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">responses</span> =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(responses.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())))<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">results</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// results 包含了所有接口返回的数据，按照请求顺序存放</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理错误</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用了 <code>fetch()</code> 函数发起了多个接口请求，并将请求结果封装在一个 Promise 对象中。然后，我们使用 <code>Promise.all()</code> 来并发发起这些请求。<code>Promise.all()</code> 接收一个 Promise 对象数组，并在所有 Promise 对象都成功返回结果后，返回一个包含所有结果的 Promise 对象。</p><p>接着，在第一个 <code>.then()</code> 中，我们使用 <code>Promise.all()</code> 来将所有结果转换成 JSON 格式。这里需要注意的是，由于 <code>fetch()</code> 函数返回的是一个对象（而不是 JSON 字符串），因此我们需要使用 <code>.json()</code> 方法将其转换为 JSON 格式。</p><p>最后，在第二个 <code>.then()</code> 中，我们可以按照请求顺序将所有数据存放在 <code>results</code> 数组中，并进行处理。</p><h3 id="使用Promise-all时，在一个请求失败的情况下，如何获取剩余请求的结果？"><a href="#使用Promise-all时，在一个请求失败的情况下，如何获取剩余请求的结果？" class="headerlink" title="使用Promise.all时，在一个请求失败的情况下，如何获取剩余请求的结果？"></a>使用Promise.all时，在一个请求失败的情况下，如何获取剩余请求的结果？</h3><p><code>Promise.all()</code>进行实现，对传入的数组进行<code>map</code>处理。</p><p>核心内容是<code>map</code>方法，<code>map</code>的每一项都是<code>promise</code>，**<code>catch</code>方法返回值会被<code>promise.resolve()</code>包裹**，这样传进<code>promise.all</code>的数据都是<code>resolved</code>状态的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">let</span> p4 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">4</span>);<br><span class="hljs-keyword">let</span> p5 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;error&quot;</span>);<br><br><span class="hljs-keyword">let</span> arr = [p1, p2, p3, p4, p5];<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e))) <span class="hljs-comment">// rejected的Promise会被处理并用resolve包裹成一个新的Promise</span><br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求成功: &quot;</span>, res);<br>&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求失败: &quot;</span>, err);<br>&#125;)<br><br><span class="hljs-comment">// 请求成功:  [ 1, 2, 3, 4, &#x27;error&#x27; ]</span><br></code></pre></td></tr></table></figure><h3 id="Async如何进行错误捕获？原理是什么？"><a href="#Async如何进行错误捕获？原理是什么？" class="headerlink" title="Async如何进行错误捕获？原理是什么？"></a>Async如何进行错误捕获？原理是什么？</h3><p>在<code>async</code>函数中可以使用<code>try...catch</code>捕获错误，如果在<code>async</code>函数中发生了错误，它将会被抛出并将被<code>catch</code>捕获。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">doSomething</span>();<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>    &#125;<br>    <span class="hljs-keyword">catch</span>(error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>async/await</code>是基于Promise的语法糖，它背后的原理与Promise类似。在<code>async</code>函数中，如果发生错误，它将返回一个被拒绝的Promise对象，其错误原因就是抛出的错误。我们可以使用<code>try...catch</code>来捕获这个错误，就像捕获普通的Promise一样。在<code>catch</code>块中，我们可以处理这个错误，或者将它重新抛出，以便于在async函数的代码中继续处理它。</p><h3 id="try…catch是如何捕获异常的？"><a href="#try…catch是如何捕获异常的？" class="headerlink" title="try…catch是如何捕获异常的？"></a>try…catch是如何捕获异常的？</h3><p>首先执行<code>try</code>代码块中的代码。</p><p>如果<code>try</code>代码块中的代码没有发生任何异常，那么<code>catch</code>块中的代码不会被执行，程序将继续执行<code>try...catch</code>块后面的代码。</p><p>如果<code>try</code>块中发生了异常，那么程序将立即跳转到<code>catch</code>块中，并执行其中的代码。<code>catch</code>块中的代码将处理异常，并且可以使用异常对象来获取异常的详细信息。</p><p>如果<code>catch</code>中的代码成功处理了异常，那么程序将继续执行<code>try...catch</code>后面的代码。</p><p>如果<code>catch</code>中的代码没有成功处理异常，或抛出了新的异常，那么程序将被终止，并将新的异常抛出到调用栈中，直到被捕获或导致程序崩溃。</p><h3 id="异常是如何被抛出的？"><a href="#异常是如何被抛出的？" class="headerlink" title="异常是如何被抛出的？"></a>异常是如何被抛出的？</h3><p>当程序发生错误或意外情况的时候，将创建一个异常对象。</p><p>异常对象将被抛出到当前函数的调用栈中，直到被捕获或导致程序崩溃。</p><p>当异常现象被抛出的时候，当前函数的执行将立即停止，并且将控制权传递给调用栈中的上一级函数。</p><p>如果异常对象没有被捕获，将继续向上传递，直到到达程序的顶层，或者导致程序崩溃。</p><p>如果异常对象被捕获了，那么它将被传递给相应的catch块，直到catch块中的代码被执行。</p><h3 id="如何定义错误对象？"><a href="#如何定义错误对象？" class="headerlink" title="如何定义错误对象？"></a>如何定义错误对象？</h3><p>使用Error对象来定义错误对象。Error是JS内置对象，它包含一些属性和方法，用于描述和处理错误。我们可以通过创建一个新的Error对象来定义一个错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">consr error = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;This is a error message.&quot;</span>);<br></code></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个新的Error对象，并传递了一个错误消息作为参数。这个错误消息将被包含在Error对象中，并且可以在抛出错误时被输出到控制台或日志中。</p><p>除了Error对象之外，JavaScript还提供了其他一些内置的错误类型，例如SyntaxError、TypeError和ReferenceError等，它们都继承自Error对象，并且具有不同的属性和方法，用于描述和处理特定类型的错误。</p><p>我们还可以自定义对象类型，继承自Error对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Error</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">message</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(message);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;MyError&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个名为MyError的错误类型，它继承自Error对象。我们重写了构造函数，以便在创建MyError对象时设置错误消息和错误名称。我们可以像使用内置的Error对象一样使用MyError对象来抛出和处理错误。</p><h3 id="AJAX中的readyState从0到4分别代表什么含义？"><a href="#AJAX中的readyState从0到4分别代表什么含义？" class="headerlink" title="AJAX中的readyState从0到4分别代表什么含义？"></a>AJAX中的readyState从0到4分别代表什么含义？</h3><ul><li>0：请求未初始化。XMLHttpRequest对象已创建，但是尚未调用open方法。</li><li>1：服务器连接已建立。open方法已经调用，但是send方法未调用。请求已经建立，但是还未发送。</li><li>2：请求已接收。send方法已经调用，并且服务器已经返回了响应头。</li><li>3：请求处理中。响应体部分已经被接收，但是仍然没有完全接收。</li><li>4：请求已完成，且响应已就绪。响应体已经被完全接收，可以通过responseText或responseXML获取完整的响应数据。</li></ul><p>readyState属性只表示请求&#x2F;响应的状态，不能代表请求&#x2F;响应的结果。</p><h3 id="浏览器原生的发送请求的API有哪些？"><a href="#浏览器原生的发送请求的API有哪些？" class="headerlink" title="浏览器原生的发送请求的API有哪些？"></a>浏览器原生的发送请求的API有哪些？</h3><ol><li>XMLHttpRequest：XMLHttpRequest 是一个浏览器原生提供的对象，用于在后台与服务器交换数据。它可以在不重新加载页面的情况下更新页面的局部内容。XMLHttpRequest 支持各种类型的请求，比如 GET、POST、PUT、DELETE 等。</li><li>Fetch API：Fetch API 是一组与浏览器原生 Fetch 函数配合使用的接口，可以提供一种相对简单、可跨域的方式来获取资源。它是基于 Promise 对象设计的，使用更加优雅，可以同时发出多个请求。</li><li>WebSocket API：WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。利用它可以实现双向通信，许多在线游戏、实时性聊天应用和股票交易应用都使用它。</li><li>Server-Sent Events（SSE）API：SSE API 允许服务器定期发送数据到客户端，它与 WebSocket API 不同，在 WebSocket 中，无论何时客户端和服务器之间有数据要发送，连接都是由客户端初始化的，而 SSE 是由服务器端初始化的，客户端只需要打开 SSE 连接，并等待服务器发送数据。</li><li>WebRTC：WebRTC 是一种浏览器中的实时通信技术，它支持浏览器间的视频和音频流的传输，也支持 P2P 数据传输。WebRTC 利用多种功能，包括网络摄像头、麦克风、数据通道等，让浏览器更加智能。</li></ol><h3 id="Fetch和Ajax的区别？"><a href="#Fetch和Ajax的区别？" class="headerlink" title="Fetch和Ajax的区别？"></a>Fetch和Ajax的区别？</h3><ol><li>API 设计：Ajax 使用 XMLHttpRequest 对象来发送和接收数据，而 Fetch 则使用更加现代化的 Promise API，使得数据请求和处理更加优雅。</li><li>数据格式：Ajax 可以处理多种格式的数据，例如 JSON、XML、HTML 和文本等，而 Fetch 仅支持 JSON 和 Blob。</li><li>缓存：在缓存方面，Ajax 可以通过设置缓存时间和缓存位置来进行缓存管理，而 Fetch 则默认不缓存响应。</li><li>跨域支持：在处理跨域请求方面，Fetch API 内置支持 CORS，可以更加轻松地处理跨域请求，而在使用 Ajax 发送跨域请求时需要进行特殊的设置。</li><li>扩展性：虽然 Ajax 可以通过添加插件来扩展其功能，但 Fetch 的 API 设计更加简单、直接，易于扩展和使用。</li></ol><h2 id="Websocket承载的上限，能同时接受多少个客户端连接？"><a href="#Websocket承载的上限，能同时接受多少个客户端连接？" class="headerlink" title="Websocket承载的上限，能同时接受多少个客户端连接？"></a>Websocket承载的上限，能同时接受多少个客户端连接？</h2><p>WebSocket承载的上限取决于多个因素，包括服务器的硬件和软件配置、网络带宽、同时连接的客户端数量、客户端发送和接收数据的频率等。因此，无法给出一个具体的答案来回答能同时接受多少个客户端连接。</p><p>一般来说，WebSocket的性能通常比HTTP长连接更好，因为它使用的是基于事件的模型，可以在服务器和客户端之间实现实时的双向通信。但是，在实际应用中，如果同时连接的客户端数量过多，可能会导致服务器的负载过高，从而影响WebSocket的性能和可靠性。</p><p>为了提高WebSocket的性能和可靠性，可以采取一些优化措施，例如使用负载均衡、优化服务器端代码、增加服务器硬件配置、限制每个客户端的连接数量等。同时，也需要根据实际情况进行测试和调整，以确保WebSocket在高并发情况下的稳定性和性能。</p><h2 id="词法作用域是什么？"><a href="#词法作用域是什么？" class="headerlink" title="词法作用域是什么？"></a>词法作用域是什么？</h2><p>词法作用域（Lexical Scope），也叫静态作用域，是指<strong>变量的作用域是在代码书写的时候就确定好的，而不是在运行时确定的</strong>。JavaScript就是一种基于词法作用域的语言。</p><p>在词法作用域中，变量的作用域是由函数嵌套关系来决定的。当函数被创建时，它的作用域链就被创建了，作用域链中包含了当前函数和所有嵌套的父级函数的变量对象。当函数执行时，它会先在自己的变量对象中查找变量，如果找不到，就会沿着作用域链一级一级地向上查找，直到找到为止，如果一直到全局作用域都没有找到，就会报错。</p><p>词法作用域的好处是可以避免变量名冲突，因为变量的作用域是在代码书写的时候就确定好的，不会受到运行时的影响。同时，也使得代码的可读性更高，因为变量的作用域是在代码书写的时候就可以看到的，不需要等到运行时才知道。</p><h2 id="环境变量和变量对象是什么？"><a href="#环境变量和变量对象是什么？" class="headerlink" title="环境变量和变量对象是什么？"></a>环境变量和变量对象是什么？</h2><p>环境变量和变量对象都是 JavaScript 中与作用域相关的概念。</p><p>环境变量（Environment Record）是指当前执行上下文中所有变量和函数的声明，以及外部环境的引用。每个执行上下文都有自己的环境变量，它们按照作用域链的顺序组成了一个链式结构，可以通过这个结构访问到所有的变量和函数。</p><p>变量对象（Variable Object）是指当前执行上下文中所有变量和函数的实际存储位置。在全局执行上下文中，变量对象就是全局对象；在函数执行上下文中，变量对象包含了函数的参数、函数声明、变量声明等。变量对象也是按照作用域链的顺序组成了一个链式结构，可以通过这个结构访问到所有的变量和函数。</p><p>在 JavaScript 中，环境变量和变量对象是密切相关的。当一个函数被调用时，会创建一个新的执行上下文，其中包含了一个新的环境变量和变量对象。在函数执行时，会使用环境变量来查找变量和函数的实际存储位置，也就是变量对象。当函数执行完毕后，执行上下文被销毁，其中的环境变量和变量对象也随之被销毁。</p><h2 id="WebWorker和WebSocket？"><a href="#WebWorker和WebSocket？" class="headerlink" title="WebWorker和WebSocket？"></a>WebWorker和WebSocket？</h2><p>WebWorker：WebWorker是HTML5提供的一种JavaScript多线程解决方案，它可以让JavaScript脚本<br>在后台运行，从而避免阻塞UI线程。WebWorker可以创建一个独立的线程来执行JavaScript代码，这<br>样就可以在主线程之外执行一些耗时的操作，比如计算密集型任务、大量数据的排序、图像处理等。</p><p>WebSocket：WebSocket是HTML5提供的一种新协议，它可以在客户端和服务器之间建立一个持久性<br>的连接，从而实现双向通信。WebSocket协议可以让服务器主动向客户端推送数据，而不需要客户端<br>发起请求。Websocket协议通常用于实时通信、在线游戏、在线聊天等场景。</p><h2 id="TypeScript和JavaScript的区别？"><a href="#TypeScript和JavaScript的区别？" class="headerlink" title="TypeScript和JavaScript的区别？"></a>TypeScript和JavaScript的区别？</h2><ol><li>类型系统：TypeScript 强制规定变量、函数和参数的类型，而 JavaScript 则没有这个限制，可以使用任意类型。TypeScript 的类型系统可以在代码编写过程中提供更加明确的类型提示，减少错误发生的可能。</li><li>面向对象特性：TypeScript 支持面向对象编程的概念，例如：类、接口、命名空间等，而 JavaScript 并不完全支持这些特性。</li><li>扩展性：TypeScript 是 JavaScript 的超集，即 TypeScript 可以使用 JavaScript 中的所有语法，同时还有自己的特性。在掌握 JavaScript 语法的前提下，只需要了解 TypeScript 新增特性即可。</li><li>构建工具和开发环境：因为 TypeScript 有类型检查的特性，需要在编译之前进行类型检查，所以需要使用额外的 TypeScript 编译器来进行编译。此外，集成开发环境如 VS Code、WebStorm 等也提供了强大的 TypeScript 支持。</li></ol><h2 id="如何理解JS模块化？"><a href="#如何理解JS模块化？" class="headerlink" title="如何理解JS模块化？"></a>如何理解JS模块化？</h2><p>JS模块化是一种组织代码的方式，旨在解决代码的复杂性和可维护性问题。传统的JS开发方式是通过在全局作用域中定义变量和函数来组织代码，这种方式很容易导致命名冲突、代码重复等问题。而JS模块化则是将代码分解为多个独立的、具有特定功能和依赖关系的模块，每个模块内部的变量和函数都是私有的，从而避免了命名冲突等问题。</p><p>在JS模块化中，模块可以有多种类型，如ES6模块、CommonJS模块、AMD模块、UMD模块等。其中，ES6模块是现代浏览器原生支持的模块化规范，它通过import和export关键字来导入和导出模块，具有静态引用的特点；CommonJS模块是Node.js采用的模块化规范，它通过require函数来加载模块，通过module.exports或exports对象来导出模块，具有动态引用的特点；AMD模块则是由RequireJS提出的异步模块定义规范，它支持动态加载和异步执行；UMD模块则是通用模块定义规范，支持在不同的环境下使用不同的模块化方式（如CommonJS、AMD、全局变量等）。</p><p>JS模块化的优点包括：代码封装，避免命名冲突；减少冗余代码，提高代码的可复用性；可维护性强，易于进行单元测试等。</p><h2 id="JS和传统的C、C-这种语言有什么区别？"><a href="#JS和传统的C、C-这种语言有什么区别？" class="headerlink" title="JS和传统的C、C++这种语言有什么区别？"></a>JS和传统的C、C++这种语言有什么区别？</h2><ol><li>JS是一种脚本语言，而C、C++是编译型语言。JS的代码不需要进行编译，可以直接在浏览器或者Node.js中运行，而C、C++需要先进行编译才能运行。</li><li>JS是弱类型语言，而C、C++是强类型语言。JS中的变量可以动态类型转换，而C、C++的变量在定义时已经确定了类型，不允许类型转换。</li><li>JS是基于对象的语言，而C、C++是过程化的语言。JS中一切都是对象，包括函数，而C、C++则是基于过程的函数式编程语言。</li><li>JS具有自动垃圾回收机制，而C、C++需要手动管理内存。JS会自动识别不再使用的对象并回收内存，而在C、C++中，需要手动释放内存。</li><li>JS的变量作用域是基于函数的，而C、C++的变量作用域是基于块的。在JS中，变量的作用域是由函数的嵌套关系确定的；而在C、C++中，变量的作用域是由大括号的嵌套关系确定的。</li></ol><h2 id="nullptr与null有什么区别？"><a href="#nullptr与null有什么区别？" class="headerlink" title="nullptr与null有什么区别？"></a>nullptr与null有什么区别？</h2><p><code>nullptr</code> 是 C++ 中的关键字，用于表示空指针，即<strong>指向空地址的指针</strong>。而 <code>null</code> 是 JavaScript 中的特殊值，通常用于定义<strong>一个空或不存在的对象</strong>。</p><p>两者的区别主要在于语言和用途的不同。<code>nullptr</code> 是 C++ 中的关键字，用于表示一个指针变量没有指向任何有效的内存地址，C++11 引入了这个关键字来代替以前的 <code>NULL</code> 宏和 <code>0</code> 字面值。而 <code>null</code> 是 JavaScript 中的特殊值，用于表示一个不存在的对象或引用。在 JavaScript 中，如果一个变量没有被赋值，它的值默认为 <code>undefined</code>，而不是 <code>null</code>。</p><p>另外，<code>nullptr</code> 可以进行类型推导，即可以自动推导出指针类型，而 <code>null</code> 是一个固定的值。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring Recruitment</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML、CSS知识点总结</title>
    <link href="/2023/04/25/HTML%E3%80%81CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/25/HTML%E3%80%81CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML、CSS相关"><a href="#HTML、CSS相关" class="headerlink" title="HTML、CSS相关"></a>HTML、CSS相关</h1><h2 id="async和defer的区别？"><a href="#async和defer的区别？" class="headerlink" title="async和defer的区别？"></a>async和defer的区别？</h2><ul><li><p>async会先同步进行脚本的加载和执行以及文本的加载和执行，可能会阻塞DOM的解析，而defer脚本的加载和文档的加载和执行是同步进行的，在DOM解析完毕之后再进行脚本的执行，不会阻塞DOM的解析</p></li><li><p>多个带defer的script标签可以保证其加载顺序，而多个带async的script标签不能保证加载顺序</p></li></ul><h2 id="CSS常见的行内元素和块级元素？它们有什么区别？"><a href="#CSS常见的行内元素和块级元素？它们有什么区别？" class="headerlink" title="CSS常见的行内元素和块级元素？它们有什么区别？"></a>CSS常见的行内元素和块级元素？它们有什么区别？</h2><p><strong>行内元素：</strong>行内元素与其他行内元素并排，不能设置宽高，宽度默认为文字的宽度。</p><p><strong>块级元素：</strong>块级元素霸占一行，不能与其他任何元素并列，能接受宽高，如果不设置宽度，那么宽度将默认变为父级的100%。</p><p>常见的行内元素有：button、input、label、select、textarea、a、img、span、script等。</p><p>常见的块级元素有：div、section、p、table、form、header、footer、h1~h6、aside、canvas、ol、ul等。</p><p>CSS中，块级元素和行内元素的区别在于：</p><ul><li>块级元素独占一行，不能与其他任何元素并列；行内元素可以与其他行内元素并排。</li><li>块级元素可以设置宽高，而行内元素不能设置宽高，宽度由内容撑开。</li></ul><h2 id="CSS中水平垂直居中方式？-行内元素，块元素"><a href="#CSS中水平垂直居中方式？-行内元素，块元素" class="headerlink" title="CSS中水平垂直居中方式？(行内元素，块元素)"></a>CSS中水平垂直居中方式？(行内元素，块元素)</h2><p>一、行内元素（inline、inline-block）</p><ol><li>水平居中：可以给元素的父元素设置 <code>text-align: center;</code>。</li><li>垂直居中：可以给元素设置 <code>line-height</code> 属性，使其等于其包含容器的高度。</li></ol><p>二、块状元素（block）</p><ol><li><p>使用 flex 布局方式</p><p>给父元素设置 <code>display: flex; align-items: center; justify-content: center;</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用位置和 transform 方式</p><p>给需要居中的元素设置 <code>position: absolute;</code> 和 <code>transform: translate(-50%, -50%);</code>，再将其父元素设置为相对定位 <code>position: relative;</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用 table-cell 方式</p><p>将父元素设置为 <code>display: table-cell; vertical-align: middle; text-align: center;</code>，再将需要居中的子元素设置为 <code>display: inline-block;</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-cell;<br>  <span class="hljs-attribute">vertical-align</span>: middle;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="CSS单行多行文本溢出省略？"><a href="#CSS单行多行文本溢出省略？" class="headerlink" title="CSS单行多行文本溢出省略？"></a>CSS单行多行文本溢出省略？</h2><p>单行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#box</span> &#123;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-attribute">text-overflow</span>: ellipsis;<br>    white-wrap: no-wrap;<br>&#125;<br></code></pre></td></tr></table></figure><p>多行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#box</span> &#123;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br><span class="hljs-attribute">text-overflow</span>: ellipsis;<br>    <span class="hljs-attribute">display</span>: -webkit-box;<br>    -webkit-box-orient: vertical;<br>    -webkit-line-clamp: <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="什么是回流和重绘？"><a href="#什么是回流和重绘？" class="headerlink" title="什么是回流和重绘？"></a>什么是回流和重绘？</h2><p>回流：当DOM节点中的部分或全部元素的尺寸、结构、布局等发生变化的时候，浏览器就会重新渲染部分或全部文档，这个过程称为回流。</p><p>重绘：页面中元素的样式发生变化，但是不影响其在文档流中的位置，浏览器就会对该元素进行重绘。</p><p>发生回流一定会引起重绘，但是重绘不一定会引起回流。</p><h2 id="在什么情况下会触发回流？"><a href="#在什么情况下会触发回流？" class="headerlink" title="在什么情况下会触发回流？"></a>在什么情况下会触发回流？</h2><ul><li>添加或删除可见的DOM元素</li><li>元素位置、尺寸(包括外边距、内边距、边框大小、高度和宽度等)发生变化</li><li>内容发生变化(例如文本变化或图片被另一个不同尺寸的图片取代)</li><li>页面一开始渲染</li><li>浏览器窗口尺寸变化(因为回流是根据视口的大小来计算元素的位置和大小的)</li></ul><h2 id="获取元素的offsetHeight等会触发回流吗？"><a href="#获取元素的offsetHeight等会触发回流吗？" class="headerlink" title="获取元素的offsetHeight等会触发回流吗？"></a>获取元素的offsetHeight等会触发回流吗？</h2><p>会。</p><p><code>offsetHeight</code> 是一个元素的实时高度，必须重排重绘以后才能得到，如果不提前进行重排重绘，<code>offsetHeight</code> 有可能拿到的是浏览器缓存队列没执行完的时候的值。</p><h2 id="使用CSS的动画属性-animation和translate-会引起回流和重绘吗？"><a href="#使用CSS的动画属性-animation和translate-会引起回流和重绘吗？" class="headerlink" title="使用CSS的动画属性(animation和translate)会引起回流和重绘吗？"></a>使用CSS的动画属性(animation和translate)会引起回流和重绘吗？</h2><p><code>animation</code>属性可以通过改变元素的位置、大小、颜色等属性来实现动画效果，这些改变会导致元素的布局（位置和大小）和绘制（颜色和背景）属性发生变化，因此可能会引起回流和重绘。</p><p><code>translate</code>属性可以通过改变元素的位置来实现动画效果，这些改变也会导致元素的布局属性发生变化，因此可能会引起回流。</p><p>然而，相对于其他属性（如改变元素的宽高），使用<code>translate</code>属性进行动画效果的性能更高，因为它只会引起元素的复合（Compositing）和绘制（Painting），而不会引起布局（Layout）的改变，从而减少了回流的可能性。因此，建议在实现动画效果时尽可能使用<code>translate</code>属性。</p><h2 id="常见的position属性有哪些？sticky定位是什么时候添加的？"><a href="#常见的position属性有哪些？sticky定位是什么时候添加的？" class="headerlink" title="常见的position属性有哪些？sticky定位是什么时候添加的？"></a>常见的position属性有哪些？sticky定位是什么时候添加的？</h2><p>常见的CSS定位(position)属性有四种：static（静态定位），relative（相对定位），absolute（绝对定位）和fixed（固定定位）。</p><ul><li>static（静态定位）：元素默认的定位方式，按照文档流位置展示，不受top、left、right、bottom等属性的影响。</li><li>relative（相对定位）：相对于元素自身原来的位置进行偏移，并不影响元素的布局。可以通过设置top、left、right、bottom属性来控制元素偏移量。</li><li>absolute（绝对定位）：相对于最近非static定位祖先元素进行偏移，如果不存在非static定位的祖先元素，则相对于文档(body)进行偏移。通过top、left、right、bottom等属性进行元素的位置控制，会使元素脱离文档流。</li><li>fixed（固定定位）：元素相对于浏览器窗口进行偏移，不随滚动条滚动而改变。通过设置top、left、right、bottom等属性控制元素位置。</li></ul><p>Sticky定位是CSS3中新增的一种定位方式，是一种相对定位和固定定位的混合型定位，定义为相对定位和固定定位的交叉。它会随着页面滚动到一定位置后停止滚动，变成固定定位。Sticky定位在2017年才被加入W3C CSS规范中。</p><h2 id="绝对定位的元素会产生reflow-回流-吗？"><a href="#绝对定位的元素会产生reflow-回流-吗？" class="headerlink" title="绝对定位的元素会产生reflow(回流)吗？"></a>绝对定位的元素会产生reflow(回流)吗？</h2><p>绝对定位的元素会在页面加载时产生一次 reflow，但是随后的页面操作中不会再次触发 reflow。这是因为绝对定位的元素在定位时已经脱离了正常文档流，不会再影响其他元素的位置和布局。</p><p>然而，当发生以下情况时，绝对定位的元素会导致 reflow：</p><ol><li>改变绝对定位元素的位置和尺寸，例如通过 JavaScript 改变其 top、left、width、height 等属性。</li><li>改变绝对定位元素后面元素的位置和尺寸，例如通过 JavaScript 改变其 margin、padding、border、width、height 等属性。</li></ol><p>因此，尽量避免频繁地改变绝对定位元素的位置和尺寸，以减少页面的 reflow 造成的性能损失。</p><h2 id="什么是flex布局？⭐"><a href="#什么是flex布局？⭐" class="headerlink" title="什么是flex布局？⭐"></a>什么是flex布局？⭐</h2><p>flex弹性布局，为盒模型提供了最大的灵活性，设置为flex布局后，子元素的float、clear和vertical-align属性将失效。它的所有子元素自动成为容器成员，称为flex项目。容器默认两条轴：水平主轴(main axis)和垂直的交叉轴(cross axis)，项目默认沿水平主轴排列。</p><p>常见属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-direction</span> <span class="hljs-comment">/* 决定主轴方向 */</span><br><span class="hljs-attribute">flex-wrap</span> <span class="hljs-comment">/* 如果一条轴线排不下，如何换行 */</span><br><span class="hljs-attribute">flex-flow</span> <span class="hljs-comment">/* flex-direction和flex-wrap属性简写，默认为row nowrap */</span><br><span class="hljs-attribute">justify-content</span> <span class="hljs-comment">/* 项目在主轴上的对齐方式 */</span><br><span class="hljs-attribute">align-items</span> <span class="hljs-comment">/* 项目在交叉轴上的对其方式 */</span><br><span class="hljs-attribute">align-content</span> <span class="hljs-comment">/* 多根轴线时的对齐方式，如果只有一条轴线则不起作用 */</span><br><span class="hljs-attribute">align-self</span>  <span class="hljs-comment">/* 允许单个项目与其他项目不一样的对齐方式，可以覆盖align-items属性，默认为auto，表示继承父元素align-items属性，如果没有父元素则等同于stretch */</span> <br></code></pre></td></tr></table></figure><p><code>flex: 1</code>代表什么含义？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;<br><span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">1</span>;<br><span class="hljs-attribute">flex-basis</span>: <span class="hljs-number">0%</span>;<br></code></pre></td></tr></table></figure><p><code>flex: auto</code>代表什么含义？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;<br><span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">1</span>;<br><span class="hljs-attribute">flex-basis</span>: auto;  <span class="hljs-comment">/*元素根据剩余空间自动调整自身大小*/</span><br></code></pre></td></tr></table></figure><h2 id="flex-1具体指的是什么？"><a href="#flex-1具体指的是什么？" class="headerlink" title="flex: 1具体指的是什么？"></a>flex: 1具体指的是什么？</h2><ul><li><code>flex-grow: 1</code> (默认为0) ：表示元素的放大比例</li><li><code>flex-shrink: 1</code> (默认为1) ：表示元素的缩小比例</li><li><code>flex-basis: 0%</code> (默认为auto) ：元素本身的大小，这个属性定义了在分配多余空间之前，元素占据的主轴空间。浏览器根据这个属性计算是否有多余空间。</li></ul><h2 id="flex-derection方向改变后对主侧轴的排列会有什么影响？"><a href="#flex-derection方向改变后对主侧轴的排列会有什么影响？" class="headerlink" title="flex-derection方向改变后对主侧轴的排列会有什么影响？"></a>flex-derection方向改变后对主侧轴的排列会有什么影响？</h2><p>当 flex-direction 方向改变后，主侧轴也会随着改变方向。这将会对元素的排列位置产生影响。例如，如果原本是沿着水平方向排列的元素，当改变为垂直方向时，这些元素将会沿着垂直方向排列。换句话说，元素在水平和垂直方向上的位置将会互换。如果元素的排列使用了 align-items 或 justify-content 属性，则也会随着主侧轴的改变而改变。因此，排列的方式也会有所调整。</p><h2 id="移动端epx-移动端适配-问题如何解决？⭐"><a href="#移动端epx-移动端适配-问题如何解决？⭐" class="headerlink" title="移动端epx(移动端适配)问题如何解决？⭐"></a>移动端epx(移动端适配)问题如何解决？⭐</h2><ul><li>使用em&#x2F;rem等单位设置元素尺寸</li><li>响应式布局、百分比布局等</li><li>使用vw和vh单位</li><li>第三方库(lib-flexible、amfe-fiexible等)进行解决，这些库会根据屏幕像素密度和屏幕尺寸等信息自动计算出合适的rem值，从而解决移动端epx问题。</li></ul><h2 id="怎么判断当前设备是手机端？"><a href="#怎么判断当前设备是手机端？" class="headerlink" title="怎么判断当前设备是手机端？"></a>怎么判断当前设备是手机端？</h2><ol><li>使用CSS3的媒体查询，根据不同的屏幕尺寸和设备类型，判断当前设备是手机端还是PC端。</li><li>使用JavaScript判断设备类型，通过navigator.userAgent判断当前设备的类型和浏览器信息，从而判断当前设备是手机端还是PC端。</li><li>使用第三方库或工具，如Device.js、Detector.js等，这些库可以根据设备类型、分辨率、屏幕尺寸等信息，判断当前设备是手机端还是PC端。</li></ol><h2 id="如何查询当前屏幕的分辨率？"><a href="#如何查询当前屏幕的分辨率？" class="headerlink" title="如何查询当前屏幕的分辨率？"></a>如何查询当前屏幕的分辨率？</h2><p>可以使用<code>window.screen</code>对象的<code>width</code>和<code>height</code>属性来获取当前屏幕的分辨率，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> screenWidth = <span class="hljs-variable language_">window</span>.<span class="hljs-property">screen</span>.<span class="hljs-property">width</span>;<br><span class="hljs-keyword">const</span> screenHeight = <span class="hljs-variable language_">window</span>.<span class="hljs-property">screen</span>.<span class="hljs-property">height</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Screen resolution: <span class="hljs-subst">$&#123;screenWidth&#125;</span> x <span class="hljs-subst">$&#123;screenHeight&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><p><code>window.screen</code>对象是一个全局对象，它包括关于当前屏幕的一些信息，例如分辨率、屏幕大小、颜色深度等。<code>width</code>属性返回屏幕的实际宽度（以像素为单位），<code>height</code>属性返回屏幕的实际高度（以像素为单位）。</p><p><strong>需要注意的一点是，<code>window.screen</code>对象只能在浏览器中使用，不能在Node.js环境中使用。</strong></p><h2 id="移动端和pc端区别？"><a href="#移动端和pc端区别？" class="headerlink" title="移动端和pc端区别？"></a>移动端和pc端区别？</h2><ol><li>屏幕尺寸：移动端设备的屏幕尺寸比 PC 端设备要小，因此在设计和实现移动端界面时需要考虑到屏幕大小的限制。</li><li>输入方式：移动端设备的主要输入方式为触摸屏幕，而 PC 端设备则是通过鼠标、键盘等输入设备进行操作。因此，在移动端界面设计时需要优化操作方式，例如使用简单易懂的手势，优化输入框的大小和位置等等。</li><li>浏览器差异：移动端设备的浏览器不同，支持的 HTML、CSS、JavaScript 功能可能有所不同。因此，在编写 Web 应用时需要考虑到兼容性问题。</li><li>网络环境：移动端设备的网络环境相对不稳定，网络带宽也相对较低，因此在设计和实现移动端应用时需要考虑到网络带宽和加载速度的问题，尽可能减少页面和资源的加载时间。</li><li>电量和性能管理：移动端设备电量和性能管理是一项需要注意的因素，由于移动端设备的电池寿命和性能资源有限，因此应尽量减少对设备资源的占用，以提升用户体验。</li></ol><h2 id="em和rem的区别？"><a href="#em和rem的区别？" class="headerlink" title="em和rem的区别？"></a>em和rem的区别？</h2><p>em和rem都是相对单位长度</p><p>em是相对于父元素的字体大小来计算元素的大小</p><p>rem是相对于根元素的字体大小来计算元素的大小</p><h2 id="如何设置rem单位等于窗口高度？"><a href="#如何设置rem单位等于窗口高度？" class="headerlink" title="如何设置rem单位等于窗口高度？"></a>如何设置rem单位等于窗口高度？</h2><p>要将<code>rem</code>单位设置为等于窗口高度，可以使用JavaScript计算窗口高度，并将其值设置为<code>html</code>元素的<code>font-size</code>属性值。这样，<code>rem</code>单位的大小就会随着窗口高度的变化而变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取窗口高区 </span><br><span class="hljs-comment">// const windowHeight = window.innerHeight; 包含滚动条高度</span><br><span class="hljs-keyword">const</span> windowHeight = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span>;<br><span class="hljs-comment">// 将窗口高度设置为html元素的fonr-size属性值</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = windowHeight + <span class="hljs-string">&quot;px&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="什么是vw和vh"><a href="#什么是vw和vh" class="headerlink" title="什么是vw和vh?"></a>什么是vw和vh?</h2><p>vw和vh是CSS3引入的视口单位，是相对于视口的宽度和高度来计算元素的大小。</p><p>1vw等于视口宽度的1%，1vh等于视口高度的1%。除了vw和vh，还有vmin和vmax两个单位，vmin是vw和vh中较小的那个，vmax是vw和vh中较大的那个。</p><h2 id="如何实现CSS的渐变？"><a href="#如何实现CSS的渐变？" class="headerlink" title="如何实现CSS的渐变？"></a>如何实现CSS的渐变？</h2><p>CSS渐变可以让你在两个或多个指定的颜色之间显示平稳的过渡。CSS定义了两种渐变类型：线性渐变和径向渐变。线性渐变是从一个方向到另一个方向的颜色过渡，而径向渐变是从一个中心点到另一个中心点的颜色过渡。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(red, yellow); <span class="hljs-comment">/* 从上到下(默认)渐变 */</span><br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(to right, red , yellow); <span class="hljs-comment">/* 从左到右渐变 */</span><br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(to bottom right, red, yellow); <span class="hljs-comment">/* 从坐上到右下线性渐变 */</span><br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(angle, color-stop1, color-stop2); <span class="hljs-comment">/* angle指定水平线与渐变线之间的角度 */</span><br></code></pre></td></tr></table></figure><h2 id="CSS如何隐藏元素？"><a href="#CSS如何隐藏元素？" class="headerlink" title="CSS如何隐藏元素？"></a>CSS如何隐藏元素？</h2><ul><li><code>diaplay: none</code>：元素从页面移除，不占用空间，但是会破坏文档流，影响其他元素布局。</li><li><code>visibility: hidden</code>：元素隐藏，但是不会从文档流移除，仍然占用空间。</li><li><code>opacity: 0</code>：元素透明度设置为0，但是仍然占用空间，也会被屏幕阅读器识别。</li><li><code>position: absolute</code>，将元素移动到屏幕外面，不会影响布局，但是仍然占用空间，也会被屏幕阅读器识别。</li></ul><h2 id="z-index在什么情况下会失效？"><a href="#z-index在什么情况下会失效？" class="headerlink" title="z-index在什么情况下会失效？"></a>z-index在什么情况下会失效？</h2><ul><li><p>元素设置了浮动</p></li><li><p>父元素的<code>position</code>为<code>relative</code>时，子元素的<code>z-index</code>会失效。</p></li><li><p>元素的<code>position</code>不是<code>relative</code>、<code>absolute</code>或者<code>fixed</code>时。</p></li></ul><h2 id="CSS常用的垂直对齐方式属性？"><a href="#CSS常用的垂直对齐方式属性？" class="headerlink" title="CSS常用的垂直对齐方式属性？"></a>CSS常用的垂直对齐方式属性？</h2><ol><li><code>vertical-align</code>：用于控制元素的垂直对齐方式。该属性可以应用于行内元素和表格单元格元素。取值可以是基线（baseline）、顶部（top）、底部（bottom）、中间（middle）等。</li><li><code>line-height</code>：用于设置行高。行高决定了行内元素在垂直方向上的位置和间距。可以使用具体的像素值或百分比值来设置行高。</li></ol><h2 id="CSS中padding和margin的百分比写法是相对于谁的？"><a href="#CSS中padding和margin的百分比写法是相对于谁的？" class="headerlink" title="CSS中padding和margin的百分比写法是相对于谁的？"></a>CSS中padding和margin的百分比写法是相对于谁的？</h2><p>相对于父元素的宽度来进行计算。</p><p>例如，如果一个元素的父元素宽度为100px，将padding-left设置为20%，则左边padding宽度为20px。</p><h2 id="怎么设置padding、border不会撑开盒子？"><a href="#怎么设置padding、border不会撑开盒子？" class="headerlink" title="怎么设置padding、border不会撑开盒子？"></a>怎么设置padding、border不会撑开盒子？</h2><p>如果要设置<code>padding</code>和<code>border</code>不会撑开盒子，可以使用<code>box-sizing</code>属性来改变盒模型的计算方式。默认情况下，盒模型的计算方式是<code>content-box</code>(标准盒模型)，即宽度只包括内容区域，不包括内边距和边框。而如果将<code>box-sizing</code>属性设置为<code>border-box</code>(怪异盒模型)，则宽度包括内容区域、内边距和边框的宽度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: border-box; <span class="hljs-comment">/* 将盒模型设置为border-box */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样设置之后，元素的实际宽度就是200px，包括内边距和边框的宽度。而不会因为内边距和边框的宽度而撑开盒子。</p><h2 id="层叠上下文是什么？会展现什么效果？它的原理是什么呢？"><a href="#层叠上下文是什么？会展现什么效果？它的原理是什么呢？" class="headerlink" title="层叠上下文是什么？会展现什么效果？它的原理是什么呢？"></a>层叠上下文是什么？会展现什么效果？它的原理是什么呢？</h2><p>层叠上下文（stacking context）是指在 HTML 中，每个元素在页面上都有一个层级，而层叠上下文就是在这个层级中，某些元素在层叠上下文中拥有更高的优先级，能够覆盖在其他元素之上。</p><p>层叠上下文的出现会影响元素的显示效果，例如：</p><ol><li>z-index 属性：如果两个元素重叠在一起，可以通过设置它们的 z-index 值来确定哪个元素在上面显示，z-index 值越高的元素会覆盖在 z-index 值较低的元素之上。</li><li>透明度：如果父元素设置了透明度，那么子元素也会继承父元素的透明度，这时就需要用到层叠上下文来控制子元素的透明度。</li><li>position 属性：某些情况下，通过设置元素的 position 属性可以创建一个新的层叠上下文，从而影响元素的显示效果。</li></ol><p>层叠上下文的原理是：在 HTML 中，每个元素都有一个 z-index 属性，它用于控制元素在层级中的位置。当两个元素重叠在一起时，会根据它们的 z-index 值来确定哪个元素在上面显示。但是，有些元素会创建新的层叠上下文，它们的 z-index 值不再是与父元素的 z-index 值相对应，而是相对于整个页面的 z-index 值。这样，就可以通过设置元素的层叠上下文来控制元素在页面上的显示效果。</p><h2 id="什么是CSS样式穿透？有哪些语法？"><a href="#什么是CSS样式穿透？有哪些语法？" class="headerlink" title="什么是CSS样式穿透？有哪些语法？"></a>什么是CSS样式穿透？有哪些语法？</h2><p>CSS样式穿透是指在CSS中，一个选择器可以影响到其他选择器的样式。它允许我们通过一个选择器来改变另一个选择器的样式，从而避免了在HTML中添加额外的类和ID。</p><p><code>&amp;</code>符号：在Less和Sass中，<code>&amp;</code>符号表示当前选择器的父级，可以将当前选择器和父级选择器合并在一起，这样可以影响到父级选择器的样式。例如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>  <span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">color</span>: white;<br>    <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>      <span class="hljs-attribute">background-color</span>: red;<br>      <span class="hljs-selector-class">.sibling</span> <span class="hljs-selector-tag">&amp;</span> &#123;<br>        <span class="hljs-attribute">color</span>: yellow;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="如何避免样式干扰？"><a href="#如何避免样式干扰？" class="headerlink" title="如何避免样式干扰？"></a>如何避免样式干扰？</h2><p>样式干扰通常是由于CSS选择器不当或者CSS权重过高导致的。</p><p>以下是几种防止样式干扰的方法：</p><ol><li>使用更具体的CSS选择器：使用更具体的CSS选择器可以减少样式冲突的风险。例如，使用类选择器 <code>.my-component .my-button</code> 而不是 <code>.my-button</code> 。</li><li>使用CSS模块化：CSS模块化可以将CSS代码封装在组件内，避免全局样式的污染。例如，使用CSS Modules或CSS-in-JS等技术。</li><li>使用CSS预处理器：CSS预处理器可以帮助我们编写更清晰、更易维护的CSS代码，并且可以避免CSS选择器的冲突。例如，使用Less、Sass等预处理器。</li><li>使用CSS命名规范：使用一致的CSS命名规范可以避免命名冲突。例如，使用BEM命名规范。</li><li>使用!important规则：使用!important规则可以提高CSS样式的权重，但是应该尽量避免使用它。如果必须使用!important规则，应该将其用在极少数情况下，并确保它不会影响其他组件的样式。</li></ol><h2 id="CSS中可以将元素建立单独渲染层，这是什么机制？-CSS中可以为一个元素提供GPU加速，是什么机制？-⭐"><a href="#CSS中可以将元素建立单独渲染层，这是什么机制？-CSS中可以为一个元素提供GPU加速，是什么机制？-⭐" class="headerlink" title="CSS中可以将元素建立单独渲染层，这是什么机制？(CSS中可以为一个元素提供GPU加速，是什么机制？)⭐"></a><code>CSS</code>中可以将元素建立单独渲染层，这是什么机制？(<code>CSS</code>中可以为一个元素提供<code>GPU</code>加速，是什么机制？)⭐</h2><p>在<code>CSS</code>中，可以通过设置某些属性，将元素建立单独的渲染层，这个机制被称为<strong>GPU加速</strong>或<strong>硬件加速</strong>。</p><p>GPU加速的原理是利用了现代计算机的硬件加速能力，将一些常规的<code>CPU</code>计算任务转移到<code>GPU</code>上进行处理。因为<code>GPU</code>的并行计算能力比<code>CPU</code>强大，所以可以加速页面的渲染速度，提高用户体验。</p><p>在<code>CSS</code>中，可以通过以下属性将元素建立单独的渲染层：</p><ol><li><code>transform</code>属性：通过<code>transform</code>属性对元素进行2D或3D变换，可以触发硬件加速。</li><li><code>opacity</code>属性：通过<code>opacity</code>属性设置元素的透明度，也可以触发硬件加速。</li><li><code>filter</code>属性：通过<code>filter</code>属性对元素进行滤镜效果，也可以触发硬件加速。</li><li><code>will-change</code>属性：通过<code>will-change</code>属性预先告知浏览器哪些属性将会被修改，可以让浏览器提前将元素建立单独的渲染层，从而加速页面渲染。</li></ol><p>需要注意的是，过度使用GPU加速可能会导致性能问题，因为GPU的资源也是有限的。在使用GPU加速时，需要根据实际情况进行优化，避免过度使用。</p><h2 id="假如有个小球-每一秒往右移动1px，一是直接改margin-left，二是position：absolute-一点点加left，三是transition-translate-横轴一点点加，这三种哪一种性能最好？"><a href="#假如有个小球-每一秒往右移动1px，一是直接改margin-left，二是position：absolute-一点点加left，三是transition-translate-横轴一点点加，这三种哪一种性能最好？" class="headerlink" title="假如有个小球 每一秒往右移动1px，一是直接改margin-left，二是position：absolute 一点点加left，三是transition translate 横轴一点点加，这三种哪一种性能最好？"></a>假如有个小球 每一秒往右移动1px，一是直接改margin-left，二是position：absolute 一点点加left，三是transition translate 横轴一点点加，这三种哪一种性能最好？</h2><p>在这种情况下，使用 <code>transform</code> 和 <code>transition</code> 来移动小球的性能最好。因为这种方式利用了<strong>GPU加速</strong>，可以避免重排和重绘，从而提高了性能。相比之下，改变 <code>margin-left</code> 和使用 <code>position: absolute</code> 来移动小球，需要进行重排和重绘，性能较差。</p><h2 id="什么是bem？"><a href="#什么是bem？" class="headerlink" title="什么是bem？"></a>什么是bem？</h2><p>BEM是一种CSS命名规范，全称为Block-Element-Modifier，即块-元素-修饰符。它的核心思想是将页面中的组件或模块抽象成一个个块（Block），块内部可以包含多个元素（Element），而元素可以包含多个修饰符（Modifier），从而实现了对页面组件的精细化管理和命名。</p><p>具体来说，BEM的命名规则如下：</p><ul><li>Block（块）：代表一个独立的组件或模块，使用单个单词或短语命名，使用连字符(-)连接单词，例如：.navbar、.card、.header。</li><li>Element（元素）：代表块内部的一个组成部分，使用双下划线(__)连接块名和元素名，例如：.card__title、.navbar__menu。</li><li>Modifier（修饰符）：代表块或元素的状态或变体，使用单个单词或短语命名，使用单下划线(_)连接块名或元素名和修饰符名，例如：.card__title_highlighted、.navbar__menu_visible。</li></ul><p>BEM的优点是可以使CSS代码更加清晰、易于维护和扩展，同时可以避免CSS命名冲突和样式耦合的问题。</p><h2 id="什么是Shadow-DOM？"><a href="#什么是Shadow-DOM？" class="headerlink" title="什么是Shadow DOM？"></a>什么是Shadow DOM？</h2><p>Shadow DOM是一项Web标准技术，用于创建封装的组件和Web应用程序，使得组件的样式和行为不会受到外部CSS样式的干扰。Shadow DOM通过创建一个隔离的DOM树来实现这个目标，这个DOM树被称为“Shadow Tree”，它的内容和结构都不会影响到页面上的其他元素。</p><p>Shadow DOM可以被看作是一种Web组件技术，它可以将HTML、CSS和JavaScript封装在一个独立的组件内部，从而使得组件的样式和行为可以完全独立于页面的其他元素。Shadow DOM还提供了一些特殊的API，如：ShadowRoot、Element.attachShadow()和Element.shadowRoot，用于创建和管理Shadow Tree。</p><p>Shadow DOM的优点是可以实现组件的封装、复用和可维护性，同时也可以提高Web应用程序的性能和安全性。在Web开发中，Shadow DOM被广泛用于构建Web组件库、单页面应用程序和桌面应用程序等。</p><h2 id="有没有了解过TailWindCSS？"><a href="#有没有了解过TailWindCSS？" class="headerlink" title="有没有了解过TailWindCSS？"></a>有没有了解过<code>TailWindCSS</code>？</h2><p>Tailwind CSS是一个“实用优先”的CSS框架，它提供了一系列的样式类，可以用来快速地构建现代化的网站和应用程序。Tailwind CSS的设计理念是遵循“高度可定制”的原则，它提供了一组基础样式类，可以通过组合这些样式类来创建任意复杂度的布局和设计。</p><p>Tailwind CSS的核心思想是使用短小的、可重复使用的样式类来构建UI组件，而不是使用自定义样式表或者内联样式。这种方式可以大大减少代码的重复，并使得样式更易于维护和重构。</p><p>Tailwind CSS提供了一系列的样式类，覆盖了常见的UI组件和布局需求，例如：排版、背景、边框、文本、表格、按钮、表单、响应式布局等。此外，它还提供了一些实用的工具类，例如：间距、宽度、高度、颜色、字体等，可以帮助开发者快速地实现常用的样式效果。</p><p>使用Tailwind CSS可以大大提高开发效率，减少代码量，并且可以快速地构建出具有现代化风格的网站和应用程序。</p><h2 id="Sass预处理器的目的是什么？"><a href="#Sass预处理器的目的是什么？" class="headerlink" title="Sass预处理器的目的是什么？"></a>Sass预处理器的目的是什么？</h2><ol><li><strong>增强 CSS 功能</strong>：Sass 通过引入变量、嵌套、混入、函数、继承等功能，使得 CSS 更加强大、灵活和易于维护。</li><li><strong>提高效率</strong>：Sass 通过嵌套规则和提供复杂样式的简单方法，减少了重复和冗余的代码。同时，Sass 模块化的架构和继承能力简化了代码的编写和维护。</li><li><strong>降低维护成本</strong>：Sass 提供了灵活的代码重用和继承机制，使得样式的修改更加容易，减少了修改代码的时间和成本。</li><li><strong>更好的文档</strong>：Sass 可以帮助团队实现更好的代码文档化。我们可以使用像变量和混入等工具来向代码中添加注释，更容易弄清楚代码的含义。</li></ol><h2 id="Sass的工作原理？"><a href="#Sass的工作原理？" class="headerlink" title="Sass的工作原理？"></a>Sass的工作原理？</h2><ol><li>Sass 文件读取：在 Sass 的编译过程中，首先需要读取 Sass 文件。</li><li>Sass 语法解析：Sass 编译器会解析 Sass 文件中的语法，包括变量、嵌套、混入、函数、继承等功能。解析的结果会被保存在内存中。</li><li>Sass 语法转换：Sass 语法会转换为 CSS 语法。例如，Sass 的变量会被转换成 CSS 的属性值，Sass 的混入会被转换成 CSS 的 @include 指令。</li><li>CSS 文件生成：Sass 编译器将转换后的 CSS 代码生成为一个或多个 CSS 文件。</li><li>CSS 文件输出：生成的 CSS 文件可以直接输出到磁盘或者返回给 Web 服务器，用于被浏览器解析和应用。</li></ol><p>在 Sass 的编译过程中，使用的核心技术是 Sass 引擎和 CSS 解析器。Sass 引擎负责解析 Sass 语法，将其转换为 CSS 代码；CSS 解析器则负责将生成的 CSS 代码解析为浏览器所能识别的样式表。这些技术共同构成了 Sass 的编译过程和原理。</p><h2 id="如何画一条0-5px的直线？"><a href="#如何画一条0-5px的直线？" class="headerlink" title="如何画一条0.5px的直线？"></a>如何画一条0.5px的直线？</h2><ul><li><p><code>transform: scaleY(0.5)</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.line</span> &#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>   <span class="hljs-attribute">height</span>: <span class="hljs-number">1px</span>;<br>   <span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#C5C5C5</span>;<br>   <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>);<br>   -webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>); <span class="hljs-comment">/* Safari 和 Chrome */</span><br>   -moz-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>); <span class="hljs-comment">/* Firefox */</span><br>   -ms-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>); <span class="hljs-comment">/* IE 9 */</span><br>   -o-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>); <span class="hljs-comment">/* Opera */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用svg绘制线条</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&quot;0.5&quot;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&quot;0.5&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;#C5C5C5&quot;</span> <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="CSS的-和-选择器？"><a href="#CSS的-和-选择器？" class="headerlink" title="CSS的+和~选择器？"></a>CSS的+和~选择器？</h2><ol><li>+选择器（相邻兄弟选择器）：选择紧接着指定元素后出现的第一个同级元素。例如，p + span 选取紧随p元素之后第一个出现的span元素。</li><li>~选择器（通用兄弟选择器）：选择指定元素之后的所有同级元素。例如，p ~ span 选取所有在p元素之后出现的span元素。</li></ol><h2 id="什么是CSS吸顶组件？"><a href="#什么是CSS吸顶组件？" class="headerlink" title="什么是CSS吸顶组件？"></a>什么是CSS吸顶组件？</h2><p>CSS吸顶组件是指在页面中的某个元素距离顶部一定距离时（例如滚动到特定位置），该元素会变为fixed定位，固定在页面顶部，不再随页面滚动而移动，这种效果也称为“滚动监听”效果。</p><p>通常需要设置一个触发“吸顶”的滚动距离和一个吸顶的目标元素，然后监听滚动事件，一旦滚动距离超过触发距离就将目标元素应用fixed定位。在实现时，可以通过CSS的position: fixed属性来实现，或通过JavaScript监听滚动事件并动态修改目标元素的位置来实现。</p><p>CSS吸顶组件在web页面开发中非常常见，如网页顶部的导航栏。它可以提高页面的易用性和美观性，为用户提供更好的交互体验。</p><h2 id="如何实现CSS吸顶组件？"><a href="#如何实现CSS吸顶组件？" class="headerlink" title="如何实现CSS吸顶组件？"></a>如何实现CSS吸顶组件？</h2><ol><li><p>使用position: sticky属性</p><p>position: sticky是一种新的CSS属性，可以让元素在特定区域内始终保持定位。实现步骤如下：</p><p>（1）在目标元素上设置position: sticky属性，并设置top属性值为距离顶部的距离。</p><p>（2）设置容器元素的高度，让目标元素在容器区域内保持sticky效果。</p><p>（3）在CSS中设置滚动时目标元素的样式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">2000px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.header</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">position</span>: sticky;</span><br><span class="language-css">    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffffff</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.fixed</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">position</span>: fixed;</span><br><span class="language-css">    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffffff</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><br>    // 头部内容区域<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>使用JavaScript监听滚动事件</p><p>获取目标元素的offsetTop值，即目标元素距离页面顶部的距离。</p><p>监听页面的滚动事件，一旦滚动距离超过目标元素的offsetTop值，就给目标元素添加fixed定位。</p><p>在CSS中设置目标元素的fixed样式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.fixed</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">position</span>: fixed;</span><br><span class="language-css">    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffffff</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> header = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.header&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> headerOffsetTop = header.<span class="hljs-property">offsetTop</span>;</span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> &gt;= headerOffsetTop) &#123;</span><br><span class="language-javascript">      header.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;fixed&#x27;</span>);</span><br><span class="language-javascript">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">      header.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;fixed&#x27;</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><br>  // 头部内容区域<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="伪类和伪元素的区别？"><a href="#伪类和伪元素的区别？" class="headerlink" title="伪类和伪元素的区别？"></a>伪类和伪元素的区别？</h2><p><strong>伪类（Pseudo-classes）</strong></p><p>伪类是用来描述一个元素在特定状态下的样式。比如 <code>:hover</code> 伪类可以用来描述鼠标悬停时的样式。</p><p>常用的伪类包括：</p><ul><li><code>:hover</code>：鼠标悬停时的样式。</li><li><code>:active</code>：元素被激活时的样式，比如鼠标按下时。</li><li><code>:focus</code>：元素获得焦点时的样式。</li><li><code>:checked</code>：需要一个输入框是否被选中来设置样式。</li><li><code>:nth-child</code>：选择某个元素的父元素的第 n 个子元素来设置样式，比如 <code>:nth-child(2)</code> 表示选择父元素的第二个子元素。</li></ul><p>伪类的语法是在元素选择器之后添加 <code>:</code>，然后加上伪类的名称，比如 <code>a:hover</code>。</p><p><strong>伪元素（Pseudo-elements）</strong></p><p>伪元素则是用来创建一些元素之外的效果，并且不需要你在 HTML 中创建新的元素。比如 <code>::before</code> 和 <code>::after</code> 伪元素可以用来在元素的开始和结束位置添加一个样式。</p><p>常用的伪元素包括：</p><ul><li><code>::before</code>：在元素之前添加内容。</li><li><code>::after</code>：在元素之后添加内容。</li><li><code>::first-line</code>：选择元素的第一行来设置样式。</li><li><code>::first-letter</code>：选择元素的第一个字母来设置样式。</li></ul><p>伪元素的语法是在元素选择器之后添加 <code>::</code>，然后加上伪元素的名称，比如 <code>.panel::before</code>。</p><h2 id="什么情况下页面会出现滚动条？"><a href="#什么情况下页面会出现滚动条？" class="headerlink" title="什么情况下页面会出现滚动条？"></a>什么情况下页面会出现滚动条？</h2><ol><li>内容高度超过浏览器窗口高度，需要滚动来查看全部内容；</li><li>设置了固定高度的元素内容超过了父元素的高度；</li><li>解决网站导航固定时内容区域过长的问题，需要滚动来查看后续内容；</li><li>当浏览器窗口大小改变时，可能导致内容溢出父元素，需要滚动。</li></ol><p>其中，滚动条的出现方式包括垂直滚动条和水平滚动条，可以通过CSS属性overflow-x和overflow-y来设置滚动条。</p><h2 id="如何获取元素的宽高？"><a href="#如何获取元素的宽高？" class="headerlink" title="如何获取元素的宽高？"></a>如何获取元素的宽高？</h2><p>offsetHeight、offsetWidth</p>]]></content>
    
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>CSS</tag>
      
      <tag>Spring Recruitment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识点整理(12)</title>
    <link href="/2023/04/24/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-12/"/>
    <url>/2023/04/24/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-12/</url>
    
    <content type="html"><![CDATA[<h2 id="国内网站一般用的是哪个版本的http协议"><a href="#国内网站一般用的是哪个版本的http协议" class="headerlink" title="国内网站一般用的是哪个版本的http协议?"></a>国内网站一般用的是哪个版本的http协议?</h2><p>http1.1</p><h2 id="http3用UDP如何避免队头阻塞"><a href="#http3用UDP如何避免队头阻塞" class="headerlink" title="http3用UDP如何避免队头阻塞?"></a>http3用UDP如何避免队头阻塞?</h2><p>HTTP&#x2F;3使用的是基于UDP协议的QUIC传输协议，相对于传统TCP协议，QUIC可以避免队头阻塞（head-of-line blocking）的问题。</p><p>队头阻塞问题指的是当一个数据包在网络传输中出现丢包或延迟时，后续的数据包被迫等待，导致整个数据传输被阻塞。这种情况在TCP协议中比较常见。</p><p>而QUIC协议可以通过以下措施来避免队头阻塞问题：</p><ol><li>使用基于多路复用的流控制（flow control）技术，将数据拆分为多个小型帧，对于每个帧进行单独的传输和确认，从而避免了数据包因为前面的数据包被丢弃而被阻塞的情况。</li><li>使用QUIC协议的拥塞控制机制，对网络拥塞做出反应，根据网络负载的情况调整传输速率，避免了TCP协议中因为网络拥塞而导致的队头阻塞。</li></ol><p>总的来说，HTTP&#x2F;3通过QUIC协议的流控制和拥塞控制机制，有效地避免了队头阻塞问题，提升了网络传输的性能和稳定性。</p><h2 id="为什么有了进程还要有线程"><a href="#为什么有了进程还要有线程" class="headerlink" title="为什么有了进程还要有线程?"></a>为什么有了进程还要有线程?</h2><p>在计算机操作系统中，进程是程序的基本执行单元，而线程是进程内的一个单独执行流，共享进程的资源和空间。虽然进程可以通过多个线程实现并发，但也有很多情况下需要使用线程，具体原因有以下几点：</p><ol><li>资源共享：进程间的资源必须通过进程间通信（IPC）进行传递，而线程可以直接共享进程的资源，包括内存空间、打开的文件、信号处理器等，因此线程的通信代价低于进程的通信。</li><li>轻量级：线程比进程更轻量级，创建和销毁线程的代价远远小于创建和销毁进程的代价。多个线程可以在同一个进程内并发执行，从而提高整个系统的执行效率。</li><li>可以利用多核心：一个进程在单个CPU上只能并发执行一个线程，而一个多线程的进程可以同时在多个CPU内进行并发执行，提高执行效率。</li><li>更灵活：线程之间的切换代价要比进程之间的切换少，因此可以更灵活地控制代码的执行流程。线程还可以对代码的并发性进行更精细的控制，比如通过锁、信号量等机制控制对共享资源的访问。</li></ol><p>综上所述，线程虽然比进程更轻量级，但在实际应用中具有不可替代的优势，可以更高效地实现并发，提高系统的执行效率和灵活性。</p><h2 id="Git中如果两个人提交分支冲突怎么办？"><a href="#Git中如果两个人提交分支冲突怎么办？" class="headerlink" title="Git中如果两个人提交分支冲突怎么办？"></a>Git中如果两个人提交分支冲突怎么办？</h2><p>当两个人在Git中提交到相同分支时，Git可能会出现分支冲突（merge conflict）的情况。这种情况通常会出现在两个人在同一个文件的同一个地方进行了修改，Git无法判断应该采用哪个修改。解决冲突的方法如下：</p><ol><li>提交前进行代码协调：在提交代码之前，可以高效地协同工作，以避免出现冲突。</li><li>Pull更新代码：如果两个人在不同的副本上对同一个文件进行了修改，可以使用<code>git pull</code>命令，将两个副本合并到本地仓库中。这样可以避免出现相同代码冲突的情况。</li><li>Merge合并分支：如果两个人对同一个分支进行修改，可以使用<code>git merge</code>命令进行合并。Git会自动检查冲突，并在本地环境中进行解决冲突。</li><li>Rebase重构提交历史：如果两个人在同一个分支上工作，可以使用<code>git rebase</code>命令来重构提交历史以解决冲突。</li></ol><p>在解决冲突时，可以使用Git提供的工具帮助进行冲突解决，并手动解决冲突。最后再提交到版本库中。处理分支冲突需要一定经验和技能，需要仔细分析分支修改的内容，并根据需求灵活采取解决方案。</p><h2 id="前端新旧浏览器如何兼容？"><a href="#前端新旧浏览器如何兼容？" class="headerlink" title="前端新旧浏览器如何兼容？"></a>前端新旧浏览器如何兼容？</h2><ol><li>根据浏览器类型增加前缀和补丁：在CSS、JS、HTML等文件中，可以根据不同浏览器类型增加前缀和补丁。例如CSS中可以使用<code>-webkit-</code>、<code>-moz-</code>、<code>-o-</code>等前缀来解决浏览器兼容性问题。</li><li>使用指针事件代替手势事件：在IE浏览器中，没有支持手势事件的API，可以使用指针事件代替手势事件。指针事件可以在IE11及以上版本的浏览器中获得支持。</li><li>使用Polyfill填充开发者的API：Polyfill是一种库，可以在不支持新API的浏览器中通过JavaScript代码使用类似的API实现相同的功能。它可以使用JavaScript来抹平不同浏览器之间的差异，帮助开发人员开发跨浏览器的Web应用程序。</li><li>使用媒体查询和弹性布局：在设计响应式布局的时候，可以使用媒体查询（Media Query）和弹性布局（Flexbox）来实现响应式设计，从而适应不同的屏幕大小和浏览器类型。</li><li>采用替代方案或设计逐渐降级：如果在旧浏览器中无法实现新的特性，也可以选择采用替代的方案或者设计逐渐降级的方案，保证在旧浏览器上的用户也能够正常访问和使用。</li></ol><h2 id="JS和传统的C、C-这种语言有什么区别？"><a href="#JS和传统的C、C-这种语言有什么区别？" class="headerlink" title="JS和传统的C、C++这种语言有什么区别？"></a>JS和传统的C、C++这种语言有什么区别？</h2><ol><li>JS是一种脚本语言，而C、C++是编译型语言。JS的代码不需要进行编译，可以直接在浏览器或者Node.js中运行，而C、C++需要先进行编译才能运行。</li><li>JS是弱类型语言，而C、C++是强类型语言。JS中的变量可以动态类型转换，而C、C++的变量在定义时已经确定了类型，不允许类型转换。</li><li>JS是基于对象的语言，而C、C++是过程化的语言。JS中一切都是对象，包括函数，而C、C++则是基于过程的函数式编程语言。</li><li>JS具有自动垃圾回收机制，而C、C++需要手动管理内存。JS会自动识别不再使用的对象并回收内存，而在C、C++中，需要手动释放内存。</li><li>JS的变量作用域是基于函数的，而C、C++的变量作用域是基于块的。在JS中，变量的作用域是由函数的嵌套关系确定的；而在C、C++中，变量的作用域是由大括号的嵌套关系确定的。</li></ol><h2 id="数组方法map、some和filter的区别？"><a href="#数组方法map、some和filter的区别？" class="headerlink" title="数组方法map、some和filter的区别？"></a>数组方法map、some和filter的区别？</h2><ul><li><p><code>map</code> 方法会对原数组中的每个元素都执行一次给定的函数，并将执行结果存储到新数组中返回。这个过程不会改变原来的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> newArr = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num * <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr); <span class="hljs-comment">// [2, 4, 6, 8]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure></li><li><p><code>some</code> 方法会对原数组中的每个元素都执行一次给定的函数，如果有任意一个元素执行后返回的是真值，则返回 <code>true</code>，否则返回 <code>false</code>。这个过程不会改变原来的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">isEven</span> = num =&gt; num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">some</span>(isEven)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p><code>filter</code> 方法会对原数组中的每个元素都执行一次给定的函数，并将执行结果为真值的元素存储到一个新数组中返回。这个过程不会改变原来的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> evenNums = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(evenNums); <span class="hljs-comment">// [2, 4]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="移动端和pc端区别？"><a href="#移动端和pc端区别？" class="headerlink" title="移动端和pc端区别？"></a>移动端和pc端区别？</h2><ol><li>屏幕尺寸：移动端设备的屏幕尺寸比 PC 端设备要小，因此在设计和实现移动端界面时需要考虑到屏幕大小的限制。</li><li>输入方式：移动端设备的主要输入方式为触摸屏幕，而 PC 端设备则是通过鼠标、键盘等输入设备进行操作。因此，在移动端界面设计时需要优化操作方式，例如使用简单易懂的手势，优化输入框的大小和位置等等。</li><li>浏览器差异：移动端设备的浏览器不同，支持的 HTML、CSS、JavaScript 功能可能有所不同。因此，在编写 Web 应用时需要考虑到兼容性问题。</li><li>网络环境：移动端设备的网络环境相对不稳定，网络带宽也相对较低，因此在设计和实现移动端应用时需要考虑到网络带宽和加载速度的问题，尽可能减少页面和资源的加载时间。</li><li>电量和性能管理：移动端设备电量和性能管理是一项需要注意的因素，由于移动端设备的电池寿命和性能资源有限，因此应尽量减少对设备资源的占用，以提升用户体验。</li></ol><h2 id="对后端的理解？"><a href="#对后端的理解？" class="headerlink" title="对后端的理解？"></a>对后端的理解？</h2><p>后端是指Web应用程序中的服务器端（Server-Side）部分，主要负责处理客户端（Front-End）请求、数据库交互及业务逻辑处理等。后端通常是由Web框架、服务器、数据库等技术组成的，比如常用的Java后端主要基于Spring&#x2F;Spring Boot、MyBatis等技术架构来实现。</p><p>后端主要任务之一是<strong>将前端用户请求转化为后端业务逻辑，将处理结果返回给前端</strong>，因此后端需要实现一些接口，以供前端调用。同时，后端还需要负责<strong>与数据库进行交互，如响应前端的请求，查询数据库中的数据并返回结果，将前端提交的数据写入数据库等</strong>。此外，后端还需要实现一些<strong>系统基础服务</strong>，如身份认证、日志输出、缓存等。</p><p>为了保证后端的稳定性和高效性，后端需要考虑编码规范、安全性、性能优化等方面的问题。另外，随着Web技术的发展，后端还需要考虑如微服务、云计算等新技术的应用及其实现，以支持更好的系统架构和运行效率。</p><h2 id="如何管理线程池？"><a href="#如何管理线程池？" class="headerlink" title="如何管理线程池？"></a>如何管理线程池？</h2><p>线程池是一种可以重复利用的线程集合，它可以减少线程的创建和销毁次数，提高应用程序的性能。为了有效地管理线程池，我们需要考虑以下几个方面：</p><ol><li>线程池大小：线程池大小的配置需要根据应用程序的性质、系统硬件环境和其他因素进行合理的配置。如果线程池大小过小，则可能导致应用程序响应变慢，如果线程池过大，则会消耗大量系统资源，降低系统性能。</li><li>线程池任务队列：线程池任务队列可以缓存等待处理的任务，以便线程池中的线程可以及时处理。在实际应用中，我们需要根据实际情况来选择使用有界队列还是无界队列，以及队列的大小。</li><li>线程池任务拒绝策略：当线程池中的线程和任务队列都已满时，可以采用不同的任务拒绝策略，例如直接丢弃任务、抛出异常、调用者运行等。</li><li>线程池监控与日志：需要针对线程池进行监控和日志记录，以便及时发现并解决线程池性能问题。</li><li>线程池关闭：在应用程序退出或者不再需要线程池时，需要正确地关闭线程池，并释放所有的资源。</li></ol><p>总之，线程池的管理需要根据实际情况进行灵活配置和优化，以保证线程池能够高效地运行并且不会导致内存泄露等问题。</p><h2 id="单页应用和多面应用的区别？"><a href="#单页应用和多面应用的区别？" class="headerlink" title="单页应用和多面应用的区别？"></a>单页应用和多面应用的区别？</h2><p>单页应用（Single Page Application，SPA）指的是在一个页面中完成整个网站的展示和交互，只有在特定情况下才会重新加载页面的一种Web应用程序。多页应用（Multi-page Application，MPA）则是由多个页面组成，每个页面都是一个独立完整的HTML文档，用户进行页面切换需要重新加载整个页面。</p><p>单页应用和多页应用的最大区别在于应用程序后续的请求处理方式不同。单页应用程序通过前端路由技术，将URL与不同的视图组件关联，用户在页面中的交互（如点击按钮、输入框输入等）都会直接更新URL，并同时触发相关的界面更新操作，不会重新加载整个页面。多页应用程序则是通过不同页面之间超链接的跳转，从服务器端获取新页面的HTML、CSS、JS等资源，并重新渲染整个页面。</p><p>总结来说，单页应用程序的特点是前端渲染，路由控制，一定程度上提高了网站的用户体验，同时开发难度也较大；多页应用程序的特点是传统的后端渲染模式，开发难度较小，但体验较差。</p><h2 id="JS中定义函数的function-fun-和var-fun-x3D-function-两种方法有什么区别？"><a href="#JS中定义函数的function-fun-和var-fun-x3D-function-两种方法有什么区别？" class="headerlink" title="JS中定义函数的function fun(){}和var fun &#x3D; function(){}两种方法有什么区别？"></a>JS中定义函数的function fun(){}和var fun &#x3D; function(){}两种方法有什么区别？</h2><ol><li>函数声明语法具有变量提升的特性，可以在函数定义之前进行调用，而函数表达式语法在变量初始化之前调用会报错。</li><li>函数声明语法在函数名后面加上了圆括号和花括号，是一种<strong>声明式</strong>的方式，而函数表达式语法是将一个<strong>匿名函数</strong>通过变量赋值进行定义，是一种<strong>表达式式</strong>的方式。</li><li>函数声明语法可以用于在全局作用域或函数作用域内定义函数，而函数表达式语法一般用于在函数作用域内定义函数，但也可以在全局作用域内使用，只需要将函数表达式赋值给一个全局变量即可。</li><li>函数表达式可以作为参数传递到其他函数中，或者作为返回值返回到其他函数中，更加灵活，而函数声明语法就没有这种灵活性。</li></ol><h2 id="为什么不能在useEffect中使用async-x2F-await"><a href="#为什么不能在useEffect中使用async-x2F-await" class="headerlink" title="为什么不能在useEffect中使用async&#x2F;await"></a>为什么不能在useEffect中使用async&#x2F;await</h2><p>在 React 中，<code>useEffect</code> Hook 是用来处理有副作用的组件，比如操作 DOM、发起网络请求等。<code>useEffect</code> 接受一个函数，该函数会在每次组件更新触发时执行。通常情况下，该函数应该是同步的，因为该函数执行完成后，React 组件才能正常渲染。</p><p>在函数中使用 <code>async</code> 关键字会使函数返回一个 Promise，而 React 并不知道如何处理 Promise。因此，在 <code>useEffect</code> 中使用 <code>async</code>&#x2F;<code>await</code> 会造成一些问题，如下：</p><ol><li><code>async</code> 函数会在 <code>useEffect</code> 函数执行后直接返回一个 Promise，而 React 无法处理 Promise。</li><li><code>async</code> 关键字不能直接放在 <code>useEffect</code> 函数中，可以在函数内部定义一个异步函数，并在函数中调用它，但这样会使函数变得十分复杂。</li></ol><p>另外，<code>useEffect</code> 函数返回的是一个清理函数，用于在组件卸载或更新前清除副作用。如果在 <code>useEffect</code> 中使用异步函数，会使该清理函数失效，从而可能会导致一些难以排查的问题。</p><p>因此，React 官方建议不要在 <code>useEffect</code> 中使用异步函数，而是在 <code>useEffect</code> 函数内部使用 Promise 或回调函数等方式处理异步逻辑。</p><h2 id="JWT采用的是什么加密方法？"><a href="#JWT采用的是什么加密方法？" class="headerlink" title="JWT采用的是什么加密方法？"></a>JWT采用的是什么加密方法？</h2><p>JWT (JSON Web Tokens) 通常使用的加密算法是对称加密算法，其中最常用的是 <strong>HMAC-SHA256</strong>。对称加密算法需要<strong>在生成 JWT 时使用一个密钥进行加密，接收 JWT 时需要相同的密钥进行解密</strong>。除了对称加密算法，JWT 也可以使用非对称加密算法，例如 RSA。</p><p>(面试的时候真的没往这方面想…一直在考虑有什么加密方法…(´。＿。｀))</p><h2 id="NodeJS服务端代码在执行前会进行解析吗？"><a href="#NodeJS服务端代码在执行前会进行解析吗？" class="headerlink" title="NodeJS服务端代码在执行前会进行解析吗？"></a>NodeJS服务端代码在执行前会进行解析吗？</h2><p>Node.js 服务端的代码也是先进行解析，然后再执行。</p><p>Node.js 的执行过程包括三个阶段：解析阶段、编译阶段和执行阶段。在解析阶段，Node.js 将 JavaScript 代码解析为抽象语法树（AST）。在编译阶段，Node.js 将 AST 转换为字节码文件，同时进行一些优化（如 Just-In-Time（JIT）编译），以加快代码的执行速度。在执行阶段，Node.js 执行字节码文件，将其转换为机器码并执行。</p><p>与浏览器不同的是，Node.js 的代码在执行之前不需要对每个 JavaScript 文件进行单独的 HTTP 请求和加载，因为所有的代码都可以在本地磁盘上找到。另外，Node.js 还可以在运行时动态加载和卸载模块，这样可以更灵活地组织代码结构。</p><p>总之，Node.js 和浏览器一样，都需要将 JavaScript 代码解析为可执行的代码，然后才能执行。区别在于 Node.js 的代码是在本地磁盘上直接找到并加载的，而不需要通过网络请求，这使得 Node.js 更加适用于开发后端应用程序。</p><h2 id="git-checkout-HEAD-命令的作用？"><a href="#git-checkout-HEAD-命令的作用？" class="headerlink" title="git checkout HEAD^ 命令的作用？"></a>git checkout HEAD^ 命令的作用？</h2><p>git checkout HEAD^ 命令的作用是将工作区切换到当前分支的父提交（即当前提交的前一个提交）。HEAD^ 是一个指向当前分支最新提交的父提交的引用。</p><p>在这个命令中：</p><ul><li>git checkout：用于切换分支或恢复工作区文件。</li><li>HEAD：一个指向当前分支最新提交的引用。</li><li>^：表示父提交。可以使用 HEAD^、HEAD^^ 等表示当前提交的前一个、前两个提交。也可以使用 HEAD<del>1、HEAD</del>2 等表示相同的意义。</li></ul><p>执行 git checkout HEAD^ 后，工作区的内容将回退到前一个提交的状态。这在需要检查或修改之前提交的代码时非常有用。请注意，这会导致当前工作区的更改丢失，因此在执行此操作之前，请确保已保存或提交所有更改。</p><h2 id="什么情况下页面会出现滚动条？"><a href="#什么情况下页面会出现滚动条？" class="headerlink" title="什么情况下页面会出现滚动条？"></a>什么情况下页面会出现滚动条？</h2><ol><li>内容高度超过浏览器窗口高度，需要滚动来查看全部内容；</li><li>设置了固定高度的元素内容超过了父元素的高度；</li><li>解决网站导航固定时内容区域过长的问题，需要滚动来查看后续内容；</li><li>当浏览器窗口大小改变时，可能导致内容溢出父元素，需要滚动。</li></ol><p>其中，滚动条的出现方式包括垂直滚动条和水平滚动条，可以通过CSS属性overflow-x和overflow-y来设置滚动条。</p><h2 id="如何获取元素的宽高？"><a href="#如何获取元素的宽高？" class="headerlink" title="如何获取元素的宽高？"></a>如何获取元素的宽高？</h2><p>offsetHeight、offsetWidth</p><h2 id="常见的position属性有哪些？sticky定位是什么时候添加的？"><a href="#常见的position属性有哪些？sticky定位是什么时候添加的？" class="headerlink" title="常见的position属性有哪些？sticky定位是什么时候添加的？"></a>常见的position属性有哪些？sticky定位是什么时候添加的？</h2><p>常见的CSS定位(position)属性有四种：static（静态定位），relative（相对定位），absolute（绝对定位）和fixed（固定定位）。</p><ul><li>static（静态定位）：元素默认的定位方式，按照文档流位置展示，不受top、left、right、bottom等属性的影响。</li><li>relative（相对定位）：相对于元素自身原来的位置进行偏移，并不影响元素的布局。可以通过设置top、left、right、bottom属性来控制元素偏移量。</li><li>absolute（绝对定位）：相对于最近非static定位祖先元素进行偏移，如果不存在非static定位的祖先元素，则相对于文档(body)进行偏移。通过top、left、right、bottom等属性进行元素的位置控制，会使元素脱离文档流。</li><li>fixed（固定定位）：元素相对于浏览器窗口进行偏移，不随滚动条滚动而改变。通过设置top、left、right、bottom等属性控制元素位置。</li></ul><p>Sticky定位是CSS3中新增的一种定位方式，是一种相对定位和固定定位的混合型定位，定义为相对定位和固定定位的交叉。它会随着页面滚动到一定位置后停止滚动，变成固定定位。Sticky定位在2017年才被加入W3C CSS规范中。</p><h2 id="统一包命令和管理，除了npm还有哪些？"><a href="#统一包命令和管理，除了npm还有哪些？" class="headerlink" title="统一包命令和管理，除了npm还有哪些？"></a>统一包命令和管理，除了npm还有哪些？</h2><ol><li>Yarn：由Facebook团队开发的JavaScript包管理器，与npm类似，但具有更好的性能和可靠性。</li><li>Bower：专注于前端库和框架的包管理器，与npm和Yarn不同，它主要面向前端资源。</li><li>NuGet：适用于.NET开发的包管理器，可以用于管理各种类型的.NET组件，包括代码库、NuGet包、MSI文件等。</li><li>Cargo：适用于Rust编程语言的包管理器，与npm和Yarn相似，可以用于安装、更新和卸载Rust包。</li></ol><h2 id="匿名函数和普通函数的区别？"><a href="#匿名函数和普通函数的区别？" class="headerlink" title="匿名函数和普通函数的区别？"></a>匿名函数和普通函数的区别？</h2><p>匿名函数没有函数名称，而普通函数具有名称。</p><p>普通函数声明方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">functionName</span>(<span class="hljs-params">args</span>) &#123;<br>    <span class="hljs-comment">// function body</span><br>&#125;<br></code></pre></td></tr></table></figure><p>匿名函数的生命和调用有两种：</p><ul><li><p>函数表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> functionName = <span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) &#123;<br>    <span class="hljs-comment">// function body</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自执行函数 (IIFE)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) &#123;<br>    <span class="hljs-comment">// function body</span><br>&#125;)(args);<br></code></pre></td></tr></table></figure><p>这也是一个匿名函数，它在声明时被包裹在一对括号中，并紧随一对括号进行自执行。这样执行后，匿名函数不会再被保存在内存中，因此它常用于一些初始化工作。</p></li></ul><h2 id="立即执行函数和普通函数的区别？"><a href="#立即执行函数和普通函数的区别？" class="headerlink" title="立即执行函数和普通函数的区别？"></a>立即执行函数和普通函数的区别？</h2><ol><li>定义：立即执行函数是一个匿名函数，在声明之后立即执行；而普通函数可以根据需要来声明和调用。</li><li>作用域：立即执行函数可以创建一个新的作用域，避免变量污染；而普通函数的作用域由声明位置和调用方式所决定。</li><li>调用：立即执行函数的调用是紧随函数定义之后立即进行，而普通函数的调用则是在需要时通过函数名调用。</li></ol><p>立即执行函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 1</span><br>&#125;)()<br></code></pre></td></tr></table></figure><p>普通函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 1</span><br>&#125;<br><span class="hljs-title function_">myFunction</span>();<br></code></pre></td></tr></table></figure><p>可以看到，立即执行函数是通过将匿名函数声明后紧随一对括号，将函数定义包含在括号内，再在末尾加上一对括号来立即执行的。而普通函数则需要在需要时通过函数名来调用。</p><p>值得注意的是，立即执行函数的主要作用在于<strong>创建一个新的作用域，避免变量污染</strong>。<strong>在立即执行函数内定义的变量只在该函数内部可见，在函数外部是不可访问的</strong>。而普通函数则不具有这个特点，它的作用域由声明位置和调用方式所决定。</p><h2 id="解析地址-的意义？"><a href="#解析地址-的意义？" class="headerlink" title="解析地址#?的意义？"></a>解析地址#?的意义？</h2><p>解析地址中的<code>#</code>是用来表示页面内的锚点的，称为“hash符号”，而<code>#?</code>则没有特别的意义。</p><p>在Web页面中，经常会遇到这种跳转到页面内指定位置的场景。例如，点击页面上的某个链接或导航菜单时，可以通过设置链接的href属性来指定要跳转到的页面和锚点位置，如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#section1&quot;</span>&gt;</span>跳转到页面内指定位置<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这种情况下，<code>#</code>后面的部分就是锚点，代表要跳转到页面内的哪个位置。通过JavaScript的location对象的属性，可以获取当前页面的URL地址（包括hash符号“#”），并进行相应的处理。</p><p>在一些现代的Web应用中，也经常使用<code>#</code>来实现路由跳转功能，这种方式称为“单页应用（SPA）”，可以实现页面的局部刷新，避免每次切换页面时都要重新发起请求，降低网络负担等优点。在这种情况下，<code>#</code>后面的部分就是页面的路由地址，用来区分不同的页面或界面状态。</p><h2 id="使用Promise实现sleep-1s的函数"><a href="#使用Promise实现sleep-1s的函数" class="headerlink" title="使用Promise实现sleep 1s的函数"></a>使用Promise实现sleep 1s的函数</h2><p>可以使用<code>Promise</code>的定时器<code>setTimeout</code>来实现一个<code>sleep</code>函数，让其在一定时间后才执行下一步操作，具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params">ms</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, ms));<br>&#125;<br><br><span class="hljs-comment">// 使用方式</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">someFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这是第一步&#x27;</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-number">1000</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;一秒钟后执行第二步&#x27;</span>);<br>&#125;<br><br><span class="hljs-title function_">someFunction</span>();<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个<code>sleep</code>函数，它返回一个Promise对象，并在一定时间后通过<code>setTimeout</code>触发回调函数，从而让Promise的状态从<code>pending</code>变为<code>resolved</code>。在具体使用时，我们可以在某个<code>async</code>函数中使用<code>await sleep(1000)</code>，让其停顿一段时间后再执行后面的操作。</p><p>使用<code>Promise</code>实现的<code>sleep</code>函数并不是真正的“睡眠”，而是<strong>在等待时间内不执行下一步操作，而是将其放入Event Loop中，在调用栈空闲时再执行下一步操作</strong>。</p><h2 id="实现点击ul中的一个li时，返回点击的是第几个li"><a href="#实现点击ul中的一个li时，返回点击的是第几个li" class="headerlink" title="实现点击ul中的一个li时，返回点击的是第几个li"></a>实现点击ul中的一个li时，返回点击的是第几个li</h2><p>可以给每个li元素绑定一个点击事件，事件回调中获取当前点击的li的索引值，即可得到点击的是第几个li元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myList&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第一个li元素<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第二个li元素<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第三个li元素<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myList = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#myList&#x27;</span>);<br>myList.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-comment">// 获取点击的li元素</span><br>  <span class="hljs-keyword">const</span> targetLi = event.<span class="hljs-property">target</span>.<span class="hljs-title function_">closest</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br>  <span class="hljs-keyword">if</span>(targetLi) &#123;<br>    <span class="hljs-comment">// 获取点击的li元素在ul中的索引值</span><br>    <span class="hljs-keyword">const</span> index = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(myList.<span class="hljs-property">children</span>).<span class="hljs-title function_">indexOf</span>(targetLi);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`点击了第<span class="hljs-subst">$&#123;index+<span class="hljs-number">1</span>&#125;</span>个li元素`</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们给ul元素绑定一个<code>click</code>事件，当点击其中的一个li元素时，事件回调函数将被触发。在事件回调函数中，我们首先使用<code>event.target</code>属性获取当前点击的目标元素，如果该元素是一个li元素，则使用<code>Array.from(myList.children).indexOf(targetLi)</code>方法获取该li元素在ul中的索引值。需注意，<code>Array.from</code>将类数组对象转换成数组，所以我们才能使用数组的<code>indexOf</code>方法来获取索引值。最后我们使用<code>console.log</code>方法将点击的li元素的索引值输出到控制台。</p><h2 id="event-target-closest的作用是什么？"><a href="#event-target-closest的作用是什么？" class="headerlink" title="event.target.closest的作用是什么？"></a>event.target.closest的作用是什么？</h2><p><code>event.target</code>属性返回触发事件的元素，而<code>closest</code>方法则可以获取指定元素的最近的祖先元素，使我们可以方便地向上遍历DOM树并获取指定的父元素或祖先元素。</p><p>该方法接受一个CSS选择器作为参数，并从当前元素开始在DOM树上向上遍历，直到找到一个与提供的选择器匹配的元素，或者到达根元素，则返回<code>null</code>。</p><p>在实际应用中，<code>closest</code>方法经常用于处理事件委托（event delegation）和特定元素的事件响应。在事件委托中，我们只在父元素绑定一个事件监听器，然后通过<code>event.target</code>来获取实际被点击的子元素，然后再获取该元素的祖先元素，从而根据祖先元素来判断具体要执行什么操作。</p><p>例如，在上面的代码示例中，我们通过<code>event.target</code>来获取实际被点击的li元素，并使用<code>closest(&#39;li&#39;)</code>获取该元素的最近的祖先li元素，以确保我们得到正确的li元素。这样的代码可以让我们的事件处理程序更加清晰、灵活和可维护。</p><h2 id="手写实现Math-pow"><a href="#手写实现Math-pow" class="headerlink" title="手写实现Math.pow()"></a>手写实现Math.pow()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myPow</span>(<span class="hljs-params">num, n</span>) &#123;<br>    <span class="hljs-comment">// if n = 0, pow(num, n) = 1</span><br>    <span class="hljs-keyword">if</span>(n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// if n &lt; 0, pow(num, n) = pow(1/num, -n);</span><br>    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>) &#123;<br>        num = <span class="hljs-number">1</span> / num;<br>        n = -n;<br>    &#125;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(n !== <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) &#123;<br>            result *= num;<br>        &#125;<br>        num *= num;<br>        n = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(n / <span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="nullptr与null有什么区别？"><a href="#nullptr与null有什么区别？" class="headerlink" title="nullptr与null有什么区别？"></a>nullptr与null有什么区别？</h2><p><code>nullptr</code> 是 C++ 中的关键字，用于表示空指针，即<strong>指向空地址的指针</strong>。而 <code>null</code> 是 JavaScript 中的特殊值，通常用于定义<strong>一个空或不存在的对象</strong>。</p><p>两者的区别主要在于语言和用途的不同。<code>nullptr</code> 是 C++ 中的关键字，用于表示一个指针变量没有指向任何有效的内存地址，C++11 引入了这个关键字来代替以前的 <code>NULL</code> 宏和 <code>0</code> 字面值。而 <code>null</code> 是 JavaScript 中的特殊值，用于表示一个不存在的对象或引用。在 JavaScript 中，如果一个变量没有被赋值，它的值默认为 <code>undefined</code>，而不是 <code>null</code>。</p><p>另外，<code>nullptr</code> 可以进行类型推导，即可以自动推导出指针类型，而 <code>null</code> 是一个固定的值。</p><h2 id="单页应用与多页应用的区别？"><a href="#单页应用与多页应用的区别？" class="headerlink" title="单页应用与多页应用的区别？"></a>单页应用与多页应用的区别？</h2><p>单页应用（Single Page Application，SPA）和多页应用（Multiple Page Application，MPA）是常见的两种 Web 应用程序结构。</p><p>单页应用是一种<strong>动态加载内容</strong>的方式，它仅仅<strong>在浏览器对服务器发起请求时加载必要的 HTML、CSS 和 JavaScript 文件，并通过 AJAX 技术从服务器获取新内容</strong>。用户在一个页面上进行所有的交互，而页面的更新和内容的变化则是由 JavaScript 控制的。单页应用可以<strong>提高网站的响应速度和用户体验，并且可以适应各种设备和屏幕尺寸</strong>。</p><p>相比之下，多页应用是一种传统的 Web 应用程序结构，<strong>浏览器在用户导航时每次向服务器请求新页面，服务器再返回一个全新的 HTML 文档</strong>。在多页应用中，<strong>每个页面都有自己的 URL，并且需要通过浏览器的后退功能进行导航</strong>。</p><p>SPA 和 MPA 的最主要区别在于其数据的加载方式。<strong>SPA 通常会在页面初始化的时候加载所有必要的组件和数据，而 MPA 则是在每次进行页面跳转的时候重新加载页面和数据</strong>。SPA 通过 AJAX 技术实现快速的页面局部更新，而 MPA 则需要向服务器请求完整的 HTML 文档。</p><p>另外，SPA 的优点还包括<strong>更流畅、更快的用户体验、可复用性更高、开发成本更低</strong>，而 MPA 的优点则包括 <strong>SEO 更加友好、实现简单易懂，适合传统的 Web 应用程序</strong>。</p><h2 id="什么是CDN-内容分发网络-？"><a href="#什么是CDN-内容分发网络-？" class="headerlink" title="什么是CDN (内容分发网络) ？"></a>什么是CDN (内容分发网络) ？</h2><p>CDN即内容分发网络（Content Delivery Network），是一种<strong>利用多台服务器分别支持在线业务的网络架构</strong>，也可以理解为一种加速数据传输的技术服务。</p><p>CDN的基本原理是，将网站的内容（如文本、图片、视频等）复制到分布在全国乃至全球各地的CDN节点上，当用户需要访问网站的内容时，可以从距离其最近的CDN节点上获取所需内容，降低了网站访问延迟和拥堵，提高了用户访问速度和稳定性。</p><p>CDN服务提供商会从中心节点向全球建立多个缓存节点，使得用户的请求可以从离自己最近的节点获取数据，因而避免了传统的以中心节点为中心的单点故障和网络拥堵问题，同时也减轻了源站的压力，提高了数据传输的效率和可靠性。</p><p>CDN技术的应用广泛，比如可以用于优化网站速度，提高用户访问体验，降低视频播放卡顿率，减轻服务器负载，提高网站的安全性等等。</p><h2 id="获取HTML文档树最深节点"><a href="#获取HTML文档树最深节点" class="headerlink" title="获取HTML文档树最深节点"></a>获取HTML文档树最深节点</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDeepestNode</span>(<span class="hljs-params">node, depth</span>) &#123;<br>  <span class="hljs-keyword">var</span> maxDepth = depth;<br>  <span class="hljs-keyword">var</span> deepestNode = node;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; node.<span class="hljs-property">childNodes</span>.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">var</span> child = node.<span class="hljs-property">childNodes</span>[i];<br>    <span class="hljs-keyword">if</span> (child.<span class="hljs-property">nodeType</span> === <span class="hljs-title class_">Node</span>.<span class="hljs-property">ELEMENT_NODE</span>) &#123;<br>      <span class="hljs-keyword">var</span> childDepth = <span class="hljs-title function_">getDeepestNode</span>(child, depth + <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">if</span> (childDepth &gt; maxDepth) &#123;<br>        deepestNode = child;<br>        maxDepth = childDepth;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> maxDepth === depth ? node : deepestNode;<br>&#125;<br><br><span class="hljs-keyword">var</span> html = <span class="hljs-string">&#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;p&gt;Paragraph 1&lt;/p&gt;&lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>;<br><span class="hljs-keyword">var</span> parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DOMParser</span>();<br><span class="hljs-keyword">var</span> doc = parser.<span class="hljs-title function_">parseFromString</span>(html, <span class="hljs-string">&#x27;text/html&#x27;</span>);<br><span class="hljs-keyword">var</span> deepestNode = <span class="hljs-title function_">getDeepestNode</span>(doc.<span class="hljs-property">documentElement</span>, <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(deepestNode.<span class="hljs-property">outerHTML</span>);<br></code></pre></td></tr></table></figure><p>在上面的示例代码中，我们定义了一个 <code>getDeepestNode</code> 函数，该函数使用递归方式计算给定节点的深度。我们遍历节点的所有子节点，并对每个子节点递归调用 <code>getDeepestNode</code> 函数，得到一个子节点的深度，然后将子节点的深度加1，最终计算出当前节点的深度。当节点没有子节点时，我们返回节点的当前深度。</p><p>接下来，我们遍历HTML文档树中的所有节点，调用 <code>getDeepestNode</code> 函数计算每个节点的深度，并找到最深的节点。当遇到有多个节点在最深处时，返回第一个最深的节点。</p><p>在示例代码中，HTML文档树中最深的节点是第二个 <code>&lt;p&gt;</code> 标签，因为它是在最深的分支的末端。所以我们输出这个节点的 <code>outerHTML</code>。</p><h2 id="Node-ELEMENT-NODE是什么含义？"><a href="#Node-ELEMENT-NODE是什么含义？" class="headerlink" title="Node.ELEMENT_NODE是什么含义？"></a>Node.ELEMENT_NODE是什么含义？</h2><p><code>Node.ELEMENT_NODE</code> 是 JavaScript 中 Node 接口的一个属性，它表示节点类型为元素节点。元素节点是 HTML 文档中的一个重要组成部分，它由开始标签、结束标签和标签之间的内容组成。</p><p>DOM 树中的每个节点都可以用一个数字常量来表示它的节点类型，其中 <code>Node.ELEMENT_NODE</code> 的值为 1，表示当前节点是元素节点。其他节点类型包括 <code>Node.TEXT_NODE</code>，<code>Node.COMMENT_NODE</code>，<code>Node.DOCUMENT_NODE</code>等等。</p><p>在 JavaScript 中，我们可以使用节点的 <code>nodeType</code> 属性来获取节点类型。例如，如果我们有以下 HTML 元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span>Example<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们可以使用 JavaScript 来获取这个元素节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> elementNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;example&quot;</span>);<br><span class="hljs-keyword">if</span> (elementNode.<span class="hljs-property">nodeType</span> === <span class="hljs-title class_">Node</span>.<span class="hljs-property">ELEMENT_NODE</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This is an element node!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们检查 <code>elementNode</code> 的 <code>nodeType</code> 属性是否等于 <code>Node.ELEMENT_NODE</code>，以确保它是一个元素节点。如果是，我们打印一条提示信息到控制台。</p><h2 id="为什么history模式会出现404的情况？"><a href="#为什么history模式会出现404的情况？" class="headerlink" title="为什么history模式会出现404的情况？"></a>为什么history模式会出现404的情况？</h2><p>在使用 HTML5 History API 中的 history 模式时，如果不正确地设置服务器配置，就有可能出现 404 错误。<strong>这是因为在 history 模式下，浏览器的 URL 地址与后端服务器的路由地址是不同的，此时需要后端服务器做出相应的配置</strong>。</p><p>在 history 模式中，URL 会随着页面的跳转而发生变化，但实际上服务器只会返回同一个 HTML 文件，因此如果没有正确地配置服务器，当用户在浏览器中直接输入 URL 或者刷新浏览器时，服务器会根据该路径去查找对应的文件，但是由于该文件不存在于服务器中，所以就会返回 404 错误。</p><p>为了解决这个问题，我们需要在服务器端进行以下配置：</p><ol><li><p>配置重定向：在任何非文件资源请求的情况下，将所有请求都重定向到 index.html 文件上。这可以通过在服务器上设置一个统配符来完成。例如，如果使用 Apache 服务器，可以在 .htaccess 文件中添加以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs htaccess">&lt;IfModule mod_rewrite.c&gt;<br>  RewriteEngine On<br>  RewriteBase /<br>  RewriteRule ^index\.html$ - [L]<br>  RewriteCond %&#123;REQUEST_FILENAME&#125; !-f<br>  RewriteCond %&#123;REQUEST_FILENAME&#125; !-d<br>  RewriteRule . /index.html [L]<br>&lt;/IfModule&gt;<br></code></pre></td></tr></table></figure></li><li><p>配置404.html文件：将服务器上的默认错误页面更改为自定义的错误页面。在这个自定义的错误页面中，我们可以在页面中使用 JavaScript 来动态获取页面路径并重定向到正确的路径上。</p></li></ol><p>以上两种配置方式可以解决 history 模式中出现 404 错误的问题，确保每个路由的请求都被正确地处理。</p><h2 id="HTTP中常见的请求头有哪些？"><a href="#HTTP中常见的请求头有哪些？" class="headerlink" title="HTTP中常见的请求头有哪些？"></a>HTTP中常见的请求头有哪些？</h2><ol><li><strong>Accept</strong>：指定客户端接受的MIME类型。如果服务器无法返回指定类型的数据，则返回406错误状态码。</li><li>User-Agent：指定请求的客户端代理名称和版本号。这个请求头可以被用于浏览器嗅探，从而让服务器返回针对特定浏览器的响应。</li><li><strong>Host</strong>：指定请求的主机名，包括端口号。在多虚拟主机环境下，服务器可以通过该头部来判断客户端所请求的主机名和端口号。</li><li>Accept-Language：指定客户端语言环境，告诉服务器可以接受哪些语言的资源。</li><li>Accept-Encoding：指定客户端可以支持的内容编码方式，如Gzip、Deflate等，告诉服务器哪种压缩格式可以被客户端处理。</li><li><strong>Connection</strong>：控制HTTP连接的行为，如关闭连接、保持连接等。</li><li><strong>If-Modified-Since</strong>：告诉服务器如果请求资源自指定日期以来没有被修改过，那么只返回304状态码，不返回资源本身，减少了网络数据传输的开销。</li><li>Authorization：用于客户端想要访问需要授权的资源，包含授权类型和凭证信息（通常是用户名密码）。</li><li><strong>Cache-Control</strong>：用于控制客户端或缓存是否可以缓存该响应，可以通过设置max-age和no-store等参数来控制缓存行为。</li><li><strong>Cookie</strong>：用于在客户端和服务端之间传递状态信息，可以通过设置cookie来实现“记住我”等功能。</li><li>Range：指定请求的范围，可以用于断点续传等场景。</li><li><strong>Content-Type</strong>：指定请求体的MIME类型，在POST请求中常被用到。</li><li><strong>Content-Length</strong>：指定请求体的长度，用于解析请求体。</li><li>Transfer-Encoding：指定分块传输编码方式，可以被用于实现长连接。</li></ol><h2 id="如果需要发送请求，在React生命周期的什么阶段进行发送合适？原因是什么？"><a href="#如果需要发送请求，在React生命周期的什么阶段进行发送合适？原因是什么？" class="headerlink" title="如果需要发送请求，在React生命周期的什么阶段进行发送合适？原因是什么？"></a>如果需要发送请求，在React生命周期的什么阶段进行发送合适？原因是什么？</h2><p>通常，发送请求可以放在React组件的生命周期的某些阶段中，具体要看数据流动的方式和实现需求。</p><p>一般来说，最常见的阶段是componentDidMount。这是因为<strong>在组件渲染完成后，DOM已经被渲染，可以正常地发送请求获取数据，然后更新组件状态，最后重新渲染组件</strong>。</p><p><strong>如果在组件挂载前就发送请求，可能会导致无法获取到需要的DOM元素</strong>，因此不适合在组件其他生命周期中发送请求。另外，如果请求放在组件的渲染方法中，则可能会导致在每次重新渲染组件时都发送多次请求，增加不必要的网络负载，影响性能。</p><p>当然，具体实现还需要考虑更多因素，比如数据流的复杂度、数据的实时性要求、组件的复用性等等。但是，通常情况下，在componentDidMount这个生命周期阶段发送请求是可行的，并且也是较为常见的做法。</p><h2 id="如何查询当前屏幕的分辨率？"><a href="#如何查询当前屏幕的分辨率？" class="headerlink" title="如何查询当前屏幕的分辨率？"></a>如何查询当前屏幕的分辨率？</h2><p>可以使用<code>window.screen</code>对象的<code>width</code>和<code>height</code>属性来获取当前屏幕的分辨率，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> screenWidth = <span class="hljs-variable language_">window</span>.<span class="hljs-property">screen</span>.<span class="hljs-property">width</span>;<br><span class="hljs-keyword">const</span> screenHeight = <span class="hljs-variable language_">window</span>.<span class="hljs-property">screen</span>.<span class="hljs-property">height</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Screen resolution: <span class="hljs-subst">$&#123;screenWidth&#125;</span> x <span class="hljs-subst">$&#123;screenHeight&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><p><code>window.screen</code>对象是一个全局对象，它包括关于当前屏幕的一些信息，例如分辨率、屏幕大小、颜色深度等。<code>width</code>属性返回屏幕的实际宽度（以像素为单位），<code>height</code>属性返回屏幕的实际高度（以像素为单位）。</p><p><strong>需要注意的一点是，<code>window.screen</code>对象只能在浏览器中使用，不能在Node.js环境中使用。</strong></p><h2 id="CDN会改变IP地址吗？"><a href="#CDN会改变IP地址吗？" class="headerlink" title="CDN会改变IP地址吗？"></a>CDN会改变IP地址吗？</h2><p>CDN（内容分发网络）会改变IP地址。</p><p>CDN是一种优化网站性能和提高速度的技术，通过缓存和加速来将网站的内容分发到不同位置的节点，然后根据用户的请求 location 来返回最近节点的缓存内容，从而提高用户访问网站时的响应速度和体验。这些节点就是由 CDN 服务提供商部署在不同地点的服务器，也就是 CDN 边缘节点，它们是用户和网站源服务器之间的中转节点。</p><p>当用户请求网站内容时，CDN 会将请求重定向到距离用户最近的边缘节点，并将缓存的内容发送回用户所在的位置。边缘节点会运行一些特性（例如 NAT 网络地址转换），这些特性常常具有重写 IP 地址的功能，从而实现通过动态网络地址转换技术（NAT）进行 IP 地址的变更。</p><p>所以，请求经过 CDN 后，用户的请求 IP 地址将会变为节点 IP 地址，而非用户的真实 IP 地址。如果需要获取用户的真实IP地址，可以使用一些特殊的技术来绕过CDN，或者将CDN配置为在HTTP请求头中传递真实IP地址。</p><h2 id="类数组怎么转换为数组？"><a href="#类数组怎么转换为数组？" class="headerlink" title="类数组怎么转换为数组？"></a>类数组怎么转换为数组？</h2><ul><li><p>Array.from()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args); <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br>&#125;<br><br><span class="hljs-title function_">func</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>拓展运算符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> args = [...<span class="hljs-variable language_">arguments</span>];<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args); <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br>&#125;<br><br><span class="hljs-title function_">func</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>Array.prototype.slice.call()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args); <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br>&#125;<br><br><span class="hljs-title function_">func</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><ul><li>封装：将客观事物抽象成类，并将自己的属性和方法让可信的类或对象操作，对不可信的隐藏</li><li>继承：可以使用现有类的所有共鞥你，并在无需重新编写原来的类的情况下对这些功能进行拓展</li><li>多态：允许将父对象设置成为和一个或更多它的子对象相等的技术，赋值之后，父对象可以根据当前赋值给它的子对象的特性以不同的方式运作。虽然针对不同对象的具体操作不同，但通过一个公共的类，他们可以通过相同的方式予以调用。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美团一面again</title>
    <link href="/2023/04/21/%E7%BE%8E%E5%9B%A2%E4%B8%80%E9%9D%A2again/"/>
    <url>/2023/04/21/%E7%BE%8E%E5%9B%A2%E4%B8%80%E9%9D%A2again/</url>
    
    <content type="html"><![CDATA[<h1 id="美团一面Again"><a href="#美团一面Again" class="headerlink" title="美团一面Again"></a>美团一面Again</h1><h2 id="怎么学习的前端？"><a href="#怎么学习的前端？" class="headerlink" title="怎么学习的前端？"></a>怎么学习的前端？</h2><h2 id="JS的数据类型有哪些？"><a href="#JS的数据类型有哪些？" class="headerlink" title="JS的数据类型有哪些？"></a>JS的数据类型有哪些？</h2><p>Null、Undefined、Number、Boolean、String、Symbol、BigInt、Object</p><h2 id="怎么判断数据类型？"><a href="#怎么判断数据类型？" class="headerlink" title="怎么判断数据类型？"></a>怎么判断数据类型？</h2><ul><li>typeof</li><li>instanceof</li><li>constructor</li><li>Object.prototype.toString.call()</li></ul><h2 id="如何理解原型链？"><a href="#如何理解原型链？" class="headerlink" title="如何理解原型链？"></a>如何理解原型链？</h2><p>JS中的原型链是一种基于对象继承的机制。每个对象都有一个内部属性[[Prototype]]，它指向另一个对象，即其原型对象。原型对象也有自己的原型对象，这样就形成了一个“链”，即原型链。</p><p>当我们访问一个对象的属性或方法时，JavaScript 引擎会先查找该对象自身是否有该属性或方法，如果不存在，就会到该对象的原型对象中查找，如果原型对象中仍然不存在，则会继续查找原型对象的原型对象，直到最终找到 Object.prototype 中为止。</p><p>可以通过对象的 <strong>proto</strong> 或 Object.getPrototypeOf() 方法来获取对象的原型（也就是该对象的 [[Prototype]] 引用）。通过给某个对象的原型对象添加属性或方法，可以实现对象之间的共享。</p><h2 id="原型链和ES6的Class有什么关系？底层实现上有什么关联吗？"><a href="#原型链和ES6的Class有什么关系？底层实现上有什么关联吗？" class="headerlink" title="原型链和ES6的Class有什么关系？底层实现上有什么关联吗？"></a>原型链和ES6的Class有什么关系？底层实现上有什么关联吗？</h2><p>ES6 的 class 关键字是基于原型链的封装，其底层实现和原型链是密切相关的。</p><p>在 ES6 中创建一个 class，实际上是创建了一个构造函数和其原型对象。该构造函数的原型对象会指向内置的 Object.prototype 对象，而该构造函数会作为其他对象的原型对象。</p><p>当使用 class 实现继承时，其本质是利用了原型链的机制。子类可以通过关键字 extends 继承父类，这样就会创建一个子类的构造函数和其原型对象，而子类的原型对象会指向父类的原型对象，从而实现了属性和方法的继承。</p><p>此外，子类的 constructor 方法会重写父类的 constructor 方法，通过在子类的 constructor 方法中使用 super()，可以在子类中调用父类的 constructor 方法，从而继承父类的属性和方法。这一机制也是基于原型链实现的。</p><h2 id="如何理解作用域？"><a href="#如何理解作用域？" class="headerlink" title="如何理解作用域？"></a>如何理解作用域？</h2><p>JavaScript 作用域是指在程序中定义变量的区域，它规定了在程序的哪个位置可以访问该变量，决定了变量的生命周期和可见性。可以将 JavaScript 作用域分为全局作用域和函数作用域。</p><p>全局作用域：全局作用域是指在 JavaScript 程序中没有局部作用域的情况下，所有变量和函数都是定义在全局作用域中的，可以在程序的任何位置被访问到。</p><p>函数作用域：函数作用域是指在 JavaScript 程序中定义变量的作用域就是该函数的范围，包括函数内部定义的变量和函数参数。在函数内部，可以访问到该函数内部的变量和函数参数，而在函数外部无法访问到。</p><p>JavaScript 的作用域是由“词法作用域”实现的，它是指在代码编写时，JavaScript 引擎通过静态分析就可以确定变量的作用域，而不需要等到运行时才去判断。这也意味着在函数中定义变量时，该变量的作用域只在该函数内部，而不会影响到外部的变量，从而避免了变量冲突的问题。</p><h2 id="改变作用域的方法？"><a href="#改变作用域的方法？" class="headerlink" title="改变作用域的方法？"></a>改变作用域的方法？</h2><ul><li>call、apply、bind</li><li>箭头函数</li></ul><h2 id="代码输出"><a href="#代码输出" class="headerlink" title="代码输出"></a>代码输出</h2><p><code>var foo = 10</code>存在变量提升。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (!foo) &#123;<br>        <span class="hljs-keyword">var</span> foo = <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo);<br>&#125;<br><br><span class="hljs-title function_">fun</span>(); <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><h2 id="如果把var改成const-x2F-let呢？"><a href="#如果把var改成const-x2F-let呢？" class="headerlink" title="如果把var改成const&#x2F;let呢？"></a>如果把var改成const&#x2F;let呢？</h2><p>输出1。</p><h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>闭包（Closure）是指一个函数能够访问并使用其定义域（词法作用域）内的变量，即使在该函数在定义域外被执行时仍然可以访问这些变量。换句话说，闭包让一个函数可以在其定义的作用域之外使用变量。</p><p>具体来说，当一个函数内部定义了另一个函数，并且该内部函数使用了外层函数的参数或变量，即使外层函数执行完毕，内部函数仍然可以访问外层函数的参数或变量，这种情况就是闭包。</p><p>闭包可以用来实现许多高级功能，如函数工厂、缓存、事件监听等。同时，闭包也需要注意内存泄漏的问题，在不需要使用闭包时及时释放闭包所占用的资源。</p><h2 id="JS针对内存泄漏的处理机制？"><a href="#JS针对内存泄漏的处理机制？" class="headerlink" title="JS针对内存泄漏的处理机制？"></a>JS针对内存泄漏的处理机制？</h2><p>内存泄漏（Memory leak）指的是应用程序中已经无法使用的内存仍然被占用，导致内存空间不足，程序出现异常或崩溃。在 JavaScript 中，常见的内存泄漏情况包括：意外的全局变量、被遗忘的定时器或回调函数、闭包、循环引用等。为了避免这些情况发生，可以采取以下措施：</p><ol><li>及时释放引用：手动解除引用时可以使用 null 将对象赋值为空，让对象成为垃圾，但这种方法并不总是有效。</li><li>避免不必要的全局变量：全局变量会一直存在于整个应用中，如果定义了太多的全局变量，会导致内存大量占用。</li><li>使用闭包时注意内存泄漏：虽然闭包可以让函数在其定义域之外访问变量，但必须小心处理该函数中使用的变量引用，以确保它们在不再需要时被正确地解引用。</li><li>避免循环引用：在创建对象之间的引用时，确保它们不会形成循环引用，否则垃圾回收器无法清除它们。</li><li>及时清除定时器和回调函数：在使用定时器和回调函数时，注意及时清除已经不需要使用的定时器和回调函数，因为这些对象将一直驻留在内存中，直到它们被清除为止。</li><li>使用对象池：使用对象池可以复用已有的对象，减少内存的使用。</li></ol><p>除了以上措施，还可以使用一些内存管理工具和框架来避免内存泄漏，例如 Chrome 开发者工具（Chrome DevTools）、Heap Snapshots、Memory Profiling 等。</p><h2 id="JS事件机制？"><a href="#JS事件机制？" class="headerlink" title="JS事件机制？"></a>JS事件机制？</h2><p>JavaScript 事件机制是指在页面加载时，页面中所有的元素和 JavaScript 对象都有可能执行的事件集合。当用户进行某些操作时，例如单击某个按钮或者是移动鼠标，页面中的元素或者对象会生成相应的事件，而这些事件需要通过事件处理来进行响应。</p><p>在 JavaScript 中，事件的处理通过addEventListener()和removeEventListener()方法来实现。addEventListener()方法用于向指定的对象添加事件句柄，removeEventListener()方法则用于删除已添加的事件句柄。</p><p>常见的 DOM 事件包括：</p><ol><li>鼠标事件：click、mouseover、mouseout、mousedown、mouseup、mousemove 等。</li><li>键盘事件：keydown、keyup、keypress 等。</li><li>表单事件：submit、reset、focus、blur、change 等。</li><li>窗口事件：load、resize、unload 等。</li></ol><p>当事件发生时，会触发已添加的事件句柄。事件句柄可以是一个函数或是一个 JavaScript 脚本代码段，用于响应事件并执行相应的操作。可以通过事件对象（event）来获取和操作事件的信息，例如事件源、事件类型等。</p><p>另外，事件冒泡和事件捕获是事件机制的两个重要概念。事件冒泡指的是，当某个元素触发事件时，它的父元素也会依次触发相应的事件，一直冒泡到根元素。而事件捕获则是由根元素向下逐层触发事件，直到触发了相应的元素。在事件处理的过程中，可以通过 stopPropagation() 方法来停止事件的继续冒泡或捕获。</p><h2 id="为元素绑定事件有哪些方案呢？有什么区别？"><a href="#为元素绑定事件有哪些方案呢？有什么区别？" class="headerlink" title="为元素绑定事件有哪些方案呢？有什么区别？"></a>为元素绑定事件有哪些方案呢？有什么区别？</h2><p>在 JavaScript 中，为元素绑定事件的方案有以下几种：</p><ol><li><p>HTML事件处理程序：即在 HTML 标签中通过写入事件属性的方式绑定事件，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;myFunction()&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这种方式比较简单，但是不太灵活，且需要将 JavaScript 代码写在 HTML 中，不利于代码的维护和升级。</p></li><li><p>DOM0级事件处理程序：通过在 JS 代码中以元素对象的属性方式给元素绑定事件处理程序，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>);<br>btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br> <span class="hljs-comment">//处理点击事件的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式比较简单，且支持事件的取消绑定（即将该属性设置为 null 即可），但是同一元素只能绑定一种事件处理程序，无法实现多个事件的同时绑定。</p></li><li><p>DOM2级事件处理程序：通过 addEventListener() 方法和 removeEventListener() 方法绑定和解绑事件处理程序，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>);<br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br> <span class="hljs-comment">//处理点击事件的代码</span><br>&#125;, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>这种方式可以同时为同一个元素的同一种事件绑定多个事件处理程序，且支持事件捕获和冒泡，灵活性更高。</p></li></ol><p>这三种方式的主要区别在于绑定事件处理程序的方法不同，前两种方式是将 JS 代码直接写在 HTML 或 JS 文件中的，而第三种方式则直接将 JS 代码绑定到了 DOM 元素上，无需将代码写在 HTML 中，使得代码更加有组织性、可维护性和可重用性。另外，第三种方式还支持为同一元素的同一种事件绑定多个处理程序，并可以进行事件捕获和冒泡。</p><h2 id="addEventListener的三个参数分别是什么？"><a href="#addEventListener的三个参数分别是什么？" class="headerlink" title="addEventListener的三个参数分别是什么？"></a>addEventListener的三个参数分别是什么？</h2><p>addEventListener 的三个参数分别为：事件类型（字符串）、事件处理函数（函数）、是否在捕获阶段捕获事件（布尔值，默认为 false）。例如：element.addEventListener(‘click’, handleClick, false); 其中，’click’ 是事件类型，handleClick 是事件处理函数，false 表示在冒泡阶段捕获事件（默认情况下）。</p><h2 id="什么是防抖和节流？"><a href="#什么是防抖和节流？" class="headerlink" title="什么是防抖和节流？"></a>什么是防抖和节流？</h2><h2 id="手写防抖"><a href="#手写防抖" class="headerlink" title="手写防抖"></a>手写防抖</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait</span>) &#123;<br>  <span class="hljs-keyword">let</span> timeout;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> context = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">const</span> args = <span class="hljs-variable language_">arguments</span>;<br>    <span class="hljs-built_in">clearTimeout</span>(timeout);<br>    timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      func.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;, wait);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="为什么要使用apply？如果不使用的话fn的this会指向什么？"><a href="#为什么要使用apply？如果不使用的话fn的this会指向什么？" class="headerlink" title="为什么要使用apply？如果不使用的话fn的this会指向什么？"></a>为什么要使用apply？如果不使用的话fn的this会指向什么？</h2><p>apply() 方法可调用一个函数，其具有一个指定的 this 值，以及作为一个数组（或类似数组对象）提供的参数，这样参数可以传到函数中。</p><p>在上面的防抖函数中，为了保证原函数（即传入 debounce 函数中的第一个参数 func）被正确地执行，并且使用了正确的 this 值，我们需要使用 apply() 。使用 apply() 将该函数执行时的上下文（即 this 值）和参数传递给原始函数。</p><p>如果不使用 apply()，函数的 this 将指向全局对象 window（如果使用的是浏览器环境）或 global 对象（如果使用的是 Node.js 环境）。这是因为在 JavaScript 中，如果函数不作为某个对象的方法调用，其 this 将默认指向全局对象。</p><p>因此，在防抖函数中，如果没有使用 apply()，原函数将无法获取正确的 this 值，这通常会导致不可预料的错误或行为。</p><h2 id="下面的代码输出什么？"><a href="#下面的代码输出什么？" class="headerlink" title="下面的代码输出什么？"></a><font color="#1b60a2">下面的代码输出什么？</font></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> object = &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello, World!&#x27;</span>,<br>    <span class="hljs-title function_">logMessage</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> message = <span class="hljs-string">&#x27;Hello Message&#x27;</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-built_in">setTimeout</span>(object.<span class="hljs-property">logMessage</span>, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>这段代码输出的结果将是 <code>undefined</code>，因为在 setTimeout 中，<code>object.logMessage</code> 函数中的 <code>this</code> 关键字将无法指向 <code>object</code> 对象本身，它将指向全局对象（例如 <code>window</code> 对象）。在全局对象中，并不存在名为 <code>message</code> 的属性，因此会输出 <code>undefined</code>。</p><p>如果我们希望它输出的是 <code>Hello, World!</code>，可以使用 <code>bind()</code> 方法将 <code>this</code> 关键字绑定到 <code>object</code> 对象上，例如 <code>setTimeout(object.logMessage.bind(object), 1000);</code> 这样就可以确保 <code>logMessage()</code> 函数中的 <code>this</code> 关键字指向 <code>object</code> 对象了。</p><h2 id="解释下JS的事件循环机制？"><a href="#解释下JS的事件循环机制？" class="headerlink" title="解释下JS的事件循环机制？"></a>解释下JS的事件循环机制？</h2><p>JavaScript 是单线程执行的语言，而事件循环机制 (Event Loop) 是其编程模型的核心。事件循环机制负责监听调用栈和消息队列，以保证异步和回调函数的正确执行。</p><p>当 JavaScript 代码运行时，所有的同步任务都会按照代码的先后顺序放入调用栈中执行，调用栈则会按照后进先出的规则执行其中的任务。而异步任务则不会马上执行，而是在满足某些条件（如网络请求返回结果）时，将任务放入消息队列中，等待调用栈中的任务执行完毕后，再将消息队列中的任务按照顺序放入调用栈中执行。</p><p>在事件循环中，调用栈中的任务执行完毕后，会先检查消息队列中是否有任务需要执行，如果有则按照顺序依次取出执行，否则继续等待新的异步任务被加入消息队列。</p><p>总结起来，事件循环机制保证了 JavaScript 代码的异步执行，让它可以处理各种待定操作，避免了等待和阻塞。</p><h2 id="解释下什么是Promise？"><a href="#解释下什么是Promise？" class="headerlink" title="解释下什么是Promise？"></a>解释下什么是Promise？</h2><p>Promise 是一种用于异步编程的语法规范，可以用于处理异步操作，减少回调地狱（Callback Hell）的情况。它可以把一个异步操作抽象成一个 Promise 对象，该对象代表了一个异步操作最终的完成或是失败。</p><p>Promise 可以看作是一种容器，其中包含着某个未来才会结束的事件（通常是一个异步操作）。根据 Promise 的状态，可以分为三种状态：</p><ul><li>等待态（Pending）：初始状态，未完成或拒绝。</li><li>完成态（Fulfilled）：操作成功完成，未来的 Promise 对象将带有一个值。</li><li>拒绝态（Rejected）：操作失败，未来的 Promise 对象将带有一个原因（reason）。</li></ul><p>在 Promise 中，可以通过 then 方法注册回调函数，当 Promise 对象的状态从等待态转变为完成态或拒绝态时，then 中相应的回调函数就会被执行。</p><p>Promise 还可以通过链式调用 then 方法来串联多个操作，可以让代码更清晰、易读，同时在多个异步操作之间方便地传递数据和解决回调地狱的问题。如果链式调用中的某个操作返回一个新的 Promise，那么后续操作会等待该 Promise 的状态发生变化，再进行下一步操作。</p><p>总之，Promise 可以简化异步程序的编写，使得代码结构更加清晰、可读性更强。</p><h2 id="回调地狱是什么概念？"><a href="#回调地狱是什么概念？" class="headerlink" title="回调地狱是什么概念？"></a>回调地狱是什么概念？</h2><p>回调地狱是指在异步编程中，由于回调函数与回调函数的嵌套过于深入，导致代码难以维护和理解的情况。回调地狱通常出现在多个异步操作依次执行的场景中，每个异步操作完成后需要执行下一个异步操作。</p><p>例如，链式的 ajax 请求、多个文件的读取或写入等等。在回调地狱中，每个异步操作的回调函数都需要嵌套在前一个操作的回调函数中，导致代码逻辑混乱、难以维护和理解。</p><p>代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getData</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) &#123;<br>  <span class="hljs-title function_">parseData</span>(response, <span class="hljs-keyword">function</span>(<span class="hljs-params">parsedData</span>) &#123;<br>    <span class="hljs-title function_">validateData</span>(parsedData, <span class="hljs-keyword">function</span>(<span class="hljs-params">validatedData</span>) &#123;<br>      <span class="hljs-title function_">saveData</span>(validatedData, <span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>      &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>为解决回调地狱带来的问题，ES6 引入了 Promise 以及 async&#x2F;await 等语法规范，可以让异步操作更加简洁、可读性更高。</p><h2 id="代码输出-1"><a href="#代码输出-1" class="headerlink" title="代码输出"></a>代码输出</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>    &#125;);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>&#125;);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-title function_">resolve</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>);<br>    <span class="hljs-title function_">reject</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">9</span>);<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10</span>);<br><span class="hljs-comment">// 1 5 6 7 10 4 8 3 2</span><br></code></pre></td></tr></table></figure><h2 id="CSS中水平垂直居中方式？-行内元素，块元素"><a href="#CSS中水平垂直居中方式？-行内元素，块元素" class="headerlink" title="CSS中水平垂直居中方式？(行内元素，块元素)"></a>CSS中水平垂直居中方式？(行内元素，块元素)</h2><p>一、行内元素（inline、inline-block）</p><ol><li>水平居中：可以给元素的父元素设置 <code>text-align: center;</code>。</li><li>垂直居中：可以给元素设置 <code>line-height</code> 属性，使其等于其包含容器的高度。</li></ol><p>二、块状元素（block）</p><ol><li><p>使用 flex 布局方式</p><p>给父元素设置 <code>display: flex; align-items: center; justify-content: center;</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用位置和 transform 方式</p><p>给需要居中的元素设置 <code>position: absolute;</code> 和 <code>transform: translate(-50%, -50%);</code>，再将其父元素设置为相对定位 <code>position: relative;</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用 table-cell 方式</p><p>将父元素设置为 <code>display: table-cell; vertical-align: middle; text-align: center;</code>，再将需要居中的子元素设置为 <code>display: inline-block;</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-cell;<br>  <span class="hljs-attribute">vertical-align</span>: middle;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="伪类和伪元素的区别？"><a href="#伪类和伪元素的区别？" class="headerlink" title="伪类和伪元素的区别？"></a>伪类和伪元素的区别？</h2><p><strong>伪类（Pseudo-classes）</strong></p><p>伪类是用来描述一个元素在特定状态下的样式。比如 <code>:hover</code> 伪类可以用来描述鼠标悬停时的样式。</p><p>常用的伪类包括：</p><ul><li><code>:hover</code>：鼠标悬停时的样式。</li><li><code>:active</code>：元素被激活时的样式，比如鼠标按下时。</li><li><code>:focus</code>：元素获得焦点时的样式。</li><li><code>:checked</code>：需要一个输入框是否被选中来设置样式。</li><li><code>:nth-child</code>：选择某个元素的父元素的第 n 个子元素来设置样式，比如 <code>:nth-child(2)</code> 表示选择父元素的第二个子元素。</li></ul><p>伪类的语法是在元素选择器之后添加 <code>:</code>，然后加上伪类的名称，比如 <code>a:hover</code>。</p><p><strong>伪元素（Pseudo-elements）</strong></p><p>伪元素则是用来创建一些元素之外的效果，并且不需要你在 HTML 中创建新的元素。比如 <code>::before</code> 和 <code>::after</code> 伪元素可以用来在元素的开始和结束位置添加一个样式。</p><p>常用的伪元素包括：</p><ul><li><code>::before</code>：在元素之前添加内容。</li><li><code>::after</code>：在元素之后添加内容。</li><li><code>::first-line</code>：选择元素的第一行来设置样式。</li><li><code>::first-letter</code>：选择元素的第一个字母来设置样式。</li></ul><p>伪元素的语法是在元素选择器之后添加 <code>::</code>，然后加上伪元素的名称，比如 <code>.panel::before</code>。</p><h2 id="async和defer的区别？"><a href="#async和defer的区别？" class="headerlink" title="async和defer的区别？"></a>async和defer的区别？</h2><h2 id="浏览器的存储方案？"><a href="#浏览器的存储方案？" class="headerlink" title="浏览器的存储方案？"></a>浏览器的存储方案？</h2><p>Cookie</p><p>Cookie 是在客户端存储的文本文件，用于存储网站的状态信息，如用户登录状态、购物车内容等。它的大小有一定限制，一般为 4KB 左右，并且会在过期时间之后自动删除。</p><p>Web Storage</p><p>Web Storage 包括 localStorage 和 sessionStorage。localStorage 存储的数据可以在同一域名下的所有页面共享，且存储容量很大，一般为 5 MB 左右；而 sessionStorage 存储的数据只能在当前会话中共享，关闭浏览器后会自动删除。</p><p>IndexedDB</p><p>IndexedDB 是一种本地的数据库，用于存储大量结构化数据，支持事务和索引功能，可进行高效的数据查询和操作。</p><p>Cache Storage</p><p>Cache Storage 用于存储网络请求的响应，能够提高 Web 应用的加载速度和并发性能。它支持缓存的添加、查询、删除、更新等操作。</p><p>File API</p><p>File API 允许 Web 应用访问本地文件系统，可以在本地文件系统中读取和写入文件，也可以将文件发送到服务器。但是，File API 只能在获得用户授权的情况下使用，且不同浏览器的实现存在差异。</p><h2 id="常见的跨域请求方案？"><a href="#常见的跨域请求方案？" class="headerlink" title="常见的跨域请求方案？"></a>常见的跨域请求方案？</h2><p>JSONP</p><p>JSONP（JSON with Padding）是一种跨域请求方案，它通过动态创建 script 标签，将数据作为回调函数的参数传递，从而实现跨域请求。但是，JSONP 只能发送 GET 请求，且只能使用 callback 形式的回调函数，存在安全问题。</p><p>CORS</p><p>CORS（Cross-Origin Resource Sharing）是一种官方标准的跨域请求方案，它通过在请求头中添加 Origin 字段，服务器返回 Access-Control-Allow-Origin 字段，来完成跨域请求。CORS 支持所有类型的 HTTP 请求，且安全性较高。</p><p>WebSocket</p><p>WebSocket 是一种基于 HTTP 协议实现的全双工通信协议，它能够在同一个 TCP 连接上进行持久连接，从而实现实时通信。WebSocket 协议可以跨域请求，但需要服务器支持。</p><p>代理</p><p>通过设置代理服务器来完成跨域请求。浏览器向同域服务器发送请求，同域服务器再将请求发送到目标服务器，获取数据后将数据返回给浏览器。代理方式可以实现任意 HTTP 请求，但需要额外的服务器支持。</p><h2 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h2><p>在浏览器中，同源策略限制着从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。同源是指协议、域名、端口号均相同。当我们在浏览器向一个不同源的服务器请求资源时，浏览器会限制这个请求，不允许跨域请求。这就是跨域问题。</p><h2 id="cors实现跨域要设置哪些请求头？分别代表什么含义？"><a href="#cors实现跨域要设置哪些请求头？分别代表什么含义？" class="headerlink" title="cors实现跨域要设置哪些请求头？分别代表什么含义？"></a>cors实现跨域要设置哪些请求头？分别代表什么含义？</h2><ol><li><p><code>Access-Control-Allow-Origin</code></p><p>该字段是必须的。它的值是指定允许哪些域名的请求可以通过。可以使用通配符表示允许来自任何域的请求（不建议在生产环境中使用）。例如：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Access</span>-Control-Allow-Origin: *<br></code></pre></td></tr></table></figure><p>or</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">Access-Control-Allow-Origin: https:<span class="hljs-regexp">//</span>example.com<br></code></pre></td></tr></table></figure><p>第一种情况允许来自所有域的请求，第二种情况仅允许来自<code>https://example.com</code>域的请求。</p></li><li><p><code>Access-Control-Allow-Credentials</code></p><p>该字段设置为<code>true</code>时，表示允许发送Cookie和认证信息（如HTTP认证、客户端证书等）到跨域的服务器。默认值为<code>false</code>。如果不需要发送Cookie，则不需要设置此字段。例如：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Access</span>-Control-Allow-Credentials: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p><code>Access-Control-Expose-Headers</code></p><p>该字段指定哪些HTTP头部字段可以在跨域响应中暴露给浏览器 JavaScript 代码访问。例如，如果想让浏览器可以访问 Response 的自定义头部字段，则需要将其加入到该字段中。例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Access</span>-Control-Expose-Headers: X-My-Custom-<span class="hljs-keyword">Header</span>, X-Another-Custom-<span class="hljs-keyword">Header</span><br></code></pre></td></tr></table></figure></li><li><p><code>Access-Control-Allow-Methods</code></p><p>该字段指示在预检请求中允许的 HTTP 方法。例如，对于一个 <code>POST</code> 请求，服务器可以返回以下头部：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Access</span>-Control-Allow-Methods: POST<br></code></pre></td></tr></table></figure></li></ol><p>额外说明：</p><p>跨域是指两个域名（协议 + 域名 + 端口号）不相同的情况。在前端，跨域通常指从一个网站的前端代码去访问另一个网站的接口数据。涉及跨域的请求会被浏览器做检查，如果检测到不符合安全机制的操作，就会阻拦这个请求。为了处理跨域问题，通常使用 CORS（跨源资源分享）方式。通过设置请求头中的CORS相关字段，服务器就可以将特定资源分享给指定的域名，从而解决跨域问题。</p><h2 id="react组件通信方式？"><a href="#react组件通信方式？" class="headerlink" title="react组件通信方式？"></a>react组件通信方式？</h2><ol><li>父子组件通过props传递数据: 父组件可以通过props向子组件传递数据和回调函数，子组件则可以通过调用父组件传递的回调函数，将数据传递回父组件；</li><li>Context方式: 通过Context可以在组件树中向多层嵌套的子组件传递数据，避免了props跨层级传递的繁琐过程；</li><li>全局状态管理工具: 如Redux，Mobx等，可以将共享状态提升到全局，通过订阅和发布的方式实现组件间的通信；</li><li>通过组件引用方式： 在某一个组件需要调用另一个组件的方法时，可以通过对该组件的引用，来调用该组件的方法。</li></ol><h2 id="jsx在react中起什么作用？"><a href="#jsx在react中起什么作用？" class="headerlink" title="jsx在react中起什么作用？"></a>jsx在react中起什么作用？</h2><p>React中使用<code>.jsx</code>后缀表示这个文件包含JSX语法。JSX是一种类似于HTML的JS语法扩展，用于描述应用程序的用户界面。在React中，组件的UI通常以JSX的形式定义。</p><p>JSX的目的是提高React组件的代码可读性和易维护性。在React中使用JSX可以将组件的UI模板和JavaScript逻辑代码合在一起，从而提高React应用程序的开发效率。</p><p>同时，<code>.jsx</code>后缀还可以方便代码编辑器和其他工具根据文件类型来识别React组件代码，提供针对性的编辑体验和功能，如语法高亮、代码补全等。</p><p>需要注意的是，虽然React推荐使用JSX来定义组件的UI，但JSX并不是React的必须要求，React同样支持使用纯JavaScript来编写组件的UI。</p><h2 id="为什么会产生reaxt-hooks？"><a href="#为什么会产生reaxt-hooks？" class="headerlink" title="为什么会产生reaxt hooks？"></a>为什么会产生reaxt hooks？</h2><h2 id="什么是高阶组件？"><a href="#什么是高阶组件？" class="headerlink" title="什么是高阶组件？"></a>什么是高阶组件？</h2><p>React高阶组件（Higher-Order Component，简称HOC）是一种被广泛使用的React设计模式，它本质上是一个函数，接收一个组件作为参数，返回一个新的组件。</p><p>HOC可以看作是一个增强器，它可以给被包裹的组件增加一些附加功能，例如：状态管理、生命周期、组件复用等等。具体实现在函数中，可以在组件的props、state、生命周期中注入新的行为等。</p><p>HOC可以帮助我们解决组件之间逻辑复用问题，同时提高了代码复用率和可维护性。另外，HOC也是React中实现代码懒加载和权限控制等功能的一种方式。</p><p>一个简单的HOC示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">withLogger</span>(<span class="hljs-params">WrappedComponent</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Component &quot;<span class="hljs-subst">$&#123;WrappedComponent.name&#125;</span>&quot; mounted`</span>);<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> &#123;<span class="hljs-attr">...this.props</span>&#125; /&gt;</span></span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，withLogger是一个HOC，接收一个组件作为参数WrappedComponent，返回一个新的Logger组件。Logger组件在渲染时会注入一些新的行为，比如在组件渲染完成后输出一条日志。被包裹的组件可以通过<code>this.props</code>来获取这些新行为。</p><p>HOC的使用方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">withLogger</span>(<span class="hljs-title class_">MyComponent</span>);<br></code></pre></td></tr></table></figure><p>在这个示例中，我们将MyComponent组件作为withLogger的参数，然后导出withLogger(MyComponent)得到一个新组件。这个新组件包含了MyComponent和withLogger的逻辑，可以直接在应用中使用。</p><h2 id="对react虚拟DOM的了解？"><a href="#对react虚拟DOM的了解？" class="headerlink" title="对react虚拟DOM的了解？"></a>对react虚拟DOM的了解？</h2><p>React的虚拟DOM（Virtual DOM）是一个轻量级的JavaScript对象树，在React通过更新状态或者props来修改虚拟DOM，最终将其渲染为真实DOM。虚拟DOM可以理解为是真实DOM树的一份快照，当真实DOM需要更新时，React会比较新旧两份虚拟DOM树的差异，然后只更新所需部分的DOM节点，这样可以减少DOM操作，提升性能。</p><p>虚拟DOM的优点包括：</p><ol><li>性能优化：虚拟DOM可以避免过多的DOM操作，大幅提升性能。</li><li>跨平台：虚拟DOM是React的一个核心概念，React的生态系统也延伸了许多跨平台的框架（如React Native、React VR），将虚拟DOM应用到其他平台上也更加方便。</li><li>组件化：虚拟DOM方式可以将应用组件化，方便组件间通信和维护。</li></ol><p>虚拟DOM的流程：</p><ol><li>React在修改数据时，会生成一个新的虚拟DOM树。</li><li>React会通过diff算法，比较新旧两棵虚拟DOM树的差异，并记录下需要更新的部分。</li><li>React会根据记录的需要更新的部分，进行DOM操作更新。</li></ol><p>总的来说，虚拟DOM的UX可以让React开发者专注于应用逻辑，而不需要过度关注DOM操作，提高了开发效率。</p><h2 id="Webpack核心流程？"><a href="#Webpack核心流程？" class="headerlink" title="Webpack核心流程？"></a>Webpack核心流程？</h2><p>Webpack的核心流程可以简单概括为以下几个步骤。</p><ol><li><p>解析Entry入口文件 Webpack会根据配置文件中的entry选项找到应用程序的入口，并从该入口文件开始递归解析整个依赖树。</p></li><li><p>编译模块</p><p>在解析依赖时，Webpack会根据配置文件中的module选项，根据不同的模块类型（ES6、CSS、图片等）选择不同的loader进行编译，将模块转换为Webpack可识别的模块。</p></li><li><p>解析依赖</p><p>在编译模块的过程中，会解析模块之间的依赖关系，生成模块之间的依赖关系图，即依赖图。</p></li><li><p>打包输出</p><p>经过编译和依赖解析之后，Webpack会把所有模块打包成一个或多个bundle文件，存储到指定的输出目录中。</p></li><li><p>优化打包结果 Webpack会对打包结果进行优化，包括代码压缩、提取公共代码、分离Chunks等操作。</p><p>在Webpack的打包过程中，还有许多其他的流程和插件，比如构建生命周期钩子、热更新、资源管理等，都是为了让开发者可以高效地完成前端项目的构建。</p></li></ol><h2 id="loader和plugin的作用？"><a href="#loader和plugin的作用？" class="headerlink" title="loader和plugin的作用？"></a>loader和plugin的作用？</h2><ol><li>Loader Loader是Webpack的核心之一，它用于对模块进行编译和转换，将非JavaScript资源（如CSS、图片、字体等）转换成Webpack可识别的模块。Loader通常会被链式调用，处理一些独立的任务，最终将处理后的结果返回给Webpack。一些著名的Loader有：babel-loader、css-loader、file-loader、url-loader等。</li><li>Plugin Plugin用于对Webpack的打包结果进行进一步处理和优化，比如优化打包结果、资源管理和注入环境变量等。Plugin的作用域更为广泛，并且往往拥有更加丰富和复杂的功能。Plugin在Webpack启动和构建生命周期中扮演着重要的角色，可以应用于几乎所有的打包场景。一些著名的Plugin有：HtmlWebpackPlugin、UglifyJsPlugin、CleanWebpackPlugin、CopyWebpackPlugin等。</li></ol><h2 id="还了解过哪些打包工具？"><a href="#还了解过哪些打包工具？" class="headerlink" title="还了解过哪些打包工具？"></a>还了解过哪些打包工具？</h2><ol><li>Parcel Parcel是一个快速、零配置的打包工具，支持JS、CSS、HTML等多种类型文件的打包和编译。与Webpack不同的是，Parcel使用的是多线程打包，具有快速打包的优势。</li><li>Rollup Rollup是一个专门针对JavaScript库和工具的打包器，它使用的是ES6的模块化规范，采用Tree Shaking的方式来对代码进行打包，去除掉未使用的代码。Rollup对于构建JavaScript库、组件和插件等非常有用。</li><li>Gulp Gulp是一个自动化构建工具，它可以帮助开发者自动处理CSS、JS、HTML等文件。它基于流式处理数据的思想，可以实现高效的打包、压缩、合并等功能。Gulp使用JavaScript代码来配置任务，非常易于扩展和使用。</li><li>Grunt Grunt是另一种常用的自动化构建工具，它与Gulp类似，也可以通过插件实现自动化任务。与Gulp不同的是，Grunt更为传统，使用配置文件来描述任务流程。</li><li>Browserify Browserify是一个基于Node.js的模块打包工具，它使开发者可以在浏览器中使用Node.js的模块系统。它采用的是CommonJS的模块化规范。</li></ol><h2 id="如何理解JS模块化？"><a href="#如何理解JS模块化？" class="headerlink" title="如何理解JS模块化？"></a>如何理解JS模块化？</h2><p>JS模块化是一种组织代码的方式，旨在解决代码的复杂性和可维护性问题。传统的JS开发方式是通过在全局作用域中定义变量和函数来组织代码，这种方式很容易导致命名冲突、代码重复等问题。而JS模块化则是将代码分解为多个独立的、具有特定功能和依赖关系的模块，每个模块内部的变量和函数都是私有的，从而避免了命名冲突等问题。</p><p>在JS模块化中，模块可以有多种类型，如ES6模块、CommonJS模块、AMD模块、UMD模块等。其中，ES6模块是现代浏览器原生支持的模块化规范，它通过import和export关键字来导入和导出模块，具有静态引用的特点；CommonJS模块是Node.js采用的模块化规范，它通过require函数来加载模块，通过module.exports或exports对象来导出模块，具有动态引用的特点；AMD模块则是由RequireJS提出的异步模块定义规范，它支持动态加载和异步执行；UMD模块则是通用模块定义规范，支持在不同的环境下使用不同的模块化方式（如CommonJS、AMD、全局变量等）。</p><p>JS模块化的优点包括：代码封装，避免命名冲突；减少冗余代码，提高代码的可复用性；可维护性强，易于进行单元测试等。</p><h2 id="写代码，实现获取url中的参数"><a href="#写代码，实现获取url中的参数" class="headerlink" title="写代码，实现获取url中的参数"></a>写代码，实现获取url中的参数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getQueryString</span>(<span class="hljs-params">str, key</span>) &#123;<br>    <span class="hljs-keyword">const</span> values = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;?&quot;</span>)[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">const</span> valueArr = values.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&amp;&quot;</span>);<br>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; valueArr.<span class="hljs-property">length</span>; i++) &#123;<br>        map.<span class="hljs-title function_">set</span>(valueArr[i].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;=&quot;</span>)[<span class="hljs-number">0</span>], valueArr[i].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;=&quot;</span>)[<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> map.<span class="hljs-title function_">get</span>(key);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getQueryString</span>(<span class="hljs-string">&quot;http://example.com?a=1&amp;b=2&amp;c=3&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>)); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h2 id="项目有哪些亮点？"><a href="#项目有哪些亮点？" class="headerlink" title="项目有哪些亮点？"></a>项目有哪些亮点？</h2><h2 id="使用第三方富文本编译器可能会遇到哪些安全问题？"><a href="#使用第三方富文本编译器可能会遇到哪些安全问题？" class="headerlink" title="使用第三方富文本编译器可能会遇到哪些安全问题？"></a>使用第三方富文本编译器可能会遇到哪些安全问题？</h2><p>使用第三方富文本编辑器时可能会存在以下安全问题：</p><ol><li>跨站脚本攻击(XSS)：富文本编辑器中允许用户对文本进行格式化、插入图片或其他媒体，而这些内容很容易被植入恶意脚本，从而造成XSS攻击。</li><li>文件上传漏洞：富文本编辑器中可以上传图片或其他媒体文件，如果没有进行严格的文件类型、大小、后缀等限制，攻击者就可以上传恶意文件到服务器上，从而控制整个系统。</li><li>恶意插件：一些恶意插件可能会通过富文本编辑器中的API和DOM接口，访问用户的浏览器、cookie等敏感信息。</li><li>版权问题：某些富文本编辑器可能没有经过合法授权，使用这些编辑器就可能会涉及到版权问题。</li></ol><p>为了保障安全，使用第三方富文本编辑器时应该注意以下几点：</p><ol><li>选择可信赖的编辑器：使用知名厂商或有良好口碑的第三方富文本编辑器，可以降低发生安全问题的概率。</li><li>进行数据过滤：在服务端对用户上传的内容进行过滤和验证，处理恶意标签、注入代码等攻击。</li><li>对上传文件进行严格限制：在服务端对上传文件的类型、大小、后缀等进行限制，并进行文件内容安全检查。</li><li>最小化API权限：在使用富文本编辑器的API和DOM接口时，尽可能限制其权限，减少恶意插件访问浏览器等敏感信息的风险。</li><li>授权审查：确保所采用的富文本编辑器源代码是来自授权渠道或已购买授权，以避免版权问题。</li></ol><h2 id="对XSS攻击的理解？"><a href="#对XSS攻击的理解？" class="headerlink" title="对XSS攻击的理解？"></a>对XSS攻击的理解？</h2><p>XSS（Cross Site Scripting）攻击，即跨站脚本攻击，是一种常见的Web攻击方式之一，其特点就是攻击者通过在目标网站上注入恶意脚本，使得受害者用户在访问该网站时执行攻击者所编写的恶意脚本，从而达到攻击的目的。</p><p>XSS攻击的危害有以下几点：</p><ol><li>盗取用户隐私数据：攻击者可以使用恶意脚本窃取用户密码、会话Cookie等隐私数据，从而进一步攻击用户的账号和个人信息。</li><li>篡改页面内容：攻击者可以通过在页面中注入恶意脚本来实现篡改页面内容，包括添加广告、假冒登录页面、弹出广告窗口等。</li><li>利用网站漏洞：攻击者可以利用漏洞进行攻击，比如通过XSS攻击利用网站上的漏洞向其他网站发送请求，从而在不知情的情况下进行攻击。</li><li>DDos攻击：攻击者可以利用XSS漏洞进行DDos攻击，向目标网站发送大量请求，从而占用网站的带宽以及服务器资源。</li></ol><p>为了防范XSS攻击，我们可以采取以下措施：</p><ol><li>对用户输入的数据进行过滤和验证，避免恶意脚本的注入。</li><li>对敏感信息进行加密传输和存储，避免信息泄露。</li><li>使用HttpOnly和secure标签设置Cookie属性，在一定程度上防止Cookie被窃取和篡改。</li><li>对Web应用程序进行漏洞扫描，及时发现漏洞并进行修复。</li><li>对网站访问日志进行监控和分析，及时发现异常IP和嫌疑用户。</li></ol><h2 id="NodeJS中间件？"><a href="#NodeJS中间件？" class="headerlink" title="NodeJS中间件？"></a>NodeJS中间件？</h2><h2 id="如果一个项目上线后，用户反映白屏了，但是开发者这边没有问题，可能是哪些原因造成的？"><a href="#如果一个项目上线后，用户反映白屏了，但是开发者这边没有问题，可能是哪些原因造成的？" class="headerlink" title="如果一个项目上线后，用户反映白屏了，但是开发者这边没有问题，可能是哪些原因造成的？"></a>如果一个项目上线后，用户反映白屏了，但是开发者这边没有问题，可能是哪些原因造成的？</h2><p>白屏问题可能由以下原因造成：</p><ol><li>浏览器缓存问题：用户使用的浏览器可能存在缓存，而此次更新的文件或资源未被缓存或缓存已经过期，导致浏览器无法正确加载页面资源。</li><li>CDN缓存问题：网站可能使用了CDN进行资源加速，如果CDN缓存未及时更新或者缓存中的页面资源损坏，也会导致白屏问题。</li><li>代码问题：可能出现了未捕获的程序错误，导致代码无法正常执行，例如语法错误，异常等。在开发环境中由于代码基本经过了调试，因此没有出现问题，但在生产环境中出现问题。</li><li>服务器配置问题：服务器可能配置有错误，例如PHP的错误配置、内存限制等，导致网站无法正常运行或仅显示部分内容。</li><li>网络问题：由于网络连接不佳或者服务器承受的请求太多，导致服务返回数据受阻或丢失，从而出现白屏问题。</li></ol><p>解决方法：</p><ol><li>用户清除浏览器缓存与Cookie缓存。</li><li>检查CDN缓存状态，尝试清除CDN缓存。</li><li>检查代码的错误日志，运行调试工具进行问题定位。同时，在代码中加上错误日志，能帮助开发者更好的了解问题的具体情况。</li><li>检查服务器配置是否正确，并优化服务器配置。</li><li>检查网络连接、服务器负载情况，尝试优化服务器性能。</li></ol><p>通过以上方法，可以排除上述可能造成白屏的原因，逐一解决白屏问题。同时，在项目上线之前，要进行全方位的测试，确保项目稳定性和可靠性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端|面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识点整理(11)</title>
    <link href="/2023/04/19/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-11/"/>
    <url>/2023/04/19/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-11/</url>
    
    <content type="html"><![CDATA[<h1 id="知识点整理-11"><a href="#知识点整理-11" class="headerlink" title="知识点整理(11)"></a>知识点整理(11)</h1><h2 id="在空间中已知三角形和一个点，求点到三角形平面的距离？"><a href="#在空间中已知三角形和一个点，求点到三角形平面的距离？" class="headerlink" title="在空间中已知三角形和一个点，求点到三角形平面的距离？"></a>在空间中已知三角形和一个点，求点到三角形平面的距离？</h2><p>求点到三角形平面的距离可以通过向量运算来实现。具体的实现方法如下：</p><ol><li>根据三角形的三个顶点计算法向量</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getNormal</span>(<span class="hljs-params">p1, p2, p3</span>) &#123;<br>  <span class="hljs-keyword">const</span> vec1 = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>().<span class="hljs-title function_">subVectors</span>(p2, p1);<br>  <span class="hljs-keyword">const</span> vec2 = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>().<span class="hljs-title function_">subVectors</span>(p3, p1);<br>  <span class="hljs-keyword">return</span> vec1.<span class="hljs-title function_">cross</span>(vec2).<span class="hljs-title function_">normalize</span>(); <span class="hljs-comment">// 叉积并标准化</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>计算点到三角形平面的距离</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">distanceToPlane</span>(<span class="hljs-params">point, normal, planePoint</span>) &#123;<br>  <span class="hljs-keyword">const</span> vec = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>().<span class="hljs-title function_">subVectors</span>(point, planePoint);<br>  <span class="hljs-keyword">return</span> vec.<span class="hljs-title function_">dot</span>(normal); <span class="hljs-comment">// 点积</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>point</code>是待求点的坐标，<code>normal</code>是三角形的法向量，<code>planePoint</code>是三角形平面上的任意一点的坐标。最后，如果距离为负数，则说明该点在三角形背面，距离取绝对值即可。</p><p>完整的实现代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getNormal</span>(<span class="hljs-params">p1, p2, p3</span>) &#123;<br>  <span class="hljs-keyword">const</span> vec1 = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>().<span class="hljs-title function_">subVectors</span>(p2, p1);<br>  <span class="hljs-keyword">const</span> vec2 = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>().<span class="hljs-title function_">subVectors</span>(p3, p1);<br>  <span class="hljs-keyword">return</span> vec1.<span class="hljs-title function_">cross</span>(vec2).<span class="hljs-title function_">normalize</span>(); <span class="hljs-comment">// 叉积并标准化</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">distanceToPlane</span>(<span class="hljs-params">point, normal, planePoint</span>) &#123;<br>  <span class="hljs-keyword">const</span> vec = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>().<span class="hljs-title function_">subVectors</span>(point, planePoint);<br>  <span class="hljs-keyword">return</span> vec.<span class="hljs-title function_">dot</span>(normal); <span class="hljs-comment">// 点积</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getPointToTriangleDistance</span>(<span class="hljs-params">point, triangle</span>) &#123;<br>  <span class="hljs-keyword">const</span> normal = <span class="hljs-title function_">getNormal</span>(triangle[<span class="hljs-number">0</span>], triangle[<span class="hljs-number">1</span>], triangle[<span class="hljs-number">2</span>]);<br>  <span class="hljs-keyword">const</span> distance = <span class="hljs-title function_">distanceToPlane</span>(point, normal, triangle[<span class="hljs-number">0</span>]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(distance);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>triangle</code>是包含三个顶点坐标的数组。</p><h2 id="页面一共可以展示五行五列的图，如何设计懒加载？"><a href="#页面一共可以展示五行五列的图，如何设计懒加载？" class="headerlink" title="页面一共可以展示五行五列的图，如何设计懒加载？"></a>页面一共可以展示五行五列的图，如何设计懒加载？</h2><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>实现图片懒加载时，可以使用节流函数来减少滚动事件的触发次数，提高性能。下面给出一个使用节流实现图片懒加载的示例代码。</p><p>先定义一个<code>throttle</code>函数，它接收一个回调函数和一个时间间隔作为参数，返回一个新的函数。新函数可以在一定时间内只触发一次回调函数，避免频繁执行回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (!timer) &#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>        timer = <span class="hljs-literal">null</span>;<br>      &#125;, delay);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来定义一个<code>lazyLoad</code>函数，它可以对指定容器内的所有图片进行懒加载。该函数首先获取容器内的所有图片元素，然后使用节流函数对滚动事件进行处理，当滚动到图片可见区域时，将图片的<code>data-src</code>属性替换为<code>src</code>属性，实现懒加载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">lazyLoad</span>(<span class="hljs-params">container</span>) &#123;<br>  <span class="hljs-keyword">const</span> imgList = container.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;img[data-src]&#x27;</span>);<br>  <span class="hljs-keyword">const</span> viewHeight = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkImage</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> scrollTop = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span>;<br>    <span class="hljs-keyword">const</span> containerHeight = container.<span class="hljs-property">offsetHeight</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; imgList.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">const</span> img = imgList[i];<br>      <span class="hljs-keyword">if</span> (img.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span> &amp;&amp; img.<span class="hljs-property">offsetTop</span> &lt; scrollTop + viewHeight + <span class="hljs-number">200</span>) &#123;<br>        img.<span class="hljs-property">src</span> = img.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>;<br>        img.<span class="hljs-title function_">removeAttribute</span>(<span class="hljs-string">&#x27;data-src&#x27;</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">const</span> handleScroll = <span class="hljs-title function_">throttle</span>(checkImage, <span class="hljs-number">500</span>);<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, handleScroll);<br>  <span class="hljs-title function_">checkImage</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，将<code>lazyLoad</code>函数应用到页面的图片容器中即可。例如，以下是一个使用<code>lazyLoad</code>函数实现懒加载的示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;image1.jpg&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;image2.jpg&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- ... --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;image25.jpg&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.img-container&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-title function_">lazyLoad</span>(container);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述代码会对容器中的图片进行懒加载，每次滚动事件触发时会节流执行<code>checkImage</code>函数，以避免频繁处理滚动事件。</p><h3 id="异步池"><a href="#异步池" class="headerlink" title="异步池"></a>异步池</h3><p>使用异步池可以更好地控制并发请求的数量，提高性能和用户体验。这里介绍一个使用异步池实现图片懒加载的示例代码。</p><p>首先，定义一个异步池<code>asyncPool</code>函数，它接收一个池大小和一个异步处理函数作为参数，返回一个新的异步处理函数。该新函数可以在池大小内并发执行异步请求，并返回所有请求的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncPool</span>(<span class="hljs-params">poolSize, array, asyncFn</span>) &#123;<br>  <span class="hljs-keyword">const</span> results = [];<br>  <span class="hljs-keyword">const</span> executing = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> array) &#123;<br>    <span class="hljs-keyword">const</span> promise = <span class="hljs-title function_">asyncFn</span>(item);<br>    results.<span class="hljs-title function_">push</span>(promise);<br><br>    <span class="hljs-keyword">if</span> (poolSize &lt;= array.<span class="hljs-property">length</span>) &#123;<br>      <span class="hljs-keyword">const</span> e = promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> executing.<span class="hljs-title function_">splice</span>(executing.<span class="hljs-title function_">indexOf</span>(e), <span class="hljs-number">1</span>));<br>      executing.<span class="hljs-title function_">push</span>(e);<br>      <span class="hljs-keyword">if</span> (executing.<span class="hljs-property">length</span> &gt;= poolSize) &#123;<br>        <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>(executing);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(results);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，定义一个<code>lazyLoad</code>函数，它可以对指定容器内的所有图片进行懒加载。该函数首先获取容器内的所有图片元素，然后将图片元素及其位置信息打包成一个图片信息对象，并将所有图片信息对象放入一个数组中。然后使用<code>asyncPool</code>函数对数组中的所有图片信息对象进行异步处理，每次处理一个图片信息对象，实现并发懒加载的效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">lazyLoad</span>(<span class="hljs-params">container</span>) &#123;<br>  <span class="hljs-keyword">const</span> imgList = container.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;img[data-src]&#x27;</span>);<br>  <span class="hljs-keyword">const</span> viewHeight = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getImageInfo</span>(<span class="hljs-params">img</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; top &#125; = img.<span class="hljs-title function_">getBoundingClientRect</span>();<br>    <span class="hljs-keyword">const</span> offsetTop = top + <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>      img,<br>      offsetTop,<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> imgInfoList = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">call</span>(imgList, getImageInfo);<br><br>  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadImage</span>(<span class="hljs-params">imgInfo</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> img = imgInfo.<span class="hljs-property">img</span>;<br>      <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleLoad</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        img.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, handleLoad);<br>        img.<span class="hljs-title function_">removeAttribute</span>(<span class="hljs-string">&#x27;data-src&#x27;</span>);<br>        <span class="hljs-title function_">resolve</span>();<br>      &#125;<br>      img.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, handleLoad);<br>      img.<span class="hljs-property">src</span> = img.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncPool</span>(<span class="hljs-number">5</span>, imgInfoList, loadImage);<br>&#125;<br><br><span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.img-container&#x27;</span>);<br><span class="hljs-title function_">lazyLoad</span>(container);<br></code></pre></td></tr></table></figure><p>上述代码会对容器中的图片进行懒加载，使用<code>asyncPool</code>函数实现并发控制。具体来说，定义一个池大小为5，在异步处理函数中加载图片，处理完毕后再将图片的<code>data-src</code>属性替换为<code>src</code>属性。该方案可以确保每次最多只有5个图片请求同时进行，避免并发请求导致负荷过大的情况。</p><h2 id="前端实现登录鉴权的方案有哪些？"><a href="#前端实现登录鉴权的方案有哪些？" class="headerlink" title="前端实现登录鉴权的方案有哪些？"></a>前端实现登录鉴权的方案有哪些？</h2><ol><li>Token 方案：在用户登录后，后端返回一个 Token，前端将 Token 存储在本地，之后每次请求时将 Token 带上，后端进行校验。Token 一般有两种形式：JWT 和自定义 Token。</li><li>Session 方案：后端将用户登录信息存储在服务器中，每次请求时进行校验，可以通过 cookie 或者 header 发送 sessionid 信息。</li><li>OAuth 方案：将用户授权给第三方应用，用户在第三方应用进行登录后，后端将用户信息进行获取，并进行鉴权和授权。</li><li>单点登录（SSO）方案：用户进行登录后，可以在多个应用之间进行共享，只需要在第一次登录时进行授权，之后在其他应用时不需要再次登录。</li></ol><h2 id="React的高阶组件是如何实现的？"><a href="#React的高阶组件是如何实现的？" class="headerlink" title="React的高阶组件是如何实现的？"></a>React的高阶组件是如何实现的？</h2><p>React高阶组件（Higher-Order Components，HOC）是一个函数，接收一个组件并返回一个增强版本的组件。它用于复用组件逻辑，可以用来实现代码复用、逻辑封装等。</p><p>React高阶组件的实现方式如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">higherOrderComponent</span>(<span class="hljs-params">WrappedComponent</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">React</span>.<span class="hljs-property">Component</span> &#123;<br>    <span class="hljs-comment">// 这里可以定义一些通用的逻辑</span><br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 在这里渲染被包裹的组件，并注入一些 props</span><br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> &#123;<span class="hljs-attr">...this.props</span>&#125; /&gt;</span></span>;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个例子演示了一个最基础的高阶组件实现方式。当组件使用这个高阶组件时，它将被包裹在高阶组件返回的类组件中。</p><p>使用这个高阶组件的方式如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EnhancedComponent</span> = <span class="hljs-title function_">higherOrderComponent</span>(<span class="hljs-title class_">BaseComponent</span>);<br></code></pre></td></tr></table></figure><p>这样，<code>EnhancedComponent</code> 就变成了增强版的 <code>BaseComponent</code>。</p><p>React高阶组件的应用有很多，例如：</p><ul><li>控制组件渲染</li><li>访问 React 组件的生命周期方法</li><li>将通用逻辑抽象为一个公共组件</li></ul><p>需要注意的是，使用高阶组件将会导致一些性能问题。因为每次渲染时，都可能会创建一个新的组件实例。为了解决这个问题，我们可以使用 <code>React.memo</code> 高阶函数对组件进行优化，使其只在依赖项发生变化时才进行更新，避免不必要的渲染。</p><h2 id="前端如何实现多个接口并发请求，并按照顺序返回结果？"><a href="#前端如何实现多个接口并发请求，并按照顺序返回结果？" class="headerlink" title="前端如何实现多个接口并发请求，并按照顺序返回结果？"></a>前端如何实现多个接口并发请求，并按照顺序返回结果？</h2><p>在前端中，我们可以使用 <code>Promise.all()</code> 来实现多个接口的并发请求，并按照顺序返回结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> api1Promise = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/api1&#x27;</span>);<br><span class="hljs-keyword">const</span> api2Promise = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/api2&#x27;</span>);<br><span class="hljs-keyword">const</span> api3Promise = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/api3&#x27;</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([api1Promise, api2Promise, api3Promise])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">responses</span> =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(responses.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())))<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">results</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// results 包含了所有接口返回的数据，按照请求顺序存放</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理错误</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用了 <code>fetch()</code> 函数发起了多个接口请求，并将请求结果封装在一个 Promise 对象中。然后，我们使用 <code>Promise.all()</code> 来并发发起这些请求。<code>Promise.all()</code> 接收一个 Promise 对象数组，并在所有 Promise 对象都成功返回结果后，返回一个包含所有结果的 Promise 对象。</p><p>接着，在第一个 <code>.then()</code> 中，我们使用 <code>Promise.all()</code> 来将所有结果转换成 JSON 格式。这里需要注意的是，由于 <code>fetch()</code> 函数返回的是一个对象（而不是 JSON 字符串），因此我们需要使用 <code>.json()</code> 方法将其转换为 JSON 格式。</p><p>最后，在第二个 <code>.then()</code> 中，我们可以按照请求顺序将所有数据存放在 <code>results</code> 数组中，并进行处理。</p><h2 id="对微前端和小程序的理解？"><a href="#对微前端和小程序的理解？" class="headerlink" title="对微前端和小程序的理解？"></a>对微前端和小程序的理解？</h2><p>微前端和小程序是两种不同的架构模式。</p><p>微前端是一种将前端应用程序拆分为多个较小、独立的部分，每个部分都可以独立构建、部署，跨团队共同开发，最终组合成完整的前端应用程序的架构风格。微前端可以将一个复杂的前端应用拆解成多个更易于理解、维护和开发的小应用，可以极大提高应用的可维护性、扩展性和可复用性。</p><p>小程序则是一种轻量、低耦合的应用形态。它与普通的网页应用不同，是运行在一个独立的、受限的执行环境中的，可以通过微信、支付宝等应用平台下载和运行。小程序具有轻便、快速、便捷等特点，并且具有开发门槛低、维护简单等优势。</p><p>在微前端中，每个小应用可以看作一个完整的应用，可以使用不同的框架、技术栈来开发。小程序则是一个更加轻量、特殊的应用类型，其开发也需要遵循一定的规范和限制。微前端和小程序都能够极大地提高应用的灵活性、可维护性、可扩展性，但适用的场景、开发方式、技术栈以及运行时环境等方面都存在差异。</p><p>需要注意的是，微前端是一种架构风格，而不是具体实现。在实施微前端时，需要结合具体的业务需求和技术栈，选择适合自己的微前端实现方式。常见的微前端实现方式有：Web Components、IFrame、Javascript Integration等。</p><h2 id="Http报文格式？"><a href="#Http报文格式？" class="headerlink" title="Http报文格式？"></a>Http报文格式？</h2><p>请求报文：请求行+请求头+请求体</p><p>请求行格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">请求方法 <span class="hljs-variable constant_">URI</span> <span class="hljs-variable constant_">HTTP</span>版本<br><span class="hljs-variable constant_">GET</span> /test <span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">2.0</span><br></code></pre></td></tr></table></figure><p>响应报文：响应行+响应头+响应体</p><p>响应行格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">HTTP</span>版本 状态码 状态描述<br><span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">2.0</span> <span class="hljs-number">200</span> <span class="hljs-variable constant_">OK</span><br></code></pre></td></tr></table></figure><h2 id="GET请求在body设置数据是否会传递？"><a href="#GET请求在body设置数据是否会传递？" class="headerlink" title="GET请求在body设置数据是否会传递？"></a>GET请求在body设置数据是否会传递？</h2><p>按照HTTP协议规范，GET请求的参数应该放在URL的查询参数部分，而不是请求体中。因此，即使在请求体中设置了数据，这些数据也不会被传递，而是会被忽略。</p><p>需要注意的是，虽然不建议在GET请求中使用请求体来传递参数，但是HTTP协议规范并未禁止这种行为。某些特定的服务端框架和应用程序可能会对此进行支持，但是这种行为并不常见，因此不推荐使用。</p><h2 id="如何画一条0-5px的直线？"><a href="#如何画一条0-5px的直线？" class="headerlink" title="如何画一条0.5px的直线？"></a>如何画一条0.5px的直线？</h2><ul><li><p><code>transform: scaleY(0.5)</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.line</span> &#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>   <span class="hljs-attribute">height</span>: <span class="hljs-number">1px</span>;<br>   <span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#C5C5C5</span>;<br>   <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>);<br>   -webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>); <span class="hljs-comment">/* Safari 和 Chrome */</span><br>   -moz-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>); <span class="hljs-comment">/* Firefox */</span><br>   -ms-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>); <span class="hljs-comment">/* IE 9 */</span><br>   -o-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>); <span class="hljs-comment">/* Opera */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用svg绘制线条</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&quot;0.5&quot;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&quot;0.5&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;#C5C5C5&quot;</span> <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="CSS的-和-选择器？"><a href="#CSS的-和-选择器？" class="headerlink" title="CSS的+和~选择器？"></a>CSS的+和~选择器？</h2><ol><li>+选择器（相邻兄弟选择器）：选择紧接着指定元素后出现的第一个同级元素。例如，p + span 选取紧随p元素之后第一个出现的span元素。</li><li>~选择器（通用兄弟选择器）：选择指定元素之后的所有同级元素。例如，p ~ span 选取所有在p元素之后出现的span元素。</li></ol><h2 id="什么是并发池？"><a href="#什么是并发池？" class="headerlink" title="什么是并发池？"></a>什么是并发池？</h2><p>并发池（Concurrent Pool）是指一组线程处理任务的资源池，它用于控制并发任务的数量，以及线程的数量和调度。并发池是提高多线程效率的一种常见方式。由于创建线程是一项昂贵的操作，在有限的 CPU 资源下，任务多线程执行时有时会导致性能下降。为了提高线程处理任务的效率，可以将并发任务扔到并发池中，使其可以更高效地利用有限的 CPU 资源。</p><p>在并发池中，当有任务需要执行时，会从池中取出一个线程，线程会负责处理任务。如果任务较多，而线程数不够，可以根据需要创建新的线程来处理，但这种操作需要消耗系统的资源，因此需要进行一定的控制和限制。</p><p>并发池还可以设置任务队列和线程池的最大大小等参数，以调整整个系统的负载和性能。增加并发池的大小或者增强并发能力可以提高任务处理的速度，但是会增加系统的开销和调度的复杂度，需要进行合理的调整和平衡。</p><p>并发池是基于多线程技术的一种高效的任务调度方案，在并发编程中被广泛应用，例如，Java中的ThreadPoolExecutor就是一个大家熟知的并发池实现。</p><h2 id="手写并发池？"><a href="#手写并发池？" class="headerlink" title="手写并发池？"></a>手写并发池？</h2><p>JavaScript 实现并发池的思路一般可以分为以下几个步骤：</p><ol><li>创建一个任务队列，用于存储待执行的任务。</li><li>创建一个线程池，用于并发执行任务。线程池中可以维护一个可用线程的队列，新任务需要执行时，从队列中获取一个线程进行执行。</li><li>在执行任务时，线程需要从任务队列中取出一个待执行的任务进行处理。处理完成后，将线程回收到线程池中，等待下一个任务。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 任务队列</span><br><span class="hljs-keyword">const</span> taskQueue = [];<br><br><span class="hljs-comment">// 线程池</span><br><span class="hljs-keyword">const</span> threadPool = [];<br><br><span class="hljs-comment">// 初始化线程池，创建可用线程</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initThreadPool</span>(<span class="hljs-params">num</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>    threadPool.<span class="hljs-title function_">push</span>(&#123;<br>      <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;available&#x27;</span><br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 执行任务</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">executeTask</span>(<span class="hljs-params">task</span>) &#123;<br>  <span class="hljs-comment">// 检查是否有可用线程</span><br>  <span class="hljs-keyword">let</span> idleThread = threadPool.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">thread</span> =&gt;</span> thread.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;available&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (idleThread) &#123;<br>    <span class="hljs-comment">// 将线程状态设置为“忙碌”</span><br>    idleThread.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;busy&#x27;</span>;<br>    <span class="hljs-comment">// 执行任务</span><br>    <span class="hljs-title function_">task</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 任务执行结束，将线程状态设置为“可用”</span><br>      idleThread.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;available&#x27;</span>;<br>      <span class="hljs-comment">// 处理下一个任务</span><br>      <span class="hljs-title function_">processTask</span>();<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 等待空闲线程</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">executeTask</span>(task);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 处理任务</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processTask</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (taskQueue.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">let</span> task = taskQueue.<span class="hljs-title function_">shift</span>();<br>    <span class="hljs-title function_">executeTask</span>(task);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 添加任务到队列</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addTask</span>(<span class="hljs-params">task</span>) &#123;<br>  taskQueue.<span class="hljs-title function_">push</span>(task);<br>  <span class="hljs-title function_">processTask</span>();<br>&#125;<br><br><span class="hljs-comment">// 初始化线程池</span><br><span class="hljs-title function_">initThreadPool</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 添加任务到队列</span><br><span class="hljs-title function_">addTask</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Task 1 completed!&#x27;</span>);<br>    <span class="hljs-title function_">callback</span>();<br>  &#125;, <span class="hljs-number">3000</span>);<br>&#125;);<br><br><span class="hljs-title function_">addTask</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Task 2 completed!&#x27;</span>);<br>    <span class="hljs-title function_">callback</span>();<br>  &#125;, <span class="hljs-number">2000</span>);<br>&#125;);<br><br><span class="hljs-title function_">addTask</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Task 3 completed!&#x27;</span>);<br>    <span class="hljs-title function_">callback</span>();<br>  &#125;, <span class="hljs-number">4000</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>以上代码中，我们定义了一个任务队列 <code>taskQueue</code> 和一个线程池 <code>threadPool</code>。在 <code>initThreadPool</code> 函数中，我们创建了一定数量的线程并添加到线程池中。</p><p>在 <code>executeTask</code> 函数中，我们检查线程池中是否有可用线程，如果有可用线程则从任务队列中取出一个任务并将其交给线程执行。任务执行完成后，我们将线程状态设置为“可用”，并继续处理下一个任务。</p><p>在 <code>addTask</code> 函数中，我们将新任务添加到任务队列中，在有可用线程时自动开始执行。我们也可以手动调用 <code>processTask</code> 函数开始执行任务。</p><h2 id="什么是异步池？"><a href="#什么是异步池？" class="headerlink" title="什么是异步池？"></a>什么是异步池？</h2><p>异步池是一种用于控制并发异步操作的机制。它通过限制异步操作的并发数量，避免过多的异步操作导致系统资源紧张、性能下降或者甚至崩溃的情况发生。</p><p>在异步编程模型中，异步操作常常需要消耗大量的系统资源，例如网络 IO、磁盘 IO、CPU 等。如果同时启动过多的异步操作，系统资源就会被耗尽，导致性能下降或者崩溃。因此，为了更好地控制异步操作的并发数量，提高系统的稳定性和性能，通常会采用异步池的机制。</p><p>异步池的实现一般使用任务队列来控制异步操作的并发数量。当有任务需要执行时，先将任务添加到队列中，然后从池中取出一个空闲的线程进行执行，执行完成后再将线程回收到池中等待下一个任务。</p><p>异步池具有以下优点：</p><ol><li>可以避免过多异步操作导致系统性能下降或者崩溃。</li><li>可以提高异步操作的执行效率和响应速度。</li><li>可以提高系统的稳定性和可靠性。</li></ol><p>异步池的应用场景非常广泛，例如网络通信、数据处理、图片处理、音视频处理等领域都会用到异步池的技术。</p><h2 id="npm-i时-D，-g，-s有什么区别？"><a href="#npm-i时-D，-g，-s有什么区别？" class="headerlink" title="npm i时 -D，-g，-s有什么区别？"></a>npm i时 -D，-g，-s有什么区别？</h2><ol><li><code>-D</code> 或 <code>--save-dev</code>: 表示将依赖项保存在<code>devDependencies</code>节点下。<code>devDependency</code>表示本地开发环境所需要的依赖项，如测试库等，这些依赖项不会放到生产环境中，而是在开发和测试中使用。在项目中执行<code>npm install</code>时，这些依赖项不会被下载。</li><li><code>-g</code> 或 <code>--global</code>: 表示将模块安装为全局模块，只需要在第一次安装时执行一次即可，以后在任意位置执行该模块时都会被引用。通常用于全局的命令行工具，例如<code>gulp-cli</code>。</li><li><code>-S</code> 或 <code>--save</code>: 表示将依赖项保存在<code>dependencies</code>节点下。<code>dependency</code>表示运行时需要的依赖项。在项目中执行<code>npm install</code>时，这些依赖项会被下载到本地并保存在<code>node_modules</code>目录下，可以被应用程序或项目引用。</li></ol><p>默认使用的是<code>-s</code></p><h2 id="开发依赖和上线依赖有什么，代码层面如何体现的？"><a href="#开发依赖和上线依赖有什么，代码层面如何体现的？" class="headerlink" title="开发依赖和上线依赖有什么，代码层面如何体现的？"></a>开发依赖和上线依赖有什么，代码层面如何体现的？</h2><p>开发依赖和生产依赖的主要区别在于它们所处的上下文环境不同。开发依赖是在在开发过程中使用的依赖项，而生产依赖是在发布后运行时需要的依赖项。</p><p>在代码层面，可以通过修改 <code>package.json</code> 文件来区分开发依赖和生产依赖。<code>package.json</code> 文件是一个描述 <code>Node.js</code> 模块的文件，它包含了模块名称、版本、作者、许可证等一系列的信息，同时还包含了 <code>dependencies</code> 和 <code>devDependencies</code> 两个节点，分别用于描述生产依赖和开发依赖。</p><p>举个例子，我们在开发过程中使用了 <code>babel</code> 和 <code>webpack</code>，但是生产环境中并不需要它们，那么在 <code>package.json</code> 文件中我们可以这样写：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my-app&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;express&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.16.4&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;babel-core&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^6.26.0&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;babel-loader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^7.1.5&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;webpack&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.39.1&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>express</code> 被声明为生产依赖项，而 <code>babel-core</code>、<code>babel-loader</code> 和 <code>webpack</code> 被声明为开发依赖项。开发依赖项一般不会被发布到生产环境中，而生产环境中只会安装相应的生产依赖项。</p><h2 id="什么是Nginx的负载均衡？"><a href="#什么是Nginx的负载均衡？" class="headerlink" title="什么是Nginx的负载均衡？"></a>什么是Nginx的负载均衡？</h2><p>Nginx的负载均衡是一种分发网络负载的技术，它能够将请求分发到不同的服务器上，以达到提高应用程序可用性、可伸缩性和容错性的效果。</p><p>Nginx 的负载均衡通过对请求进行分发，把负载均衡器作为客户端，把服务器作为后端，当客户端发送请求后，负载均衡器根据某种算法，将请求转发到不同的服务器上，分散了服务器的压力，实现了资源的共享。</p><p>Nginx 的负载均衡有四种模式：轮询模式、IP哈希模式、最少连接模式和加权轮询模式。其中，</p><ol><li>轮询模式：按照每一次的连接顺序，在后端服务器间进行轮询；</li><li>IP哈希模式：通过对每一个请求连接的IP地址进行哈希计算，来决定调度的服务器；</li><li>最少连接模式：根据当前所有已连接的客户端数来判断应该将请求发送到哪个服务器上；</li><li>加权轮询模式：根据服务器的性能指标给不同的服务器分配不同的权值，来决定应该将连接转发到哪个服务器上。</li></ol><p>通过Nginx的负载均衡，可以减小单台服务器的压力，提高应用程序的效率和负载能力，从而更好地满足用户需求。</p><h2 id="类方法和实例方法有什么不同？"><a href="#类方法和实例方法有什么不同？" class="headerlink" title="类方法和实例方法有什么不同？"></a>类方法和实例方法有什么不同？</h2><ol><li>对象与类的调用方式不同：实例方法是对象调用的，类方法是类直接调用的。</li><li>实例方法与类方法的传参不同：实例方法通常至少有一个self参数，表示实例本身，可以访问实例的属性和方法；而类方法通常至少有一个cls参数，表示类本身，可以访问类的属性和方法。</li><li>实例方法执行的上下文不同：实例方法的执行上下文是实例对象，可以在执行过程中修改实例对象的属性和方法；而类方法的执行上下文是类对象，而不是实例对象，所以无法在执行过程中修改实例对象的属性和方法。</li></ol><h2 id="什么是CSS吸顶组件？"><a href="#什么是CSS吸顶组件？" class="headerlink" title="什么是CSS吸顶组件？"></a>什么是CSS吸顶组件？</h2><p>CSS吸顶组件是指在页面中的某个元素距离顶部一定距离时（例如滚动到特定位置），该元素会变为fixed定位，固定在页面顶部，不再随页面滚动而移动，这种效果也称为“滚动监听”效果。</p><p>通常需要设置一个触发“吸顶”的滚动距离和一个吸顶的目标元素，然后监听滚动事件，一旦滚动距离超过触发距离就将目标元素应用fixed定位。在实现时，可以通过CSS的position: fixed属性来实现，或通过JavaScript监听滚动事件并动态修改目标元素的位置来实现。</p><p>CSS吸顶组件在web页面开发中非常常见，如网页顶部的导航栏。它可以提高页面的易用性和美观性，为用户提供更好的交互体验。</p><h2 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h2><ol><li><p>使用position: sticky属性</p><p>position: sticky是一种新的CSS属性，可以让元素在特定区域内始终保持定位。实现步骤如下：</p><p>（1）在目标元素上设置position: sticky属性，并设置top属性值为距离顶部的距离。</p><p>（2）设置容器元素的高度，让目标元素在容器区域内保持sticky效果。</p><p>（3）在CSS中设置滚动时目标元素的样式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">2000px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.header</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">position</span>: sticky;</span><br><span class="language-css">    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffffff</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.fixed</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">position</span>: fixed;</span><br><span class="language-css">    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffffff</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><br>    // 头部内容区域<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>使用JavaScript监听滚动事件</p><p>获取目标元素的offsetTop值，即目标元素距离页面顶部的距离。</p><p>监听页面的滚动事件，一旦滚动距离超过目标元素的offsetTop值，就给目标元素添加fixed定位。</p><p>在CSS中设置目标元素的fixed样式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.fixed</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">position</span>: fixed;</span><br><span class="language-css">    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffffff</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> header = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.header&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> headerOffsetTop = header.<span class="hljs-property">offsetTop</span>;</span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> &gt;= headerOffsetTop) &#123;</span><br><span class="language-javascript">      header.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;fixed&#x27;</span>);</span><br><span class="language-javascript">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">      header.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;fixed&#x27;</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><br>  // 头部内容区域<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识点整理(10)</title>
    <link href="/2023/04/19/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-10/"/>
    <url>/2023/04/19/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-10/</url>
    
    <content type="html"><![CDATA[<h1 id="知识点整理-10"><a href="#知识点整理-10" class="headerlink" title="知识点整理(10)"></a>知识点整理(10)</h1><h2 id="为什么要设计ElementUI、Ant-Design等组件库？"><a href="#为什么要设计ElementUI、Ant-Design等组件库？" class="headerlink" title="为什么要设计ElementUI、Ant Design等组件库？"></a>为什么要设计ElementUI、Ant Design等组件库？</h2><ol><li><p>提高开发效率：组件库的设计和开发是为了解决重复工作，使用现有组件能够<strong>加快开发速度，减少重复工作量，提高开发效率</strong>。</p></li><li><p>提高代码可维护性：组件库的使用能够<strong>使得代码更加规范化，便于维护</strong>，同时也避免了代码重复，减轻了开发人员负担。</p></li><li><p>优化用户体验：设计的组件库对UI、交互、动效等方面进行了深入优化，可以帮助开发人员打造出<strong>更好的用户体验</strong>。</p></li><li><p>响应式设计：组件库<strong>具有响应式的特性，能够满足不同尺寸和设备的适配需求</strong>，提高网站或应用的可用性。</p></li><li><p>节省开发成本：使用现成组件库可以<strong>节省开发成本和人力成本</strong>，既可以降低开发难度和技术门槛，也可以降低公司的开发成本。</p></li></ol><h2 id="设计组件库有哪些注意事项？"><a href="#设计组件库有哪些注意事项？" class="headerlink" title="设计组件库有哪些注意事项？"></a>设计组件库有哪些注意事项？</h2><ol><li>UI和交互设计：组件库的设计需要遵循良好的UI设计和交互设计原则，提供<strong>良好的用户体验，包括直观的视觉指引、简单易懂的界面、良好的交互反馈</strong>等。</li><li>组件设计：在设计组件时，需要考虑组件的基础特性、定位、使用场景、可扩展性、可定制性等，同时要有充分的用户体验测试。</li><li>兼容性：组件库要考虑到<strong>各种浏览器和设备的兼容性</strong>，建议采用<strong>响应式设计和渐进增强</strong>的设计策略。</li><li>文档和示例：组件库需要完善的文档和示例，<strong>方便开发人员使用和调试</strong>，避免不必要的耗时。</li><li>维护和更新：组件库需要持续的维护和更新，包括bug修复、功能增强、安全性更新等，保证组件库的<strong>稳定性和可靠性</strong>。</li><li>样式管理：组件库的样式需要考虑到<strong>全局样式管理和组件内部样式的优化</strong>，防止出现样式冲突和不必要的CSS代码重复。</li><li>可重用性：组件库的组件应尽可能保持独立性，便于<strong>在不同的应用中重复使用</strong>。</li></ol><h2 id="开发组件库的过程中有什么难点？"><a href="#开发组件库的过程中有什么难点？" class="headerlink" title="开发组件库的过程中有什么难点？"></a>开发组件库的过程中有什么难点？</h2><ol><li>设计阶段：在组件库的设计阶段，需要考虑到组件的<strong>丰富性和可用性</strong>，以及<strong>组件间的协调和统一性</strong>，需要在设计和开发之前进行充分的需求分析和用户调研。</li><li>兼容性：组件库需要考虑到各<strong>种浏览器和设备的兼容性</strong>，包括浏览器的版本不同、设备分辨率不同等，需要进行多个平台的测试。</li><li>在多个项目中使用：组件库的组件需要在多个项目中使用，因此需要满足<strong>通用性</strong>的需求，同时需要保证可维护性，以便在多个项目中进行更新和升级。</li><li>长期维护：组件库需要考虑到长期维护的需求，需要进行<strong>稳定性的测试和更新</strong>。</li><li>性能优化：组件库需要考虑到性能优化的问题，<strong>避免在页面中渲染过多的组件和数据</strong>，同时需要对组件库进行<strong>代码分离和按需加载</strong>等优化。</li><li>API的设计：组件库的API设计需要充分考虑到<strong>不同需求下的定制性和扩展性</strong>，同时需要保证API的易用性和一致性。</li><li>文档和示例：组件库需要考虑到文档和示例的编写和更新，以便开发者能够快速地掌握组件库的使用方法。</li></ol><h2 id="Ant-Design组件库是怎么实现的？"><a href="#Ant-Design组件库是怎么实现的？" class="headerlink" title="Ant Design组件库是怎么实现的？"></a>Ant Design组件库是怎么实现的？</h2><ol><li>核心代码实现：Ant Design的核心代码实现是基于React框架，使用TypeScript语言编写，使用webpack进行打包。代码中主要包含了不同组件的实现，包括表单、按钮、导航、布局等。</li><li>样式实现：Ant Design的样式实现主要是基于Less预处理器进行开发，使用了变量、混入、嵌套等功能。通过变量的定义和使用，实现了全局的样式风格的统一。同时，还使用一些第三方的CSS库，如Normalize.css和iconfont等。</li><li>工具库：Ant Design中有一个封装了常用工具函数的utility库，此库包括类型检测、数据处理、字符串处理、时间处理等常用方法，并对一些方法进行了二次封装，方便调用。</li><li>国际化实现：Ant Design支持多语言和多区域的国际化，其实现基于react-intl库，通过对不同语言的国际化配置，实现组件中文本的切换。</li><li>文档和示例：Ant Design的文档和示例基于dumi库进行生成，同时还有一个在线的交互式示例网站Ant Design Pro，用户可以通过此网站直接预览和体验各个组件。</li></ol><h2 id="ESLint如何进行配置？常见的配置有哪些？"><a href="#ESLint如何进行配置？常见的配置有哪些？" class="headerlink" title="ESLint如何进行配置？常见的配置有哪些？"></a>ESLint如何进行配置？常见的配置有哪些？</h2><p>ESLint的配置文件可以使用JS、JSON、YAML、XML格式的文件进行配置。通常将配置文件命名为<code>.eslintrc.js</code>、<code>.eslintrc.json</code>、<code>.eslintrc.yaml</code>、<code>.eslintrc.yml</code>、<code>.eslintrc.xml</code>中的一种，放置于项目的根目录下。</p><p>ESLint的配置文件可以使用JS、JSON、YAML、XML格式的文件进行配置。通常我们将配置文件命名为<code>.eslintrc.js</code>、<code>.eslintrc.json</code>、<code>.eslintrc.yaml</code>、<code>.eslintrc.yml</code>、<code>.eslintrc.xml</code>中的一种，放置于项目的根目录下。</p><p>常见的ESLint配置有以下几项：</p><ol><li><code>env</code>: 指定应用程序的运行环境，一般是浏览器或Node.js环境</li><li><code>extends</code>: 指定要扩展的 ESLint 配置文件</li><li><code>rules</code>: 配置规则，可以禁用或启用规则，以及覆盖默认规则或扩展规则重载规则、覆盖提示程度等</li><li><code>globals</code>: 在代码中定义全局变量，防止报未定义错误</li><li><code>parserOptions</code>: 配置ESLint的解析器，如支持ECMAScript的版本等</li><li><code>plugins</code>: 通过ESLint插件扩展规则，可以开启或关闭插件</li><li><code>ignore</code>: 跳过某些文件或文件夹</li></ol><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">env</span>: &#123;<br>    <span class="hljs-attr">browser</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">es6</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">node</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  <span class="hljs-attr">extends</span>: [<span class="hljs-string">&#x27;eslint:recommended&#x27;</span>, <span class="hljs-string">&#x27;plugin:react/recommended&#x27;</span>],<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-string">&#x27;react&#x27;</span>],<br>  <span class="hljs-attr">parserOptions</span>: &#123;<br>    <span class="hljs-attr">ecmaVersion</span>: <span class="hljs-number">2018</span>,<br>    <span class="hljs-attr">sourceType</span>: <span class="hljs-string">&#x27;module&#x27;</span>,<br>    <span class="hljs-attr">ecmaFeatures</span>: &#123;<br>      <span class="hljs-attr">jsx</span>: <span class="hljs-literal">true</span>,<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-attr">rules</span>: &#123;<br>    <span class="hljs-string">&#x27;react/prop-types&#x27;</span>: <span class="hljs-string">&#x27;off&#x27;</span>,<br>    <span class="hljs-string">&#x27;no-unused-vars&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>该配置使用了ESLint默认的<code>recommended</code>规则和<code>react/recommended</code>规则，指定了环境为浏览器、ES6和Node.js环境，启用了React插件，禁用了对于React中props的类型检查，开启了对于未使用变量的警告。</p><p>需要注意的是，ESLint的配置可以进行优先级继承，通常情况下，更具体、具有更小范围的文件配置优先级更高，在不同目录下的配置文件可以进行覆盖和继承。</p><h2 id="CommonJS和ES-Module的区别？"><a href="#CommonJS和ES-Module的区别？" class="headerlink" title="CommonJS和ES Module的区别？"></a>CommonJS和ES Module的区别？</h2><ol><li>导入方式：CommonJS使用require语句导入模块，ES Module使用import语句导入模块。</li><li>导出方式：CommonJS使用module.exports和exports对象导出模块，ES Module使用export语句导出模块。</li><li>运行时加载：CommonJS是同步加载模块，也就是说模块加载完成后再执行后续代码；ES Module是异步加载模块，可以进行静态分析，也就是说可以在编译时就进行加载和分析，提高了应用程序的运行效率。</li><li>执行上下文：CommonJS在导入模块时，会将导出的内容复制一份并保存在内存中，导入的模块内容是一个对象；ES Module在导入模块时，使用链接技术，也就是在外部保存对导出对象的引用，导入的模块直接指向导出对象。</li><li>浏览器支持：CommonJS主要用于服务器端JavaScript编程，而ES Module是由ECMA标准制定的，支持ES6的浏览器都可以使用。</li></ol><h2 id="什么是Promise？"><a href="#什么是Promise？" class="headerlink" title="什么是Promise？"></a>什么是Promise？</h2><p>Promise是一种异步编程的解决方案，它可以将回调函数的嵌套层级降低，使异步操作的代码更易于理解和维护。对于一些需要等待异步操作完成后才能进行接下来的操作的场景，Promise可以帮助我们处理这种异步操作。</p><p>Promise可以理解为一个容器，其中保存了异步操作的结果。在Promise执行过程中，可以分为三种状态：</p><ol><li>Pending状态：Promise对象创建时处于Pending状态，表示异步操作正在执行。</li><li>Resolved状态：异步操作成功时，Promise对象的状态变为Resolved（也称作Fulfilled）状态，并且保存异步操作的结果，可以通过Promise的then方法获取。</li><li>Rejected状态：异步操作失败时，Promise对象的状态变为Rejected状态，并保存异步操作的错误信息，可以通过Promise的catch方法获取错误信息。</li></ol><p>Promise对象一旦进入Resolved或者Rejected状态，就不会再改变状态。所以在Promise对象创建后，可以通过then方法添加回调函数，当异步操作成功时调用该回调函数，如果异步操作失败则可以通过catch方法添加回调函数，当异步操作失败时调用该回调函数，在回调函数中对异步操作的结果进行处理。</p><p>Promise还具有链式调用的特点。当异步操作需要串联多个异步操作时，可以通过then方法将多个异步操作串联起来，然后在最后一个异步操作返回结果时，可以通过resolve方法返回结果，从而触发then方法中的回调函数进行处理。</p><h2 id="手写给对象添加去重方法？"><a href="#手写给对象添加去重方法？" class="headerlink" title="手写给对象添加去重方法？"></a>手写给对象添加去重方法？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 利用Map方法给对象去重</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">uniqueByKey</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <span class="hljs-keyword">const</span> newObj = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      <span class="hljs-keyword">const</span> value = <span class="hljs-variable language_">this</span>[key];<br>      <span class="hljs-keyword">if</span> (!map.<span class="hljs-title function_">has</span>(key)) &#123;<br>        map.<span class="hljs-title function_">set</span>(key, value);<br>        newObj[key] = value;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newObj;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="手写打点计时器？"><a href="#手写打点计时器？" class="headerlink" title="手写打点计时器？"></a>手写打点计时器？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Stopwatch</span>(<span class="hljs-params">interval, callback</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">startTime</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">timerId</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">interval</span> = interval;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">callback</span> = callback;<br>&#125;<br><br><span class="hljs-title class_">Stopwatch</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">start</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">timerId</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">startTime</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">timerId</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), <span class="hljs-variable language_">this</span>.<span class="hljs-property">interval</span>); <span class="hljs-comment">// 注意这里要先绑定this才能正确执行tick方法</span><br>  &#125;<br>&#125;;<br><br><span class="hljs-title class_">Stopwatch</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">tick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> elapsedTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - <span class="hljs-variable language_">this</span>.<span class="hljs-property">startTime</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">callback</span>(elapsedTime);<br>&#125;;<br><br><span class="hljs-title class_">Stopwatch</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">stop</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timerId</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">timerId</span> = <span class="hljs-literal">null</span>;<br>&#125;;<br><br><span class="hljs-title class_">Stopwatch</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">reset</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">stop</span>();<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">startTime</span> = <span class="hljs-literal">null</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>首先，我们定义一个 Stopwatch 构造函数，它接受两个参数 interval 和 callback，分别表示计时器的时间间隔和每次执行的任务。</li><li>在构造函数中，我们初始化了一些属性，包括 startTime、timerId、interval 和 callback。</li><li>然后，我们定义了 start、tick、stop 和 reset 方法。</li><li>start 方法用来启动计时器。它首先检查 timerId 是否为 null，如果是的话，就记录当前时间（也就是计时器的起始时间）并创建一个定时器。定时器会在每个时间间隔内调用 tick 方法。</li><li>tick 方法用来执行每次任务。它首先计算已经经过的时间（也就是当前时间减去起始时间），然后调用 callback 函数执行任务，将已经花费的时间作为参数传递给 callback 函数。</li><li>stop 方法用来停止计时器。它清除定时器并设置 timerId 为 null。</li><li>reset 方法用来重置计时器。它调用 stop 方法停止计时器并将 startTime 设置为 null。</li></ol><p>使用该计时器，我们可以像下面这样编写代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> stopwatch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stopwatch</span>(<span class="hljs-number">1000</span>, <span class="hljs-function"><span class="hljs-params">elapsedTime</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Elapsed time: <span class="hljs-subst">$&#123;elapsedTime&#125;</span> ms`</span>);<br>&#125;);<br><br>stopwatch.<span class="hljs-title function_">start</span>();<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  stopwatch.<span class="hljs-title function_">stop</span>();<br>&#125;, <span class="hljs-number">5000</span>);<br></code></pre></td></tr></table></figure><p>上面的代码创建了一个计时器，每隔 1 秒执行一次任务（输出已经花费的时间），并在 5 秒后停止计时器。运行上面的代码后，你会看到类似如下的输出内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Elapsed</span> <span class="hljs-attr">time</span>: <span class="hljs-number">1009</span> ms<br><span class="hljs-title class_">Elapsed</span> <span class="hljs-attr">time</span>: <span class="hljs-number">2012</span> ms<br><span class="hljs-title class_">Elapsed</span> <span class="hljs-attr">time</span>: <span class="hljs-number">3021</span> ms<br><span class="hljs-title class_">Elapsed</span> <span class="hljs-attr">time</span>: <span class="hljs-number">4028</span> ms<br><span class="hljs-title class_">Elapsed</span> <span class="hljs-attr">time</span>: <span class="hljs-number">5037</span> ms<br></code></pre></td></tr></table></figure><p>这表示计时器每隔 1 秒执行一次任务，并输出已经花费的时间。在 5 秒后，计时器被停止。</p><h2 id="Sass预处理器的目的是什么？"><a href="#Sass预处理器的目的是什么？" class="headerlink" title="Sass预处理器的目的是什么？"></a>Sass预处理器的目的是什么？</h2><ol><li><strong>增强 CSS 功能</strong>：Sass 通过引入变量、嵌套、混入、函数、继承等功能，使得 CSS 更加强大、灵活和易于维护。</li><li><strong>提高效率</strong>：Sass 通过嵌套规则和提供复杂样式的简单方法，减少了重复和冗余的代码。同时，Sass 模块化的架构和继承能力简化了代码的编写和维护。</li><li><strong>降低维护成本</strong>：Sass 提供了灵活的代码重用和继承机制，使得样式的修改更加容易，减少了修改代码的时间和成本。</li><li><strong>更好的文档</strong>：Sass 可以帮助团队实现更好的代码文档化。我们可以使用像变量和混入等工具来向代码中添加注释，更容易弄清楚代码的含义。</li></ol><h2 id="Sass的工作原理？"><a href="#Sass的工作原理？" class="headerlink" title="Sass的工作原理？"></a>Sass的工作原理？</h2><ol><li>Sass 文件读取：在 Sass 的编译过程中，首先需要读取 Sass 文件。</li><li>Sass 语法解析：Sass 编译器会解析 Sass 文件中的语法，包括变量、嵌套、混入、函数、继承等功能。解析的结果会被保存在内存中。</li><li>Sass 语法转换：Sass 语法会转换为 CSS 语法。例如，Sass 的变量会被转换成 CSS 的属性值，Sass 的混入会被转换成 CSS 的 @include 指令。</li><li>CSS 文件生成：Sass 编译器将转换后的 CSS 代码生成为一个或多个 CSS 文件。</li><li>CSS 文件输出：生成的 CSS 文件可以直接输出到磁盘或者返回给 Web 服务器，用于被浏览器解析和应用。</li></ol><p>在 Sass 的编译过程中，使用的核心技术是 Sass 引擎和 CSS 解析器。Sass 引擎负责解析 Sass 语法，将其转换为 CSS 代码；CSS 解析器则负责将生成的 CSS 代码解析为浏览器所能识别的样式表。这些技术共同构成了 Sass 的编译过程和原理。</p><h2 id="Vite和Webpack的区别？"><a href="#Vite和Webpack的区别？" class="headerlink" title="Vite和Webpack的区别？"></a>Vite和Webpack的区别？</h2><ol><li>构建过程不同：Webpack 是通过一系列 Loader 和插件对代码进行编译和打包，Vite 则是通过浏览器原生支持的 ES Modules（ESM）导入的方式进行实时编译和构建，避免了打包过程中的耗时和资源浪费。</li><li>开发环境启动速度不同：Vite 开发环境的启动速度比 Webpack 快很多，基本上可以做到开发环境立即响应，因为 Vite 不需要进行打包操作，而 Webpack 则需要在每次启动开发环境时进行较为繁琐的构建。</li><li>支持的文件类型不同：Webpack 支持多种文件类型的打包构建，而 Vite 目前只支持 Javascript 和 Vue 单组件。</li><li>热更新实现不同：Webpack 的热更新实现是通过 HMR（Hot Module Replacement）机制，重新加载模块实现快速更新，而 Vite 利用了浏览器中的 ESM 特性，通过一个 WebSocket 服务器实现了模块的实时编译和热更新。</li></ol><p>总而言之，Vite 相较于 Webpack 有着更快的构建速度和更优秀的开发体验，但它的能力没有 Webpack 强大，不支持多种文件类型的打包构建。Vite 使得前端开发者可以更快地进行开发并且代码构建的过程更加高效。</p><h2 id="Vite打包的产物能直接发布吗？"><a href="#Vite打包的产物能直接发布吗？" class="headerlink" title="Vite打包的产物能直接发布吗？"></a>Vite打包的产物能直接发布吗？</h2><p>Vite 打包的产物的确可以直接发布到线上服务器，但需要注意以下几点：</p><ol><li>Vite 打包出来的文件默认不会压缩，需要自行使用类似 UglifyJS，Terser 等工具进行压缩和混淆，以减小文件体积和提高加载速度。</li><li>由于 Vite 采用的是预处理打包方式，打包出来的代码可能会出现一些奇怪的问题，需要在发布前进行全面测试和校验。</li><li>在打包过程中需要注意依赖的引入方式，是否存在跨域访问的问题等，以保证打包产物能够正常运行。</li></ol><p>总之，Vite 打包的产物可以直接发布，但需要注意以上问题以确保生产环境的稳定运行。对于有更严格需求的项目，最好还是通过 CI&#x2F;CD 工具进行自动化构建和部署。</p><h2 id="TypeScript和JavaScript的区别？"><a href="#TypeScript和JavaScript的区别？" class="headerlink" title="TypeScript和JavaScript的区别？"></a>TypeScript和JavaScript的区别？</h2><ol><li>类型系统：TypeScript 强制规定变量、函数和参数的类型，而 JavaScript 则没有这个限制，可以使用任意类型。TypeScript 的类型系统可以在代码编写过程中提供更加明确的类型提示，减少错误发生的可能。</li><li>面向对象特性：TypeScript 支持面向对象编程的概念，例如：类、接口、命名空间等，而 JavaScript 并不完全支持这些特性。</li><li>扩展性：TypeScript 是 JavaScript 的超集，即 TypeScript 可以使用 JavaScript 中的所有语法，同时还有自己的特性。在掌握 JavaScript 语法的前提下，只需要了解 TypeScript 新增特性即可。</li><li>构建工具和开发环境：因为 TypeScript 有类型检查的特性，需要在编译之前进行类型检查，所以需要使用额外的 TypeScript 编译器来进行编译。此外，集成开发环境如 VS Code、WebStorm 等也提供了强大的 TypeScript 支持。</li></ol><h2 id="Java和NodeJS的区别？"><a href="#Java和NodeJS的区别？" class="headerlink" title="Java和NodeJS的区别？"></a>Java和NodeJS的区别？</h2><ol><li>语言类型：Java 是一种<strong>静态、面向对象、类型安全</strong>的编程语言，而 Node.js 是一种基<strong>于事件驱动、非阻塞 I&#x2F;O</strong> 的服务器端 JavaScript 运行环境。</li><li>并发处理：Java 有线程的概念，线程可以提供<strong>并发执行</strong>能力，可以同时处理多个请求。而 Node.js 使用单线程，采用了<strong>事件轮询和异步 I&#x2F;O</strong> 的方式来处理并发请求，通常使用非阻塞 I&#x2F;O 模型。</li><li>异步编程：Java 提供了<strong>多线程和同步异步两种编程方式</strong>，但是<strong>在面对高并发请求时，使用多线程会带来线程上下文切换和同步锁等开销，降低性能</strong>。而 Node.js 采用事件驱动的编程方式，<strong>使用回调函数实现异步编程，能更好地支持高并发场景</strong>。</li><li>开发效率：Java 属于较庞大的语言，需要编写大量代码，而 Node.js 的代码相对来说更简洁，具有更快的开发效率，但并不意味着其运行效率就低。</li><li>应用场景：Java 适合用于大规模企业级应用的开发，例如电商系统、金融系统等，这些系统的开发通常需要<strong>处理复杂的业务流程和多种数据源</strong>。而 Node.js 适合用于<strong>高并发、I&#x2F;O 密集型</strong>的应用，例如实时聊天、推送消息、数据分析等。</li></ol><h2 id="NodeJS是单线程的，会发生阻塞吗？"><a href="#NodeJS是单线程的，会发生阻塞吗？" class="headerlink" title="NodeJS是单线程的，会发生阻塞吗？"></a>NodeJS是单线程的，会发生阻塞吗？</h2><p>虽然 Node.js 的主线程是单线程运行的，但是 Node.js 底层采用了基于 libuv 库的<strong>事件驱动和非阻塞 I&#x2F;O</strong> 的机制来实现异步非阻塞的编程模型，因此不会导致阻塞。</p><p>在 Node.js 中，<strong>当有异步 I&#x2F;O 操作时，主线程会将该事件交给 libuv（由 C++ 编写）来处理，然后继续处理后面的请求</strong>。在操作完成后，libuv 会<strong>触发相应的回调函数，通过事件循环机制，将数据返回给主线程</strong>。这样，就能在不阻塞主线程的情况下处理多个 I&#x2F;O 操作。</p><p>然而，也需要注意的是，如果在 Node.js 应用程序的代码编写中存在非异步操作（如大量运算、文件读取等），并且这些操作时间过长，将会导致 Node.js 暂停事件循环并终止响应，这种情况被称为事件循环阻塞。所以在编写 Node.js 代码时，还需要注意避免这种情况的发生。</p><h2 id="HTTPS中的数字证书是哪一方发送的？"><a href="#HTTPS中的数字证书是哪一方发送的？" class="headerlink" title="HTTPS中的数字证书是哪一方发送的？"></a>HTTPS中的数字证书是哪一方发送的？</h2><p>在HTTPS通信中，数字证书是由服务器端发送给客户端的。</p><p>当客户端首次访问使用HTTPS协议的网站时，服务器会向客户端发送数字证书。客户端接收到数字证书后，会进行数字证书的验证过程，验证证书是否有效、证书颁发机构是否可信等。如果数字证书验证通过，客户端会生成会话密钥并使用证书中的公钥对该密钥进行加密，然后将加密后的密钥发送给服务器端。服务器端使用自己的私钥对密钥进行解密，然后双方就可以使用该密钥进行加密通信。</p><p>因此，在HTTPS协议中，数字证书是由服务器端发送给客户端的，客户端通过验证数字证书的有效性，并使用其公钥加密会话密钥，从而确保双方的通信是加密的、安全的。</p><h2 id="什么是JS的包装类型？"><a href="#什么是JS的包装类型？" class="headerlink" title="什么是JS的包装类型？"></a>什么是JS的包装类型？</h2><p>JavaScript的包装类型（Wrapping Objects）指的是将基本数据类型（例如字符串、数字、布尔值等）通过包装类（String、Number、Boolean）转换为对象。这样，我们就可以使用对象的方法和属性来操作基本数据类型。</p><p>Number包装类型有哪些方法？</p><ol><li>toExponential(): 将数字转换为指数计数形式的字符串。</li><li>toFixed(): 将数字转换为字符串，保留指定位数的小数。</li><li>toLocaleString(): 将数字转换为指定地区的格式化字符串。</li><li>toPrecision(): 将数字转换为字符串，将字符串中数字的总位数限制为指定的数字。</li><li>toString(): 将数字转换为字符串。</li><li>valueOf(): 返回数字的原始值。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//定义一个数字</span><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">123.456</span>;<br><br><span class="hljs-comment">// toExponential()</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toExponential</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// &quot;1.23e+2&quot;</span><br><br><span class="hljs-comment">// toFixed()</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// &quot;123.46&quot;</span><br><br><span class="hljs-comment">// toLocaleString()</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">&#x27;en-US&#x27;</span>)); <span class="hljs-comment">// &quot;123.456&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">&#x27;de-DE&#x27;</span>)); <span class="hljs-comment">// &quot;123,456&quot;</span><br><br><span class="hljs-comment">// toPrecision()</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toPrecision</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// &quot;123.46&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toPrecision</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// &quot;1.2e+2&quot;</span><br><br><span class="hljs-comment">// toString()</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// &quot;123.456&quot;</span><br><br><span class="hljs-comment">// valueOf()</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">valueOf</span>()); <span class="hljs-comment">// 123.456</span><br></code></pre></td></tr></table></figure><h2 id="闭包有哪些优点？可以做哪些事情？"><a href="#闭包有哪些优点？可以做哪些事情？" class="headerlink" title="闭包有哪些优点？可以做哪些事情？"></a>闭包有哪些优点？可以做哪些事情？</h2><p>闭包是指一个函数可以访问其父作用域的变量，即使父作用域已经结束执行，这些变量仍然可以被访问。闭包有如下优点：</p><ol><li>保护变量：由于闭包的函数可以访问其父作用域的变量，因此可以将一些变量私有化，避免在全局范围内被访问和修改，从而增强程序的安全性。</li><li>延长变量寿命：通过闭包，可以将变量的生命周期延长至其内部函数执行结束之后，这样可以避免变量在外部被提前销毁。</li><li>保存状态：闭包可以记住函数执行时的状态，也就是函数执行环境中的变量值。这使得下次再次访问该函数时，可以使用上次保存的状态继续进行操作。</li><li>可以做柯里化：类似于函数式编程语言中的柯里化，通过闭包，可以将一个函数转化为另一个函数，使得该函数的某些参数被预先设置，并返回一个接受剩余参数的新函数。这个特性可以帮助我们创建更加灵活的函数。</li></ol><p>闭包可以做如下事情：</p><ol><li>实现模块化：通过使用闭包将一些变量、方法封装在模块内，提高代码的可复用性和可维护性。</li><li>实现缓存机制：闭包可以实现一些缓存机制，避免频繁的计算和请求，提高程序的执行效率。</li><li>实现事件绑定：由于闭包可以保存状态，并且可以访问函数外部的变量，因此可以在事件绑定的过程中保存一些状态，比如记录用户的点击次数等。</li><li>传递变量：由于闭包可以将函数内部的变量保留在内存中，因此可以在不同的执行环境中传递变量的值。</li></ol><h2 id="React和Vue有哪些区别？"><a href="#React和Vue有哪些区别？" class="headerlink" title="React和Vue有哪些区别？"></a>React和Vue有哪些区别？</h2><ol><li>语言：React是使用JavaScript语言编写的，而Vue是使用JavaScript和模板语言编写的。</li><li>数据绑定：React通常使用单向数据流（父组件向子组件传递数据，子组件可更改该数据），Vue则提供了双向数据绑定。</li><li>组件通信：React使用props和回调函数来实现组件之间的通信，而Vue使用props，事件总线，Vuex等来实现组件之间的通信。</li><li>模板：React使用JSX语法编写组件，而Vue使用模板语言编写组件。</li><li>性能：React在大型组件和动态数据渲染时性能优于Vue，但是Vue在小型组件和静态数据渲染时性能优于React。</li><li>学习曲线：Vue相比于React有着更低的学习曲线，因为Vue提供了更直观和简洁的API，而React则更加灵活但需要一些额外的学习。</li></ol><h2 id="什么是虚拟DOM？"><a href="#什么是虚拟DOM？" class="headerlink" title="什么是虚拟DOM？"></a>什么是虚拟DOM？</h2><p>虚拟DOM（Virtual DOM）是指一种构建在内存中的、轻量级的虚拟节点树。在React等某些JavaScript框架中，组件经常被定义为一个虚拟的数据结构，它们包含了组件的状态和属性，但是没有DOM元素。当一个组件的状态发生改变时，虚拟DOM会在内存中重新构建一棵树，然后与之前的树进行比较，找出两棵树中不同的部分并更新到实际的DOM上，从而实现了页面内容的更新。</p><p>虚拟DOM的优点在于：</p><ol><li>减少DOM操作次数：通过计算前后两次虚拟DOM树的差异，只更新差异的部分，而不是整个页面都进行重绘，从而避免了一些性能上的浪费。</li><li>提高渲染效率：虚拟DOM可以根据需要进行分类，一个虚拟节点上所包含的真实节点也只会在其附近需要更新的时候才会被添加到真实的DOM树中。</li><li>更好地实现跨平台：虚拟DOM的本质是一个跨平台的数据结构，可以轻松地在不同平台和环境中实现页面的构建和渲染，例如React Native就是利用虚拟DOM实现的。</li></ol><p>虚拟DOM的实现过程一般包括三个步骤：生成虚拟DOM树、对比新旧虚拟DOM树、更新真实DOM树。虽然虚拟DOM有些许性能上的消耗，但是在复杂的应用场景下，它还是展现出了出色的性能优势。</p><h2 id="React-Diff算法的实现细节？"><a href="#React-Diff算法的实现细节？" class="headerlink" title="React Diff算法的实现细节？"></a>React Diff算法的实现细节？</h2><p>React Diff算法是指React通过比较前后两次的虚拟DOM树来计算出真实DOM树中需要更新的节点，从而提高渲染性能的算法。</p><p>React Diff算法的实现细节如下：</p><ol><li>只会在同一个节点（即相同的组件）之间进行比较：React会判断新旧两个节点是否相同，如果不同，则直接暴力删除旧节点，新增一个新节点，重新创建所有子节点，这时会丢失所有DOM节点上的状态。如果相同，则继续下一步比较。</li><li>对属性进行比较：React比较前后两次虚拟DOM节点的属性，只更新有改变的属性，提高渲染效率。</li><li>采用“key”进行优化：在对列表进行Diff算法时，通过给每一个单独的列表项加上唯一的“key”属性，可以更快速精准地找出需要更新的节点。</li><li>对子节点进行递归比较：当两个节点的属性相同且节点类型相同时，React会对它们的子节点进行递归比较，找出需要更新的子节点。</li><li>按顺序更新子节点：React将之前生成的虚拟DOM节点数组与新的虚拟DOM节点数组进行比较，找出需要更新、新增和删除的节点，并按顺序更新节点。</li></ol><h2 id="实现大数相加？"><a href="#实现大数相加？" class="headerlink" title="实现大数相加？"></a>实现大数相加？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bigNumberAdd</span>(<span class="hljs-params">num1, num2</span>) &#123;<br>  <span class="hljs-keyword">let</span> i = num1.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> j = num2.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>; <span class="hljs-comment">// 进位</span><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-string">&#x27;&#x27;</span>; <span class="hljs-comment">// 结果</span><br><br>  <span class="hljs-comment">// 遍历两个数字的每个位数</span><br>  <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">let</span> a = num1[i] ? <span class="hljs-built_in">parseInt</span>(num1[i]) : <span class="hljs-number">0</span>; <span class="hljs-comment">// 取出num1当前位数上的数字</span><br>    <span class="hljs-keyword">let</span> b = num2[j] ? <span class="hljs-built_in">parseInt</span>(num2[j]) : <span class="hljs-number">0</span>; <span class="hljs-comment">// 取出num2当前位数上的数字</span><br>    <span class="hljs-keyword">let</span> sum = a + b + carry; <span class="hljs-comment">// 计算两个数的和，以及上一次的进位</span><br>    carry = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(sum / <span class="hljs-number">10</span>); <span class="hljs-comment">// 更新进位</span><br>    result = (sum % <span class="hljs-number">10</span>) + result; <span class="hljs-comment">// 更新结果</span><br>    i--;<br>    j--;<br>  &#125;<br><br>  <span class="hljs-comment">// 处理最高位的进位</span><br>  <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>    result = carry + result;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识点整理(9)</title>
    <link href="/2023/04/17/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-9/"/>
    <url>/2023/04/17/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-9/</url>
    
    <content type="html"><![CDATA[<h1 id="知识点整理-9"><a href="#知识点整理-9" class="headerlink" title="知识点整理(9)"></a>知识点整理(9)</h1><h2 id="flex-derection方向改变后对主侧轴的排列会有什么影响？"><a href="#flex-derection方向改变后对主侧轴的排列会有什么影响？" class="headerlink" title="flex-derection方向改变后对主侧轴的排列会有什么影响？"></a>flex-derection方向改变后对主侧轴的排列会有什么影响？</h2><p>当 flex-direction 方向改变后，主侧轴也会随着改变方向。这将会对元素的排列位置产生影响。例如，如果原本是沿着水平方向排列的元素，当改变为垂直方向时，这些元素将会沿着垂直方向排列。换句话说，元素在水平和垂直方向上的位置将会互换。如果元素的排列使用了 align-items 或 justify-content 属性，则也会随着主侧轴的改变而改变。因此，排列的方式也会有所调整。</p><h2 id="绝对定位的元素会产生reflow吗？"><a href="#绝对定位的元素会产生reflow吗？" class="headerlink" title="绝对定位的元素会产生reflow吗？"></a>绝对定位的元素会产生reflow吗？</h2><p>绝对定位的元素会在页面加载时产生一次 reflow，但是随后的页面操作中不会再次触发 reflow。这是因为绝对定位的元素在定位时已经脱离了正常文档流，不会再影响其他元素的位置和布局。</p><p>然而，当发生以下情况时，绝对定位的元素会导致 reflow：</p><ol><li>改变绝对定位元素的位置和尺寸，例如通过 JavaScript 改变其 top、left、width、height 等属性。</li><li>改变绝对定位元素后面元素的位置和尺寸，例如通过 JavaScript 改变其 margin、padding、border、width、height 等属性。</li></ol><p>因此，尽量避免频繁地改变绝对定位元素的位置和尺寸，以减少页面的 reflow 造成的性能损失。</p><h2 id="Node-js的模块化和ES6的区别？"><a href="#Node-js的模块化和ES6的区别？" class="headerlink" title="Node.js的模块化和ES6的区别？"></a>Node.js的模块化和ES6的区别？</h2><ol><li>模块导出方式不同：Node.js 采用 <code>module.exports</code> 和 <code>exports</code> 导出模块，ES6 采用 <code>export</code> 导出模块。</li><li>模块引入方式不同：Node.js 采用 <code>require()</code> 引入模块，ES6 采用 <code>import</code> 引入模块。</li><li>支持的 ECMAScript 版本不同：Node.js 目前默认支持 ES5 和部分 ES6 特性，而 ES6 支持的特性更加丰富。</li><li>模块文件后缀名不同：Node.js 默认使用 <code>.js</code> 后缀作为模块文件后缀名，而在 ES6 中，可以使用 <code>.js</code>、<code>.mjs</code> 或 <code>.jsx</code> 作为模块文件后缀名。</li><li>模块依赖管理不同：Node.js 采用 CommonJS 规范管理模块依赖关系，并通过 <code>npm</code> 包管理器进行模块管理。而 ES6 采用 ECMAScript 规范管理模块依赖关系，并通过 <code>import</code> 和 <code>export</code> 语法进行模块管理。</li></ol><h2 id="Node-js事件循环机制？"><a href="#Node-js事件循环机制？" class="headerlink" title="Node.js事件循环机制？"></a>Node.js事件循环机制？</h2><p><img src="https://static.vue-js.com/f2e34d80-c90e-11eb-ab90-d9ae814b240d.png" alt="img"></p><p>Node.js的EventLoop存在六个阶段，每个阶段都有对应的一个先进先出的回调队列。</p><ul><li>timers阶段：执行timer (setTimeout, setInterval) 的回调</li><li>I&#x2F;O事件回调阶段(I&#x2F;O callbacks)：执行延迟到下一个循环迭代的I&#x2F;O回调，即上一轮循环中为被执行的一些I&#x2F;O回调</li><li>闲置阶段：仅系统内部使用</li><li>轮询阶段(poll)：检索新的I&#x2F;O事件，执行I&#x2F;O相关的回调(几乎所有情况下，除了关闭的回调函数，那些由计时器和<code>setImmediate()</code>调度的之外)，其余情况node将适当在此阻塞</li><li>检查阶段(check)：<code>setImmediate()</code>回调函数在这里执行</li><li>关闭事件回调阶段(close callback)：一些关闭的回调函数，如：<code>socket.on(&quot;colse&quot;, ...)</code></li></ul><p>除了上述6个阶段，还存在<code>process.nextTick</code>，其不属于事件循环的任何一个阶段，它属于该阶段与下阶段之间的过渡, 即本阶段执行结束, 进入下一个阶段前, 所要执行的回调，类似插队</p><p>流程图如下所示：</p><p><img src="https://static.vue-js.com/fbe731d0-c90e-11eb-ab90-d9ae814b240d.png" alt="img"></p><h2 id="Node-js的宏任务队列与微任务队列"><a href="#Node-js的宏任务队列与微任务队列" class="headerlink" title="Node.js的宏任务队列与微任务队列"></a>Node.js的宏任务队列与微任务队列</h2><p>在<code>Node</code>中，同样存在宏任务和微任务，与浏览器中的事件循环相似</p><p>微任务对应有：</p><ul><li>next tick queue：process.nextTick</li><li>other queue：Promise的then回调、queueMicrotask</li></ul><p>宏任务对应有：</p><ul><li>timer queue：setTimeout、setInterval</li><li>poll queue：IO事件</li><li>check queue：setImmediate</li><li>close queue：close事件</li></ul><p>其执行顺序为：</p><ul><li>next tick microtask queue</li><li>other microtask queue</li><li>timer queue</li><li>poll queue</li><li>check queue</li><li>close queue</li></ul><h2 id="Node-js的事件循环机制和浏览器的事件循环机制有什么区别？"><a href="#Node-js的事件循环机制和浏览器的事件循环机制有什么区别？" class="headerlink" title="Node.js的事件循环机制和浏览器的事件循环机制有什么区别？"></a>Node.js的事件循环机制和浏览器的事件循环机制有什么区别？</h2><p>Node.js 的事件循环机制主要有以下几点特点：</p><ol><li>基于单线程。Node.js 在执行 JavaScript 代码时只有一个主线程，所有的异步任务都是在该线程中执行的。</li><li>采用时间驱动机制。Node.js 的事件循环机制以事件驱动的方式来处理异步任务，使用回调函数处理异步任务完成的事件。</li><li>实现了 I&#x2F;O 多路复用。Node.js 使用 I&#x2F;O 多路复用技术来处理网络 I&#x2F;O 操作，实现了非阻塞式的处理。</li></ol><p>而浏览器的事件循环机制主要有以下几点特点：</p><ol><li>基于多线程。浏览器使用多线程来执行 JavaScript 代码，可以同时处理多个任务。</li><li>采用事件循环或消息队列机制。在一般情况下，浏览器采用事件循环机制来处理 DOM 事件等异步任务。在一些特殊情况下，例如 Web Workers 中，浏览器采用消息队列机制来处理异步任务。</li><li>对于 Ajax 等异步任务，浏览器会将其交由浏览器内核的线程池来处理，同时也可能会使用缓存来优化异步请求的处理。</li></ol><h2 id="什么是Node-js的EventEmmiter？"><a href="#什么是Node-js的EventEmmiter？" class="headerlink" title="什么是Node.js的EventEmmiter？"></a>什么是Node.js的EventEmmiter？</h2><p>Node.js 的 EventEmmiter 是 Node.js 核心模块中的一个类，它提供了一种基于事件（Event）的编程模型。</p><p>EventEmitter 实例对象具有两个主要功能：</p><ol><li>触发事件：通过 emit() 方法触发指定的事件，并把相关数据传递给事件监听函数（event listener or handler）。</li><li>注册监听器：通过 on() 或 addListener() 方法注册一个或多个事件监听函数，当事件被触发时，相关的监听函数将被调用执行。</li></ol><p>EventEmitter 提供了一种便捷的机制，用于解决应用程序内各个组件之间的通信问题，同时还允许用户扩展基类（base class），适应各种事件处理需求。</p><p>例如，我们可以在 Node.js 中使用 EventEmitter 来监听网络连接事件，处理 HTTP 请求和响应，并在我们的应用程序中生成自定义的事件。</p><p>基本用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入 Node.js 核心模块</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><br><span class="hljs-comment">// 创建 EventEmitter 实例对象</span><br><span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();<br><br><span class="hljs-comment">// 绑定事件监听器</span><br>myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;event&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`event has been fired: <span class="hljs-subst">$&#123;num&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-comment">// 触发事件</span><br>myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;event&#x27;</span>, <span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">event has been <span class="hljs-attr">fired</span>: <span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><h2 id="Node-js文件查找的优先级？require方法的文件查找策略？"><a href="#Node-js文件查找的优先级？require方法的文件查找策略？" class="headerlink" title="Node.js文件查找的优先级？require方法的文件查找策略？"></a>Node.js文件查找的优先级？require方法的文件查找策略？</h2><ul><li>缓存的模块优先级最高</li><li>如果是内置模块，则直接返回，优先级仅次缓存的模块</li><li>如果是绝对路径 &#x2F; 开头，则从根目录找</li><li>如果是相对路径 .&#x2F;开头，则从当前require文件相对位置找</li><li>如果文件没有携带后缀，先从js、json、node按顺序查找</li><li>如果是目录，则根据 package.json的main属性值决定目录下入口文件，默认情况为 index.js</li><li>如果文件为第三方模块，则会引入 node_modules 文件，如果不在当前仓库文件中，则自动从上级递归查找，直到根目录</li></ul><p>NodeJS对CommonJS进行了支持和实现，让我们在开发node的过程中可以方便的进行模块化开发：</p><ul><li>在Node中每个JS文件都是一个单独的模块</li><li>模块中包含CommonJS规范的核心变量：</li></ul><h3 id="查找策略"><a href="#查找策略" class="headerlink" title="查找策略"></a>查找策略</h3><p><code>require</code>方法接收一下几种参数的传递：</p><ul><li>原生模块：http、fs、path等</li><li>相对路径的文件模块：.&#x2F;mod或..&#x2F;mod</li><li>绝对路径的文件模块：&#x2F;pathtomodule&#x2F;mod</li><li>目录作为模块：.&#x2F;dirname</li><li>非原生模块的文件模块：mod</li></ul><p><code>require</code>参数较为简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同，如下图：</p><p><img src="https://static.vue-js.com/33ae8ef0-c9ba-11eb-85f6-6fac77c0c9b3.png" alt="img"></p><p>从上图可以看见，文件模块存在缓存区，寻找模块路径的时候都会<strong>优先从缓存中加载已经存在的模块</strong>。</p><p><strong>原生模块</strong>：</p><p>像原生模块这些，通过<code>require</code>方法在解析文件名之后，优先检查模块是否在原生模块列表中，如果在则从原生模块中加载</p><p><strong>绝对路径、相对路径</strong>：</p><p>如果<code>require</code>绝对路径的文件，则直接查找对应的路径，速度最快</p><p>相对路径的模块则相对于当前调用<code>require</code>的文件去查找</p><p>如果按确切的文件名没有找到模块，则 <code>NodeJs</code> 会尝试带上 <code>.js</code>、<code>.json</code>或 <code>.node</code>拓展名再加载</p><p><strong>目录作为模块</strong>：</p><p>默认情况是根据根目录中<code>package.json</code>文件的<code>main</code>来指定目录模块，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123; <br>    <span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;some-library&quot;</span>,<br>  <span class="hljs-string">&quot;main&quot;</span> : <span class="hljs-string">&quot;main.js&quot;</span> <br>&#125;<br></code></pre></td></tr></table></figure><p>如果这是在<code>./some-library node_modules</code>目录中，则 <code>require(&#39;./some-library&#39;)</code> 会试图加载 <code>./some-library/main.js</code></p><p>如果目录里没有 <code>package.json</code>文件，或者 <code>main</code>入口不存在或无法解析，则会试图加载目录下的 <code>index.js</code> 或 <code>index.node</code> 文件</p><p><strong>非原生模块</strong>：</p><p>在每个文件中都存在<code>module.paths</code>，表示模块的搜索路径，<code>require</code>就是根据其来寻找文件</p><p>在<code>window</code>下输出如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">[ <br>    <span class="hljs-string">&#x27;c:\\nodejs\\node_modules&#x27;</span>,<br><span class="hljs-string">&#x27;c:\\node_modules&#x27;</span> <br>]<br></code></pre></td></tr></table></figure><p>可以看出<code>module path</code>的生成规则为：从当前文件目录开始查找<code>node_modules</code>目录；然后依次进入父目录，查找父目录下的<code>node_modules</code>目录，依次迭代，直到根目录下的<code>node_modules</code>目录</p><p>当都找不到的时候，则会从系统<code>NODE_PATH</code>环境变量查找</p><p>例如：</p><p>如果在<code>/home/ry/projects/foo.js</code>文件里调用了 <code>require(&#39;bar.js&#39;)</code>，则 Node.js 会按以下顺序查找：</p><ul><li>&#x2F;home&#x2F;ry&#x2F;projects&#x2F;node_modules&#x2F;bar.js</li><li>&#x2F;home&#x2F;ry&#x2F;node_modules&#x2F;bar.js</li><li>&#x2F;home&#x2F;node_modules&#x2F;bar.js</li><li>&#x2F;node_modules&#x2F;bar.js</li></ul><p>这使得程序本地化它们的依赖，避免它们产生冲突</p><h2 id="Node-js中间件？如何封装？"><a href="#Node-js中间件？如何封装？" class="headerlink" title="Node.js中间件？如何封装？"></a>Node.js中间件？如何封装？</h2><p>中间件（Middleware）是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的。</p><p>在<code>NodeJS</code>中，中间件主要是指封装<code>http</code>请求细节处理的方法</p><p>例如在<code>express</code>、<code>koa</code>等<code>web</code>框架中，中间件的本质为一个回调函数，参数包含请求对象、响应对象和执行下一个中间件的函数</p><p><img src="https://static.vue-js.com/6a6ed3f0-cce4-11eb-85f6-6fac77c0c9b3.png" alt="img"></p><p>在这些中间件函数中，我们可以执行业务逻辑代码，修改请求和响应对象、返回响应数据等操作。</p><p><strong>如何进行封装：</strong></p><p>编写中间件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logger</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;req.method&#125;</span> <span class="hljs-subst">$&#123;req.url&#125;</span> was requested`</span>);<br>  <span class="hljs-title function_">next</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">errorHandler</span>(<span class="hljs-params">err, req, res, next</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err.<span class="hljs-property">stack</span>);<br>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Something broke!&#x27;</span>);<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  logger,<br>  errorHandler<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用中间件(Express)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; logger, errorHandler &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./middleware&#x27;</span>);<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br>app.<span class="hljs-title function_">use</span>(logger);<br><span class="hljs-comment">// more middleware and routes</span><br>app.<span class="hljs-title function_">use</span>(errorHandler);<br><br><span class="hljs-comment">// start the server</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PORT</span> = <span class="hljs-number">3000</span>;<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-variable constant_">PORT</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Server listening on port <span class="hljs-subst">$&#123;PORT&#125;</span>`</span>));<br></code></pre></td></tr></table></figure><h2 id="什么是JWT鉴权机制？"><a href="#什么是JWT鉴权机制？" class="headerlink" title="什么是JWT鉴权机制？"></a>什么是JWT鉴权机制？</h2><p>JWT（JSON Web Token），本质就是一个字符串书写规范，如下图，作用是用来在用户和服务器之间传递安全可靠的信息。</p><p>在目前前后端分离的开发过程中，使用<code>token</code>鉴权机制用于身份验证是最常见的方案，流程如下：</p><ul><li>服务器当验证用户账号和密码正确的时候，给用户颁发一个令牌，这个令牌作为后续用户访问一些接口的凭证</li><li>后续访问会根据这个令牌判断用户时候有权限进行访问</li></ul><p><code>Token</code>，分成了三部分，头部（Header）、载荷（Payload）、签名（Signature），并以<code>.</code>进行拼接。其中头部和载荷都是以<code>JSON</code>格式存放数据，只是进行了编码。</p><p>Express生成token</p><p>借助第三方库<code>jsonwebtoken</code>，通过<code>jsonwebtoken</code>的<code>sign</code>方法生成一个<code>token</code>：</p><ul><li>第一个参数指的是<code>PayLoad</code></li><li>第二个参数为密钥，服务端特有</li><li>第三个参数是option，可以定义token过期时间</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;jsonwebtoken&quot;</span>); <span class="hljs-comment">// 引入存储token</span><br><span class="hljs-keyword">const</span> secret = <span class="hljs-string">&quot;moodnotes&quot;</span>; <span class="hljs-comment">// token的前缀 </span><br><span class="hljs-keyword">const</span> token = jwt.<span class="hljs-title function_">sign</span>(userInfo, secret, &#123; <span class="hljs-comment">// 通过登录信息生成token</span><br>    <span class="hljs-attr">expiresIn</span>: <span class="hljs-number">60</span>*<span class="hljs-number">60</span>*<span class="hljs-number">24</span> <span class="hljs-comment">// 24小时后过期</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>验证token</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">decode = jwt.<span class="hljs-title function_">verify</span>(token, secret); <span class="hljs-comment">// 验证token</span><br></code></pre></td></tr></table></figure><h3 id="JWT鉴权机制的优缺点"><a href="#JWT鉴权机制的优缺点" class="headerlink" title="JWT鉴权机制的优缺点"></a>JWT鉴权机制的优缺点</h3><p>优点：</p><ul><li>json具有通用性，所以可以跨语言</li><li>组成简单，字节占用小，便于传输</li><li>服务端无需保存会话信息，很容易进行水平扩展</li><li>一处生成，多处使用，可以在分布式系统中，解决单点登录问题</li><li>可防护CSRF攻击</li></ul><p>缺点：</p><ul><li>payload部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息</li><li>需要保护好加密密钥，一旦泄露后果不堪设想</li><li>为避免token被劫持，最好使用https协议</li></ul><h2 id="NodeJS如何实现图片上传？"><a href="#NodeJS如何实现图片上传？" class="headerlink" title="NodeJS如何实现图片上传？"></a>NodeJS如何实现图片上传？</h2><p>文件上传在日常开发中应用很广泛，我们发微博、发微信朋友圈都会用到了图片上传功能。</p><p>因为浏览器限制，浏览器不能直接操作文件系统的，需要通过浏览器所暴露出来的统一接口，由用户主动授权发起来访问文件动作，然后读取文件内容进指定内存里，最后执行提交请求操作，将内存里的文件内容数据上传到服务端，服务端解析前端传来的数据信息后存入文件里。</p><p>对于文件上传，我们需要设置请求头为<code>content-type:multipart/form-data</code></p><blockquote><p>multipart互联网上的混合资源，就是资源由多种元素组成，form-data表示可以使用HTML Forms 和 POST 方法上传文件</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /t2/upload.do HTTP/<span class="hljs-number">1.1</span><br>User-Agent<span class="hljs-punctuation">:</span> SOHUWapRebot<br>Accept-Language<span class="hljs-punctuation">:</span> zh-cn<span class="hljs-punctuation">,</span>zh;q=<span class="hljs-number">0.5</span><br>Accept-Charset<span class="hljs-punctuation">:</span> GBK<span class="hljs-punctuation">,</span>utf<span class="hljs-number">-8</span>;q=<span class="hljs-number">0.7</span><span class="hljs-punctuation">,</span>*;q=<span class="hljs-number">0.7</span><br>Connection<span class="hljs-punctuation">:</span> keep-alive<br>Content-Length<span class="hljs-punctuation">:</span> <span class="hljs-number">60408</span><br>Content-Type<span class="hljs-punctuation">:</span>multipart/form-data; boundary=ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC<br>Host<span class="hljs-punctuation">:</span> w.sohu.com<br><br>--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC<br>Content-Disposition<span class="hljs-punctuation">:</span> form-data; name=<span class="hljs-string">&quot;city&quot;</span><br><br>Santa colo<br>--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC<br>Content-Disposition<span class="hljs-punctuation">:</span> form-data;name=<span class="hljs-string">&quot;desc&quot;</span><br>Content-Type<span class="hljs-punctuation">:</span> text/plain; charset=UTF<span class="hljs-number">-8</span><br>Content-Transfer-Encoding<span class="hljs-punctuation">:</span> <span class="hljs-number">8</span>bit<br> <br>...<br>--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC<br>Content-Disposition<span class="hljs-punctuation">:</span> form-data;name=<span class="hljs-string">&quot;pic&quot;</span>; filename=<span class="hljs-string">&quot;photo.jpg&quot;</span><br>Content-Type<span class="hljs-punctuation">:</span> application/octet-stream<br>Content-Transfer-Encoding<span class="hljs-punctuation">:</span> binary<br> <br>... binary data of the jpg ...<br>--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC--<br></code></pre></td></tr></table></figure><p><code>boundary</code>表示分隔符，如果要上传多个表单项，就要使用<code>boundary</code>分割，每个表单项由<code>———XXX</code>开始，以<code>———XXX</code>结尾</p><p>而<code>xxx</code>是即时生成的字符串，用以确保整个分隔符不会在文件或表单项的内容中出现</p><p>每个表单项必须包含一个 <code>Content-Disposition</code> 头，其他的头信息则为可选项， 比如 <code>Content-Type</code></p><p><code>Content-Disposition</code> 包含了 <code>type</code>和 一个名字为<code>name</code>的 <code>parameter</code>，<code>type</code> 是 <code>form-data</code>，<code>name</code>参数的值则为表单控件（也即 field）的名字，如果是文件，那么还有一个 <code>filename</code>参数，值就是文件名</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">Content-Disposition<span class="hljs-punctuation">:</span> form-data; name=<span class="hljs-string">&quot;user&quot;</span>; filename=<span class="hljs-string">&quot;logo.png&quot;</span><br></code></pre></td></tr></table></figure><p>至于使用<code>multipart/form-data</code>，是因为文件是以二进制的形式存在，其作用是专门用于传输大型二进制数据，效率高。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">处理文件上传的路由</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> multer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;multer&#x27;</span>)<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-keyword">const</span> dirPath = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;..&#x27;</span>, <span class="hljs-string">&#x27;public/upload&#x27;</span>)<br><br><span class="hljs-keyword">const</span> storage = multer.<span class="hljs-title function_">diskStorage</span>(&#123;<br>  <span class="hljs-comment">// destination: &#x27;upload&#x27;, //string时,服务启动将会自动创建文件夹</span><br>  <span class="hljs-attr">destination</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">req, file, cb</span>) &#123; <span class="hljs-comment">//函数需手动创建文件夹</span><br>    <span class="hljs-comment">// console.log(&#x27;destination()&#x27;, file)</span><br>    <span class="hljs-keyword">if</span> (!fs.<span class="hljs-title function_">existsSync</span>(dirPath)) &#123;<br>      fs.<span class="hljs-title function_">mkdir</span>(dirPath, <span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123;<br>        <span class="hljs-keyword">if</span> (err) &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-title function_">cb</span>(<span class="hljs-literal">null</span>, dirPath)<br>        &#125;<br>      &#125;)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">cb</span>(<span class="hljs-literal">null</span>, dirPath)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">filename</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">req, file, cb</span>) &#123;<br>    <span class="hljs-comment">// console.log(&#x27;filename()&#x27;, file)</span><br>    <span class="hljs-keyword">var</span> ext = path.<span class="hljs-title function_">extname</span>(file.<span class="hljs-property">originalname</span>)<br>    <span class="hljs-title function_">cb</span>(<span class="hljs-literal">null</span>, file.<span class="hljs-property">fieldname</span> + <span class="hljs-string">&#x27;-&#x27;</span> + <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() + ext)<br>  &#125;<br>&#125;)<br><span class="hljs-keyword">const</span> upload = <span class="hljs-title function_">multer</span>(&#123;storage&#125;)<br><span class="hljs-keyword">const</span> uploadSingle = upload.<span class="hljs-title function_">single</span>(<span class="hljs-string">&#x27;file&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">fileUpload</span>(<span class="hljs-params">router</span>) &#123;<br><br>  <span class="hljs-comment">// 上传图片</span><br>  router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/manage/img/upload&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">uploadSingle</span>(req, res, <span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123; <span class="hljs-comment">//错误处理</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;上传文件失败, &quot;</span> , err);<br>      <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123;<br>          <span class="hljs-attr">code</span>: <span class="hljs-number">500</span>,<br>          <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;上传文件失败, &#x27;</span> + err<br>        &#125;)<br>      &#125;<br>      <span class="hljs-keyword">var</span> file = req.<span class="hljs-property">file</span><br>      res.<span class="hljs-title function_">send</span>(&#123;<br>        <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,<br>        <span class="hljs-attr">data</span>: &#123;<br>          <span class="hljs-attr">name</span>: file.<span class="hljs-property">filename</span>,<br>          <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:6000/upload/&#x27;</span> + file.<span class="hljs-property">filename</span><br>        &#125;<br>      &#125;)<br><br>    &#125;)<br>  &#125;)<br><br>  <span class="hljs-comment">// 删除图片</span><br>  router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/manage/img/delete&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123;name&#125; = req.<span class="hljs-property">body</span><br>    fs.<span class="hljs-title function_">unlink</span>(path.<span class="hljs-title function_">join</span>(dirPath, name), <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>        res.<span class="hljs-title function_">send</span>(&#123;<br>          <span class="hljs-attr">status</span>: <span class="hljs-number">1</span>,<br>          <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;删除文件失败, &#x27;</span> + err<br>        &#125;)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        res.<span class="hljs-title function_">send</span>(&#123;<br>          <span class="hljs-attr">status</span>: <span class="hljs-number">0</span><br>        &#125;)<br>      &#125;<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Node性能如何进行监控以及优化？"><a href="#Node性能如何进行监控以及优化？" class="headerlink" title="Node性能如何进行监控以及优化？"></a>Node性能如何进行监控以及优化？</h2><p><code>Node</code>作为一门服务端语言，性能方面尤为重要，其衡量指标一般有如下：</p><ul><li>CPU</li><li>内存</li><li>I&#x2F;O</li><li>网络</li></ul><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>主要分成了两部分：</p><ul><li>CPU负载：在某个时间段内，占用以及等待CPU的进程总数</li><li>CPU使用率：CPU时间占用状况，等于 1 - 空闲CPU时间(idle time) &#x2F; CPU总时间</li></ul><p>这两个指标都是用来评估系统当前CPU的繁忙程度的量化指标</p><p><code>Node</code>应用一般不会消耗很多的<code>CPU</code>，如果<code>CPU</code>占用率高，则表明应用存在很多同步操作，导致异步任务回调被阻塞</p><h3 id="内存指标"><a href="#内存指标" class="headerlink" title="内存指标"></a>内存指标</h3><p>内存是一个非常容易量化的指标。 内存占用率是评判一个系统的内存瓶颈的常见指标。 对于Node来说，内部内存堆栈的使用状态也是一个可以量化的指标</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// /app/lib/memory.js</span><br><span class="hljs-keyword">const</span> os = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;os&#x27;</span>);<br><span class="hljs-comment">// 获取当前Node内存堆栈情况</span><br><span class="hljs-keyword">const</span> &#123; rss, heapUsed, heapTotal &#125; = process.<span class="hljs-title function_">memoryUsage</span>();<br><span class="hljs-comment">// 获取系统空闲内存</span><br><span class="hljs-keyword">const</span> sysFree = os.<span class="hljs-title function_">freemem</span>();<br><span class="hljs-comment">// 获取系统总内存</span><br><span class="hljs-keyword">const</span> sysTotal = os.<span class="hljs-title function_">totalmem</span>();<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">memory</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">sys</span>: <span class="hljs-number">1</span> - sysFree / sysTotal,  <span class="hljs-comment">// 系统内存占用率</span><br>      <span class="hljs-attr">heap</span>: heapUsed / headTotal,   <span class="hljs-comment">// Node堆内存占用率</span><br>      <span class="hljs-attr">node</span>: rss / sysTotal,         <span class="hljs-comment">// Node占用系统内存的比例</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>rss：表示node进程占用的内存总量。</li><li>heapTotal：表示堆内存的总量。</li><li>heapUsed：实际堆内存的使用量。</li><li>external ：外部程序的内存使用量，包含Node核心的C++程序的内存使用量</li></ul><p>在<code>Node</code>中，一个进程的最大内存容量为1.5GB。因此我们需要减少内存泄露</p><h3 id="磁盘-I-x2F-O"><a href="#磁盘-I-x2F-O" class="headerlink" title="磁盘 I&#x2F;O"></a>磁盘 I&#x2F;O</h3><p>硬盘的<code>IO</code> 开销是非常昂贵的，硬盘 IO 花费的 CPU 时钟周期是内存的 164000 倍</p><p>内存 <code>IO</code>比磁盘<code>IO</code> 快非常多，所以使用内存缓存数据是有效的优化方法。常用的工具如 <code>redis</code>、<code>memcached</code>等</p><p>并不是所有数据都需要缓存，访问频率高，生成代价比较高的才考虑是否缓存，也就是说影响你性能瓶颈的考虑去缓存，并且而且缓存还有缓存雪崩、缓存穿透等问题要解决</p><h3 id="如何进行监控？"><a href="#如何进行监控？" class="headerlink" title="如何进行监控？"></a>如何进行监控？</h3><p>关于性能方面的监控，一般情况都需要借助工具来实现</p><p>这里采用<code>Easy-Monitor 2.0</code>，其是轻量级的 <code>Node.js</code> 项目内核性能监控 + 分析工具，在默认模式下，只需要在项目入口文件 <code>require</code> 一次，无需改动任何业务代码即可开启内核级别的性能监控分析</p><p>使用方法如下：</p><p>在你的项目入口文件中按照如下方式引入，当然请传入你的项目名称：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> easyMonitor = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;easy-monitor&#x27;</span>);<br><span class="hljs-title function_">easyMonitor</span>(<span class="hljs-string">&#x27;你的项目名称&#x27;</span>);<br></code></pre></td></tr></table></figure><p>打开浏览器，访问 <code>http://localhost:12333</code> ，即可看到进程界面</p><p>关于定制化开发、通用配置项以及如何动态更新配置项详见官方文档</p><h2 id="如何进行优化？"><a href="#如何进行优化？" class="headerlink" title="如何进行优化？"></a>如何进行优化？</h2><p>关于<code>Node</code>的性能优化的方式有：</p><ul><li>使用最新版本Node.js</li><li>正确使用流 Stream</li><li>代码层面优化</li><li>内存管理优化</li></ul><h2 id="JS中定义函数的function-fun-和var-fun-x3D-function-两种方法有什么区别？"><a href="#JS中定义函数的function-fun-和var-fun-x3D-function-两种方法有什么区别？" class="headerlink" title="JS中定义函数的function fun(){}和var fun &#x3D; function(){}两种方法有什么区别？"></a>JS中定义函数的function fun(){}和var fun &#x3D; function(){}两种方法有什么区别？</h2><ol><li>变量提升的不同。使用function定义的函数会进行变量提升，可以在函数声明之前调用；而使用var定义的函数表达式不会进行变量提升，只有函数表达式赋值后才能调用。</li><li>函数作用域的不同。使用function定义的函数会创建一个自己的作用域，函数内定义的变量和参数只在函数内部可见；而使用var定义函数的函数表达式和其他变量一样，也是定义在当前作用域中。</li><li>函数的可读性不同。使用function定义的函数可读性更强，函数名在定义时就已经存在；而使用var定义的函数表达式需要赋值后才能使用变量名调用，可读性稍差。</li><li>函数的修改和删除不同。使用function定义的函数可以通过重复定义来修改或者重新定义来删除；而使用var定义的函数表达式无法被修改或删除。</li></ol><p>需要注意的是，如果使用var定义函数表达式，因为var会进行变量提升，所以如果在赋值之前调用函数，则该函数值为undefined，而不是一个函数。建议在声明函数表达式时使用let或const来避免这种情况。</p>]]></content>
    
    
    
    <tags>
      
      <tag>NodeJS</tag>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识点整理(8)</title>
    <link href="/2023/04/14/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-8/"/>
    <url>/2023/04/14/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-8/</url>
    
    <content type="html"><![CDATA[<h1 id="知识点整理-8"><a href="#知识点整理-8" class="headerlink" title="知识点整理(8)"></a>知识点整理(8)</h1><h2 id="匿名通信与命名通信的区别？"><a href="#匿名通信与命名通信的区别？" class="headerlink" title="匿名通信与命名通信的区别？"></a>匿名通信与命名通信的区别？</h2><p>匿名通信和命名通信是通信方式的不同方式。匿名通信是发送者和接收者都是匿名的方式，不会透露身份信息，保护隐私和安全。而命名通信是使用实名或者昵称方式进行通信，对身份信息没有保护作用。</p><p>具体区别如下：</p><ol><li><p>匿名通信只能是据有血缘关系的进程之间进行通信，只能半双工通信；命名通信可以在任意两个进程之间进行通讯，可以全双工通信，命名管道提供了一个路径名与之关联，以FIFO文件的形式存储于文件系统中，能够实现任意两个进程之间通信。</p></li><li><p>匿名通信只需要发送者和接收者拥有匿名身份，通信过程中不需要透露身份信息，保护隐私和安全。而命名通信需要使用实名或昵称等方式进行通信，会透露身份信息。</p></li><li><p>匿名通信可以避免被窃听、篡改、攻击等威胁，因为使用匿名身份进行通信。命名通信可能容易被攻击者获取身份信息进行攻击。</p></li><li><p>匿名通信的验证和监管比较困难，因为发送者和接收者都是匿名的。命名通信可以更容易地监管和验证通信过程。</p></li><li><p>匿名通信常常被用在各种机密通信、点对点通信和加密通信中。命名通信通常是为了建立信任关系和社交沟通而使用的。</p></li></ol><h2 id="硬链接和软链接的区别？"><a href="#硬链接和软链接的区别？" class="headerlink" title="硬链接和软链接的区别？"></a>硬链接和软链接的区别？</h2><ul><li>硬链接指向一个inode节点，可以跨目录，但是不能跨文件系统</li><li>软链接存放另一个文件的路径的形式存在，可以跨文件，但是不能跨分区。</li></ul><h2 id="WebWorker和WebSocket？"><a href="#WebWorker和WebSocket？" class="headerlink" title="WebWorker和WebSocket？"></a>WebWorker和WebSocket？</h2><p>WebWorker：WebWorker是HTML5提供的一种JavaScript多线程解决方案，它可以让JavaScript脚本<br>在后台运行，从而避免阻塞UI线程。WebWorker可以创建一个独立的线程来执行JavaScript代码，这<br>样就可以在主线程之外执行一些耗时的操作，比如计算密集型任务、大量数据的排序、图像处理等。</p><p>WebSocket：WebSocket是HTML5提供的一种新协议，它可以在客户端和服务器之间建立一个持久性<br>的连接，从而实现双向通信。WebSocket协议可以让服务器主动向客户端推送数据，而不需要客户端<br>发起请求。Websocket协议通常用于实时通信、在线游戏、在线聊天等场景。</p><h2 id="浏览器中多个tab页面如何进行通信？"><a href="#浏览器中多个tab页面如何进行通信？" class="headerlink" title="浏览器中多个tab页面如何进行通信？"></a>浏览器中多个tab页面如何进行通信？</h2><p>在浏览器中，多个tab页面之间可以通过以下方式进行通信：</p><ol><li>LocalStorage：可以使用LocalStorage在多个tab页面之间共享数据。LocalStorage是一种本地存储机制，可以在浏览器中存储少量数据，并且可以跨tab页面进行访问和修改数据。</li><li>PostMessage API：PostMessage API是一种浏览器内部传输消息的机制。可以使用PostMessage API向其他tab页面发送消息，并接收来自其他tab页面的消息。可以用它来实现跨域通信。</li><li>SharedWorker：SharedWorker是HTML5新增的一种Web Worker，可以在多个tab之间共享数据和通信。SharedWorker是一个独立的线程，可以在多个URL和窗口之间共享。从而实现多个页面之间的通信。</li><li>BroadcastChannel API：BroadcastChannel API是HTML5新增的一种跨页面通信的机制。可以在不同的页面之间广播消息，并监听接收来自其他页面的消息。</li></ol><h2 id="cookie的特点？"><a href="#cookie的特点？" class="headerlink" title="cookie的特点？"></a>cookie的特点？</h2><p>Cookie是一种存储在客户端的小型文本文件，由一个名称、一个值和其他几个用于控制Cookie有效期<br>安全性、使用范围的可选属性组成。Cookie的特点如下：</p><ul><li>存储位置: Cookie存储在浏览器里面。</li><li>存储大小: Cookie的大小在4KB左右，数量在50个左右。</li><li>存储时间: Cookie的存储时间非常灵活。</li><li>安全性: 通过加密和安全传输技术 (SSL) ，减少Cookie被破解的可能性。</li></ul><h2 id="cookie有哪些属性？"><a href="#cookie有哪些属性？" class="headerlink" title="cookie有哪些属性？"></a>cookie有哪些属性？</h2><ul><li>Name: cookie的名称。</li><li>Value: cookie的值。</li><li>Domain: cookie所属的域名</li><li>Path: cookie所属的路径。</li><li>Expires&#x2F;Max-age: cookie的过期时间或存活时间。</li><li>Size: cookie的大小。</li><li>HttpOnly: 设置为true，表示只能通过HTTP或HTTPS访问，不能通过JavaScript访问。</li><li>Secure: 设置为true，表示只能通过HTTPS访问。</li><li>SameSite: 设置为Strict，表示浏览器不会在跨站点请求中发送Cookie；设置为Lax，表示浏览器只会在第三方站点的GET请求中发送Cookie；设置为None，表示浏览器会在所有跨站点请求中发送Cookie。</li><li>Priority: 设置为High，表示浏览器会优先发送该Cookie。</li></ul><h2 id="cookie和session的区别？"><a href="#cookie和session的区别？" class="headerlink" title="cookie和session的区别？"></a>cookie和session的区别？</h2><ul><li>Cookie数据存放在客户的浏览器上，session数据放在服务器上。</li><li>Cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，如果主要考虑到安全应当使用Session。</li><li>Session会在一定时间内保存在服务器上。</li><li>Cookie会在一定时间内保存在客户端上。</li><li>Session可以存储任何类型的对象，而Cookie只能存储字符串类型的数据.</li><li>Session依赖于Cookie，即Session ID存储在Cookie中。</li></ul><h2 id="CSS单行多行文本溢出省略？"><a href="#CSS单行多行文本溢出省略？" class="headerlink" title="CSS单行多行文本溢出省略？"></a>CSS单行多行文本溢出省略？</h2><p>单行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#box</span> &#123;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-attribute">text-overflow</span>: ellipsis;<br>    white-wrap: no-wrap;<br>&#125;<br></code></pre></td></tr></table></figure><p>多行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#box</span> &#123;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br><span class="hljs-attribute">text-overflow</span>: ellipsis;<br>    <span class="hljs-attribute">display</span>: -webkit-box;<br>    -webkit-box-orient: vertical;<br>    -webkit-line-clamp: <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="如何实现函数的柯里化-长度不限-？"><a href="#如何实现函数的柯里化-长度不限-？" class="headerlink" title="如何实现函数的柯里化(长度不限)？"></a>如何实现函数的柯里化(长度不限)？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeToCurry</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> args = [...<span class="hljs-variable language_">arguments</span>]; <span class="hljs-comment">// 获取传入的所有参数</span><br>        <span class="hljs-keyword">if</span>(args.<span class="hljs-property">length</span> === fn.<span class="hljs-property">length</span>) &#123; <span class="hljs-comment">// 参数符合fn参数数量</span><br>            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args); <span class="hljs-comment">// 执行函数</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">newFn</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 返回一个函数</span><br>                <span class="hljs-keyword">const</span> newArgs = [...<span class="hljs-variable language_">arguments</span>]; <span class="hljs-comment">// 获取再传入的参数</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_">changeToCurry</span>(...[...args, ...newArgs]); <span class="hljs-comment">// 执行柯里化函数</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Symbol-for和Sumbol-keyFor的区别？"><a href="#Symbol-for和Sumbol-keyFor的区别？" class="headerlink" title="Symbol.for和Sumbol.keyFor的区别？"></a>Symbol.for和Sumbol.keyFor的区别？</h2><p>Symbol.for方法接受一个字符串参数，如果全局没有以该参数作为名称的Symbol值，则会创建一个新的Symbol值并注册到全局Symbol注册表中，返回该Symbol值。如果全局已经有该名称的Symbol值，则直接返回该Symbol值。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1 === s2); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>Symbol.keyFor方法用于获取Symbol注册表中与某个Symbol值关联的键名。只能用于全局环境，即在同一个realm的不同Script运行时返回相同的结果。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(s1)); <span class="hljs-comment">// foo</span><br><br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(s2)); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>需要注意的是，Symbol.for创建的Symbol值会被注册到全局注册表中，如果不小心使用了相同的名称，则容易冲突，可能会造成潜在的问题。因此，建议只在确实需要在不同的模块或Script之间共享Symbol值时使用Symbol.for方法。</p><h2 id="JS手写构造一个Biglnt类型数据的函数？"><a href="#JS手写构造一个Biglnt类型数据的函数？" class="headerlink" title="JS手写构造一个Biglnt类型数据的函数？"></a>JS手写构造一个Biglnt类型数据的函数？</h2><p>函数接受一个整数参数，并把它存储为一个持有每个数字位的数组（digits）。 具体步骤描述： 1、通过sign变量存储参数value的符号。 2、通过while循环将参数value从右往左拆分为独立的数字，存储在digits数组中。 3、构建BigInt对象的prototype，在其原型中实现两个方法：valueOf返回BigInt对象的数值，toString返回BigInt对象的字符串表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">BigInt</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">var</span> digits = [];<br>    <span class="hljs-keyword">var</span> sign = value &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>    value = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(value);<br>    <br>    <span class="hljs-keyword">while</span> (value &gt; <span class="hljs-number">0</span>) &#123;<br>        digits.<span class="hljs-title function_">push</span>(value % <span class="hljs-number">10</span>);<br>        value = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(value / <span class="hljs-number">10</span>);<br>    &#125;<br>    <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">digits</span> = digits;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sign</span> = sign;<br>&#125;<br><br><span class="hljs-title class_">BigInt</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">valueOf</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> value = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">digits</span>.<span class="hljs-property">length</span>; i++) &#123;<br>        value += <span class="hljs-variable language_">this</span>.<span class="hljs-property">digits</span>[i] * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">10</span>, i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">sign</span> * value;<br>&#125;<br><br><span class="hljs-title class_">BigInt</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">digits</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        str += <span class="hljs-variable language_">this</span>.<span class="hljs-property">digits</span>[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">sign</span> == -<span class="hljs-number">1</span> ? <span class="hljs-string">&quot;-&quot;</span> : <span class="hljs-string">&quot;&quot;</span>) + str;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浏览器开发者工具栏各有什么作用？"><a href="#浏览器开发者工具栏各有什么作用？" class="headerlink" title="浏览器开发者工具栏各有什么作用？"></a>浏览器开发者工具栏各有什么作用？</h2><ol><li><p>Element（元素检查器）：允许开发者查看和编辑HTML、CSS和JavaScript代码。可以通过该工具通过单击页面上的元素并查看其代码来快速识别网页上的问题。</p></li><li><p>Console（控制台）：可以在此执行 JavaScript 代码并查看控制台输出，可用于调试和诊断问题。</p></li><li><p>Sources（源代码）：可以在此查看网页源代码、调试 JavaScript 代码以及断点调试等。</p></li><li><p>Network（网络）：可以在此查看网页请求和响应的详细信息，包括请求和响应头、请求和响应体等。</p></li><li><p>Performance（性能）：可以在此分析页面性能和加载时间，包括页面渲染、资源加载、事件响应等方面的数据分析。</p></li><li><p>Application（应用）：可以在此查看网页使用的本地存储，包括 Cookies、LocalStorage、SessionStorage 等。</p></li><li><p>Security（安全）：可以在此查看网页的安全信息，包括 SSL&#x2F;TLS 连接情况、证书信息等。</p></li><li><p>Audits（审计）：可以在此对网页进行审计和分析，查找并修复性能问题、移动端适配问题、SEO 优化问题等。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>前端总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>携程二面</title>
    <link href="/2023/04/13/%E6%90%BA%E7%A8%8B%E4%BA%8C%E9%9D%A2/"/>
    <url>/2023/04/13/%E6%90%BA%E7%A8%8B%E4%BA%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="携程二面"><a href="#携程二面" class="headerlink" title="携程二面"></a>携程二面</h1><h2 id="学习前端知识的流程？"><a href="#学习前端知识的流程？" class="headerlink" title="学习前端知识的流程？"></a>学习前端知识的流程？</h2><h2 id="React-Hooks是怎样实现的？"><a href="#React-Hooks是怎样实现的？" class="headerlink" title="React Hooks是怎样实现的？"></a>React Hooks是怎样实现的？</h2><p>React Hooks 是 React 在函数式组件中引入状态、副作用和其他特性的重要手段。它的实现原理是通过使用闭包和一些 React 中的核心函数来实现的，对于理解 React 的函数式编程思想非常有帮助。</p><h2 id="类组件和函数组件在渲染和性能方面有什么区别？"><a href="#类组件和函数组件在渲染和性能方面有什么区别？" class="headerlink" title="类组件和函数组件在渲染和性能方面有什么区别？"></a>类组件和函数组件在渲染和性能方面有什么区别？</h2><p><strong>渲染方式</strong></p><p>类组件使用 <code>render()</code> 方法来渲染 DOM，需要继承自 <code>React.Component</code> 或 <code>React.PureComponent</code>，并且需要实现一些必要的生命周期方法。</p><p>函数组件是一个简单的 JavaScript 函数，通过返回一个 JSX 元素来表示要渲染的 DOM，不需要继承任何类或实现生命周期方法。</p><p><strong>渲染性能</strong></p><p>由于类组件存在生命周期方法和状态，每次渲染都需要进行完整的生命周期流程，从而使得渲染性能较低。</p><p>函数组件由于不需要进行生命周期的处理和状态的维护，每次渲染只需要简单地执行函数体，从而使得渲染性能较高。此外，React 还引入了 Hooks，使得函数组件在处理状态和副作用时可以与类组件一样方便。</p><p><strong>用法和场景</strong></p><p>类组件通常用于实现比较复杂的交互逻辑和组件状态。例如，当一个组件需要在生命周期中进行一些异步请求，或者需要在组件更新时进行一些状态同步时，类组件就比较合适。</p><p>函数组件通常用于实现简单的 UI 和逻辑，例如展示列表、根据数据渲染不同的组件等。此外，函数组件通常比较易于编写和维护，可以提高开发效率。</p><h2 id="函数组件如何模拟生命周期？"><a href="#函数组件如何模拟生命周期？" class="headerlink" title="函数组件如何模拟生命周期？"></a>函数组件如何模拟生命周期？</h2><h2 id="为什么选择用Node-js做服务端？"><a href="#为什么选择用Node-js做服务端？" class="headerlink" title="为什么选择用Node.js做服务端？"></a>为什么选择用Node.js做服务端？</h2><p><strong>快速</strong></p><p>Node.js 使用事件驱动和非阻塞I&#x2F;O模型，使得其非常适合处理高并发的请求。这使得响应速度非常快，可以在短时间内处理大量的请求。</p><p><strong>JavaScript</strong></p><p>由于 Node.js 是基于 JavaScript 构建的，因此前端开发者可以在服务端使用同一种语言进行开发，这样可以提高开发效率和便捷性。</p><p><strong>社区</strong></p><p>Node.js 有着庞大而活跃的社区，有许多库和工具可以使用，可以方便的解决常见的问题。</p><p><strong>可扩展性</strong></p><p>Node.js 具有很好的可扩展性，可以通过添加更多的进程和服务器来解决负载问题，同时也支持分布式处理。</p><p><strong>应用场景多样</strong></p><p>Node.js 可以被应用于各种场景，从简单的服务端渲染到实时应用、大规模数据操作等。同时也可以用于移动和桌面应用程序开发。</p><h2 id="Node-js相比Java等后端语言有什么特点？"><a href="#Node-js相比Java等后端语言有什么特点？" class="headerlink" title="Node.js相比Java等后端语言有什么特点？"></a>Node.js相比Java等后端语言有什么特点？</h2><ol><li><p>事件驱动和非阻塞 I&#x2F;O</p><p>Node.js 采用事件驱动和非阻塞 I&#x2F;O 的模式，因此能够处理大量的并发请求，并且响应速度更快。相比之下，Java 等后端语言的线程模型会产生更多的上下文切换和性能损失。</p></li><li><p>JavaScript</p><p>Node.js 使用 JavaScript 作为编程语言，前端开发者可以在服务端使用同一种语言进行开发，允许代码重用和简化学习曲线。</p></li><li><p>较小的模块和包管理器</p><p>Node.js 的模块和包管理器让开发人员可以轻松地共享和重用代码。相比之下，Java 的依赖管理可能相对更为复杂。</p></li><li><p>适合构建实时应用</p><p>Node.js 非常适合构建实时应用程序和基于事件的应用程序，如聊天应用、游戏、推送通知等。Java 等传统后端语言适合于处理更多的简单请求和数据处理。</p></li><li><p>跨平台</p><p>Node.js 是跨平台的，可以在多个操作系统上运行，包括 Windows、MacOS、Linux 等，对于开发人员来说更加方便。</p></li></ol><h2 id="长列表进行性能优化？可以通过哪些指标进行优化？【项目】"><a href="#长列表进行性能优化？可以通过哪些指标进行优化？【项目】" class="headerlink" title="长列表进行性能优化？可以通过哪些指标进行优化？【项目】"></a>长列表进行性能优化？可以通过哪些指标进行优化？【项目】</h2><ol><li>合理使用虚拟滚动和无限滚动等技术，减少 DOM 元素的数量和页面渲染的时间。</li><li>尽量减小每个列表项的渲染时间，如通过性能优化的 JavaScript 引擎、使用优化的 CSS 属性等方式来提高性能。</li><li>合理使用懒加载技术，延迟加载非必要的列表项。</li><li>对于大型的列表数据，可以使用分页或者增量加载方式，即每次只加载部分数据而不是一次性加载整个列表。</li><li>避免不必要的更新，在数据更新时，可以使用 shouldComponentUpdate 方法来优化更新，减少不必要的 DOM 操作。</li><li>对于复杂的列表项，可以使用 React 的 PureComponents，减少渲染时间。</li><li>对于列表中图片等资源，可以合理使用缓存技术，减少网络请求和提高加载速度。</li></ol><h2 id="首屏渲染时间过长可以从哪些方面进行排查？"><a href="#首屏渲染时间过长可以从哪些方面进行排查？" class="headerlink" title="首屏渲染时间过长可以从哪些方面进行排查？"></a>首屏渲染时间过长可以从哪些方面进行排查？</h2><ol><li>网络连接问题：检查网络连接是否稳定，网络质量是否良好。可以使用浏览器自带的开发者工具，查看资源加载情况，如请求时间、响应时间等。</li><li>页面文件大小：页面文件大小过大可能会导致页面渲染时间过长。可以使用浏览器自带的网络分析工具，找出页面中容量较大的文件，并对其进行优化压缩等处理。</li><li>缓存策略：正确的缓存策略可以有效减少页面加载时间，尽可能利用本地缓存和浏览器缓存避免重复请求。</li><li>图片优化：过多或过大的图片文件可能会拖慢页面加载速度。可以使用图片压缩工具、图片懒加载等方法减少页面中的图片数量和大小。</li><li>JavaScript 代码：JavaScript 代码可能会影响页面加载速度。可以使用代码压缩、代码分割等方法来减少代码大小和加载时间。</li><li>CSS 代码：复杂的 CSS 可能会影响页面加载速度。可以使用 CSS 压缩、提取公共 CSS 等方法来减少 CSS 文件大小。</li><li>服务器性能：服务器性能也可能影响页面加载速度。可以优化服务器配置、使用 CDN 加速等方法来提升页面加载速度。</li></ol><h2 id="有了解过服务端渲染吗？"><a href="#有了解过服务端渲染吗？" class="headerlink" title="有了解过服务端渲染吗？"></a>有了解过服务端渲染吗？</h2><p>服务端渲染（Server-Side Rendering，SSR）是指将应用的初始 HTML 从服务端生成并发送给浏览器，而不是在浏览器端使用 JavaScript 动态生成 HTML。在服务端渲染时，服务器会使用一些模板引擎或框架，将数据注入到 HTML 模板中，生成最终的 HTML 页面，然后将 HTML 页面发送给浏览器。</p><p>服务端渲染的优点在于：</p><ol><li>SEO 友好：由于搜索引擎可以直接抓取服务端渲染后的 HTML 页面，因此可以更好地处理搜索引擎优化（SEO）。</li><li>首屏渲染快：服务端渲染可以在浏览器接收到 HTML 页面之前快速呈现页面，提高首屏渲染速度。</li><li>更好的用户体验：由于用户不需要等待应用完全加载才能渲染内容，因此可以提供更好的用户体验。</li><li>更节省流量：由于初始 HTML 由服务器生成，而不是在客户端通过 JavaScript 生成，因此可以减少客户端的网络请求和流量。</li></ol><p>服务端渲染也有一些缺点，如需要更多的服务器资源和维护开销，不够灵活等，在使用时需要进行综合考量。</p><h2 id="电脑上有可以展示的项目吗？"><a href="#电脑上有可以展示的项目吗？" class="headerlink" title="电脑上有可以展示的项目吗？"></a>电脑上有可以展示的项目吗？</h2><h2 id="浏览器原生的发送请求的API有哪些？"><a href="#浏览器原生的发送请求的API有哪些？" class="headerlink" title="浏览器原生的发送请求的API有哪些？"></a>浏览器原生的发送请求的API有哪些？</h2><ol><li>XMLHttpRequest：XMLHttpRequest 是一个浏览器原生提供的对象，用于在后台与服务器交换数据。它可以在不重新加载页面的情况下更新页面的局部内容。XMLHttpRequest 支持各种类型的请求，比如 GET、POST、PUT、DELETE 等。</li><li>Fetch API：Fetch API 是一组与浏览器原生 Fetch 函数配合使用的接口，可以提供一种相对简单、可跨域的方式来获取资源。它是基于 Promise 对象设计的，使用更加优雅，可以同时发出多个请求。</li><li>WebSocket API：WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。利用它可以实现双向通信，许多在线游戏、实时性聊天应用和股票交易应用都使用它。</li><li>Server-Sent Events（SSE）API：SSE API 允许服务器定期发送数据到客户端，它与 WebSocket API 不同，在 WebSocket 中，无论何时客户端和服务器之间有数据要发送，连接都是由客户端初始化的，而 SSE 是由服务器端初始化的，客户端只需要打开 SSE 连接，并等待服务器发送数据。</li><li>WebRTC：WebRTC 是一种浏览器中的实时通信技术，它支持浏览器间的视频和音频流的传输，也支持 P2P 数据传输。WebRTC 利用多种功能，包括网络摄像头、麦克风、数据通道等，让浏览器更加智能。</li></ol><h2 id="Fetch和Ajax的区别？"><a href="#Fetch和Ajax的区别？" class="headerlink" title="Fetch和Ajax的区别？"></a>Fetch和Ajax的区别？</h2><ol><li>API 设计：Ajax 使用 XMLHttpRequest 对象来发送和接收数据，而 Fetch 则使用更加现代化的 Promise API，使得数据请求和处理更加优雅。</li><li>数据格式：Ajax 可以处理多种格式的数据，例如 JSON、XML、HTML 和文本等，而 Fetch 仅支持 JSON 和 Blob。</li><li>缓存：在缓存方面，Ajax 可以通过设置缓存时间和缓存位置来进行缓存管理，而 Fetch 则默认不缓存响应。</li><li>跨域支持：在处理跨域请求方面，Fetch API 内置支持 CORS，可以更加轻松地处理跨域请求，而在使用 Ajax 发送跨域请求时需要进行特殊的设置。</li><li>扩展性：虽然 Ajax 可以通过添加插件来扩展其功能，但 Fetch 的 API 设计更加简单、直接，易于扩展和使用。</li></ol><h2 id="项目中主要是如何发送请求的？"><a href="#项目中主要是如何发送请求的？" class="headerlink" title="项目中主要是如何发送请求的？"></a>项目中主要是如何发送请求的？</h2><p>axios</p><h2 id="状态码除了200还有哪些？"><a href="#状态码除了200还有哪些？" class="headerlink" title="状态码除了200还有哪些？"></a>状态码除了200还有哪些？</h2><p>1xx 接收到请求并继续(不常见)</p><p>2xx 请求成功</p><p> 200 请求成功</p><p> 204 请求已处理但是没有返回内容</p><p> 206 客户端进行了范围请求，服务器端执行了这部分GET请求，响应报文中包含由Content-Range指定范围的实体内容</p><p>3xx 重定向状态码</p><p> 301 永久重定向</p><p> 302 临时重定向</p><p> 303 所请求的资源存在另一个URI，应使用GET方法定向获取请求资源</p><p> 304 缓存中有需要的数据，无须进行请求</p><p> 307 临时重定向，不会从POST变成GET</p><p>4xx 客户端错误</p><p> 400 请求报文存在语法错误</p><p> 401 请求须通过HTTP认证</p><p> 403 请求资源被服务器拒绝</p><p> 404 找不到资源</p><p> 405 方法被识别但禁止使用</p><p>5xx 服务器端发生错误</p><p> 500 服务器端在执行请求时发生错误</p><p> 502 服务器接收到的响应无效</p><p> 503 服务器暂时超负载or停机维护</p><p> 504 超时</p><h2 id="Chrome开发者工具中Elements主要用来做什么？"><a href="#Chrome开发者工具中Elements主要用来做什么？" class="headerlink" title="Chrome开发者工具中Elements主要用来做什么？"></a>Chrome开发者工具中Elements主要用来做什么？</h2><p>Chrome开发者工具中Elements主要用来查看和编辑网页的DOM结构和样式。具体的使用如下：</p><ol><li>查看DOM结构：在Elements面板中，可以看到网页中所有的HTML元素及其嵌套关系。可以通过点击元素来快速定位到特定的元素，并查看其属性值、样式、事件等信息。</li><li>编辑DOM结构：在Elements面板中，可以直接编辑网页的HTML和CSS代码，实时预览编辑结果。可添加、删除、修改网页中的元素和样式，便于前端开发和调试。</li><li>查看计算样式：在Elements面板中，可以查看指定元素的样式属性及其来源。还可以查看元素的盒模型大小、外边距、内边距等信息，方便排版和布局。</li><li>调试JavaScript：在Elements面板中，可以调试JavaScript代码。可以在控制台中输入命令、设置断点，查看变量、堆栈、网络请求等信息。</li></ol><h2 id="Chrome开发者工具中Sources的作用？如何调试代码？"><a href="#Chrome开发者工具中Sources的作用？如何调试代码？" class="headerlink" title="Chrome开发者工具中Sources的作用？如何调试代码？"></a>Chrome开发者工具中Sources的作用？如何调试代码？</h2><p>Chrome开发者工具中Sources主要用于调试JavaScript代码和查看相关资源，具体的作用有：</p><ol><li>查看页面中的JavaScript文件：在Sources面板中，可以查看当前页面中加载的JavaScript文件，包括内联、外链文件和异步加载文件等。</li><li>编辑和调试JavaScript代码：在Sources面板中，可以直接在浏览器中编辑JavaScript代码，并实时预览效果。还可以设置断点、单步调试、查看变量、堆栈、网络请求等信息，帮助开发人员快速定位和解决代码错误。</li><li>查看网页的CSS和资源：在Sources中，还可以查看网页的CSS样式及其相关资源，例如图片、字体、音频、视频等等。</li></ol><p>调试代码的步骤如下：</p><ol><li>打开Chrome浏览器，在需要调试的页面上右键选择“检查”或快捷键“ctrl + shift + I”打开开发者工具。</li><li>在Sources面板中选择需要调试的JavaScript文件，点击行号左边的标记来设置断点。</li><li>执行页面操作，例如点击按钮、输入内容等等，查看代码执行过程中的变量值、堆栈等信息。</li><li>在Console中输入指令，例如console.log()打印变量信息。</li><li>如果需要单步调试，可以点击面板上的“单步执行”按钮，一步一步执行代码。</li></ol><h2 id="Chrome开发者工具中NetWorks中一般会关注哪些东西？"><a href="#Chrome开发者工具中NetWorks中一般会关注哪些东西？" class="headerlink" title="Chrome开发者工具中NetWorks中一般会关注哪些东西？"></a>Chrome开发者工具中NetWorks中一般会关注哪些东西？</h2><p>在Chrome开发者工具中，NetWork面板主要用于<strong>分析和监控网站的网络请求</strong>。一般需要关注以下几个方面：</p><ol><li>请求类型：网络请求分为GET、POST、PUT、DELETE等，需要关注请求类型是否正确。</li><li>请求的URL和状态码：查看请求的URL和状态码，可以获取请求是否成功以及返回的内容。</li><li>请求和响应的头信息：请求和响应的头信息中包含了很多重要的信息，例如Cookie、User-Agent、Referer、Cache-Control等等。</li><li>请求和响应的内容：在NetWork面板中，可以通过点击请求和响应的内容查看详细信息，例如请求和响应的参数、JSON数据、HTML代码等等。</li><li>请求和响应时间：了解请求和响应时间可以帮助我们优化网站的性能。</li><li>缓存信息：在NetWork面板中可以查看是否启用了缓存，并了解缓存的过期时间等。</li><li>XHR请求：如果网站使用了XHR请求，可以通过NetWork面板中的XHR过滤器查看和分析这些请求。</li></ol><h2 id="Chrome开发者工具中Performance的作用？"><a href="#Chrome开发者工具中Performance的作用？" class="headerlink" title="Chrome开发者工具中Performance的作用？"></a>Chrome开发者工具中Performance的作用？</h2><p>Chrome开发者工具中的Performance（性能）标签页可以用于分析网页的性能问题，包括CPU占用、网络请求、JavaScript执行等方面。其主要作用如下：</p><ol><li>分析加载时间：可以使用Performance标签页来分析网页的加载时间，找出网页加载过程中的瓶颈，优化网页的性能表现。</li><li>分析性能问题：性能标签页中提供了CPU和内存使用率、网络传输、JavaScript执行和渲染等方面的数据，可以帮助开发者发现性能问题。</li><li>记录用户交互：Performance标签页可以记录用户的操作和交互行为，开发者可以借此了解用户体验，优化网站设计。</li><li>模拟设备模式：Performance标签页中提供模拟设备模式，可以模拟不同设备下的网站运行情况，帮助开发者优化响应式设计。</li></ol><h2 id="Chrome开发者工具中Application中主要管理的是什么样的工作？"><a href="#Chrome开发者工具中Application中主要管理的是什么样的工作？" class="headerlink" title="Chrome开发者工具中Application中主要管理的是什么样的工作？"></a>Chrome开发者工具中Application中主要管理的是什么样的工作？</h2><p>Chrome开发者工具中的Application（应用程序）标签页主要管理网页应用程序的缓存、存储、数据库、Service Worker等内容。其主要功能如下：</p><ol><li>缓存管理：Application标签页中可以查看网页应用程序的缓存资源，包括HTTP缓存、Service Worker缓存等，并可以手动清除缓存。</li><li>存储管理：可以查看网页应用程序使用的本地存储（localStorage、sessionStorage）等方式，也可以在此处清除这些数据。</li><li>数据库管理：可以查看网页应用程序使用的Web SQL和IndexedDB数据库，并且可以在此处查看、修改、删除数据库中的数据。</li><li>Service Worker管理：可以注册和注销Service Worker，查看当前Service Worker的状态，并手动刷新缓存等。</li></ol><p>通过使用Application标签页，开发者可以更好地管理和调试网页应用程序的缓存、存储、数据库和Service Worker等内容，提高开发效率和用户体验。</p><h2 id="Application-Service-Workers是用来做什么的？"><a href="#Application-Service-Workers是用来做什么的？" class="headerlink" title="Application Service Workers是用来做什么的？"></a>Application Service Workers是用来做什么的？</h2><p>Chrome开发者工具中的Application Service Workers选项是用来查看和调试网页应用程序中的Service Workers的。</p><p>通过该选项，可以查看当前网页应用程序所使用的Service Workers，包括其版本，以及缓存的资源和数据。此外，还可以手动更新和刷新Service Workers，以确保网页应用程序始终使用最新的版本。还可以改变Service Workers的状态，来测试网页应用程序在不同状态下的行为，例如离线模式、在线模式、更新中等等。</p><p>在开发网页应用程序时，Service Workers可以提供许多便利的工具和功能。使用Chrome开发者工具中的Application Service Workers选项，开发人员可以快速地调试和测试Service Workers，并优化网页应用程序的性能和体验。</p><p>Application Service Workers是一种浏览器特性，用于在后台运行脚本，以提供离线体验、消息推送和更高性能等功能。与传统的JavaScript脚本不同，Service Workers运行在单独的线程中，不会因为页面加载或关闭而终止，可以在多个页面或应用程序之间共享状态和资源。</p><p>Service Workers可以缓存应用程序的资源（如HTML、CSS、JavaScript、图像和API响应等），使应用程序能够在没有网络连接的情况下仍能够正常运行。当应用程序需要更新或升级资源时，Service Workers会自动更新缓存中的内容，以确保应用程序保持最新的版本。</p><p>此外，Service Workers还可以推送消息通知，以提供更好的用户体验。例如，当应用程序的新内容可用时，Service Workers可以发送消息通知给用户，以便用户及时查看内容。</p><p>总之，Application Service Workers是一种强大的浏览器特性，能够为网页应用程序提供离线、推送和更高性能等功能，在现代网页应用程序的开发中起着越来越重要的作用。</p><h2 id="前端项目工程初始化，package-json文件主要是什么样的作用？"><a href="#前端项目工程初始化，package-json文件主要是什么样的作用？" class="headerlink" title="前端项目工程初始化，package.json文件主要是什么样的作用？"></a>前端项目工程初始化，package.json文件主要是什么样的作用？</h2><ol><li>管理项目依赖：在package.json文件中，可以定义项目所需要的依赖包及其版本号，以便管理和安装项目所需的npm包。</li><li>配置项目：在package.json文件中还可以定义项目的一些基本配置信息，如项目名称、版本号、作者、许可证等，也可以定义脚本命令，例如：启动项目、打包构建等等。</li><li>版本控制：package.json中还包含了项目的版本信息，可以在版本升级或更新时及时更新版本信息。</li><li>社区交流：在开源社区中，人们可以通过查看项目的package.json文件快速了解项目的基本信息和相关依赖，从而更好地参与到项目的开发、交流与协作中。</li></ol><h2 id="dependencies和DevDependencies的区别？"><a href="#dependencies和DevDependencies的区别？" class="headerlink" title="dependencies和DevDependencies的区别？"></a>dependencies和DevDependencies的区别？</h2><p>devDependencies是项目生产环境中所依赖的工具包</p><p>dependencies是项目正常运行时所依赖的工具包</p><ol><li>dependencies是指项目运行时必须要依赖的包，例如React、Vue、jQuery等等，这些包是直接影响到项目的运行，因此一定要安装并引入它们才能使项目正常运行。</li><li>DevDependencies是指开发过程中需要依赖的包，例如Babel、Webpack等等，这些包通常用于打包构建代码、测试、格式化等开发环境中的工作，它们不会直接影响到项目的运行，只是在开发过程中需要用到它们进行开发。</li><li>在npm install命令中，如果不指定参数，则会同时安装dependencies和DevDependencies中的所有包，如果只想安装dependencies中的包，可以使用npm install –production参数。</li></ol><h2 id="在项目的什么环节二者会出现差异？"><a href="#在项目的什么环节二者会出现差异？" class="headerlink" title="在项目的什么环节二者会出现差异？"></a>在项目的什么环节二者会出现差异？</h2><p>在项目开发过程中dependencies和DevDependencies可能会出现差异。在开发项目时，需要依赖各种开发工具和测试框架来进行代码编写和测试。这些工具和框架通常作为开发人员的开发环境，它们的作用是协助开发人员进行代码编写和测试，但是在项目运行时并不需要它们。</p><p>当开发人员将项目发布到生产环境中时，只需要安装dependencies中的依赖即可。而DevDependencies中的依赖包只需要在开发和测试过程中使用，发布时可以不安装它们。</p><p>因此，在开发一个项目时，我们需要清楚的区分哪些依赖包是生产环境必需的，哪些是开发环境必需的。这样可以减小项目的体积，并减少不必要的依赖。</p><h2 id="dependencies的依赖中，版本号中的-代表什么含义？"><a href="#dependencies的依赖中，版本号中的-代表什么含义？" class="headerlink" title="dependencies的依赖中，版本号中的^代表什么含义？"></a>dependencies的依赖中，版本号中的<code>^</code>代表什么含义？</h2><p>在package.json文件中，^符号代表允许自动更新的版本号，即只要版本号的最左边的非零数字不变，就允许自动更新版本号。例如，^16.8.0表示允许更新到16.x.x的任何版本，但不允许更新到17.x.x及以上的版本。这意味着只有当React的主要版本号（即16）变化时，才需要手动更新项目中的React版本号。</p><h2 id="了解TypeScript吗？"><a href="#了解TypeScript吗？" class="headerlink" title="了解TypeScript吗？"></a>了解TypeScript吗？</h2><h2 id="通过什么渠道了解前端新发展？"><a href="#通过什么渠道了解前端新发展？" class="headerlink" title="通过什么渠道了解前端新发展？"></a>通过什么渠道了解前端新发展？</h2><h2 id="页面和页面之间如何进行通信？"><a href="#页面和页面之间如何进行通信？" class="headerlink" title="页面和页面之间如何进行通信？"></a>页面和页面之间如何进行通信？</h2><ol><li>URL参数传递：通过URL的参数来传递数据，一般用于简单的数据传递，如跳转页面时带上一个ID或者其他参数。</li><li>LocalStorage：可以将数据存储在本地，然后在另外一个页面中通过读取LocalStorage来获得数据。</li><li>Cookies：也可以使用Cookie来传递数据，在另一个页面中读取Cookie来获得数据。</li><li>消息总线（Message Bus）：使用消息总线（Message Bus）来实现不同页面之间的通信，比如使用Vue.js框架中的vuex状态管理工具。</li><li>WebSocket： 使用WebSocket可以在多个页面之间建立长连接，实现实时通信。</li></ol><h3 id="不同域名下的页面进行通信？"><a href="#不同域名下的页面进行通信？" class="headerlink" title="不同域名下的页面进行通信？"></a>不同域名下的页面进行通信？</h3><ol><li><p>跨文档消息传输（Cross-document messaging）：通过JavaScript API从一个窗口向另一个窗口发送消息，使用postMessage方法。</p></li><li><p>JSONP：在页面中嵌入一个外部脚本文件，将数据封装在回调函数中，以JSONP格式传递。</p></li><li><p>服务器代理（Server proxy）：通过一个中间代理服务器，让服务器将请求发送至目标域名，在服务器端进行处理，返回结果。</p></li><li><p>iframe：利用iframe加载一个与目标域名下的页面通信的iframe，通过JavaScript API跨域访问iframe的内容。</p></li><li><p>WebSocket：一种支持浏览器和服务器间实时、双向通信的协议，可用于不同域名下的页面进行通信。</p></li></ol><h2 id="ES6常用的语法？"><a href="#ES6常用的语法？" class="headerlink" title="ES6常用的语法？"></a>ES6常用的语法？</h2>]]></content>
    
    
    
    <tags>
      
      <tag>前端|面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美团一面</title>
    <link href="/2023/04/13/%E7%BE%8E%E5%9B%A2%E4%B8%80%E9%9D%A2/"/>
    <url>/2023/04/13/%E7%BE%8E%E5%9B%A2%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="美团一面"><a href="#美团一面" class="headerlink" title="美团一面"></a>美团一面</h1><h2 id="项目中遇到过什么难点？"><a href="#项目中遇到过什么难点？" class="headerlink" title="项目中遇到过什么难点？"></a>项目中遇到过什么难点？</h2><h2 id="路由权限管理是如何实现的？"><a href="#路由权限管理是如何实现的？" class="headerlink" title="路由权限管理是如何实现的？"></a>路由权限管理是如何实现的？</h2><h2 id="权限是如何进行存储的？"><a href="#权限是如何进行存储的？" class="headerlink" title="权限是如何进行存储的？"></a>权限是如何进行存储的？</h2><h2 id="如何实现路由缓存的？原理？"><a href="#如何实现路由缓存的？原理？" class="headerlink" title="如何实现路由缓存的？原理？"></a>如何实现路由缓存的？原理？</h2><h2 id="TCP和UDP的区别？"><a href="#TCP和UDP的区别？" class="headerlink" title="TCP和UDP的区别？"></a>TCP和UDP的区别？</h2><ol><li>连接方式不同：TCP是面向连接的协议，需要在传输数据之前先建立连接；UDP是无连接的协议，直接发送数据包。</li><li>数据传输方式不同：TCP提供可靠的、面向字节流的数据传输，保证数据按照发送顺序到达目标；UDP则提供不可靠的、面向数据包的数据传输，数据包之间没有先后顺序之分，也不保证数据能到达目标。</li><li>可靠性不同：TCP在传输数据时提供可靠性保障，通过确认、重传、滑动窗口等机制保证数据的完整性和正确性；UDP则不提供可靠性保障，因此在传输数据时可能会丢失或重复。</li><li>传输效率不同：由于TCP提供较为复杂的可靠性保障机制，因此在传输效率方面相对较低；UDP则不提供可靠性保障机制，因此在传输效率方面较高。</li></ol><h2 id="TCP和UDP的应用场景？"><a href="#TCP和UDP的应用场景？" class="headerlink" title="TCP和UDP的应用场景？"></a>TCP和UDP的应用场景？</h2><p>TCP适用于数据量较大、传输时间较长、数据传输要求可靠性的应用场景，如<strong>文件传输，发送邮件等</strong>；而UDP适用于实时通信、网络广播等要求传输效率高、数据可靠性不高的应用场景，如<strong>视频通信，电话会议等</strong>。</p><h2 id="HTTP和HTTPS的区别？"><a href="#HTTP和HTTPS的区别？" class="headerlink" title="HTTP和HTTPS的区别？"></a>HTTP和HTTPS的区别？</h2><ol><li>安全性：HTTP协议传输的数据不加密，易受到黑客攻击和窃取；而HTTPS协议通过SSL&#x2F;TLS协议对传输的数据进行加密，提高了数据的安全性和防窃听能力。</li><li>端口号：HTTP协议使用的默认端口号是80，HTTPS协议使用的默认端口号是443。</li><li>速度：由于加密和解密过程的存在，HTTPS协议会比HTTP协议慢一些，尤其是在数据传输大文件时的速度会更明显。</li><li>SSL证书：在使用HTTPS协议时，需要经过SSL证书验证，确保访问的网站是真实的，而不是由黑客伪装的虚假网站。</li></ol><h2 id="HTTP2-0更新了哪些内容？"><a href="#HTTP2-0更新了哪些内容？" class="headerlink" title="HTTP2.0更新了哪些内容？"></a>HTTP2.0更新了哪些内容？</h2><ol><li>二进制格式：HTTP&#x2F;2在传输数据时采用二进制格式，而非HTTP&#x2F;1.x的文本格式，这使得解析和传输更加高效。</li><li>多路复用：HTTP&#x2F;2允许客户端和服务器之间同时保持多个请求和响应连接，这使得客户端可以发送多个请求，而无需等待每个响应，从而提高了数据传输的效率。</li><li>头部压缩：HTTP&#x2F;2使用HPACK算法对头部字段进行压缩，减少了头部发送的数据量，提高了传输速度。</li><li>服务器推送：HTTP&#x2F;2允许服务器在客户端请求之前发送额外的响应数据，从而可以提前获取客户端需要的资源并缓存起来，减少了客户端请求的次数和等待时间。</li><li>流量控制：HTTP&#x2F;2允许客户端和服务器之间进行流量控制，可以根据实际情况来分配网络带宽，以避免网络拥塞和延迟。</li></ol><h2 id="HTTP2-0头部压缩的比例是怎样的？"><a href="#HTTP2-0头部压缩的比例是怎样的？" class="headerlink" title="HTTP2.0头部压缩的比例是怎样的？"></a>HTTP2.0头部压缩的比例是怎样的？</h2><p>HTTP&#x2F;2使用HPACK算法进行头部压缩，可以将HTTP头部字段中的冗余数据删除，从而减少传输的数据量，提高传输速度。</p><p>具体来说，HTTP&#x2F;2的头部压缩可以做到80%~90%的压缩比率，这对移动网络等带宽有限的环境来说非常有利。因为HTTP头部中的很多字段是重复的，并且头部压缩只需要在建立连接时进行，减少了后续请求的数据量，同时还减少了数据传输过程中的网络阻塞。</p><p>此外，虽然HTTP&#x2F;2使用了头部压缩技术，在传输效率上得到了极大提高，但是在实际使用时，掌握合适的压缩策略非常重要，否则就会带来安全问题，比如攻击者通过伪造头部字段来欺骗服务器，破坏数据传输的完整性。</p><h2 id="HTTP3-0更新了哪些内容？"><a href="#HTTP3-0更新了哪些内容？" class="headerlink" title="HTTP3.0更新了哪些内容？"></a>HTTP3.0更新了哪些内容？</h2><ol><li>基于QUIC协议：HTTP&#x2F;3不再基于TCP协议，而是基于QUIC协议，这使得HTTP&#x2F;3具有更快的连接和数据传输速度。</li><li>握手和连接建立更快：因为QUIC协议支持0-RTT，在第一次连接时就能够建立连接，减少了握手时间。</li><li>不再需要头部压缩：HTTP&#x2F;3使用了QUIC协议中的“0-RTT”技术，避免了头部压缩带来的安全漏洞问题。</li><li>报文传输加密：HTTP&#x2F;3的报文传输默认使用加密，保护了数据安全性。</li><li>降低网络拥塞：HTTP&#x2F;3可以有效降低网络拥塞，因为它能够充分利用QUIC协议的拥塞控制算法。</li></ol><p>HTTP缓存？</p><ol><li><p>强缓存： 强缓存是指浏览器直接从本地缓存中读取资源，而不发送请求到服务器。强缓存可以通过设置响应头信息实现，如果缓存命中，则直接使用本地缓存，不会发送请求到服务器。常用的设置强缓存的HTTP响应头如下：</p><ul><li>Expires： 过期时间，是一个具体的时间点，在该时间点前可以直接从缓存中获取资源。</li></ul><ul><li>Cache-Control： 缓存控制，可以通过max-age指定时间段，在该时间段内可以直接从缓存中获取资源。</li></ul></li><li><p>协商缓存： 协商缓存是指浏览器会先发送请求到服务器，通过比较请求头信息和服务器端响应头的信息来判断是否需要重新获取资源。如果请求命中缓存，则服务器会返回304状态码，告诉浏览器可以使用缓存。协商缓存包括两种方式：</p><ul><li><p>Last-Modified&#x2F;If-Modified-Since：服务器返回资源最后一次修改的时间，在下一次请求时，客户端会发送If-Modified-Since请求头表示上一次获取资源的最后修改时间，服务器会判断时间是否有变化，如果没有变化则返回304状态码。</p></li><li><p>ETag&#x2F;If-None-Match：服务器返回资源的唯一标识，称作ETag，在下一次请求时，客户端会发送If-None-Match请求头，请求头内容为上一次获取资源的ETag，服务器会判断ETag是否匹配，如果匹配则返回304状态码。</p></li></ul></li></ol><h2 id="返回304状态码的时候响应体里的内容？"><a href="#返回304状态码的时候响应体里的内容？" class="headerlink" title="返回304状态码的时候响应体里的内容？"></a>返回304状态码的时候响应体里的内容？</h2><p>返回304状态码时，响应体是没有内容的，因为浏览器可以直接从本地缓存中获取资源。当请求命中缓存，且服务器判断资源没有更新时，就会返回304响应状态码，告知浏览器可以使用本地缓存，而不需要重新下载资源。此时服务器只需在响应头中包含<code>ETag</code>或<code>Last-Modified</code>等响应头字段，告诉浏览器缓存的版本信息。因此，304响应状态码不会包含响应体，只会包含响应头。</p><h2 id="命中本地强缓存的时候状态码是多少？"><a href="#命中本地强缓存的时候状态码是多少？" class="headerlink" title="命中本地强缓存的时候状态码是多少？"></a>命中本地强缓存的时候状态码是多少？</h2><p>当命中本地强缓存时，状态码是<strong>200 OK</strong>。因为浏览器直接从本地缓存中获取了资源，并且确认缓存未过期或者协商缓存未失效，因此服务器不需要再次返回资源，而是直接返回200状态码表示请求成功。此时响应头中会包含相应的缓存控制信息，例如<code>Cache-Control</code>、<code>Expires</code>等字段，用来告诉浏览器如何缓存该资源以及缓存有效期等信息。</p><h2 id="强缓存的资源存储在本地的什么位置？"><a href="#强缓存的资源存储在本地的什么位置？" class="headerlink" title="强缓存的资源存储在本地的什么位置？"></a>强缓存的资源存储在本地的什么位置？</h2><p>浏览器会将强缓存的资源存储在浏览器的缓存中，也就是本地磁盘或内存中。具体来说，对于不同类型的资源，浏览器对其的缓存位置可能有所不同：</p><ol><li>对于HTML文档，通常会被缓存到内存中，因为HTML文档相对较小，频繁的请求也不会导致内存占用过高。</li><li>对于CSS、JavaScript、图片等静态资源，则会被缓存到本地磁盘中，因为这些资源相对较大，频繁加载会占用大量内存，并且缓存在本地磁盘中可以加快下一次访问时的加载速度。</li></ol><p>但无论是缓存到内存还是本地磁盘中，浏览器都会根据缓存策略规则来管理缓存，并在缓存过期或失效时进行更新或重新加载。</p><h2 id="Etag里面的文本结构是怎样的？"><a href="#Etag里面的文本结构是怎样的？" class="headerlink" title="Etag里面的文本结构是怎样的？"></a>Etag里面的文本结构是怎样的？</h2><p>Etag（实体标记）是 HTTP 协议头中的一种机制，用于<strong>标识资源是否被修改过</strong>。Etag 的文本结构通常是<strong>一个由双引号包围的字符串</strong>，如下所示：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">ETag:</span> <span class="hljs-string">&quot;686897696a7c876b7e&quot;</span><br></code></pre></td></tr></table></figure><p><strong><code>ETag</code>没有指定生成值的方法。通常，使用内容的散列，最后修改时间戳的散列或仅修订版本号。</strong></p><p>实体标记通常是<strong>由服务器生成的标识符</strong>，而这个标识符可以根据服务器的算法和资源内容计算出来，只有当资源内容发生改变时，Etag 值才会发生变化。</p><p>当客户端请求同一资源时，客户端会向服务器发送 “If-None-Match” 的请求头，这个请求头包含上次请求获得的 Etag 值，如果服务器发现该资源的 Etag 值仍然匹配，则会返回 HTTP 304 Not Modified 状态码，告诉客户端可以直接使用缓存中的资源。如果 Etag 值不匹配，则服务器会返回新的资源给客户端。</p><p>因此 Etag 的作用是<strong>减少了无效的带宽消耗，增加了缓存的命中率</strong>。</p><h2 id="如果HTTP响应头中ETag值改变了，是否意味着文件内容一定已经更改？"><a href="#如果HTTP响应头中ETag值改变了，是否意味着文件内容一定已经更改？" class="headerlink" title="如果HTTP响应头中ETag值改变了，是否意味着文件内容一定已经更改？"></a>如果HTTP响应头中ETag值改变了，是否意味着文件内容一定已经更改？</h2><p>不一定。虽然 ETag 值是用于标识 HTTP 协议中一个特定的资源的版本号，但它不一定是由文件内容决定的，而是由服务器生成的。服务器可以采用不同的算法生成 ETag 值，例如将文件最后修改时间和文件大小作为参数来计算 ETag 值，而并没有考虑文件内容是否有变化。</p><p>因此，如果服务器端修改了 ETag 值，不一定意味着文件内容一定已经更改。在实际应用中，更准确的判断资源是否改变的方法是将 ETag 值与实际文件内容的哈希值比较。只有当 ETag 值与实际哈希值不一致时，才能判断文件内容发生了变更。</p><h2 id="进程通信方式有哪些？"><a href="#进程通信方式有哪些？" class="headerlink" title="进程通信方式有哪些？"></a>进程通信方式有哪些？</h2><ol><li>管道(Pipe)：管道是一种最基本的进程间通信方式，它是一段共享内存区域，一个进程想要往其中写入信息，另一个进程则从中读取信息。</li><li>命名管道(FIFO)：命名管道也是一种管道通信方式，但它是有名字的，可以实现不同进程的通信。</li><li>信号(Signal)：信号是一种异步通信方式，可以在不同进程之间传递信息。当一个进程向另一个进程发送一个信号时，操作系统会中断该进程的正常执行流程，转而处理信号。</li><li>消息队列(Message Queue)：消息队列是一种可存放在操作系统中的消息链表，进程可以将消息发送到队列中，另一个进程则可以从队列中读取消息。</li><li>共享内存(Shared Memory)：共享内存是一种映射到多个进程地址空间的内存区域，多个进程可以同时访问这个内存区域。</li><li>信号量(Semaphore)：信号量是一种计数器，用于同步进程和资源分配。</li><li>网络套接字(Socket)：套接字是一种网络通信方式，可以在不同计算机间传递信息。</li></ol><h2 id="进程共享内存通信具体是怎样实现的？"><a href="#进程共享内存通信具体是怎样实现的？" class="headerlink" title="进程共享内存通信具体是怎样实现的？"></a>进程共享内存通信具体是怎样实现的？</h2><ol><li>创建共享内存：需要调用操作系统提供的函数，例如shmget()，创建一个共享内存区域并返回一个共享内存标识符。</li><li>将共享内存附加到进程地址空间：使用shmat()函数将共享内存附加到进程的地址空间。该函数会返回一个指向共享内存区域的指针。这一步相当于将共享内存映射到进程的地址空间中。</li><li>进程间读写共享内存：多个进程可以直接通过指针操作共享内存区域进行数据的读写。需要注意的是，在读写数据时，需要通过信号量等机制进行进程同步，避免多个进程同时修改同一段内存区域，导致数据冲突。</li><li>分离共享内存：当进程不再需要使用共享内存时，需要调用shmdt()函数将它从进程地址空间中分离，这一步相当于解除共享内存和进程地址空间的映射关系。</li><li>删除共享内存：当所有使用该共享内存的进程都调用了shmdt()进行分离后，需要调用shmctl()函数删除共享内存。</li></ol><p>需要注意的是，在使用共享内存进行进程间通信时，需要保证多个进程对数据的读写操作是原子性的，避免出现数据冲突等问题。因此，通常使用信号量等同步机制进行进程间同步。</p><h2 id="共享内存通信的好处是什么？"><a href="#共享内存通信的好处是什么？" class="headerlink" title="共享内存通信的好处是什么？"></a>共享内存通信的好处是什么？</h2><ol><li>高效性：共享内存通信是一种高效的进程间通信机制。由于多个进程可以直接访问同一块物理内存，因此数据的传递速度很快，可以实现高速的数据交换。</li><li>灵活性：共享内存通信可以传递任意类型的数据，包括结构体、数组、指针等多种数据类型。而其他进程间通信机制（如管道、消息队列等）则往往需要数据进行序列化和反序列化，传递数据时需要额外的处理，增加了通信的复杂度。</li><li>容量大：共享内存通信可以很容易地传输大量的数据，因为共享内存区域的容量可以在创建时进行指定，从而满足不同应用的实际需求。</li><li>维护方便：共享内存通信的使用和管理比较简单，只需创建、附加、使用、分离和删除几个步骤，对于多进程间共享数据的应用场景，可以提供简单有效的通信方案。</li></ol><h2 id="为什么管道通信和消息队列通信会存在资源大小的限制？"><a href="#为什么管道通信和消息队列通信会存在资源大小的限制？" class="headerlink" title="为什么管道通信和消息队列通信会存在资源大小的限制？"></a>为什么管道通信和消息队列通信会存在资源大小的限制？</h2><p>管道通信和消息队列通信会存在资源大小的限制，主要是由于它们使用的内核缓冲区大小有限，而且这些内核缓冲区是由操作系统分配的。</p><p>具体来说，管道通信和消息队列通信使用的内核缓冲区大小是固定的，而且通常比较小（例如Linux中管道的缓冲区大小为4KB，消息队列缓冲区默认大小为16KB）。因此，当需要传输的数据量超过内核缓冲区大小时，就会出现资源大小的限制。这时，要么数据无法传输，要么就需要分多次传输或者使用其他进程间通信方式。</p><p>此外，由于管道和消息队列都是一种面向字节流的通信方式，因此在传输结构体、对象、数组等复杂的数据类型时，需要进行序列化和反序列化处理。这种处理会带来额外的开销和复杂性，进一步限制了通信的资源和效率。</p><p>综上所述，管道通信和消息队列通信存在资源大小的限制，这是因为它们使用的内核缓冲区大小有限，并且数据类型限制较多，不能很好地支持大数据量和复杂数据类型的通信。</p><h2 id="如果没有共享内存通信会导致什么问题？"><a href="#如果没有共享内存通信会导致什么问题？" class="headerlink" title="如果没有共享内存通信会导致什么问题？"></a>如果没有共享内存通信会导致什么问题？</h2><ol><li>低效率：使用进程间通信(IPC)方式进行数据交换消耗的时间和资源比较大。常用的IPC方式包括管道、消息队列、信号量等，这些方式都需要用到中间缓冲区、系统调用等，这些操作耗费了很多时间和系统资源。</li><li>程序设计复杂：采用IPC方式进行通信，需要对通信方式的技术细节进行了解和掌握，需要考虑数据格式、传输方式、同步方式、异常处理等问题，程序设计复杂度相对高。</li><li>难以建立复杂数据结构：使用IPC方式进行通信，不同进程需要采用不同的数据结构进行数据交换，相互之间不太容易建立复杂的数据结构，例如链表或树。</li><li>容易出错：使用IPC方式进行通信，需要进行同步操作，否则可能会发生死锁或者忙等等问题，这些问题难以排除。</li></ol><p>如果进程没有共享内存通信，则会导致进程间通信的效率变得低下，设计难度加大，难以建立复杂的数据结构，而且容易出现错误，降低了程序可维护性和可靠性，也使得应用程序性能不尽如人意。</p><h2 id="堆和栈的区别？"><a href="#堆和栈的区别？" class="headerlink" title="堆和栈的区别？"></a>堆和栈的区别？</h2><ol><li>内存分配方式：栈是一种自动分配的数据结构，由编译器自动分配和释放内存，不需要程序员显式地操作；而堆则需要程序员显式地进行分配和释放内存。</li><li>内存大小和使用方式： 栈空间的大小通常是固定的，由操作系统决定，而堆则是动态分配的，可以根据需要随时调整大小；栈空间通常被用来存储程序的局部变量（例如函数中定义的变量），而堆空间通常被用来存储程序的全局变量和动态数据结构（例如对象、数组等）。</li><li>内存访问速度：栈内存的访问速度比堆内存更快，因为栈空间的数据结构更简单，访问时只需要进出栈即可，而堆空间的数据结构比较复杂，访问时需要经过指针跳转等操作，因此比较耗时。</li><li>内存分配的效率：堆的内存分配效率比栈要低，因为堆需要动态分配内存，需要进行堆内存管理，可能存在内存碎片问题；而栈则由编译器负责管理，内存分配和回收都比较快捷，不存在这种问题。</li></ol><h2 id="堆和栈，哪个操作系统处理起来会更快？"><a href="#堆和栈，哪个操作系统处理起来会更快？" class="headerlink" title="堆和栈，哪个操作系统处理起来会更快？"></a>堆和栈，哪个操作系统处理起来会更快？</h2><p>一般来说，栈的处理速度比堆更快，这是因为<strong>栈的内存分配和释放是由编译器自动完成的，不需要进行复杂的内存管理操作，而且它的数据结构相对简单，访问速度更快</strong>。而堆在内存分配和释放时需要进行一些额外的操作，例如寻找可用内存，管理内存分配器等，因此操作系统在处理堆时需要花费更多的时间。</p><p>但是，在实际应用中，我们往往需要使用堆空间来存储动态数据结构，例如动态数组、链表、堆等。这些数据结构使用栈空间无法实现，只能使用堆空间。因此，在程序设计时需要根据实际需求合理使用栈和堆，以取得更好的性能和效率。</p><h2 id="JS常见的定义变量的方式有哪些？"><a href="#JS常见的定义变量的方式有哪些？" class="headerlink" title="JS常见的定义变量的方式有哪些？"></a>JS常见的定义变量的方式有哪些？</h2><ul><li>let</li><li>const </li><li>var</li><li>function</li><li>class</li></ul><h2 id="var、let和const的区别？"><a href="#var、let和const的区别？" class="headerlink" title="var、let和const的区别？"></a>var、let和const的区别？</h2><ol><li><p>变量作用域</p><p>var会有变量提升的问题，即变量可以在代码块之外进行访问。而let和const都是块级作用域的，只能在相应的代码块内部使用。</p></li><li><p>变量的赋值</p><p>var和let都支持对变量进行重新赋值，而const定义的变量是不允许重新赋值的，赋值会导致 SyntaxError 错误。</p></li><li><p>声明的变量是否具有初始值</p><p>var 和 let 可以在声明的时候不赋初值，在需要的时候赋值。而 const 声明的常量必须在声明时赋初值，不然会导致 SyntaxError 错误。</p></li><li><p>作用域提升</p><p>由于变量提升，使用 var 声明的变量可以在声明之前使用。而使用 let 和 const 的变量不会有这种情况，如果在声明之前使用会导致 ReferenceError 错误。</p></li></ol><p>在开发中，建议优先使用 let 和 const 关键字来定义变量，因为它们具备严格的作用域和赋值规则，利于编写可维护和可读性高的代码。只有在需要兼容较老版本的浏览器或在需要变量提升的特殊情况下，才考虑使用 var 关键字。</p><h2 id="代码输出"><a href="#代码输出" class="headerlink" title="代码输出"></a>代码输出</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    a = <span class="hljs-number">20</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>&#125;)()<br></code></pre></td></tr></table></figure><p>这段代码会在控制台输出 20。</p><p>因为变量a在全局作用域中被先声明并赋值为10，匿名函数立即被调用，而函数内部对a的赋值操作不使用var或let关键字声明新的变量，因此直接操作的是全局作用域中的变量a，使其值变为20。最终console.log()输出20。</p><p><strong>如果把var改成let呢？</strong></p><p>如果将 <code>var a = 10</code> 改为 <code>let a = 10</code>，则输出依然为20，这是因为立即执行函数表达式中的块级作用域中的 <code>a</code> 变量被改变为20后，在块级作用域外部的全局作用域中，对 <code>a</code> 变量的引用也改变了。而且，在使用 <code>let</code> 声明时，变量 <code>a</code> 的作用域被限制在该块级作用域内，不会在其它作用域中被修改或访问，因此代码块内部修改的是块级作用域中的 <code>a</code> 变量的值。</p><h2 id="JS中数组可以调用的方法有哪些？"><a href="#JS中数组可以调用的方法有哪些？" class="headerlink" title="JS中数组可以调用的方法有哪些？"></a>JS中数组可以调用的方法有哪些？</h2><ol><li>push()：向数组末尾添加一个或多个元素，返回新的数组长度</li><li>pop()：删除数组的最后一个元素并返回该元素</li><li>shift()：删除数组的第一个元素并返回该元素</li><li>unshift()：向数组开头添加一个或多个元素，返回新的数组长度</li><li>splice()：删除或替换数组的某个或某些元素，或向指定位置插入元素</li><li>slice()：截取数组的一部分，不会改变原数组，返回截取的新数组</li><li>concat()：连接两个或多个数组，返回连接后的新数组</li><li>join()：将数组中所有元素转换成字符串，并使用指定的分隔符连接起来</li><li>reverse()：颠倒数组中元素的顺序，改变原数组，返回改变后的数组</li><li>sort()：按照字母表顺序对数组中元素进行排序，改变原数组，返回改变后的数组</li><li>map()：对数组中每个元素执行指定的操作并返回操作后的新数组</li><li>filter()：返回数组中符合指定条件的所有元素组成的新数组</li><li>reduce()：使数组中每个元素执行指定操作，返回最终结果</li><li>forEach()：对数组中每个元素执行指定的操作，没有返回值</li><li>indexOf()：返回指定元素在数组中的位置，如果不存在则返回 -1</li><li>lastIndexOf()：返回指定元素在数组中最后出现的位置，如果不存在则返回 -1</li></ol><h2 id="ES6中有哪些新特性？"><a href="#ES6中有哪些新特性？" class="headerlink" title="ES6中有哪些新特性？"></a>ES6中有哪些新特性？</h2><ol><li>let 和 const：用来声明块级作用域的变量和常量，解决了 var 变量作用域的问题。</li><li>箭头函数：使用箭头 &#x3D;&gt; 定义函数，简化了函数的声明方式。</li><li>模板字符串：使用反引号 &#96;&#96; 来定义字符串，可以在字符串中引用变量和表达式，并且支持多行字符串。</li><li>默认参数：函数的参数可以设置默认值，调用函数时如果没有传递参数则使用默认值。</li><li>扩展运算符：使用 … 来表示剩余参数和展开数组，方便函数的调用和对象的赋值和合并操作。</li><li>解构赋值：可以方便地从数组和对象中提取变量并赋值给新的变量。</li><li>class 和 extends：引入了类和继承的概念，是一种更加面向对象的编程方式。</li><li>Promise：解决了异步编程过程中回调地狱的问题，使得异步编程更加简单。</li><li>模块化：使用 import 和 export 来实现模块化，使得代码组织更加清晰和可维护。</li><li>for…of 循环：用来遍历可迭代对象，比如数组和字符串。</li><li>Map 和 Set：引入了 Map 和 Set 数据结构，用来存储键值对和集合，提供了更好的数据组织和操作方式。</li><li>Proxy 和 Reflect：引入了 Proxy 和 Reflect 对象，可以用来拦截和改变对对象的操作，提供了更加高级的元编程功能。</li><li>Symbol和Symbol.species：引入了 Symbol 数据类型和 Symbol.species属性，用来标识对象的唯一性和改变内置方法中使用的构造函数类型。</li></ol><h2 id="箭头函数的指向？"><a href="#箭头函数的指向？" class="headerlink" title="箭头函数的指向？"></a>箭头函数的指向？</h2><p>箭头函数中的 this 是继承自外层作用域，也就是说箭头函数没有自己的 this，它内部的 this 指向的是定义它时所处的环境中的 this (从所处上下文中捕获的)。</p><h2 id="Set和Map的用法和特点？"><a href="#Set和Map的用法和特点？" class="headerlink" title="Set和Map的用法和特点？"></a>Set和Map的用法和特点？</h2><h3 id="Set-的用法和特点"><a href="#Set-的用法和特点" class="headerlink" title="Set 的用法和特点"></a>Set 的用法和特点</h3><p>Set 是一种类似于数组的数据结构，它可以存储任意类型的唯一值。Set 中不允许出现重复的元素，因此可以用来实现数组去重。</p><p>Set 的常用方法包括：</p><ul><li>add(value)：往 Set 中添加一个值。</li><li>delete(value)：从 Set 中删除一个值。</li><li>has(value)：判断 Set 中是否存在某个值。</li><li>clear()：清空 Set 中的所有元素。</li><li>size：获取 Set 中元素的个数。</li></ul><p>Set 的特点包括：</p><ul><li>Set 中的元素是唯一的，不会出现重复的值。</li><li>Set 中的元素是无序的，即元素排列的顺序不是添加的顺序。</li><li>Set 的性能比数组要好一些，尤其是在大量元素判断是否存在时。</li></ul><h3 id="Map-的用法和特点"><a href="#Map-的用法和特点" class="headerlink" title="Map 的用法和特点"></a>Map 的用法和特点</h3><p>Map 是一种键值对的数据结构，它可以存储任意类型的键和值。Map 中的元素是唯一的，而且键和值可以是任意类型，包括对象和函数。</p><p>Map 的常用方法包括：</p><ul><li>set(key, value)：向 Map 中添加一个键值对。</li><li>get(key)：获取 Map 中指定键对应的值。</li><li>has(key)：判断 Map 中是否存在指定键。</li><li>delete(key)：删除 Map 中指定键的值。</li><li>clear()：清空 Map 中的所有键值对。</li><li>size：获取 Map 中键值对的个数。</li></ul><p>Map 的特点包括：</p><ul><li>Map 中的键是唯一的，且值可以是任意类型。</li><li>Map 中的键值对是有序的，即元素排列的顺序是添加的顺序。</li><li>Map 的性能比对象要好一些，尤其是在大量元素判断是否存在时。</li></ul><p>总的来说，Set 和 Map 都可以用来存储数据，但是应用场景不同。当需要存储唯一值时，可以使用 Set，而当需要存储键值对时，可以使用 Map。</p><h2 id="ES6中的Class是怎样定义的？"><a href="#ES6中的Class是怎样定义的？" class="headerlink" title="ES6中的Class是怎样定义的？"></a>ES6中的Class是怎样定义的？</h2><p>ES6 中的 Class 是一种语法糖，它可以更方便地定义JS中的构造函数，从而实现面向对象编程。Class 的定义方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-comment">// 类的构造函数</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">prop</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">prop</span> = prop;<br>  &#125;<br><br>  <span class="hljs-comment">// 类的方法</span><br>  <span class="hljs-title function_">myMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码定义了一个名为 MyClass 的类，它的构造函数为 constructor，接收一个参数 prop，将其赋值给实例的属性 this.prop。类中的方法可以直接定义在类体内。</p><p>使用 Class 来创建实例时，需要使用 <code>new</code> 关键字，给构造函数传递参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>(<span class="hljs-string">&#x27;myProp&#x27;</span>);<br></code></pre></td></tr></table></figure><p>上述代码创建了一个新的 MyClass 实例，并将 ‘myProp’ 传递给构造函数。</p><p>使用 Class 定义类时，可以继承自其他类，实现类的继承：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ParentClass</span> &#123;<br>  <span class="hljs-comment">// 子类的构造函数</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">prop1, prop2</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(prop1); <span class="hljs-comment">// 调用父类的构造函数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">prop2</span> = prop2;<br>  &#125;<br><br>  <span class="hljs-comment">// 子类的方法</span><br>  <span class="hljs-title function_">childMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码定义了一个名为 ChildClass 的类，它继承于 ParentClass，拥有自己的构造函数和方法。在子类的构造函数中，需要调用 <code>super</code> 方法，以调用父类的构造函数。</p><p>Class 的定义使得 JS 中的面向对象编程变得更加易于理解和使用。</p><h2 id="类中的方法是用逗号隔开、分号隔开还是不需要写？"><a href="#类中的方法是用逗号隔开、分号隔开还是不需要写？" class="headerlink" title="类中的方法是用逗号隔开、分号隔开还是不需要写？"></a>类中的方法是用逗号隔开、分号隔开还是不需要写？</h2><p>在类中定义方法的时候，并不需要使用逗号或分号来隔开各个方法。在类的定义中，方法之间使用换行符隔开即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greetings</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span> = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">sayBye</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Goodbye&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在类中定义方法的时候，不需要使用 function 关键字。</p><h2 id="for…of和for…in的区别？"><a href="#for…of和for…in的区别？" class="headerlink" title="for…of和for…in的区别？"></a>for…of和for…in的区别？</h2><ol><li><code>for...of</code> 遍历可迭代对象（Iterable），如数组、Set、Map 等，遍历出的是元素的值。</li><li><code>for...in</code> 遍历对象的属性（包括继承下来的属性），遍历出的是属性名或者属性值。</li></ol><h2 id="Node-js实现统计所有接口的响应时间-服务端接到请求到给出内容的间隔时间-怎么实现？"><a href="#Node-js实现统计所有接口的响应时间-服务端接到请求到给出内容的间隔时间-怎么实现？" class="headerlink" title="Node.js实现统计所有接口的响应时间(服务端接到请求到给出内容的间隔时间)怎么实现？"></a>Node.js实现统计所有接口的响应时间(服务端接到请求到给出内容的间隔时间)怎么实现？</h2><p><strong>可以使用 Express 框架和一个自定义的中间件来实现统计所有接口的响应时间。具体的实现步骤如下：</strong></p><p>使用 Express 框架创建应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br></code></pre></td></tr></table></figure><p>实现一个自定义的中间件，记录请求开始时间和请求结束时间，并计算出请求响应时间：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">responseTimeLogger</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>  <span class="hljs-keyword">const</span> start = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>  res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;finish&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> end = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    <span class="hljs-keyword">const</span> duration = end - start;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>      <span class="hljs-string">`<span class="hljs-subst">$&#123;req.method&#125;</span> <span class="hljs-subst">$&#123;req.originalUrl&#125;</span> <span class="hljs-subst">$&#123;duration&#125;</span>ms`</span><br>    );<br>  &#125;);<br>  <span class="hljs-title function_">next</span>();<br>&#125;<br><br>app.<span class="hljs-title function_">use</span>(responseTimeLogger);<br></code></pre></td></tr></table></figure><p>在应用中添加路由，以便测试统计响应时间是否正常：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello, World!&#x27;</span>);<br>&#125;);<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/foo&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span> &#125;);<br>  &#125;, <span class="hljs-number">500</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>启动应用并测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;App is listening on port 3000.&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>打开浏览器，访问首页和 &#x2F;api&#x2F;foo 接口，可以在控制台中看到类似于以下的输出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> / 2ms<br><span class="hljs-built_in">GET</span> /api/foo 503ms<br></code></pre></td></tr></table></figure><p>其中，<code>GET / 2ms</code> 表示访问首页的响应时间为 2ms，<code>GET /api/foo 503ms</code> 表示访问 &#x2F;api&#x2F;foo 接口的响应时间为 503ms。</p><p>这样，我们就利用自定义的中间件实现了统计所有接口的响应时间的功能。</p><p><strong>还可以使用 Node.js 的原生模块 <code>http</code>、<code>fs</code> 等进行实现。具体步骤如下：</strong></p><p>创建 http 服务器，监听客户端请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server is running on port 3000.&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>创建一个对象用于保存接口响应时间：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> responseTime = &#123;&#125;;<br></code></pre></td></tr></table></figure><p>监听客户端请求，并记录请求开始时间：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> start = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>  <span class="hljs-comment">// ...</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>在发送请求响应之前，记录请求结束时间，并计算请求响应间隔时间：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript">http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> start = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><br>  res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;finish&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> end = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    <span class="hljs-keyword">const</span> duration = end - start;<br>    <span class="hljs-keyword">const</span> path = req.<span class="hljs-property">url</span>;<br><br>    <span class="hljs-keyword">if</span> (responseTime[path]) &#123;<br>      responseTime[path].<span class="hljs-property">count</span>++;<br>      responseTime[path].<span class="hljs-property">total</span> += duration;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      responseTime[path] = &#123;<br>        <span class="hljs-attr">count</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">total</span>: duration<br>      &#125;;<br>    &#125;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;req.method&#125;</span> <span class="hljs-subst">$&#123;req.url&#125;</span> <span class="hljs-subst">$&#123;duration&#125;</span>ms`</span>);<br>  &#125;);<br><br>  <span class="hljs-comment">// send response to client</span><br>  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span>&#125;);<br>  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;Hello, World!&#x27;</span>);<br>  res.<span class="hljs-title function_">end</span>();<br>&#125;)<br></code></pre></td></tr></table></figure><p>在服务器关闭时将统计数据输出到文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br>process.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  fs.<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-string">&#x27;response-time.txt&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(responseTime, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>));<br>  process.<span class="hljs-title function_">exit</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>将上述代码片段放入一个独立的模块中，以便在多个文件中使用。最终代码示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-keyword">const</span> responseTime = &#123;&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-keyword">const</span> start = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><br>  res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;finish&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> end = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    <span class="hljs-keyword">const</span> duration = end - start;<br>    <span class="hljs-keyword">const</span> path = req.<span class="hljs-property">url</span>;<br><br>    <span class="hljs-keyword">if</span> (responseTime[path]) &#123;<br>      responseTime[path].<span class="hljs-property">count</span>++;<br>      responseTime[path].<span class="hljs-property">total</span> += duration;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      responseTime[path] = &#123;<br>        <span class="hljs-attr">count</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">total</span>: duration<br>      &#125;;<br>    &#125;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;req.method&#125;</span> <span class="hljs-subst">$&#123;req.url&#125;</span> <span class="hljs-subst">$&#123;duration&#125;</span>ms`</span>);<br>  &#125;);<br>&#125;<br><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">log</span>(req, res);<br><br>  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span>&#125;);<br>  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;Hello, World!&#x27;</span>);<br>  res.<span class="hljs-title function_">end</span>();<br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server is running on port 3000.&#x27;</span>);<br>&#125;);<br><br>process.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  fs.<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-string">&#x27;response-time.txt&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(responseTime, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>));<br>  process.<span class="hljs-title function_">exit</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>以上代码使用了 Node.js 的原生模块 <code>fs</code> 将统计数据输出到文件中。</p><h2 id="归并排序如何实现？时间复杂度是多少？"><a href="#归并排序如何实现？时间复杂度是多少？" class="headerlink" title="归并排序如何实现？时间复杂度是多少？"></a>归并排序如何实现？时间复杂度是多少？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">mergeSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> len = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">// 如果长度&lt;2, 无需进行排序</span><br>    <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr; <br>    <span class="hljs-comment">// 将数组从中间进行切割</span><br>    <span class="hljs-keyword">const</span> middle = len &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">const</span> left = arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, middle), right = arr.<span class="hljs-title function_">slice</span>(middle);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(<span class="hljs-title function_">mergeSort</span>(left), <span class="hljs-title function_">mergeSort</span>(right));<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">merge</span> = (<span class="hljs-params">left, right</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 存储最终结果的数组</span><br>    <span class="hljs-keyword">const</span> result = [];<br>    <span class="hljs-comment">// 比较left和right中的元素并将较小的先存入result中</span><br>    <span class="hljs-keyword">while</span>(left.<span class="hljs-property">length</span> &amp;&amp; right.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">if</span>(left[<span class="hljs-number">0</span>] &lt;= right[<span class="hljs-number">0</span>]) &#123;<br>            result.<span class="hljs-title function_">push</span>(left.<span class="hljs-title function_">shift</span>());<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            result.<span class="hljs-title function_">push</span>(right.<span class="hljs-title function_">shift</span>());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(left.<span class="hljs-property">length</span>) &#123;<br>        result.<span class="hljs-title function_">push</span>(left.<span class="hljs-title function_">shift</span>());<br>    &#125;<br>    <span class="hljs-keyword">while</span>(right.<span class="hljs-property">length</span>) &#123;<br>        result.<span class="hljs-title function_">push</span>(right.<span class="hljs-title function_">shift</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度O(NlogN)</p><p>最近的前端新技术有哪些？从哪些途径了解的？</p><p>最有成就感的一件事？</p><p>项目协作开发整个项目的流程？</p><p>上大学后思考方式上有哪些改变？</p><p>假如你在一个团队内，让你做一个产品，需求不明确，该怎样去做？</p><p>反问：部门业务(React&#x2F;Vue负责托管公司所有页面、Node方向保证产品稳定性)</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端|面经</tag>
      
      <tag>NodeJs</tag>
      
      <tag>进程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识点整理(7)</title>
    <link href="/2023/04/13/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-7/"/>
    <url>/2023/04/13/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-7/</url>
    
    <content type="html"><![CDATA[<h1 id="知识点整理-7"><a href="#知识点整理-7" class="headerlink" title="知识点整理(7)"></a>知识点整理(7)</h1><h2 id="git-amend的作用？"><a href="#git-amend的作用？" class="headerlink" title="git amend的作用？"></a>git amend的作用？</h2><p>git amend命令用于修改最近一次的提交记录。它允许您添加、删除或修改之前提交的文件、提交消息等。</p><p>使用git amend命令，您可以：</p><ol><li>修改上一次提交的提交消息。</li><li>将一些忘记添加到上一次提交中的文件添加到该提交中。</li><li>修改上一次提交中的某些文件。</li><li>将上一次提交中的某些文件删除。</li></ol><p>使用git amend命令修改最近一次提交记录有以下两种方式：</p><p><strong>修改最近一次提交记录的提交消息：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git commit --amend -m &quot;New commit message&quot;<br></code></pre></td></tr></table></figure><p>这个命令将会修改最近一次提交记录的提交消息。</p><p><strong>添加、删除或修改最近一次提交记录中的文件：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs git">git add &lt;file&gt;  # 添加文件到暂存区<br>git rm &lt;file&gt;   # 从暂存区和工作目录中删除文件<br>git reset &lt;file&gt;   # 从暂存区中删除文件，但不删除工作目录中的文件<br>git commit --amend   # 修改最近一次提交记录<br></code></pre></td></tr></table></figure><p>注意：使用git amend修改提交记录时，只能修改最近一次提交记录，如果要修改更早的提交记录，需要使用git rebase等其他命令。</p><h2 id="Websocket承载的上限，能同时接受多少个客户端连接？"><a href="#Websocket承载的上限，能同时接受多少个客户端连接？" class="headerlink" title="Websocket承载的上限，能同时接受多少个客户端连接？"></a>Websocket承载的上限，能同时接受多少个客户端连接？</h2><p>WebSocket承载的上限取决于多个因素，包括服务器的硬件和软件配置、网络带宽、同时连接的客户端数量、客户端发送和接收数据的频率等。因此，无法给出一个具体的答案来回答能同时接受多少个客户端连接。</p><p>一般来说，WebSocket的性能通常比HTTP长连接更好，因为它使用的是基于事件的模型，可以在服务器和客户端之间实现实时的双向通信。但是，在实际应用中，如果同时连接的客户端数量过多，可能会导致服务器的负载过高，从而影响WebSocket的性能和可靠性。</p><p>为了提高WebSocket的性能和可靠性，可以采取一些优化措施，例如使用负载均衡、优化服务器端代码、增加服务器硬件配置、限制每个客户端的连接数量等。同时，也需要根据实际情况进行测试和调整，以确保WebSocket在高并发情况下的稳定性和性能。</p><h2 id="操作系统的功能有哪些？"><a href="#操作系统的功能有哪些？" class="headerlink" title="操作系统的功能有哪些？"></a>操作系统的功能有哪些？</h2><ol><li><p>进程管理：操作系统管理计算机上运行的所有进程，包括进程的创建、调度、终止、通信等。</p></li><li><p>内存管理：操作系统管理计算机内存的分配和释放，确保程序能够访问到所需的内存空间。</p></li><li><p>文件系统：操作系统管理计算机上的文件和目录，包括文件的创建、读取、写入、复制、删除等。</p></li><li><p>设备管理：操作系统管理计算机上的各种设备，包括输入输出设备、存储设备、网络设备等。</p></li><li><p>用户接口：操作系统提供了用户与计算机交互的接口，包括命令行接口、图形用户界面等。</p></li><li><p>安全性管理：操作系统确保计算机系统的安全性，包括用户身份验证、访问控制、病毒防护等。</p></li><li><p>网络管理：操作系统提供了网络通信的支持，包括TCP&#x2F;IP协议栈、网络驱动程序等。</p></li></ol><h2 id="并发和并行的区别？"><a href="#并发和并行的区别？" class="headerlink" title="并发和并行的区别？"></a>并发和并行的区别？</h2><p>并发和并行都是多任务处理的概念，但是它们的含义不同。</p><p>并发是指在同一时间段内，有多个任务在交替执行，这些任务可能在同一个处理器上交替执行，也可能在多个处理器上并行执行。在并发执行中，每个任务都会分配一定的时间片，轮流执行，但是在任意时刻只有一个任务在执行。</p><p>并行是指在同一时刻，有多个任务在同时执行，这些任务可以在多个处理器上并行执行，也可以在同一处理器上通过多核心并行执行。在并行执行中，多个任务同时执行，每个任务都能够分配到独立的处理器或处理器核心。</p><p>简单来说，如果是在同一个处理器上，任务是交替执行的，就是并发；如果是在多个处理器上或者是多核心并行执行，就是并行。</p><p>总之，并发和并行都是提高计算机系统效率的重要手段，但是它们的实现方式和效果不同。在实际应用中，需要根据具体情况选择并发或并行的方式来处理任务。</p><h2 id="Websocket使用的是TCP还是UDP协议？为什么？"><a href="#Websocket使用的是TCP还是UDP协议？为什么？" class="headerlink" title="Websocket使用的是TCP还是UDP协议？为什么？"></a>Websocket使用的是TCP还是UDP协议？为什么？</h2><p>Websocket使用的是TCP协议，而不是UDP协议。</p><p>TCP协议是一种面向连接的、可靠的、有序的协议，它在数据传输过程中提供了数据完整性、可靠性和有序性的保证。Websocket需要<strong>保证数据的可靠性和有序性</strong>，因此选择了TCP协议作为底层传输协议。</p><p>相比之下，UDP协议是一种无连接的、不可靠的、无序的协议，它不提供数据的可靠性和有序性保证，适合于一些实时性要求高、数据量小、可丢失的应用，如在线游戏、音视频传输等。但是Websocket需要保证数据的可靠性和有序性，因此不适合使用UDP协议作为底层传输协议。</p><p>综上所述，Websocket使用TCP协议作为底层传输协议，可以保证数据的可靠性和有序性，适用于需要保证数据完整性和可靠性的应用。</p><h2 id="TCP在连接时会出现拥塞和粘包的问题，要怎么解决粘包的问题？"><a href="#TCP在连接时会出现拥塞和粘包的问题，要怎么解决粘包的问题？" class="headerlink" title="TCP在连接时会出现拥塞和粘包的问题，要怎么解决粘包的问题？"></a>TCP在连接时会出现拥塞和粘包的问题，要怎么解决粘包的问题？</h2><p>TCP协议在传输过程中会出现拥塞和粘包的问题，其中粘包问题是由于<strong>发送端发送的数据大小与接收端接收的数据大小不一致，导致多个数据包被粘在一起，从而造成接收端解析数据时出现错误</strong>。解决粘包问题的方法如下：</p><ol><li>使用消息定长：在发送端每次发送固定长度的数据，接收端每次接收相同长度的数据，这样就能避免粘包问题。</li><li>使用消息分隔符：在发送端每次发送数据时，在每个数据包的末尾添加一个特定的分隔符，接收端根据分隔符将数据包分开处理。</li><li>使用消息长度：在发送端每次发送数据时，在数据包的头部添加一个表示数据长度的字段，接收端根据字段的值来判断每个数据包的长度。</li><li>应用层协议处理：在应用层协议中定义数据格式和处理方式，例如HTTP协议中使用头部信息和分隔符来处理请求和响应数据。</li></ol><p>综上所述，通过使用消息定长、消息分隔符、消息长度和应用层协议处理等方法，可以有效解决TCP协议中的粘包问题。</p><h2 id="什么是全双工通信？"><a href="#什么是全双工通信？" class="headerlink" title="什么是全双工通信？"></a>什么是全双工通信？</h2><p>全双工通信是指在通信的两端，数据可以同时双向传输，即两端都可以同时发送和接收数据。全双工通信可以实现双向通信，通信效率高，通信质量稳定。与半双工通信和单工通信相比，全双工通信具有更高的带宽利用率和更快的数据传输速度。</p><p>在全双工通信中，通信双方可以同时发送和接收数据，而且在发送和接收数据时不需要等待对方的响应。这种通信方式可以在同一信道上实现双向通信，例如电话通信、视频会议、网络通信等都可以采用全双工通信方式。</p><p>在全双工通信中，通信双方需要使用专门的设备进行通信，例如全双工电缆、全双工网卡等。这些设备可以同时进行发送和接收数据，并且能够处理来自对方的数据，从而实现双向通信。</p><p>因此，全双工通信可以提高通信效率和通信质量，广泛应用于各种通信场景中。</p><h2 id="Http的报文格式？"><a href="#Http的报文格式？" class="headerlink" title="Http的报文格式？"></a>Http的报文格式？</h2><p>HTTP（超文本传输协议）的报文格式分为请求报文和响应报文两种类型。</p><p><strong>请求报文格式</strong></p><p>请求报文由三个部分组成：请求行、请求头和请求体。</p><p>请求行格式：METHOD URL HTTP&#x2F;版本号</p><p>例如：GET &#x2F;index.html HTTP&#x2F;1.1</p><p>请求头格式：键值对，每个键值对用冒号分隔，每个键值对占一行，最后一行用空行表示请求头结束。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Host</span>: www.<span class="hljs-property">example</span>.<span class="hljs-property">com</span> <span class="hljs-title class_">User</span>-<span class="hljs-title class_">Agent</span>: <span class="hljs-title class_">Mozilla</span>/<span class="hljs-number">5.0</span> (<span class="hljs-title class_">Windows</span> <span class="hljs-variable constant_">NT</span> <span class="hljs-number">10.0</span>; <span class="hljs-title class_">Win64</span>; x64) <span class="hljs-title class_">AppleWebKit</span>/<span class="hljs-number">537.36</span> (<span class="hljs-variable constant_">KHTML</span>, like <span class="hljs-title class_">Gecko</span>) <span class="hljs-title class_">Chrome</span>/<span class="hljs-number">58.0</span><span class="hljs-number">.3029</span><span class="hljs-number">.110</span> <span class="hljs-title class_">Safari</span>/<span class="hljs-number">537.36</span> <span class="hljs-title class_">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0.9</span>,image/webp,*<span class="hljs-comment">/*;q=0.8</span><br></code></pre></td></tr></table></figure><p>请求体格式：用于传输数据，可以为空。</p><p><strong>响应报文格式</strong></p><p>响应报文也由三个部分组成：状态行、响应头和响应体。</p><p>状态行格式：HTTP&#x2F;版本号 状态码 状态码的原因短语</p><p>例如：HTTP&#x2F;1.1 200 OK</p><p>响应头格式：键值对，每个键值对用冒号分隔，每个键值对占一行，最后一行用空行表示响应头结束。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Type</span>: text/html; charset=utf-<span class="hljs-number">8</span> <span class="hljs-title class_">Server</span>: <span class="hljs-title class_">Apache</span>/<span class="hljs-number">2.4</span><span class="hljs-number">.18</span> (<span class="hljs-title class_">Ubuntu</span>) <span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Length</span>: <span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><p>响应体格式：用于传输数据，可以为空。</p><h2 id="Http状态码1-5代表什么含义"><a href="#Http状态码1-5代表什么含义" class="headerlink" title="Http状态码1-5代表什么含义?"></a>Http状态码1-5代表什么含义?</h2><p>HTTP状态码是服务器响应HTTP请求时返回的3位数字代码。这些代码分为5类，每类都代表了不同的含义。</p><p>1xx（信息性状态码）：表示请求已经被接收，继续处理。这个类别的状态码通常是在客户端发送请求时使用，用于提示客户端请求是否被服务器接收。</p><p>2xx（成功状态码）：表示请求已经被成功接收、理解、接受和处理。这个类别的状态码意味着服务器已经成功地处理了请求。</p><p>3xx（重定向状态码）：表示客户端需要进一步操作才能完成请求。这个类别的状态码通常用于重定向，即让客户端请求另一个URL。</p><p>4xx（客户端错误状态码）：表示客户端发送的请求有错误，服务器无法处理该请求。这个类别的状态码通常是由于客户端发送的请求有误、缺少参数或权限等原因引起的。</p><p>5xx（服务器错误状态码）：表示服务器在处理请求时发生了错误。这个类别的状态码通常是由于服务器无法处理请求、服务器内部错误或服务器过载等原因引起的。</p><p>以下是HTTP状态码的具体含义：</p><ul><li>1xx：信息性状态码<ul><li>100：Continue</li><li>101：Switching Protocols</li></ul></li><li>2xx：成功状态码<ul><li>200：OK</li><li>201：Created</li><li>202：Accepted</li><li>204：No Content</li></ul></li><li>3xx：重定向状态码<ul><li>301：Moved Permanently</li><li>302：Found</li><li>303：See Other</li><li>304：Not Modified</li><li>307：Temporary Redirect</li></ul></li><li>4xx：客户端错误状态码<ul><li>400：Bad Request</li><li>401：Unauthorized</li><li>403：Forbidden</li><li>404：Not Found</li><li>405：Method Not Allowed</li><li>408：Request Timeout</li><li>409：Conflict</li><li>410：Gone</li><li>413：Payload Too Large</li><li>414：URI Too Long</li><li>415：Unsupported Media Type</li><li>429：Too Many Requests</li></ul></li><li>5xx：服务器错误状态码<ul><li>500：Internal Server Error</li><li>501：Not Implemented</li><li>502：Bad Gateway</li><li>503：Service Unavailable</li><li>504：Gateway Timeout</li><li>505：HTTP Version Not Supported</li></ul></li></ul><h2 id="前端如何解决跨域？"><a href="#前端如何解决跨域？" class="headerlink" title="前端如何解决跨域？"></a>前端如何解决跨域？</h2><ol><li><p>JSONP</p><p>JSONP是一种跨域解决方案，它利用了script标签的跨域特性来实现。</p></li><li><p>CORS</p><p>CORS是一种新的跨域解决方案，它需要服务器端进行配置。通过在响应头中添加Access-Control-Allow-Origin字段，允许指定的域名跨域访问。</p></li><li><p>代理</p><p>通过在服务器端设置代理，将前端请求发送到后端服务器，然后由后端服务器发送请求到目标服务器，最后将结果返回给前端。</p></li></ol><h2 id="跨域相关的HTTP请求头有哪些？"><a href="#跨域相关的HTTP请求头有哪些？" class="headerlink" title="跨域相关的HTTP请求头有哪些？"></a>跨域相关的HTTP请求头有哪些？</h2><ol><li><p>Access-Control-Allow-Origin</p><p>该字段用于允许哪些域名可以跨域访问资源。可以设置为*，表示允许所有域名访问。</p></li><li><p>Access-Control-Allow-Methods</p><p>该字段用于允许哪些HTTP方法可以跨域访问资源。例如GET、POST、PUT、DELETE等。</p></li><li><p>Access-Control-Allow-Headers</p><p>该字段用于允许哪些HTTP头可以跨域访问资源。例如Content-Type、Authorization等。</p></li></ol><h2 id="Http缓存，由哪些header控制？"><a href="#Http缓存，由哪些header控制？" class="headerlink" title="Http缓存，由哪些header控制？"></a>Http缓存，由哪些header控制？</h2><p>强缓存：Cache-Control、Expires</p><p>协商缓存：Etag&#x2F;If-None-Match、Last-Mpdified&#x2F;If-Modified-Since</p><h2 id="Node中的事件循环机制？"><a href="#Node中的事件循环机制？" class="headerlink" title="Node中的事件循环机制？"></a>Node中的事件循环机制？</h2><p>Node.js的事件循环机制是其异步非阻塞I&#x2F;O的核心，它是基于事件驱动的非阻塞I&#x2F;O模型实现的。</p><p>在Node.js中，事件循环机制分为6个阶段，分别是：</p><ol><li>timers阶段：处理setTimeout和setInterval等定时器的回调函数。</li><li>I&#x2F;O callbacks阶段：处理一些系统I&#x2F;O操作的回调函数，如网络请求的回调函数。</li><li>idle, prepare阶段：只在内部使用，可以忽略。</li><li>poll阶段：等待I&#x2F;O事件完成，如网络请求的响应、文件读写完成等。</li><li>check阶段：处理setImmediate()的回调函数。</li><li>close callbacks阶段：处理一些关闭事件的回调函数，如socket连接关闭的回调函数。</li></ol><p>事件循环机制的流程如下：</p><ol><li>进入循环：Node.js会在事件循环开始时，进入timers阶段。</li><li>执行timers：Node.js会执行所有定时器的回调函数。</li><li>进入I&#x2F;O callbacks阶段：处理所有I&#x2F;O事件的回调函数。</li><li>进入poll阶段：等待I&#x2F;O事件完成。</li><li>执行check阶段：处理setImmediate()的回调函数。</li><li>执行close callbacks阶段：处理所有关闭事件的回调函数。</li><li>等待下一个循环：事件循环会等待新的事件被触发，然后再次进入循环。</li></ol><p>事件循环机制的核心是事件队列，所有的回调函数都会被加入到事件队列中，事件循环机制会不断地从事件队列中取出待执行的回调函数，按照一定的顺序执行。</p><p>总之，Node.js的事件循环机制是其异步非阻塞I&#x2F;O的核心，通过不断地循环执行事件队列中的回调函数，实现了高效的异步非阻塞I&#x2F;O模型。</p><h2 id="小根堆的概念？作用？"><a href="#小根堆的概念？作用？" class="headerlink" title="小根堆的概念？作用？"></a>小根堆的概念？作用？</h2><p>小根堆（Min Heap）是一种基于树形结构的数据结构，它满足以下两个条件：</p><ol><li>堆中每个节点的值都小于或等于其子节点的值。</li><li>堆是一棵完全二叉树。</li></ol><p>小根堆的作用：</p><ol><li>堆排序：小根堆可以用来进行堆排序，堆排序是一种高效的排序算法，时间复杂度为O(nlogn)。</li><li>优先队列：小根堆可以用来实现优先队列，优先队列是一种数据结构，它可以按照优先级来处理元素，小根堆可以实现按照元素值的大小来进行优先级排序。</li><li>最小值查询：小根堆可以用来查询最小值，由于小根堆的性质，堆顶元素始终是堆中的最小值。</li><li>贪心算法：小根堆可以用来实现贪心算法，贪心算法是一种基于贪心思想的算法，它每次选择当前最优的方案，小根堆可以用来找到当前最优的方案。</li></ol><p>总之，小根堆是一种非常实用的数据结构，它可以用来实现堆排序、优先队列、最小值查询和贪心算法等。</p><h2 id="TCP可靠的原因是什么？依靠了哪些机制？"><a href="#TCP可靠的原因是什么？依靠了哪些机制？" class="headerlink" title="TCP可靠的原因是什么？依靠了哪些机制？"></a>TCP可靠的原因是什么？依靠了哪些机制？</h2><ol><li>应答机制：TCP在发送数据之后，会等待接收方的应答，以确认数据是否已经到达。如果接收方未能及时应答，TCP会进行重传，直到接收到应答为止。</li><li>序列号和确认应答：TCP会为每个数据包分配一个序列号，用于标识数据包的顺序和完整性。接收方在收到数据包后，会发送一个确认应答，其中包含期望接收的下一个序列号，用于告诉发送方哪些数据已经接收到了。</li><li>数据包校验和：TCP会对每个数据包进行校验和计算，以检测数据在传输过程中是否发生了损坏或丢失。如果校验和不匹配，TCP会进行重传，以确保数据的完整性。</li><li>滑动窗口：TCP使用滑动窗口机制来控制数据流量，以避免网络拥塞。发送方和接收方都有一个窗口大小，用于控制发送和接收的数据量。发送方会根据接收方的窗口大小来控制发送的数据量，以避免数据包的丢失或拥塞。</li></ol><h2 id="网络层的协议有哪些？"><a href="#网络层的协议有哪些？" class="headerlink" title="网络层的协议有哪些？"></a>网络层的协议有哪些？</h2><ol><li>IP协议（Internet Protocol）：IP是互联网中最重要的协议之一，负责将数据包从源地址传输到目的地址，并通过路由选择算法选择最优路径。IPv4和IPv6是最常用的IP协议版本。</li><li>ICMP协议（Internet Control Message Protocol）：ICMP是IP协议的附属协议，用于传输网络控制信息和错误报文。常用的功能包括ping命令和traceroute命令。</li><li>ARP协议（Address Resolution Protocol）：ARP是用于将IP地址转换为MAC地址的协议，通过查询本地网络中的ARP缓存表或广播ARP请求来查找目标MAC地址。</li><li>RARP协议（Reverse Address Resolution Protocol）：RARP是ARP的反向协议，用于将MAC地址转换为IP地址。现在已经很少使用。</li><li>OSPF协议（Open Shortest Path First）：OSPF是一种开放的链路状态路由协议，用于在局域网和广域网中选择最短路径，实现路由的自适应和动态变化。</li><li>BGP协议（Border Gateway Protocol）：BGP是一种自治系统间的路由协议，用于在不同自治系统之间传输路由信息，实现互联网中的全球路由选择。</li><li>RIP协议（Routing Information Protocol）：RIP是一种基于距离向量的内部网关协议，用于在小型网络中选择最短路径，实现路由的自适应和动态变化。</li></ol><h2 id="如何获取URL中的参数？"><a href="#如何获取URL中的参数？" class="headerlink" title="如何获取URL中的参数？"></a>如何获取URL中的参数？</h2><p>获取URL中的参数可以使用JavaScript中的URLSearchParams对象。以下是一个简单的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取当前URL中的参数</span><br><span class="hljs-keyword">let</span> params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">search</span>);<br><br><span class="hljs-comment">// 获取特定参数的值</span><br><span class="hljs-keyword">let</span> id = params.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-keyword">let</span> name = params.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;name&quot;</span>);<br><br><span class="hljs-comment">// 打印参数值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id); <span class="hljs-comment">// 输出参数id的值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// 输出参数name的值</span><br></code></pre></td></tr></table></figure><p>上述代码中，首先使用<code>URLSearchParams</code>对象获取当前URL中的参数。然后使用<code>get</code>方法获取特定参数的值。最后使用<code>console.log</code>方法打印参数值。</p><p>字符串分割方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getAllParams</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 获取当前URL</span><br>  <span class="hljs-keyword">let</span> url = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>;<br><br>  <span class="hljs-comment">// 获取参数部分</span><br>  <span class="hljs-keyword">let</span> params = url.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;?&quot;</span>)[<span class="hljs-number">1</span>];<br><br>  <span class="hljs-comment">// 分割参数</span><br>  <span class="hljs-keyword">let</span> paramArr = params.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&amp;&quot;</span>);<br><br>  <span class="hljs-comment">// 创建一个空对象，用于存储参数</span><br>  <span class="hljs-keyword">let</span> paramObj = &#123;&#125;;<br><br>  <span class="hljs-comment">// 遍历参数数组，将参数存储到对象中</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; paramArr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> param = paramArr[i].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;=&quot;</span>);<br><br>    <span class="hljs-comment">// 将参数名和参数值存储到对象中</span><br>    paramObj[param[<span class="hljs-number">0</span>]] = param[<span class="hljs-number">1</span>];<br>  &#125;<br><br>  <span class="hljs-comment">// 返回参数对象</span><br>  <span class="hljs-keyword">return</span> paramObj;<br>&#125;<br><br><span class="hljs-comment">// 获取所有参数</span><br><span class="hljs-keyword">let</span> params = <span class="hljs-title function_">getAllParams</span>();<br><br><span class="hljs-comment">// 打印参数对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params);<br></code></pre></td></tr></table></figure><h2 id="手写JS计算m的n次方，要求时间复杂度O-logN-？"><a href="#手写JS计算m的n次方，要求时间复杂度O-logN-？" class="headerlink" title="手写JS计算m的n次方，要求时间复杂度O(logN)？"></a>手写JS计算m的n次方，要求时间复杂度O(logN)？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">power</span>(<span class="hljs-params">m, n</span>) &#123;<br>  <span class="hljs-comment">// 如果n等于0，返回1</span><br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果n是负数，将m变为倒数，n变为相反数</span><br>  <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br>    m = <span class="hljs-number">1</span> / m;<br>    n = -n;<br>  &#125;<br><br>  <span class="hljs-comment">// 用二分法计算m的n次方</span><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 如果n是奇数，将结果乘上m</span><br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) &#123;<br>      result *= m;<br>    &#125;<br>    <span class="hljs-comment">// 将m平方，将n除以2</span><br>    m *= m;<br>    n = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(n / <span class="hljs-number">2</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 返回结果</span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 计算2的10次方</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">power</span>(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>)); <span class="hljs-comment">// 输出1024</span><br></code></pre></td></tr></table></figure><h2 id="什么是bem？"><a href="#什么是bem？" class="headerlink" title="什么是bem？"></a>什么是bem？</h2><p>BEM是一种CSS命名规范，全称为Block-Element-Modifier，即块-元素-修饰符。它的核心思想是将页面中的组件或模块抽象成一个个块（Block），块内部可以包含多个元素（Element），而元素可以包含多个修饰符（Modifier），从而实现了对页面组件的精细化管理和命名。</p><p>具体来说，BEM的命名规则如下：</p><ul><li>Block（块）：代表一个独立的组件或模块，使用单个单词或短语命名，使用连字符(-)连接单词，例如：.navbar、.card、.header。</li><li>Element（元素）：代表块内部的一个组成部分，使用双下划线(__)连接块名和元素名，例如：.card__title、.navbar__menu。</li><li>Modifier（修饰符）：代表块或元素的状态或变体，使用单个单词或短语命名，使用单下划线(_)连接块名或元素名和修饰符名，例如：.card__title_highlighted、.navbar__menu_visible。</li></ul><p>BEM的优点是可以使CSS代码更加清晰、易于维护和扩展，同时可以避免CSS命名冲突和样式耦合的问题。</p><h2 id="什么是shadow-dom？"><a href="#什么是shadow-dom？" class="headerlink" title="什么是shadow dom？"></a>什么是shadow dom？</h2><p>Shadow DOM是一项Web标准技术，用于创建封装的组件和Web应用程序，使得组件的样式和行为不会受到外部CSS样式的干扰。Shadow DOM通过创建一个隔离的DOM树来实现这个目标，这个DOM树被称为“Shadow Tree”，它的内容和结构都不会影响到页面上的其他元素。</p><p>Shadow DOM可以被看作是一种Web组件技术，它可以将HTML、CSS和JavaScript封装在一个独立的组件内部，从而使得组件的样式和行为可以完全独立于页面的其他元素。Shadow DOM还提供了一些特殊的API，如：ShadowRoot、Element.attachShadow()和Element.shadowRoot，用于创建和管理Shadow Tree。</p><p>Shadow DOM的优点是可以实现组件的封装、复用和可维护性，同时也可以提高Web应用程序的性能和安全性。在Web开发中，Shadow DOM被广泛用于构建Web组件库、单页面应用程序和桌面应用程序等。</p><h2 id="TCP客户端和服务端同时发出断开请求后续会怎么样？"><a href="#TCP客户端和服务端同时发出断开请求后续会怎么样？" class="headerlink" title="TCP客户端和服务端同时发出断开请求后续会怎么样？"></a>TCP客户端和服务端同时发出断开请求后续会怎么样？</h2><p>在 TCP 连接中，当客户端和服务端都发出断开请求时，会发生以下情况：</p><ol><li>服务端先收到断开请求：服务端会发送一个 ACK 确认客户端的断开请求，并关闭连接。此时客户端还没有收到服务端的 ACK，仍然处于等待状态。</li><li>客户端先收到断开请求：客户端会发送一个 ACK 确认服务端的断开请求，并关闭连接。此时服务端还没有收到客户端的 ACK，仍然处于等待状态。</li><li>客户端和服务端同时收到断开请求：客户端和服务端都会发送一个 ACK 确认对方的断开请求，并关闭连接。此时连接会立即断开，双方都不会处于等待状态。</li></ol><p>总之，在 TCP 连接中，任何一方发送断开请求后，都需要等待对方的确认，才能真正关闭连接。如果双方同时发出断开请求，则连接会立即断开，否则需要等待对方的确认。</p><h2 id="Http1-0时候发起一个http请求会开启一个TCP连接吗？"><a href="#Http1-0时候发起一个http请求会开启一个TCP连接吗？" class="headerlink" title="Http1.0时候发起一个http请求会开启一个TCP连接吗？"></a>Http1.0时候发起一个http请求会开启一个TCP连接吗？</h2><p>在 HTTP&#x2F;1.0 中，每次发起 HTTP 请求都会建立一个新的 TCP 连接。这是因为 HTTP&#x2F;1.0 中每个请求和响应都是独立的，没有复用连接的机制。</p><p>在 HTTP&#x2F;1.0 中，每个 TCP 连接只能处理一个请求和响应，因此在处理多个请求和响应时，需要建立多个 TCP 连接。这样会导致建立和关闭连接的开销比较大，影响了 HTTP 请求的性能。</p><p>为了解决这个问题，HTTP&#x2F;1.1 引入了持久连接，允许在同一个 TCP 连接上发送多个请求和响应。这样可以减少建立和关闭连接的开销，提高 HTTP 请求的性能。</p><h2 id="一般的发Http请求的流程是什么样的？"><a href="#一般的发Http请求的流程是什么样的？" class="headerlink" title="一般的发Http请求的流程是什么样的？"></a>一般的发Http请求的流程是什么样的？</h2><p>一般的发 Http 请求的流程如下：</p><ol><li>构建请求：构建 HTTP 请求报文，包括请求方法、请求 URL、请求头以及请求体等信息。</li><li>建立连接：通过 TCP 协议与服务器建立连接，可以使用 HTTP&#x2F;1.0 中的短连接或者 HTTP&#x2F;1.1 中的长连接。</li><li>发送请求：将构建好的 HTTP 请求报文发送给服务器。</li><li>接收响应：等待服务器返回响应报文，接收响应数据。</li><li>处理响应：对服务器返回的响应数据进行处理，包括状态码、响应头以及响应体等信息。</li><li>断开连接：根据 HTTP&#x2F;1.0 或者 HTTP&#x2F;1.1 的规定，关闭 TCP 连接。</li></ol><p>其中，建立连接和断开连接的过程是比较耗时的，影响了 HTTP 请求的性能。因此，为了提高 HTTP 请求的性能，可以使用 HTTP&#x2F;1.1 中的持久连接或者 HTTP&#x2F;2 中的多路复用等技术。</p><h2 id="Http-keep-alive会引起其他的什么问题？"><a href="#Http-keep-alive会引起其他的什么问题？" class="headerlink" title="Http keep-alive会引起其他的什么问题？"></a>Http keep-alive会引起其他的什么问题？</h2><p>HTTP Keep-Alive 是一种 HTTP&#x2F;1.1 中的持久连接技术，可以使客户端和服务器在同一个 TCP 连接上发送多个 HTTP 请求和响应，从而减少连接建立和关闭的开销，提高性能。</p><p>然而，HTTP Keep-Alive 也可能引起以下问题：</p><ol><li>服务器资源占用：当客户端和服务器之间的连接不关闭时，服务器需要一直维护这个连接，占用一定的资源。如果同时有大量客户端连接服务器，会导致服务器资源占用过多，影响服务器的性能。</li><li>网络拥塞：当客户端和服务器之间的连接不关闭时，会占用网络带宽，可能导致网络拥塞，影响网络性能。</li><li>安全性问题：HTTP Keep-Alive 可能会导致安全性问题，例如，当客户端和服务器之间的连接不关闭时，可能会被黑客利用进行攻击，例如，利用长连接进行 DoS 攻击或者发送恶意请求等。</li></ol><p>因此，在使用 HTTP Keep-Alive 技术时，需要合理设置连接的超时时间，以及采取一定的安全措施，避免出现以上问题。</p><h2 id="层叠上下文是什么？会展现什么效果？它的原理是什么呢？"><a href="#层叠上下文是什么？会展现什么效果？它的原理是什么呢？" class="headerlink" title="层叠上下文是什么？会展现什么效果？它的原理是什么呢？"></a>层叠上下文是什么？会展现什么效果？它的原理是什么呢？</h2><p>层叠上下文（stacking context）是指在 HTML 中，每个元素在页面上都有一个层级，而层叠上下文就是在这个层级中，某些元素在层叠上下文中拥有更高的优先级，能够覆盖在其他元素之上。</p><p>层叠上下文的出现会影响元素的显示效果，例如：</p><ol><li>z-index 属性：如果两个元素重叠在一起，可以通过设置它们的 z-index 值来确定哪个元素在上面显示，z-index 值越高的元素会覆盖在 z-index 值较低的元素之上。</li><li>透明度：如果父元素设置了透明度，那么子元素也会继承父元素的透明度，这时就需要用到层叠上下文来控制子元素的透明度。</li><li>position 属性：某些情况下，通过设置元素的 position 属性可以创建一个新的层叠上下文，从而影响元素的显示效果。</li></ol><p>层叠上下文的原理是：在 HTML 中，每个元素都有一个 z-index 属性，它用于控制元素在层级中的位置。当两个元素重叠在一起时，会根据它们的 z-index 值来确定哪个元素在上面显示。但是，有些元素会创建新的层叠上下文，它们的 z-index 值不再是与父元素的 z-index 值相对应，而是相对于整个页面的 z-index 值。这样，就可以通过设置元素的层叠上下文来控制元素在页面上的显示效果。</p><h2 id="什么是GPU加速？"><a href="#什么是GPU加速？" class="headerlink" title="什么是GPU加速？"></a>什么是GPU加速？</h2><p>GPU加速是指利用计算机的图形处理器（GPU）来加速图形和多媒体应用程序的运行。GPU加速可以提高应用程序的性能，减少CPU的负载，从而提高整个系统的响应速度。</p><p>在GPU加速中，GPU负责处理图形和多媒体数据，而CPU则负责处理其他计算任务。这样可以使系统资源得到更好的利用，提高系统的整体性能。</p><p>GPU加速的实现方式有多种，其中最常见的是使用OpenGL或DirectX等图形库来与GPU进行交互。另外，一些Web浏览器也支持GPU加速，可以加速网页的渲染和动画效果。</p><p>GPU加速可以应用于许多领域，例如游戏开发、视频编辑、3D建模等。随着计算机硬件和软件的不断发展，GPU加速的应用范围也越来越广泛。</p><h2 id="假如有个小球-每一秒往右移动1px，一是直接改margin-left，二是position：absolute-一点点加left，三是transition-translate-横轴一点点加，这三种哪一种性能最好？"><a href="#假如有个小球-每一秒往右移动1px，一是直接改margin-left，二是position：absolute-一点点加left，三是transition-translate-横轴一点点加，这三种哪一种性能最好？" class="headerlink" title="假如有个小球 每一秒往右移动1px，一是直接改margin-left，二是position：absolute 一点点加left，三是transition translate 横轴一点点加，这三种哪一种性能最好？"></a>假如有个小球 每一秒往右移动1px，一是直接改margin-left，二是position：absolute 一点点加left，三是transition translate 横轴一点点加，这三种哪一种性能最好？</h2><p>在这种情况下，使用 <code>transform</code> 和 <code>transition</code> 来移动小球的性能最好。因为这种方式利用了GPU加速，可以避免重排和重绘，从而提高了性能。相比之下，改变 <code>margin-left</code> 和使用 <code>position: absolute</code> 来移动小球，需要进行重排和重绘，性能较差。</p><h2 id="什么是变量提升？原理是什么？"><a href="#什么是变量提升？原理是什么？" class="headerlink" title="什么是变量提升？原理是什么？"></a>什么是变量提升？原理是什么？</h2><p>在JavaScript中，变量提升是指变量和函数的声明会被提升到作用域的顶部，无论实际声明的位置在哪里，这也被称为“提升到顶部”。也就是说，在执行代码之前，JavaScript引擎会扫描整个作用域，找出所有的变量和函数声明，并将它们提升到作用域的顶部，这样在代码执行时就可以访问它们了。</p><p>变量提升的原理是JavaScript引擎在解析代码时，会先处理变量和函数的声明，将它们存储在内存中，然后再执行代码。这样就可以让变量和函数在声明之前就可以被使用了。但是需要注意的是，只有声明会被提升，而不是赋值。因此，如果一个变量在声明之前被使用，它的值将为undefined。</p><h2 id="产生变量提升的原因？"><a href="#产生变量提升的原因？" class="headerlink" title="产生变量提升的原因？"></a>产生变量提升的原因？</h2><p>产生变量提升的原因是JavaScript引擎在解析代码时，会先处理变量和函数的声明，将它们存储在内存中，然后再执行代码。这是由于JavaScript的执行顺序是自上而下的，而变量和函数的声明在代码中可能出现在后面的位置。如果不进行变量提升，那么在使用变量或函数之前必须要先声明，否则会报错。通过变量提升，JavaScript引擎可以在代码执行之前就将变量和函数的声明提前到作用域的顶部，从而让变量和函数在声明之前就可以被使用了。</p><h2 id="什么是执行上下文？"><a href="#什么是执行上下文？" class="headerlink" title="什么是执行上下文？"></a>什么是执行上下文？</h2><p>JavaScript执行上下文是指JavaScript代码在执行时所处的环境，包括变量、函数声明、作用域链、this指向等。每当JavaScript代码开始执行时，都会创建一个新的执行上下文，并将其压入执行上下文栈（Execution Context Stack）中。当代码执行完成后，该执行上下文会被弹出栈并销毁。</p><p>执行上下文包括三种类型：</p><ol><li>全局执行上下文：在代码执行之前就会被创建，它是默认的最外层的执行上下文。</li><li>函数执行上下文：每当一个函数被调用时，都会创建一个新的函数执行上下文。</li><li>Eval执行上下文：eval()函数会在当前作用域中创建一个新的执行上下文。</li></ol><p>执行上下文中包含了当前代码所处的作用域链、变量对象、this指向等信息，这些信息会在代码执行时被用到，从而影响到代码的执行结果。</p><h2 id="词法作用域是什么？"><a href="#词法作用域是什么？" class="headerlink" title="词法作用域是什么？"></a>词法作用域是什么？</h2><p>词法作用域（Lexical Scope），也叫静态作用域，是指<strong>变量的作用域是在代码书写的时候就确定好的，而不是在运行时确定的</strong>。JavaScript就是一种基于词法作用域的语言。</p><p>在词法作用域中，变量的作用域是由函数嵌套关系来决定的。当函数被创建时，它的作用域链就被创建了，作用域链中包含了当前函数和所有嵌套的父级函数的变量对象。当函数执行时，它会先在自己的变量对象中查找变量，如果找不到，就会沿着作用域链一级一级地向上查找，直到找到为止，如果一直到全局作用域都没有找到，就会报错。</p><p>词法作用域的好处是可以避免变量名冲突，因为变量的作用域是在代码书写的时候就确定好的，不会受到运行时的影响。同时，也使得代码的可读性更高，因为变量的作用域是在代码书写的时候就可以看到的，不需要等到运行时才知道。</p><h2 id="环境变量和变量对象是什么？"><a href="#环境变量和变量对象是什么？" class="headerlink" title="环境变量和变量对象是什么？"></a>环境变量和变量对象是什么？</h2><p>环境变量和变量对象都是 JavaScript 中与作用域相关的概念。</p><p>环境变量（Environment Record）是指当前执行上下文中所有变量和函数的声明，以及外部环境的引用。每个执行上下文都有自己的环境变量，它们按照作用域链的顺序组成了一个链式结构，可以通过这个结构访问到所有的变量和函数。</p><p>变量对象（Variable Object）是指当前执行上下文中所有变量和函数的实际存储位置。在全局执行上下文中，变量对象就是全局对象；在函数执行上下文中，变量对象包含了函数的参数、函数声明、变量声明等。变量对象也是按照作用域链的顺序组成了一个链式结构，可以通过这个结构访问到所有的变量和函数。</p><p>在 JavaScript 中，环境变量和变量对象是密切相关的。当一个函数被调用时，会创建一个新的执行上下文，其中包含了一个新的环境变量和变量对象。在函数执行时，会使用环境变量来查找变量和函数的实际存储位置，也就是变量对象。当函数执行完毕后，执行上下文被销毁，其中的环境变量和变量对象也随之被销毁。</p><h2 id="TCP的发送速度是如何得到控制的？"><a href="#TCP的发送速度是如何得到控制的？" class="headerlink" title="TCP的发送速度是如何得到控制的？"></a>TCP的发送速度是如何得到控制的？</h2><ol><li>慢启动算法（Slow Start）：发送方刚开始发送数据时，先发送一小部分数据，然后根据收到的确认消息逐渐增加发送的数据量，以逐渐探测网络的拥塞情况。</li><li>拥塞避免算法（Congestion Avoidance）：当发现网络拥塞时，发送方就会进入拥塞避免阶段，此时发送方会将发送窗口的大小限制在一个较小的值范围内，以避免网络拥塞。</li><li>快重传算法（Fast Retransmit）：当发送方连续发送多个数据包时，如果接收方收到其中一个数据包有丢失或损坏，就会立即发送一个重复确认消息，告诉发送方需要重传该数据包。发送方收到这个重复确认消息后，就会立即重传该数据包，而不是等到超时后再重传，从而加快数据传输速度。</li><li>快恢复算法（Fast Recovery）：当发送方收到重复确认消息时，就会进入快恢复阶段，此时发送方会将发送窗口的大小减半，并重传丢失的数据包，以避免网络拥塞。</li><li>拥塞控制算法（Congestion Control）：TCP中还有一种全局的拥塞控制算法，它通过计算网络的拥塞程度来动态调整发送方的发送速度，以避免网络拥塞。常用的拥塞控制算法有TCP Reno、TCP Vegas、TCP New Reno等。</li></ol><h2 id="什么是CSS样式穿透？有哪些语法？"><a href="#什么是CSS样式穿透？有哪些语法？" class="headerlink" title="什么是CSS样式穿透？有哪些语法？"></a>什么是CSS样式穿透？有哪些语法？</h2><p>CSS样式穿透是指在CSS中，一个选择器可以影响到其他选择器的样式。它允许我们通过一个选择器来改变另一个选择器的样式，从而避免了在HTML中添加额外的类和ID。</p><p><code>&amp;</code>符号：在Less和Sass中，<code>&amp;</code>符号表示当前选择器的父级，可以将当前选择器和父级选择器合并在一起，这样可以影响到父级选择器的样式。例如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>  <span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">color</span>: white;<br>    <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>      <span class="hljs-attribute">background-color</span>: red;<br>      <span class="hljs-selector-class">.sibling</span> <span class="hljs-selector-tag">&amp;</span> &#123;<br>        <span class="hljs-attribute">color</span>: yellow;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="在TCP中有keep-alive，Vue也有keep-alive，Http也有keep-alive，它们都是指什么？"><a href="#在TCP中有keep-alive，Vue也有keep-alive，Http也有keep-alive，它们都是指什么？" class="headerlink" title="在TCP中有keep-alive，Vue也有keep-alive，Http也有keep-alive，它们都是指什么？"></a>在TCP中有keep-alive，Vue也有keep-alive，Http也有keep-alive，它们都是指什么？</h2><ol><li>在TCP协议中，keep-alive是一种保持连接的机制，可以在客户端和服务器之间保持长时间的空闲连接。当客户端和服务器之间没有数据传输时，keep-alive机制会发送一些探测包来检测对方是否还活着，从而确保连接的有效性。这个机制在一些长连接场景下比较常见，例如HTTP长连接、FTP数据传输等。</li><li>在Vue中，keep-alive是一个组件，可以将动态组件进行缓存，以便在切换时可以保留它们的状态或避免重新渲染。这个组件在一些需要频繁切换的场景下比较常见，例如Tab切换、路由切换等。</li><li>在HTTP协议中，keep-alive是一种持久连接机制，可以在客户端和服务器之间保持一个TCP连接，从而避免在每个HTTP请求之间重新建立TCP连接。这个机制可以减少连接建立和关闭的开销，提高HTTP请求的效率，尤其是在一些高并发的Web应用中。</li></ol><h2 id="不同域名指向同一个ip是否是同源的？"><a href="#不同域名指向同一个ip是否是同源的？" class="headerlink" title="不同域名指向同一个ip是否是同源的？"></a>不同域名指向同一个ip是否是同源的？</h2><p>不同域名指向同一个IP地址并不一定是同源的。同源策略是浏览器的一种安全策略，它是指只有当两个页面具有相同的协议、域名和端口号时，才允许这两个页面之间进行交互（例如访问彼此的DOM、Cookie等）。因此，如果两个页面的域名不同，即使它们指向同一个IP地址，也不会被认为是同源的。</p><p>但是，如果在同一个域名下使用不同的子域名（例如a.example.com和b.example.com）指向同一个IP地址，这种情况下它们被认为是同源的，因为它们具有相同的主域名。</p><p>总之，同源策略是根据协议、域名和端口号来判断是否允许跨域访问，而IP地址并不是同源策略的判断依据。</p><h2 id="DFS和BFS的使用场景？"><a href="#DFS和BFS的使用场景？" class="headerlink" title="DFS和BFS的使用场景？"></a>DFS和BFS的使用场景？</h2><p>DFS（深度优先搜索）和BFS（广度优先搜索）都是图遍历算法，它们的使用场景如下：</p><p>DFS使用场景：</p><ul><li>求解连通块问题</li><li>求解迷宫问题</li><li>求解拓扑排序问题</li><li>求解生成树问题</li><li>求解二叉树的遍历问题</li></ul><p>BFS使用场景：</p><ul><li>求解最短路径问题</li><li>求解连通块问题</li><li>求解迷宫问题</li><li>求解拓扑排序问题</li><li>求解生成树问题</li></ul><p>总的来说，DFS更适合解决深度优先的问题，BFS更适合解决广度优先的问题。在实际应用中，需要根据具体问题的特点选择合适的算法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>百度一面</title>
    <link href="/2023/04/12/%E7%99%BE%E5%BA%A6%E4%B8%80%E9%9D%A2/"/>
    <url>/2023/04/12/%E7%99%BE%E5%BA%A6%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="百度一面"><a href="#百度一面" class="headerlink" title="百度一面"></a>百度一面</h1><h2 id="介绍项目"><a href="#介绍项目" class="headerlink" title="介绍项目"></a>介绍项目</h2><h2 id="React如何实现路由缓存的？【项目】"><a href="#React如何实现路由缓存的？【项目】" class="headerlink" title="React如何实现路由缓存的？【项目】"></a><code>React</code>如何实现路由缓存的？【项目】</h2><h2 id="React路由权限控制【项目】"><a href="#React路由权限控制【项目】" class="headerlink" title="React路由权限控制【项目】"></a><code>React</code>路由权限控制【项目】</h2><h2 id="React-Hooks解决了什么问题？有什么优势和限制？"><a href="#React-Hooks解决了什么问题？有什么优势和限制？" class="headerlink" title="React Hooks解决了什么问题？有什么优势和限制？"></a><code>React Hooks</code>解决了什么问题？有什么优势和限制？</h2><p><code>React Hooks</code>解决了在函数组件中管理状态和副作用的问题。以前，函数组件是无状态的，不能使用生命周期方法和<code>state</code>，这意味着无法在函数组件中进行复杂的逻辑和状态管理。使用<code>React Hooks</code>，函数组件可以使用状态和生命周期方法，从而使函数组件具有类组件的能力。</p><p>优势：</p><ol><li>更简洁的代码：使用<code>React Hooks</code>可以减少代码量，使代码更易读。</li><li>更易于测试：使用<code>React Hooks</code>可以减少副作用和状态的耦合，使测试更容易。</li><li>更灵活的逻辑：使用<code>React Hooks</code>可以在函数组件中使用状态和生命周期方法，使逻辑更加灵活。</li><li>更好的性能：使用<code>React Hooks</code>可以减少组件的重新渲染，提高性能。</li></ol><p>限制：</p><ol><li>可能存在性能问题：使用<code>React Hooks</code>可能会导致某些性能问题，需要注意优化。</li><li>可能存在兼容性问题：使用<code>React Hooks</code>可能会存在兼容性问题，需要注意浏览器和React版本的兼容性。</li></ol><h2 id="React-Hooks在使用上有什么限制？"><a href="#React-Hooks在使用上有什么限制？" class="headerlink" title="React Hooks在使用上有什么限制？"></a>React Hooks在使用上有什么限制？</h2><ol><li>只能在函数组件中使用：React Hooks 只能在函数组件中使用，无法在类组件中使用。</li><li>不能在循环、条件语句中使用：React Hooks 必须按照固定的顺序调用，不能在循环、条件语句中使用。</li><li>使用时必须按照约定命名：使用 useState、useEffect 等 React Hooks 时必须按照约定命名，否则会导致无法正常使用。</li><li>不能在普通函数中使用：React Hooks 只能在函数组件中使用，不能在普通函数中使用。</li><li>不能在嵌套组件中使用：React Hooks 只能在最顶层的函数组件中使用，不能在嵌套组件中使用。</li><li>不能在条件渲染的分支中使用：React Hooks 必须在每次渲染时都按照相同的顺序调用，不能在条件渲染的分支中使用。</li><li>不能在 useEffect 中使用 async&#x2F;await：在 useEffect 中使用 async&#x2F;await 会导致一些问题，应该使用 Promise.then()。</li></ol><h2 id="为什么要使用类似React这种MVVM框架？为什么不直接使用原生前端开发？"><a href="#为什么要使用类似React这种MVVM框架？为什么不直接使用原生前端开发？" class="headerlink" title="为什么要使用类似React这种MVVM框架？为什么不直接使用原生前端开发？"></a>为什么要使用类似<code>React</code>这种<code>MVVM</code>框架？为什么不直接使用原生前端开发？</h2><p>使用类似 <code>React</code> 这种 <code>MVVM</code> 框架的主要原因是可以提高前端开发的效率和可维护性。以下是具体的原因：</p><ol><li>组件化开发：<code>React</code> 将页面拆分成多个组件，每个组件负责一部分功能，通过组合和嵌套组件来实现整个页面的功能。这样可以使代码更加模块化和可复用，提高开发效率和代码质量。</li><li>虚拟 DOM：<code>React</code> 使用虚拟 DOM 来代替直接操作 DOM，这样可以避免频繁的 DOM 操作，提高页面性能。</li><li>单向数据流：<code>React</code> 的数据流是单向的，从父组件传递到子组件，这样可以避免数据混乱和难以维护的问题。</li><li>模板语法：<code>React</code> 使用 JSX 语法，可以将组件和数据混合在一起，提高代码可读性和可维护性。</li><li>多平台支持：<code>React</code> 可以用于 Web 开发、移动端开发和桌面端开发，可以实现多平台的代码复用。</li></ol><h2 id="前端直接引入地图SDK会导致页面体积非常大，引起性能问题，如何解决？【项目】"><a href="#前端直接引入地图SDK会导致页面体积非常大，引起性能问题，如何解决？【项目】" class="headerlink" title="前端直接引入地图SDK会导致页面体积非常大，引起性能问题，如何解决？【项目】"></a>前端直接引入地图<code>SDK</code>会导致页面体积非常大，引起性能问题，如何解决？【项目】</h2><ol><li>懒加载：将地图 SDK 的引入延迟到需要使用地图的页面或组件中，这样可以减少页面初始加载时的体积，提高页面加载速度。</li><li>分包加载：将地图 SDK 的引入分离成一个单独的包，只有当用户需要使用地图时才会加载该包，这样可以减小页面的初始加载体积，并且可以使地图相关的代码更容易维护。</li><li>使用第三方库：使用第三方地图库，例如 <code>Mapbox</code>、<code>Leaflet</code> 等，这些库通常提供了更小的文件大小和更高效的加载方式，可以帮助减少页面体积和提高性能。</li><li>服务端渲染：使用服务端渲染技术，将地图相关的代码在服务端生成并输出 HTML，减少客户端的代码量和加载时间。</li><li>CDN 加速：使用 CDN 加速地图 SDK 的加载，可以减少服务器的负担和提高地图 SDK 的加载速度。</li></ol><h2 id="项目开发中遇到过哪些性能问题？如何解决？"><a href="#项目开发中遇到过哪些性能问题？如何解决？" class="headerlink" title="项目开发中遇到过哪些性能问题？如何解决？"></a>项目开发中遇到过哪些性能问题？如何解决？</h2><ol><li><p>首屏加载慢：当用户打开页面时，需要等待很长时间才能看到页面的内容。</p><p>解决方法：使用懒加载技术、减少 HTTP 请求、优化图片大小和格式、合理使用缓存等。</p></li><li><p>页面响应慢：当用户与页面进行交互时，页面响应时间很长，影响用户体验。</p><p>解决方法：使用异步加载技术、优化 JavaScript 代码、减少 DOM 操作、避免频繁的重排和重绘等。</p></li><li><p>大量的 HTTP 请求：当页面需要加载大量的资源时，会产生大量的 HTTP 请求，影响页面的加载速度。</p><p>解决方法：使用合并和压缩技术、使用 CDN 加速、使用 HTTP2 协议等。</p></li><li><p>大量的 JavaScript 和 CSS 文件：当页面需要加载大量的 JavaScript 和 CSS 文件时，也会影响页面的加载速度。</p><p>解决方法：使用合并和压缩技术、使用模块化开发、使用 CSS 预处理器等。</p></li><li><p>内存泄漏：当页面长时间运行时，可能会出现内存泄漏问题，导致页面变得越来越慢。</p><p>解决方法：使用垃圾回收机制、避免循环引用、及时释放不需要的资源等。</p></li></ol><h2 id="项目上线部署流程？"><a href="#项目上线部署流程？" class="headerlink" title="项目上线部署流程？"></a>项目上线部署流程？</h2><ol><li>打包：将前端项目打包成静态资源文件，例如 HTML、CSS、JavaScript、图片等。可以使用 Webpack、Gulp、Grunt 等工具进行打包。</li><li>上传到服务器：将打包好的静态资源文件上传到服务器上，可以使用 FTP、SFTP、SCP、rsync 等工具进行上传。</li><li>配置服务器：根据项目需要，对服务器进行配置，例如安装 Web 服务器、配置域名、SSL 证书、反向代理等。</li><li>启动服务：启动 Web 服务器并将静态资源文件部署到 Web 服务器上，例如使用 Nginx、Apache 等 Web 服务器。</li><li>测试和验证：测试和验证部署的 Web 服务器是否正常工作，例如访问网站、检查日志、排除错误等。</li><li>监控和维护：监控部署的 Web 服务器，确保其稳定运行，并及时处理出现的异常问题。</li></ol><h2 id="是否了解Node-js的EventEmitter事件机制-实现I-x2F-O非阻塞的基础-？"><a href="#是否了解Node-js的EventEmitter事件机制-实现I-x2F-O非阻塞的基础-？" class="headerlink" title="是否了解Node.js的EventEmitter事件机制(实现I&#x2F;O非阻塞的基础)？"></a>是否了解<code>Node.js</code>的<code>EventEmitter</code>事件机制(实现I&#x2F;O非阻塞的基础)？</h2><p><code>EventEmitter</code>是Node.js中一个重要的模块，它提供了一种事件机制，用于实现基于观察者模式的事件处理。它的主要作用是在对象之间建立一种松耦合的联系，使得一个对象在发生某个动作时，可以通知多个对象进行相应的处理。</p><p>在Node.js中，<code>EventEmitter</code>模块是一个核心模块，可以直接使用。使用<code>EventEmitter</code>模块，需要先创建一个事件对象，然后在需要的时候触发事件，并绑定相应的事件处理函数。</p><p>下面是一个简单的例子：</p><p>Copy</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyEmitter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">EventEmitter</span> &#123;&#125;<br><br><span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEmitter</span>();<br>myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;event&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;触发了事件&#x27;</span>);<br>&#125;);<br>myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;event&#x27;</span>);<br></code></pre></td></tr></table></figure><p>上述代码中，我们首先引入<code>events</code>模块，然后创建了一个自定义的事件类<code>MyEmitter</code>，并实例化它为<code>myEmitter</code>。接着，我们在<code>myEmitter</code>上绑定了一个<code>event</code>事件的处理函数，当事件被触发时，会输出<strong>触发了事件</strong>这个字符串。</p><p>在实际使用中，我们可以利用<code>EventEmitter</code>实现很多功能，例如实现自定义事件、异步处理、流处理等。在Node.js中，很多核心模块都是基于事件机制实现的，例如<code>http</code>模块、<code>fs</code>模块等。因此，熟练掌握<code>EventEmitter</code>机制对于Node.js开发非常重要。</p><h2 id="富文本编辑器的选取？"><a href="#富文本编辑器的选取？" class="headerlink" title="富文本编辑器的选取？"></a>富文本编辑器的选取？</h2><h2 id="浏览器输入url到页面渲染出来的整个详细流程？"><a href="#浏览器输入url到页面渲染出来的整个详细流程？" class="headerlink" title="浏览器输入url到页面渲染出来的整个详细流程？"></a>浏览器输入<code>url</code>到页面渲染出来的整个详细流程？</h2><ol><li>首先判断输入的内容是否为合法的域名，如果不是则作为关键字交给搜索引擎进行处理；如果域名中有非法字符则进行转义。</li><li>首先判断浏览器中是否有所需资源的缓存，如果有则直接使用，否则进行DNS查询获取域名对应的IP地址。</li><li>DNS查询<ol><li>判断本地的DNS缓存中是否有该IP地址，如果命中则返回</li><li>如果还是没有命中，则将域名发送到本地域名服务器，本地域名服务器采用递归查询自己的DNS服务器，查找成功则返回。</li><li>如果本地域名服务器的DNS缓存没有命中，则向上级域名服务器进行迭代查询<ul><li>首先本地域名服务器向根域名服务器进行请求，获取顶级域名服务器的地址给本地服务器。</li><li>本地域名服务器拿到这个顶级域名服务器后就想起发送请求，获取权威域名服务器的地址。</li><li>本地域名服务器向权威域名服务器发送请求，获取域名对应的IP地址。</li></ul></li><li>本地域名服务器将得到的IP地址发送给操作系统，同时自己将IP地址缓存起来。</li><li>操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来。</li><li>至此，浏览器得到了域名对应的IP地址，并将IP地址缓存起来。</li></ol></li><li>通过IP地址与本地的子网掩码相与，判断是否与请求主机在一个子网中，如果在一个子网中，则使用ARP协议获取目标主机的MAC地址，如果不在一个子网中，那么请求应该转发给网关，由它代为转发，此时同样可以通过ARP协议获取网关MAC地址，此时目的主机的MAC地址应该为网关地址。</li><li>进行TCP的三次握手</li><li>进行HTTPS握手</li><li><strong>返回数据</strong>：将网页请求发送至服务器端，服务器端返回一个html文件作为响应。浏览器接受响应后，开始对html文件进行解析并开始页面的渲染过程。</li><li><strong>页面渲染</strong>：根据html文件构建DOM树，根据解析到的css构建CSSOM树，如果遇到script标签，则判断有无async和defer属性，否则script的加载和执行会造成页面渲染的阻塞。当DOM树和CSSOM树建立好后，根据他们构建渲染树。渲染树构建好后，根据渲染树进行布局，然后使用浏览器的UI接口对页面进行绘制。此时整个页面就显示出来了。</li><li>TCP四次挥手</li></ol><h2 id="https加密的详细过程？在协商过程中使用的是什么加密？"><a href="#https加密的详细过程？在协商过程中使用的是什么加密？" class="headerlink" title="https加密的详细过程？在协商过程中使用的是什么加密？"></a><code>https</code>加密的详细过程？在协商过程中使用的是什么加密？</h2><ol><li>客户端发送请求：客户端向服务器发送一个HTTPS请求，请求中包含了协议版本、加密算法、随机数等信息。</li><li>服务器证书：服务器向客户端发送自己的证书，证书中包含了服务器公钥、证书颁发机构、证书有效期等信息。</li><li>客户端验证证书：客户端验证服务器证书的合法性，包括验证证书是否过期、证书颁发机构是否受信任、证书中的域名是否与服务器匹配等。</li><li>生成共享密钥：如果服务器证书验证通过，客户端会生成一个随机数作为共享密钥，并使用服务器的公钥加密该密钥，然后发送给服务器。</li><li>服务器解密共享密钥：服务器使用自己的私钥对客户端发送的共享密钥进行解密，得到共享密钥。</li><li>加密通信：客户端和服务器使用共享密钥进行加密通信，通信过程中的数据全部使用共享密钥进行加密和解密。</li></ol><h2 id="数据-HTML、CSS和JS等资源-返回到浏览器后的详细渲染过程？"><a href="#数据-HTML、CSS和JS等资源-返回到浏览器后的详细渲染过程？" class="headerlink" title="数据(HTML、CSS和JS等资源)返回到浏览器后的详细渲染过程？"></a>数据(<code>HTML</code>、<code>CSS</code>和<code>JS</code>等资源)返回到浏览器后的详细渲染过程？</h2><p>当浏览器收到HTML、CSS和JS等资源后，会进行以下渲染过程：</p><ol><li>解析HTML：浏览器会根据HTML文档的结构解析出文档树（DOM树），同时也会解析出CSS文档的样式规则（CSSOM树）。</li><li>构建渲染树：浏览器会将DOM树和CSSOM树结合起来构建渲染树（Render Tree），渲染树只包含需要显示的节点和样式信息。</li><li>布局：浏览器会根据渲染树中每个节点的布局信息（包括位置、大小等）计算出每个节点在屏幕上的位置。</li><li>绘制：浏览器会将渲染树中的每个节点绘制到屏幕上，形成最终的页面展示效果。</li><li>JS执行：如果HTML中包含了JS代码，浏览器会执行这些代码，可能会修改DOM树、CSSOM树以及渲染树等。</li></ol><h2 id="CSS中可以将元素建立单独渲染层，这是什么机制？-CSS中可以为一个元素提供GPU加速，是什么机制？"><a href="#CSS中可以将元素建立单独渲染层，这是什么机制？-CSS中可以为一个元素提供GPU加速，是什么机制？" class="headerlink" title="CSS中可以将元素建立单独渲染层，这是什么机制？(CSS中可以为一个元素提供GPU加速，是什么机制？)"></a><code>CSS</code>中可以将元素建立单独渲染层，这是什么机制？(<code>CSS</code>中可以为一个元素提供<code>GPU</code>加速，是什么机制？)</h2><p>在<code>CSS</code>中，可以通过设置某些属性，将元素建立单独的渲染层，这个机制被称为<strong>GPU加速</strong>或<strong>硬件加速</strong>。</p><p>GPU加速的原理是利用了现代计算机的硬件加速能力，将一些常规的<code>CPU</code>计算任务转移到<code>GPU</code>上进行处理。因为<code>GPU</code>的并行计算能力比<code>CPU</code>强大，所以可以加速页面的渲染速度，提高用户体验。</p><p>在<code>CSS</code>中，可以通过以下属性将元素建立单独的渲染层：</p><ol><li><code>transform</code>属性：通过<code>transform</code>属性对元素进行2D或3D变换，可以触发硬件加速。</li><li><code>opacity</code>属性：通过<code>opacity</code>属性设置元素的透明度，也可以触发硬件加速。</li><li><code>filter</code>属性：通过<code>filter</code>属性对元素进行滤镜效果，也可以触发硬件加速。</li><li><code>will-change</code>属性：通过<code>will-change</code>属性预先告知浏览器哪些属性将会被修改，可以让浏览器提前将元素建立单独的渲染层，从而加速页面渲染。</li></ol><p>需要注意的是，过度使用GPU加速可能会导致性能问题，因为GPU的资源也是有限的。在使用GPU加速时，需要根据实际情况进行优化，避免过度使用。</p><h2 id="有没有了解过TailWindCSS？"><a href="#有没有了解过TailWindCSS？" class="headerlink" title="有没有了解过TailWindCSS？"></a>有没有了解过<code>TailWindCSS</code>？</h2><p>Tailwind CSS是一个“实用优先”的CSS框架，它提供了一系列的样式类，可以用来快速地构建现代化的网站和应用程序。Tailwind CSS的设计理念是遵循“高度可定制”的原则，它提供了一组基础样式类，可以通过组合这些样式类来创建任意复杂度的布局和设计。</p><p>Tailwind CSS的核心思想是使用短小的、可重复使用的样式类来构建UI组件，而不是使用自定义样式表或者内联样式。这种方式可以大大减少代码的重复，并使得样式更易于维护和重构。</p><p>Tailwind CSS提供了一系列的样式类，覆盖了常见的UI组件和布局需求，例如：排版、背景、边框、文本、表格、按钮、表单、响应式布局等。此外，它还提供了一些实用的工具类，例如：间距、宽度、高度、颜色、字体等，可以帮助开发者快速地实现常用的样式效果。</p><p>使用Tailwind CSS可以大大提高开发效率，减少代码量，并且可以快速地构建出具有现代化风格的网站和应用程序。</p><h2 id="ES6有哪些新特性？"><a href="#ES6有哪些新特性？" class="headerlink" title="ES6有哪些新特性？"></a><code>ES6</code>有哪些新特性？</h2><h2 id="Map和WeakMap是基础数据类型吗？"><a href="#Map和WeakMap是基础数据类型吗？" class="headerlink" title="Map和WeakMap是基础数据类型吗？"></a><code>Map</code>和<code>WeakMap</code>是基础数据类型吗？</h2><p>不是，是引用数据类型。</p><h2 id="Map和WeakMap的区别？"><a href="#Map和WeakMap的区别？" class="headerlink" title="Map和WeakMap的区别？"></a><code>Map</code>和<code>WeakMap</code>的区别？</h2><p><code>Map</code>和<code>WeakMap</code>的主要区别在于键的引用类型和引用方式、键值对的垃圾回收机制、以及性能特点方面。</p><ol><li><p>键的引用类型和引用方式</p><p><code>Map</code>的键可以是任意类型的数据，包括基础数据类型和对象。而<code>WeakMap</code>的键必须是对象类型。由于<code>Map</code>的键是强引用的，所以即使键所对应的对象被删除，键值对依然存在。而<code>WeakMap</code>的键是弱引用的，当键所对应的对象被垃圾回收时，键值对也会自动被删除。</p></li><li><p>键值对的垃圾回收机制</p><p><code>Map</code>中的键值对不会被自动删除，只有在手动删除或<code>Map</code>对象被销毁时才会被清空。而<code>WeakMap</code>中的键值对会在键所对应的对象被垃圾回收时自动删除。</p></li><li><p>性能特点</p><p>由于<code>Map</code>的键是强引用的，所以<code>Map</code>的性能相对较高，但是在大量数据存储时，可能会占用较多的内存。而<code>WeakMap</code>的键是弱引用的，所以<code>WeakMap</code>的性能相对较低，但是可以更有效地管理内存，避免内存泄漏。</p></li></ol><p>综上所述，<code>Map</code>适用于需要长期存储大量数据的场景，而<code>WeakMap</code>适用于临时存储数据或需要更有效地管理内存的场景。</p><h2 id="weakMap使用场景？"><a href="#weakMap使用场景？" class="headerlink" title="weakMap使用场景？"></a>weakMap使用场景？</h2><ol><li><p>保护私有属性</p><p>在JavaScript中，对象的属性都是公开的，可以被其他代码访问和修改。但有时我们需要保护一些属性，使其不被外界访问和修改。使用WeakMap可以实现这个目的，因为WeakMap中的数据只能通过键访问，而且键是弱引用，不能被外界访问。</p></li><li><p>避免内存泄漏</p><p>使用WeakMap可以避免内存泄漏，因为WeakMap中的键是弱引用，当键所引用的对象被垃圾回收时，键也会被自动删除，从而避免内存泄漏。</p></li></ol><h2 id="弱引用的好处？使用场景？"><a href="#弱引用的好处？使用场景？" class="headerlink" title="弱引用的好处？使用场景？"></a>弱引用的好处？使用场景？</h2><h3 id="弱引用的优点"><a href="#弱引用的优点" class="headerlink" title="弱引用的优点"></a>弱引用的优点</h3><ol><li><p>避免内存泄漏</p><p>使用弱引用可以避免因为对象之间的循环引用而导致的内存泄漏。当一个对象不再被其他对象引用时，它会被垃圾回收器回收。如果一个对象被其他对象循环引用，即使它们都不再被程序使用，也不会被垃圾回收器回收，从而导致内存泄漏。使用弱引用可以避免这种情况。</p></li><li><p>优化性能</p><p>使用弱引用可以避免过度缓存，优化程序的性能。如果一个对象被缓存起来，但是在程序执行过程中很少被使用，却一直占用内存，会影响程序的性能。使用弱引用可以让缓存的对象在不使用时被垃圾回收器回收，避免浪费内存。</p></li><li><p>简化代码</p><p>使用弱引用可以简化代码，避免手动管理对象的生命周期。弱引用可以让程序自动管理对象的生命周期，减少代码的复杂度和出错的可能性。</p></li></ol><p>总之，弱引用是一种优化程序性能和避免内存泄漏的有效手段，它可以让程序更加健壮、高效和易于维护。</p><h3 id="弱引用使用场景"><a href="#弱引用使用场景" class="headerlink" title="弱引用使用场景"></a>弱引用使用场景</h3><ol><li><p>缓存</p><p>使用弱引用可以避免过度缓存，优化程序的性能。如果一个对象被缓存起来，但是在程序执行过程中很少被使用，却一直占用内存，会影响程序的性能。使用弱引用可以让缓存的对象在不使用时被垃圾回收器回收，避免浪费内存。</p></li><li><p>监听事件</p><p>使用弱引用可以避免因为监听事件而导致的内存泄漏。例如，当一个对象监听了另一个对象的事件，如果不及时取消监听，会导致对象之间的循环引用，从而导致内存泄漏。使用弱引用可以避免这种情况。</p></li><li><p>缓存DOM元素</p><p>在Web开发中，经常需要缓存DOM元素，以避免重复查询。但是，如果缓存的DOM元素不及时释放，会导致内存泄漏。使用弱引用可以避免这种情况，当DOM元素不再被使用时，会被自动释放。</p></li></ol><h2 id="对垃圾回收机制的理解？"><a href="#对垃圾回收机制的理解？" class="headerlink" title="对垃圾回收机制的理解？"></a>对垃圾回收机制的理解？</h2><p>JavaScript的垃圾回收机制是自动的，程序员不需要手动释放内存。垃圾回收机制的主要任务是识别不再使用的内存，然后释放它们，以便让系统可以重复使用这些内存。</p><p>JavaScript中的垃圾回收机制主要有两种方式：标记清除和引用计数。</p><ol><li><p>标记清除</p><p>标记清除是JavaScript中最常用的垃圾回收算法。它的原理是通过标记对象是否可达来判断对象是否还在使用中。当一个对象不再被使用时，垃圾回收器会将其标记为可回收对象，然后在下一次垃圾回收时将其回收。</p><p>标记清除算法的缺点是，当存在循环引用时，垃圾回收器无法判断哪些对象是可达的，哪些对象是不可达的，从而导致内存泄漏。</p></li><li><p>引用计数</p><p>引用计数是一种不常用的垃圾回收算法。它的原理是为每个对象维护一个引用计数器，当对象被引用时，计数器加1；当对象不再被引用时，计数器减1。当计数器为0时，垃圾回收器会将其回收。</p><p>引用计数算法的缺点是，它无法处理循环引用的情况，从而导致内存泄漏。</p></li></ol><p>JavaScript中的垃圾回收机制是自动的，程序员不需要手动释放内存。垃圾回收机制的主要任务是识别不再使用的内存，然后释放它们，以便让系统可以重复使用这些内存。在实际开发中，我们应该尽量避免循环引用的情况，以便让垃圾回收器更好地工作。</p><h2 id="写项目的时候有没有用到哪些设计模式使得代码更加利于修改？"><a href="#写项目的时候有没有用到哪些设计模式使得代码更加利于修改？" class="headerlink" title="写项目的时候有没有用到哪些设计模式使得代码更加利于修改？"></a>写项目的时候有没有用到哪些设计模式使得代码更加利于修改？</h2><ol><li><p>MVC（Model-View-Controller）模式</p><p>MVC模式是一种将应用程序分成三个核心部分的设计模式：模型（Model）、视图（View）和控制器（Controller）。这种模式可以使得代码更加清晰、易于维护和修改，也可以提高代码的重用性和可扩展性。</p></li><li><p>MVVM（Model-View-ViewModel）模式</p><p>MVVM模式是一种MVC模式的变体，它将控制器（Controller）替换为视图模型（ViewModel）。视图模型负责将模型数据转换为视图可以使用的数据，并且可以通过双向绑定来实现数据的自动更新，从而减少了手动操作DOM的代码量。</p></li><li><p>单例模式</p><p>单例模式是一种保证一个类只有一个实例的设计模式。在前端开发中，常用于管理全局状态或资源，例如全局配置、全局事件管理等。</p></li><li><p>装饰者模式</p><p>装饰者模式是一种在不改变原有对象的基础上，动态地给对象增加新的功能的设计模式。在前端开发中，常用于对原有组件进行功能扩展或增强。</p></li><li><p>观察者模式</p><p>观察者模式是一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖它的对象都会得到通知并自动更新。在前端开发中，常用于实现事件监听和发布-订阅模式。</p></li></ol><p>使用这些设计模式可以使前端项目的代码更加易于维护和修改，提高代码的重用性和可扩展性。但是，过度使用设计模式也会增加代码的复杂度，所以需要根据实际情况选择合适的设计模式。</p><h2 id="git合并commit有哪几种方式？"><a href="#git合并commit有哪几种方式？" class="headerlink" title="git合并commit有哪几种方式？"></a><code>git</code>合并<code>commit</code>有哪几种方式？</h2><p>git merge</p><p>git merge 会新建一个新的 commit 对象，然后两个分支以前的 commit 记录都指向这个新 commit 记录。这种方法会保留之前每个分支的 commit 历史。</p><p>git rebase</p><p>git rebase 会先找到两个分支的第一个共同的 commit 祖先记录，然后将提取当前分支这之后的所有 commit 记录，然后将这个 commit 记录添加到目标分支的最新提交后面。经过这个合并后，两个分支合并后的 commit 记录就变为了线性的记录了。</p><h2 id="有没有使用过单元测试工具或代码检查？"><a href="#有没有使用过单元测试工具或代码检查？" class="headerlink" title="有没有使用过单元测试工具或代码检查？"></a>有没有使用过单元测试工具或代码检查？</h2><ol><li>Jest：Facebook 开源的 JavaScript 测试框架，支持单元测试、集成测试和快照测试等。</li><li>Mocha：一个功能丰富的 JavaScript 测试框架，支持异步测试、前端和后端测试，以及 BDD 和 TDD 等测试风格。</li><li>Jasmine：一个行为驱动开发（BDD）框架，支持浏览器和 Node.js 等环境，可以进行单元测试、集成测试和端到端测试。</li><li>Karma：一个测试运行器，可以在多个浏览器和平台上运行测试，并支持与其他测试框架集成。</li><li>Enzyme：一个 React 组件测试工具，可以方便地进行组件渲染、事件模拟和快照测试等。</li><li>Ava：一个快速、轻量级的测试框架，支持并行测试和异步测试，可以在浏览器和 Node.js 等环境下运行。</li><li>Puppeteer：一个由 Google 开发的自动化测试工具，可以模拟用户操作和浏览器环境，用于进行端到端测试。</li><li>Cypress：一个端到端测试工具，具有自动重试、实时重载和可视化测试等功能，可以在浏览器中运行测试。</li></ol><h2 id="ESLint代码检查原理？"><a href="#ESLint代码检查原理？" class="headerlink" title="ESLint代码检查原理？"></a>ESLint代码检查原理？</h2><p>ESLint是一个开源的JavaScript代码检查工具，它可以检查代码的语法错误、代码风格、潜在的错误等。ESLint的核心原理是基于抽象语法树（AST）来检查代码。</p><p>ESLint会将代码解析成AST，然后通过遍历AST节点来检查代码，检查的规则由配置文件中的规则集合定义。ESLint的规则集合包括官方规则和第三方规则，可以根据需要自定义规则。</p><p>在检查代码时，ESLint会根据规则集合中的规则来判断代码是否符合规范，如果不符合则输出错误或警告信息。ESLint还支持自动修复代码中的一些问题，可以通过–fix选项来修复代码中的问题。</p><p>ESLint的检查原理可以总结为以下几个步骤：</p><ol><li>将代码解析成AST。</li><li>遍历AST节点，根据规则集合中的规则判断代码是否符合规范。</li><li>如果代码不符合规范，则输出错误或警告信息。</li><li>如果需要，可以通过–fix选项来自动修复代码中的问题。</li></ol><p>总之，ESLint的检查原理基于抽象语法树（AST）来检查代码，可以根据规则集合中的规则来判断代码是否符合规范。</p><h2 id="bebel将ES6转换为ES5的流程？"><a href="#bebel将ES6转换为ES5的流程？" class="headerlink" title="bebel将ES6转换为ES5的流程？"></a><code>bebel</code>将<code>ES6</code>转换为<code>ES5</code>的流程？</h2><ol><li>Babel首先读取ES6代码并将其转换为一个字符串。</li><li>然后，Babel使用解析器将字符串转换为AST。</li><li>Babel会遍历AST并应用配置的插件和预设来转换代码。每个插件都会检查AST节点并决定是否需要修改它。如果需要修改，插件会返回新的AST节点以替换原来的节点。</li><li>转换后，Babel会将AST转换回代码字符串。</li><li>最后，Babel会将ES5代码写入文件或输出到控制台。</li></ol><h2 id="设计一个Button组件，要求点击按钮发起一个POST请求，当请求结束后通知给父组件。"><a href="#设计一个Button组件，要求点击按钮发起一个POST请求，当请求结束后通知给父组件。" class="headerlink" title="设计一个Button组件，要求点击按钮发起一个POST请求，当请求结束后通知给父组件。"></a>设计一个<code>Button</code>组件，要求点击按钮发起一个<code>POST</code>请求，当请求结束后通知给父组件。</h2><ul><li>该请求耗时很长</li><li><code>POST</code>请求非幂等</li></ul><p>以下是一个简单的React <code>Button</code>组件的实现，满足上述要求：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> [loading, setLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(props.<span class="hljs-property">url</span>, &#123;<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>        <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(props.<span class="hljs-property">data</span>),<br>        <span class="hljs-attr">headers</span>: &#123;<br>          <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>        &#125;<br>      &#125;);<br>      <span class="hljs-keyword">if</span> (response.<span class="hljs-property">ok</span>) &#123;<br>        props.<span class="hljs-title function_">onSuccess</span>();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        props.<span class="hljs-title function_">onError</span>();<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      props.<span class="hljs-title function_">onError</span>();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>);<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span> <span class="hljs-attr">disabled</span>=<span class="hljs-string">&#123;loading&#125;</span>&gt;</span></span><br><span class="language-xml">      &#123;loading ? &#x27;Loading...&#x27; : props.label&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Button</span>;<br></code></pre></td></tr></table></figure><p>该组件接受以下属性：</p><ul><li><code>url</code>：<code>POST</code>请求的URL。</li><li><code>data</code>：要发送的数据。</li><li><code>label</code>：按钮上显示的文本。</li><li><code>onSuccess</code>：请求成功后的回调函数。</li><li><code>onError</code>：请求失败后的回调函数。</li></ul><p>该组件使用了React的状态钩子来管理按钮的加载状态，当按钮被点击时，它会设置<code>loading</code>状态为<code>true</code>并发起<code>POST</code>请求。如果请求成功，它会调用<code>props.onSuccess</code>回调函数，否则调用<code>props.onError</code>回调函数。无论请求成功与否，它都会将<code>loading</code>状态设置为<code>false</code>，以使按钮再次可用。</p><p>该组件可以在父组件中使用，如下所示：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Button&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSuccess</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Request succeeded!&#x27;</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleError</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Request failed!&#x27;</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;https://example.com/api&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">name:</span> &#x27;<span class="hljs-attr">John</span>&#x27; &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;Submit&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onSuccess</span>=<span class="hljs-string">&#123;handleSuccess&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onError</span>=<span class="hljs-string">&#123;handleError&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p>在这个例子中，当<code>Button</code>被点击时，它会向<code>https://example.com/api</code>发送一个<code>POST</code>请求，并将<code>&#123; name: &#39;John&#39; &#125;</code>作为请求体。如果请求成功，它会弹出一个消息框显示<code>Request succeeded!</code>，否则显示<code>Request failed!</code>。注意，这个例子并没有考虑请求的幂等性和请求耗时较长的情况，这些问题需要根据具体情况进行处理。</p><h2 id="了解过哪些前端新知识？"><a href="#了解过哪些前端新知识？" class="headerlink" title="了解过哪些前端新知识？"></a>了解过哪些前端新知识？</h2>]]></content>
    
    
    
    <tags>
      
      <tag>性能优化</tag>
      
      <tag>前端|面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识点整理(6)</title>
    <link href="/2023/04/12/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-6/"/>
    <url>/2023/04/12/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-6/</url>
    
    <content type="html"><![CDATA[<h1 id="知识点整理-6"><a href="#知识点整理-6" class="headerlink" title="知识点整理(6)"></a>知识点整理(6)</h1><h2 id="callback、Promise和async-x2F-await三者间的区别？"><a href="#callback、Promise和async-x2F-await三者间的区别？" class="headerlink" title="callback、Promise和async&#x2F;await三者间的区别？"></a>callback、Promise和async&#x2F;await三者间的区别？</h2><ol><li>callback是一种传统的处理异步操作的方式，通过将一个函数作为参数传递给另一个函数，在异步操作完成后调用该函数来处理异步操作的结果。callback的缺点是，<strong>如果嵌套过多，会形成回调地狱，代码难以维护</strong>。</li><li>Promise是ES6中提出的一种处理异步操作的方式，它可以更好地处理异步操作的结果。Promise可以链式调用，避免了回调地狱的问题，同时还可以更好地处理错误。Promise有三种状态：pending、fulfilled和rejected，可以通过then()和catch()方法来处理异步操作的结果。</li><li>async&#x2F;await是ES8中提出的一种基于Promise的异步编程方式。async函数返回一个Promise对象，可以使用await关键字来等待异步操作的结果，使得异步代码看起来更像同步代码。async&#x2F;await通过将异步操作转换为同步操作来实现异步编程的效果。</li></ol><h2 id="如何避免样式干扰？"><a href="#如何避免样式干扰？" class="headerlink" title="如何避免样式干扰？"></a>如何避免样式干扰？</h2><p>样式干扰通常是由于CSS选择器不当或者CSS权重过高导致的。</p><p>以下是几种防止样式干扰的方法：</p><ol><li>使用更具体的CSS选择器：使用更具体的CSS选择器可以减少样式冲突的风险。例如，使用类选择器 <code>.my-component .my-button</code> 而不是 <code>.my-button</code> 。</li><li>使用CSS模块化：CSS模块化可以将CSS代码封装在组件内，避免全局样式的污染。例如，使用CSS Modules或CSS-in-JS等技术。</li><li>使用CSS预处理器：CSS预处理器可以帮助我们编写更清晰、更易维护的CSS代码，并且可以避免CSS选择器的冲突。例如，使用Less、Sass等预处理器。</li><li>使用CSS命名规范：使用一致的CSS命名规范可以避免命名冲突。例如，使用BEM命名规范。</li><li>使用!important规则：使用!important规则可以提高CSS样式的权重，但是应该尽量避免使用它。如果必须使用!important规则，应该将其用在极少数情况下，并确保它不会影响其他组件的样式。</li></ol><h2 id="使用CSS的动画属性-animation和translate-会引起回流和重绘吗？"><a href="#使用CSS的动画属性-animation和translate-会引起回流和重绘吗？" class="headerlink" title="使用CSS的动画属性(animation和translate)会引起回流和重绘吗？"></a>使用CSS的动画属性(animation和translate)会引起回流和重绘吗？</h2><p><code>animation</code>属性可以通过改变元素的位置、大小、颜色等属性来实现动画效果，这些改变会导致元素的布局（位置和大小）和绘制（颜色和背景）属性发生变化，因此可能会引起回流和重绘。</p><p><code>translate</code>属性可以通过改变元素的位置来实现动画效果，这些改变也会导致元素的布局属性发生变化，因此可能会引起回流。</p><p>然而，相对于其他属性（如改变元素的宽高），使用<code>translate</code>属性进行动画效果的性能更高，因为它只会引起元素的复合（Compositing）和绘制（Painting），而不会引起布局（Layout）的改变，从而减少了回流的可能性。因此，建议在实现动画效果时尽可能使用<code>translate</code>属性。</p><h2 id="JS如何阻止冒泡？"><a href="#JS如何阻止冒泡？" class="headerlink" title="JS如何阻止冒泡？"></a>JS如何阻止冒泡？</h2><p>在JS中，可以使用<code>event.stopPropagation()</code>方法来阻止事件冒泡。</p><p>事件冒泡是指当一个元素上的事件被触发时，该事件会向上冒泡到父元素，直到冒泡到文档根节点为止。如果希望阻止事件冒泡，可以在事件处理函数中使用<code>event.stopPropagation()</code>方法来阻止事件继续向上冒泡。</p><p>例如，以下代码可以阻止按钮点击事件冒泡到父元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.parent&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Parent element clicked.&#x27;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.child&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Child element clicked.&#x27;</span>);<br>  event.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// 阻止事件冒泡</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>在上面的代码中，当点击子元素时，<code>event.stopPropagation()</code>方法会阻止事件继续向上冒泡到父元素，因此只会触发子元素的点击事件处理函数，而不会触发父元素的点击事件处理函数。</p><h2 id="怎么设置padding、border不会撑开盒子？"><a href="#怎么设置padding、border不会撑开盒子？" class="headerlink" title="怎么设置padding、border不会撑开盒子？"></a>怎么设置padding、border不会撑开盒子？</h2><p>如果要设置<code>padding</code>和<code>border</code>不会撑开盒子，可以使用<code>box-sizing</code>属性来改变盒模型的计算方式。默认情况下，盒模型的计算方式是<code>content-box</code>(标准盒模型)，即宽度只包括内容区域，不包括内边距和边框。而如果将<code>box-sizing</code>属性设置为<code>border-box</code>(怪异盒模型)，则宽度包括内容区域、内边距和边框的宽度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: border-box; <span class="hljs-comment">/* 将盒模型设置为border-box */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样设置之后，元素的实际宽度就是200px，包括内边距和边框的宽度。而不会因为内边距和边框的宽度而撑开盒子。</p><h2 id="常用的Webpack-plugin有哪些？"><a href="#常用的Webpack-plugin有哪些？" class="headerlink" title="常用的Webpack plugin有哪些？"></a>常用的Webpack plugin有哪些？</h2><ol><li>HtmlWebpackPlugin：自动生成HTML文件，包括引入打包后的JS、CSS文件等。</li><li>MiniCssExtractPlugin：将CSS从打包后的JS中分离出来，生成单独的CSS文件。</li><li>CleanWebpackPlugin：在每次打包时清除之前生成的文件。</li><li>CopyWebpackPlugin：将文件从源目录复制到目标目录。</li><li>DefinePlugin：定义全局变量，可以在代码中直接使用。</li><li>UglifyJsPlugin：压缩JS代码，减小文件体积。</li><li>HotModuleReplacementPlugin：实现热更新，修改代码后无需刷新页面即可看到效果。</li><li>ExtractTextWebpackPlugin：将CSS从打包后的JS中分离出来，生成单独的CSS文件。</li><li>ProvidePlugin：自动加载模块，无需import或require。</li><li>BundleAnalyzerPlugin：分析打包后的文件大小，找出体积较大的模块。</li></ol><h2 id="CSS如何隐藏元素？"><a href="#CSS如何隐藏元素？" class="headerlink" title="CSS如何隐藏元素？"></a>CSS如何隐藏元素？</h2><ul><li><code>diaplay: none</code>：元素从页面移除，不占用空间，但是会破坏文档流，影响其他元素布局。</li><li><code>visibility: hidden</code>：元素隐藏，但是不会从文档流移除，仍然占用空间。</li><li><code>opacity: 0</code>：元素透明度设置为0，但是仍然占用空间，也会被屏幕阅读器识别。</li><li><code>position: absolute</code>，将元素移动到屏幕外面，不会影响布局，但是仍然占用空间，也会被屏幕阅读器识别。</li></ul><h2 id="前端性能优化的过程和具体方法？"><a href="#前端性能优化的过程和具体方法？" class="headerlink" title="前端性能优化的过程和具体方法？"></a>前端性能优化的过程和具体方法？</h2><p>前端性能优化的过程可以分为以下几个步骤：</p><ol><li>分析性能瓶颈：使用浏览器的开发者工具或第三方工具来分析页面性能，例如 Chrome DevTools、Lighthouse、PageSpeed Insights 等。</li><li>识别优化机会：根据分析结果，识别出需要优化的关键资源，例如 JavaScript、CSS、图片等。</li><li>制定优化策略：根据优化机会，制定相应的优化策略，例如缩小文件大小、减少 HTTP 请求、使用缓存等。</li><li>实施优化方案：根据制定的优化策略，实施具体的优化方案。</li><li>测试和监控：对优化后的页面进行测试和监控，确保优化效果。</li></ol><p>具体的优化方法包括：</p><ol><li>压缩代码：使用压缩工具压缩 JavaScript、CSS、HTML 代码，减小文件大小，加快加载速度。</li><li>减少 HTTP 请求：将多个小文件合并为一个大文件，减少 HTTP 请求次数。</li><li>使用缓存：使用浏览器缓存或服务器缓存来减少文件加载时间。</li><li>延迟加载：将不必要的资源延迟加载，例如图片、视频等。</li><li>使用图片压缩：使用图片压缩工具将图片压缩，减小文件大小，加快加载速度。</li><li>使用 CDN：使用 CDN（内容分发网络）来加速文件加载速度。</li><li>使用 Web Workers：使用 Web Workers 来在后台运行 JavaScript 代码，提高页面响应速度。</li><li>避免重排和重绘：避免频繁的 DOM 操作和样式修改，减少浏览器的重排和重绘次数。</li><li>使用异步加载：使用异步加载技术，例如 async 和 defer 属性来加快页面加载速度。</li><li>优化图片大小：使用合适的图片格式和尺寸，减小图片大小，加快加载速度。</li></ol><h2 id="如何监控性能指标？"><a href="#如何监控性能指标？" class="headerlink" title="如何监控性能指标？"></a>如何监控性能指标？</h2><p>前端监控性能指标可以通过以下几种方式实现：</p><ol><li>使用浏览器自带的开发者工具，如Chrome DevTools、Firefox Developer Tools等，通过Performance面板可以监控页面的加载、解析、渲染等过程的性能指标，如网络请求时间、DOMContentLoaded时间、首次渲染时间等。</li><li>使用第三方性能监控工具，如Google Analytics、New Relic、AppDynamics等，这些工具可以在网站代码中嵌入一段JavaScript代码，通过前端代码监控页面的性能指标，并将数据发送到后台进行分析和展示。</li><li>使用性能指标监控库，如Performance.js、Metrics.js等，这些库可以通过JavaScript代码监控页面的性能指标，并提供API接口让开发者可以自定义监控指标和展示方式。</li><li>使用前端性能监控服务，如SpeedCurve、Pingdom等，这些服务可以在多个地点模拟用户访问网站，并监控页面的性能指标，同时提供报告和分析工具，帮助开发者优化页面性能。</li></ol><h2 id="Webpack5有哪些新特性？"><a href="#Webpack5有哪些新特性？" class="headerlink" title="Webpack5有哪些新特性？"></a>Webpack5有哪些新特性？</h2><ol><li>支持Module Federation：Module Federation是Webpack5中的一个新特性，它允许多个独立的Webpack构建共享模块，从而实现跨域共享模块的能力。</li><li>支持持久化缓存：Webpack5引入了持久化缓存，可以将编译过程中的中间结果缓存到本地磁盘上，从而提高二次构建的速度。</li><li>支持WebAssembly：Webpack5对WebAssembly提供了原生支持，可以将WebAssembly模块打包为单独的chunk，从而提高应用程序的性能。</li><li>支持Tree Shaking优化：Webpack5对Tree Shaking优化进行了改进，可以更精确地识别和移除无用代码。</li><li>支持Top-level await：Webpack5支持Top-level await，可以在模块顶层使用await关键字，从而简化异步代码的写法。</li></ol><h2 id="Webpack4相比3有哪些新特性？"><a href="#Webpack4相比3有哪些新特性？" class="headerlink" title="Webpack4相比3有哪些新特性？"></a>Webpack4相比3有哪些新特性？</h2><ol><li>Webpack4引入了Mode选项，可以通过设置Mode为development或production来自动启用不同的优化策略。</li><li>Webpack4<strong>对代码分割进行了优化，可以更好地支持动态导入和异步加载</strong>。</li><li>Webpack4<strong>对性能优化进行了改进，可以更快地进行编译和构建</strong>。</li><li>Webpack4支持多种文件格式的导入和导出，如JSON、WebAssembly等。</li><li>Webpack4对API进行了改进，提供了更好的插件和Loader接口。</li></ol><h2 id="Webpack3更新了哪些？"><a href="#Webpack3更新了哪些？" class="headerlink" title="Webpack3更新了哪些？"></a>Webpack3更新了哪些？</h2><ol><li><strong>Scope Hoisting</strong>：Webpack3引入了Scope Hoisting功能，可以将模块的作用域提升，从而减少代码量，提高性能。</li><li>Magic Comments：Webpack3支持Magic Comments，可以通过在代码中添加特殊注释来控制chunk的生成和命名。</li><li><strong>动态import</strong>：Webpack3支持动态import，可以在运行时动态加载模块，从而提高应用程序的性能和灵活性。</li><li>CommonChunkPlugin：Webpack3对CommonChunkPlugin进行了优化，可以更灵活地配置和使用。</li><li>Loader Options：Webpack3引入了Loader Options功能，可以在配置文件中为Loader设置选项，从而更方便地进行定制化配置。</li><li>NamedModulesPlugin：Webpack3引入了NamedModulesPlugin插件，可以为模块和chunk生成可读性更好的名称。</li><li><strong>配置文件优化</strong>：Webpack3对配置文件进行了优化，可以更方便地进行模块解析、路径映射、文件处理等操作。</li></ol><h2 id="Webpack3、4、5版本有哪些差异？"><a href="#Webpack3、4、5版本有哪些差异？" class="headerlink" title="Webpack3、4、5版本有哪些差异？"></a>Webpack3、4、5版本有哪些差异？</h2><ol><li>性能：Webpack4和Webpack5相比于Webpack3，在构建速度和性能优化方面有了很大的提升，尤其是Webpack5更加注重性能优化，引入了持久化缓存和Module Federation等功能。</li><li>模块热替换：Webpack4和Webpack5相比于Webpack3，在模块热替换方面有所改进，提供了更好的开发体验。</li><li>Tree Shaking：Webpack4和Webpack5相比于Webpack3，在Tree Shaking方面有了更好的支持，可以更精确地识别和移除无用代码。</li><li>Mode选项：Webpack4引入了Mode选项，可以通过设置Mode为development或production来自动启用不同的优化策略。</li><li>WebAssembly：Webpack5对WebAssembly提供了原生支持，可以将WebAssembly模块打包为单独的chunk，从而提高应用程序的性能。</li><li>Top-level await：Webpack5支持Top-level await，可以在模块顶层使用await关键字，从而简化异步代码的写法。</li><li>插件和Loader：Webpack4和Webpack5相比于Webpack3，在插件和Loader方面提供了更好的接口和扩展性。</li></ol><h2 id="JS常用的压缩工具？"><a href="#JS常用的压缩工具？" class="headerlink" title="JS常用的压缩工具？"></a>JS常用的压缩工具？</h2><ol><li>UglifyJS：UglifyJS是一个广泛使用的JavaScript压缩工具，它可以将JavaScript代码压缩成更小、更高效的形式，从而提高网页的性能。它支持ES6语法，并且可以在命令行或者作为Gulp、Grunt等构建工具的插件使用。</li><li>Closure Compiler：Closure Compiler是Google开发的JavaScript压缩工具，可以将JavaScript代码压缩成更小的形式，并且可以进行代码优化和错误检查。它支持ES6语法和模块化，并且可以在命令行或者作为Gulp、Grunt等构建工具的插件使用。</li><li>Babel-minify：Babel-minify是一个基于Babel的JavaScript压缩工具，可以将JavaScript代码压缩成更小、更高效的形式。它支持ES6语法和模块化，并且可以在命令行或者作为Gulp、Grunt等构建工具的插件使用。</li><li>Terser：Terser是一个JavaScript压缩工具，可以将JavaScript代码压缩成更小、更高效的形式。它支持ES6语法和模块化，并且可以在命令行或者作为Gulp、Grunt等构建工具的插件使用。</li></ol><h2 id="JS进行压缩的原理是什么？"><a href="#JS进行压缩的原理是什么？" class="headerlink" title="JS进行压缩的原理是什么？"></a>JS进行压缩的原理是什么？</h2><p>JS压缩的原理是通过<strong>删除JavaScript代码中的空格、注释、不必要的分号和换行符等无用字符</strong>，以及<strong>将变量名、函数名等重复的内容替换成更短的名称</strong>来减小文件大小。这样可以<strong>减少文件的加载时间和网络传输的流量，提高网页的性能</strong>。</p><p>JS压缩工具一般分为两种压缩方式：</p><ol><li>基于词法分析的压缩方式：这种方式通过对JavaScript代码进行词法分析，找出其中的关键字、变量名、函数名等，然后将其替换成更短的名称，同时删除无用的字符和注释，从而减小文件大小。常用的JS压缩工具如UglifyJS和Closure Compiler都是基于词法分析的压缩方式。</li><li>基于语法分析的压缩方式：这种方式通过对JavaScript代码进行语法分析，找出其中的无用代码、重复代码等，然后将其删除或合并，同时进行变量名、函数名等的替换和删除无用的字符和注释，从而减小文件大小。常用的JS压缩工具如Babel-minify和Terser都是基于语法分析的压缩方式。</li></ol><h2 id="UglifyJS和Terser的区别？"><a href="#UglifyJS和Terser的区别？" class="headerlink" title="UglifyJS和Terser的区别？"></a>UglifyJS和Terser的区别？</h2><ol><li>压缩效率：Terser相对于UglifyJS来说，能够更好地压缩JavaScript代码，生成的压缩文件体积更小。</li><li>ES6+支持：Terser支持ES6+语法，包括箭头函数、模板字符串、解构赋值等，而UglifyJS只支持ES5语法。</li><li>代码质量：Terser生成的代码质量更高，更容易维护和调试，而UglifyJS在某些情况下可能会生成一些难以阅读的代码。</li><li>插件支持：Terser支持插件机制，可以使用插件对JavaScript代码进行更细致的优化和压缩，而UglifyJS没有插件机制。</li><li>平台支持：Terser支持多种平台，包括Node.js、浏览器、Webpack等，而UglifyJS主要是针对浏览器环境进行优化。</li></ol><h2 id="为什么Terser压缩的代码更小？"><a href="#为什么Terser压缩的代码更小？" class="headerlink" title="为什么Terser压缩的代码更小？"></a>为什么Terser压缩的代码更小？</h2><ol><li>更好的算法：Terser采用了更先进的压缩算法，例如更好的代码分析和优化，更多的死代码消除等，能够更好地识别和删除不必要的代码，从而生成更小的压缩文件。</li><li>ES6+支持：Terser能够支持ES6+语法，包括箭头函数、模板字符串、解构赋值等，能够更好地处理新的语法特性，从而生成更小的压缩文件。</li><li>代码优化：Terser能够对代码进行更深入的优化，例如内联函数、变量重命名、常量替换等，从而进一步减小代码体积。</li></ol><h2 id="什么是SSR？"><a href="#什么是SSR？" class="headerlink" title="什么是SSR？"></a>什么是SSR？</h2><p>SSR，全称为Server Side Rendering，即服务器端渲染。它是指在<strong>服务器端生成HTML代码，然后将其发送到浏览器端进行展示</strong>的一种技术。</p><p>在传统的前端开发中，所有的HTML、CSS和JavaScript代码都是在浏览器端进行渲染的，这种方式被称作客户端渲染（CSR）。但是，随着Web应用程序的复杂性不断增加，客户端渲染会带来一些问题，例如：</p><ol><li>首屏加载慢：因为需要等待所有的JavaScript代码加载完成后才能进行页面渲染，用户需要等待较长时间才能看到页面内容。</li><li>SEO不友好：由于搜索引擎爬虫无法执行JavaScript代码，因此客户端渲染的页面对SEO不友好。</li><li>用户体验差：由于需要等待JavaScript代码加载完成后才能进行页面渲染，因此会出现白屏或者Loading页面，用户体验较差。</li></ol><p>SSR技术就是为了解决这些问题而提出的。通过在服务器端生成HTML代码，可以<strong>大大缩短首屏加载时间，提高SEO友好性，改善用户体验</strong>。同时，由于服务器端生成的HTML代码已经包含了页面内容，因此<strong>不需要等待JavaScript代码加载完成，可以直接展示给用户</strong>。</p><h2 id="执行npm-install后发生了什么？"><a href="#执行npm-install后发生了什么？" class="headerlink" title="执行npm install后发生了什么？"></a>执行npm install后发生了什么？</h2><ol><li>检查package.json文件，确定需要安装的模块和版本号。</li><li>从npm仓库中下载指定版本的模块，并将其存储在本地的node_modules目录中。</li><li>如果package.json文件中定义了依赖关系，npm会递归地安装这些依赖模块，直到所有的依赖关系都被满足。</li><li>如果package.json文件中定义了开发环境依赖关系，npm会将这些模块安装在node_modules&#x2F;.dev目录中，而不是node_modules目录中。</li><li>如果npm在安装过程中发现了与当前包管理器版本不兼容的模块，它会尝试自动修复这些模块。</li><li>安装完成后，npm会在本地生成一个package-lock.json文件，用于记录所有安装的模块及其版本号，以便在以后重新安装时保证一致性。</li></ol><h2 id="执行npm-run-start后发生了什么？"><a href="#执行npm-run-start后发生了什么？" class="headerlink" title="执行npm run start后发生了什么？"></a>执行npm run start后发生了什么？</h2><ol><li>npm会查找package.json文件中scripts对象中名为”start”的脚本，并执行该脚本命令。</li><li>根据scripts对象中的”start”命令，npm会执行相应的命令，如”node server.js”或”webpack-dev-server”等。</li><li>如果”start”命令中包含了其他命令，如”prestart”或”poststart”，npm会先执行这些命令，再执行”start”命令。</li><li>如果”start”命令中包含了环境变量，npm会将这些变量传递给执行的命令。</li><li>如果在执行过程中出现错误，npm会显示相应的错误信息，并停止执行。</li></ol><h2 id="前端如何适配手机端？怎么知道当前设备是手机端？"><a href="#前端如何适配手机端？怎么知道当前设备是手机端？" class="headerlink" title="前端如何适配手机端？怎么知道当前设备是手机端？"></a>前端如何适配手机端？怎么知道当前设备是手机端？</h2><p>前端适配手机端主要有以下几种方式：</p><ol><li>使用响应式设计：通过CSS3的媒体查询，根据不同的屏幕尺寸和设备类型，动态调整网页布局和样式。</li><li>使用移动端框架：如Bootstrap、Foundation、Ant Design Mobile等，这些框架提供了一些常用的组件和布局，可以快速构建移动端应用。</li><li>使用Viewport：设置Viewport的meta标签，可以让网页自适应不同的设备屏幕尺寸。</li><li>使用Flexbox布局：使用Flexbox布局可以更方便地实现自适应布局。</li><li>通过JavaScript判断设备类型：可以通过navigator.userAgent判断当前设备的类型和浏览器信息，从而根据不同的设备类型，选择不同的布局和样式。</li></ol><p>判断当前设备是手机端，可以通过以下几种方式：</p><ol><li>使用CSS3的媒体查询，根据不同的屏幕尺寸和设备类型，判断当前设备是手机端还是PC端。</li><li>使用JavaScript判断设备类型，通过navigator.userAgent判断当前设备的类型和浏览器信息，从而判断当前设备是手机端还是PC端。</li><li>使用第三方库或工具，如Device.js、Detector.js等，这些库可以根据设备类型、分辨率、屏幕尺寸等信息，判断当前设备是手机端还是PC端。</li></ol><h2 id="什么是SEO？"><a href="#什么是SEO？" class="headerlink" title="什么是SEO？"></a>什么是SEO？</h2><p>SEO（Search Engine Optimization）是指通过各种技术手段，优化网站结构、内容、外部链接等因素，提高网站在搜索引擎中的排名，从而获得更多的有机流量和用户。SEO主要分为以下几个方面：</p><ol><li>网站结构优化：包括网站的URL结构、页面标题、Meta标签、HTML标签等的优化，以便搜索引擎更好地理解和抓取网站内容。</li><li>内容优化：包括网站内容的质量、关键词密度、标题、描述、图片等的优化，以提高网站的相关性和权威性。</li><li>外部链接优化：包括外部链接的质量、数量、来源、锚文本等的优化，以提高网站的权重和流量。</li><li>移动端优化：包括网站的响应式设计、页面加载速度、移动端友好性等的优化，以适应移动互联网时代的需求。</li><li>社交媒体优化：包括网站在社交媒体上的活跃度、分享度、关注度等的优化，以提高网站的曝光度和口碑效应。</li></ol><p>SEO的优化需要综合考虑多个因素，包括用户体验、搜索引擎算法、竞争对手等，需要长期持续地进行优化和调整。</p><h2 id="SEO的优化有哪些方法？"><a href="#SEO的优化有哪些方法？" class="headerlink" title="SEO的优化有哪些方法？"></a>SEO的优化有哪些方法？</h2><ol><li>关键词优化：通过研究用户搜索行为和竞争对手情况，确定关键词，并将其合理地分布在网站的标题、内容、Meta标签等位置，以提高网站的相关性和排名。</li><li>内容优化：通过提高网站内容的质量和原创性，增加关键词密度和标题、描述等元素的优化，以提高网站的权威性和吸引力。</li><li>网站结构优化：通过优化网站的URL、HTML标签、网站结构等，使搜索引擎更好地识别和抓取网站内容，提高网站的可访问性和相关性。</li><li>外部链接优化：通过获取高质量的外部链接，提高网站的权重和流量，并避免使用无效或违规的链接方式。</li><li>移动端优化：通过响应式设计、页面加载速度、移动端友好性等方式，提高移动端用户的体验和访问量。</li><li>社交媒体优化：通过在社交媒体上活跃、分享、关注等方式，提高网站的曝光度和口碑效应。</li></ol><h2 id="如何正则匹配一个手机号？"><a href="#如何正则匹配一个手机号？" class="headerlink" title="如何正则匹配一个手机号？"></a>如何正则匹配一个手机号？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">^<span class="hljs-number">1</span>[<span class="hljs-number">3</span>-<span class="hljs-number">9</span>]\d&#123;<span class="hljs-number">9</span>&#125;$<br></code></pre></td></tr></table></figure><ul><li><code>^</code> 表示字符串开始位置</li><li><code>1</code> 表示手机号码的第一位必须为1</li><li><code>[3-9]</code> 表示手机号码的第二位可以是3-9中的任意一个数字</li><li><code>\d&#123;9&#125;</code> 表示手机号码的后9位必须是数字</li><li><code>$</code> 表示字符串结束位置</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识点整理(5)</title>
    <link href="/2023/04/11/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-5/"/>
    <url>/2023/04/11/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-5/</url>
    
    <content type="html"><![CDATA[<h1 id="知识点整理-5"><a href="#知识点整理-5" class="headerlink" title="知识点整理(5)"></a>知识点整理(5)</h1><h2 id="在多线程的情况下如何保证线程安全？"><a href="#在多线程的情况下如何保证线程安全？" class="headerlink" title="在多线程的情况下如何保证线程安全？"></a>在多线程的情况下如何保证线程安全？</h2><ol><li>加锁：使用锁机制来保护共享资源，确保同一时间只有一个线程可以访问共享资源，其他线程需要等待锁释放后才能访问。</li><li>使用原子操作：原子操作是不可被中断的操作，可以保证多线程访问共享资源时的原子性，避免数据不一致的问题。</li><li>使用线程安全的数据结构：如ConcurrentHashMap、CopyOnWriteArrayList等，这些数据结构是线程安全的，多个线程可以同时访问并修改其中的元素，不需要加锁。</li><li>使用volatile关键字：volatile关键字可以保证变量在多线程中的可见性，即一个线程修改了变量的值，其他线程可以立即看到修改后的值。</li><li>避免共享资源：尽量避免多个线程访问共享资源，可以采用线程本地存储（ThreadLocal）等方式来避免共享资源的访问冲突。</li></ol><h2 id="线程有哪几种状态？"><a href="#线程有哪几种状态？" class="headerlink" title="线程有哪几种状态？"></a>线程有哪几种状态？</h2><ol><li>新建状态（New）：当线程对象被创建时，它就处于新建状态，此时它还没有被启动。</li><li>就绪状态（Runnable）：当线程被调用start()方法后，它进入就绪状态，表示它已经准备好运行，等待系统分配资源。</li><li>运行状态（Running）：当系统分配到资源后，线程就进入运行状态，开始执行run()方法中的代码。</li><li>阻塞状态（Blocked）：当线程等待某个操作完成或等待某个资源时，它进入阻塞状态，暂时停止执行。</li><li>等待状态（Waiting）：当线程执行某个操作后，需要等待另一个线程或操作完成时，它进入等待状态，调用wait()或join()方法时，线程就会进入等待状态。</li><li>超时等待状态（Timed Waiting）：当线程执行某个操作后，需要等待一段时间后再继续执行时，它进入超时等待状态，调用sleep()、wait(long)或join(long)等方法时，线程就会进入超时等待状态。</li><li>终止状态（Terminated）：当线程执行完run()方法后，它就进入终止状态，线程执行结束，不再继续执行。</li></ol><h2 id="超时重传机制的原理？"><a href="#超时重传机制的原理？" class="headerlink" title="超时重传机制的原理？"></a>超时重传机制的原理？</h2><blockquote><p>超时重传机制是指在网络通信中，当发送方发送数据后，如果没有收到确认应答或者收到了错误的应答，就会触发超时重传机制，重新发送数据。</p></blockquote><ol><li>发送数据：发送方将数据发送给接收方，并启动计时器，等待接收方的应答。</li><li>接收应答：接收方接收到数据后，向发送方发送应答信息，表示已经收到数据。</li><li>超时计时器：发送方启动一个计时器，等待接收方的应答。如果在规定的时间内没有收到应答，就认为数据丢失或超时，触发超时重传机制。</li><li>重传数据：发送方重新发送数据，等待接收方的应答。</li><li>停止计时器：当发送方收到接收方的应答后，停止计时器，表示数据已经成功发送。如果在规定的时间内没有收到应答，就会重新触发超时重传机制。</li></ol><h2 id="TLS是如何保证可靠传输的？"><a href="#TLS是如何保证可靠传输的？" class="headerlink" title="TLS是如何保证可靠传输的？"></a>TLS是如何保证可靠传输的？</h2><blockquote><p>TLS（Transport Layer Security）是一种加密协议，用于保护网络通信中的数据安全性和完整性。它是SSL（Secure Sockets Layer）协议的继任者。</p></blockquote><p>TLS使用公钥加密技术和数字证书来确保通信的安全性。它采用了对称加密和非对称加密的组合方式来保护通信的内容和身份验证。通信双方首先通过握手协议交换密钥，然后使用这些密钥对数据进行加密和解密。</p><ol><li>加密通信：TLS使用对称加密算法来加密通信内容，保护数据的机密性。</li><li>数据完整性：TLS使用消息认证码（MAC）来保证数据的完整性，防止数据被篡改或损坏。</li><li>身份验证：TLS使用数字证书来进行身份验证，确保通信双方的身份是合法的。</li><li>防止重放攻击：TLS使用时间戳和随机数来防止重放攻击，确保通信的实时性。</li></ol><h2 id="React为什么要使用虚拟DOM？"><a href="#React为什么要使用虚拟DOM？" class="headerlink" title="React为什么要使用虚拟DOM？"></a>React为什么要使用虚拟DOM？</h2><p>提高性能和开发效率。</p><p>传统的DOM操作是非常耗费性能的，因为每次更新DOM都需要重新计算布局、绘制等操作，而且频繁的DOM操作会导致页面卡顿和性能下降。而虚拟DOM是在内存中维护一个虚拟的DOM树，通过对比新旧虚拟DOM树的差异，最终只更新需要更新的部分，从而减少DOM操作次数，提高性能。</p><p>此外，使用虚拟DOM还可以提高开发效率。开发者可以通过JSX语法编写组件，将组件的状态和属性传递给虚拟DOM，React会根据虚拟DOM自动更新组件的状态，从而减少了手动操作DOM的代码量，提高了开发效率。</p><h2 id="什么是React-Fiber？"><a href="#什么是React-Fiber？" class="headerlink" title="什么是React Fiber？"></a>什么是React Fiber？</h2><p>React Fiber是React v16中引入的一种新的协调引擎，用于重新设计和实现React的核心算法。它的目标是提高React的性能、灵活性和可扩展性。</p><p>React v15在渲染时,会递归比对 VirtualDOM树，找出需要变动的节点步更新它过程期间， React会占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，导致用户感觉到卡顿。</p><p>为了给用户制造一种应用很快的”假象”，不能让一个任务长期霸占着资源。可以将浏览器的渲染、布局、绘制、资源载、事件响应、脚本执行视作操作系统的”进程”，需要通过某些调策略合理地分配CPU资源，从而提高浏览器的用户响应速率，同时兼顾任务执行效率。</p><p>React通过Fiber架构，让这个执行过程变得可中断。适时的让出CPU执行权，除了可以让浏览器及时的响应用户的交互，还有一些好处：</p><ul><li>分批延时的对DOM进行操作，避免一次性操作大量DOM节点，可以获得更好的用户体验。</li><li>给浏览器一些喘息的机会，它会对代码进行编译优化 ( JIT ) 及热代码优化，或对 reflow 进行修正。</li></ul><p>React Fiber的主要特点包括：</p><ol><li>可中断的渲染：React Fiber可以在渲染过程中暂停、中断和恢复渲染，以支持更高优先级的任务，如动画和用户输入。</li><li>渐进式渲染：React Fiber可以将渲染过程分为多个阶段，并在每个阶段中执行一部分工作，以避免长时间的阻塞，提高用户体验。</li><li>异步渲染：React Fiber可以在不同的时间段内执行渲染，以支持异步渲染和服务器端渲染等场景。</li><li>更好的错误处理：React Fiber可以更好地捕获和处理错误，以提高应用程序的健壮性和可靠性。</li></ol><h2 id="React为什么要引入Hooks？Hooks的优势和劣势？"><a href="#React为什么要引入Hooks？Hooks的优势和劣势？" class="headerlink" title="React为什么要引入Hooks？Hooks的优势和劣势？"></a>React为什么要引入Hooks？Hooks的优势和劣势？</h2><p>React引入Hooks的主要原因是为了解决<strong>组件之间复用状态逻辑</strong>的问题。</p><p>在React之前，组件之间复用状态逻辑通常需要使用高阶组件、render props等技术，这些技术增加了组件的复杂性和理解难度，同时也不够直观和自然。而Hooks可以让组件之间复用状态逻辑变得更加简单和直观，同时可以提高代码的重用性和可读性。</p><p>优势：</p><ol><li>更少的代码量：使用Hooks可以<strong>减少组件之间的重复代码，提高代码的重用性</strong>，同时也可以提高代码的可读性和可维护性。</li><li>更好的逻辑复用：使用Hooks可以将状态逻辑从组件中抽离出来，使得逻辑复用更加自然和简单。</li><li>更好的测试性：使用Hooks可以更容易地编写和执行单元测试，以保证代码的质量和稳定性。</li></ol><p>劣势：</p><ol><li>学习曲线：使用Hooks需要掌握一些新的概念和用法，对于初学者来说可能需要一定的学习曲线。</li><li>兼容性问题：Hooks是在React v16.8中引入的，需要React 16.8或更高版本才能使用，如果项目中使用的是旧版本的React，需要升级React版本才能使用Hooks。</li></ol><h2 id="操作DOM的时候，如何给节点添加兄弟节点？"><a href="#操作DOM的时候，如何给节点添加兄弟节点？" class="headerlink" title="操作DOM的时候，如何给节点添加兄弟节点？"></a>操作DOM的时候，如何给节点添加兄弟节点？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取当前元素</span><br><span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;box&quot;</span>);<br><span class="hljs-comment">// 创建新元素</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;a&quot;</span>);<br><span class="hljs-comment">// 设置元素内容</span><br>a.<span class="hljs-property">href</span> = <span class="hljs-string">&quot;www.abc.com&quot;</span>;<br>a.<span class="hljs-property">innerText</span> = <span class="hljs-string">&quot;ABC&quot;</span>;<br><span class="hljs-comment">// 添加元素到box中</span><br>box.<span class="hljs-title function_">appendChildren</span>(a); <span class="hljs-comment">// 给父元素添加子元素</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;p&quot;</span>);<br>box.<span class="hljs-title function_">insertBefore</span>(p, a); <span class="hljs-comment">// 假设box中存在p元素，在p元素前面插入a元素</span><br><span class="hljs-comment">// 获取克隆元素</span><br><span class="hljs-keyword">const</span> cloneP = p.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 默认参数为false,是狗采用深度克隆</span><br>box.<span class="hljs-title function_">appendChild</span>(cloneP);<br></code></pre></td></tr></table></figure><h2 id="appendChild的实现原理？"><a href="#appendChild的实现原理？" class="headerlink" title="appendChild的实现原理？"></a>appendChild的实现原理？</h2><ol><li>首先，检查要添加的子节点是否是一个DOM节点，如果不是则抛出一个错误。</li><li>然后，检查要添加的子节点是否已经是一个父节点的子节点，如果是则将子节点从原来的父节点中移除。</li><li>最后，将子节点添加到指定的父节点的子节点列表的末尾。</li></ol><p>在添加子节点的过程中，<strong>appendChild()方法会自动更新父节点、子节点和兄弟节点的引用关系。同时，appendChild()方法也会自动更新文档的布局和渲染</strong>，因此需要谨慎使用，以避免频繁的DOM操作导致性能下降。</p><p>appendChild()方法只能将一个节点添加到一个父节点中，如果要添加多个节点，需要多次调用appendChild()方法。</p><p>在插入子节点的过程中，insertBefore()方法会自动更新父节点、子节点和兄弟节点的引用关系。同时，insertBefore()方法也会自动更新文档的布局和渲染，因此需要谨慎使用，以避免频繁的DOM操作导致性能下降。</p><p>需要注意的是，如果要将一个节点插入到一个父节点的子节点列表的末尾，可以使用appendChild()方法。如果要将一个节点插入到指定位置，可以使用insertBefore()方法。</p><ol><li>首先，检查要插入的子节点是否是一个DOM节点，如果不是则抛出一个错误。</li><li>然后，检查要插入的参考节点是否是一个子节点，如果不是则抛出一个错误。</li><li>接着，检查要插入的子节点是否已经是一个父节点的子节点，如果是则将子节点从原来的父节点中移除。</li><li>最后，将子节点插入到指定的位置，即参考节点的前面。</li></ol><p>在插入子节点的过程中，insertBefore()方法会自动更新父节点、子节点和兄弟节点的引用关系。同时，insertBefore()方法也会自动更新文档的布局和渲染，因此需要谨慎使用，以避免频繁的DOM操作导致性能下降。</p><p>如果要将一个节点插入到一个父节点的子节点列表的末尾，可以使用appendChild()方法。如果要将一个节点插入到指定位置，可以使用insertBefore()方法。</p><h2 id="代码懒加载的实现原理？"><a href="#代码懒加载的实现原理？" class="headerlink" title="代码懒加载的实现原理？"></a>代码懒加载的实现原理？</h2><blockquote><p>代码懒加载（Code Splitting）是一种优化网页性能的技术，它的原理是将网页的代码分割成多个小块，只在需要时才加载这些小块，从而提高网页的加载速度和性能。</p></blockquote><p>代码懒加载的实现原理如下：</p><ol><li>将网页的代码分割成多个小块，每个小块对应一个模块或页面组件。</li><li>在网页加载时，只加载必要的代码块，其他代码块暂时不加载。</li><li>当用户访问到需要使用某个模块或组件时，再动态加载对应的代码块。</li><li>加载完成后，将新的模块或组件插入到网页中，从而实现懒加载效果。</li></ol><p>代码懒加载可以使用Webpack等工具来实现。Webpack可以将网页的代码分割成多个小块，并使用动态import()语法来实现懒加载。当Webpack打包代码时，会将代码分割成多个小块，并生成多个独立的文件。在网页加载时，只加载必要的代码块，其他代码块暂时不加载。当用户需要访问某个模块或组件时，再动态加载对应的代码块，并将它插入到网页中。</p><p>代码懒加载可以大大提高网页的性能和用户体验，特别是在移动设备等网络环境不佳的情况下。</p><h2 id="git-amend命令的作用？"><a href="#git-amend命令的作用？" class="headerlink" title="git amend命令的作用？"></a>git amend命令的作用？</h2><p>git amend命令是Git版本控制系统中的一个命令，用于修改最后一次提交的信息或者将缺失的文件添加到最后一次提交中。</p><p>具体来说，git amend命令可以用于以下两种情况：</p><ol><li><p>修改最后一次提交的信息：如果最后一次提交的信息存在错误或者需要进行修改，可以使用git amend命令来修改。具体操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit --amend<br></code></pre></td></tr></table></figure><p>在执行上述命令之后，Git会打开默认编辑器，让你修改最后一次提交的信息。修改完成后，保存并关闭编辑器即可。</p></li><li><p>将缺失的文件添加到最后一次提交中：如果最后一次提交中漏掉了某个文件，可以使用git amend命令将该文件添加到最后一次提交中。具体操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add missed_file<br>$ git commit --amend<br></code></pre></td></tr></table></figure><p>在执行上述命令之后，Git会将missed_file文件添加到最后一次提交中。</p></li></ol><p>需要注意的是，使用git amend命令修改最后一次提交的信息或者添加缺失的文件，会改变Git仓库的历史记录，因此需要谨慎使用。</p><h2 id="instanceof有什么缺点？"><a href="#instanceof有什么缺点？" class="headerlink" title="instanceof有什么缺点？"></a>instanceof有什么缺点？</h2><ol><li>instanceof无法检测基本数据类型：instanceof只能检测对象类型，对于基本数据类型（如number、string、boolean等）无法进行检测。</li><li>instanceof无法检测null和undefined：当使用instanceof检测null或undefined时，会抛出TypeError错误。</li><li>instanceof无法检测继承自同一父类的对象：如果两个不同的对象继承自同一个父类，那么使用instanceof检测时会返回true，这可能会导致一些问题。</li><li>instanceof无法检测跨iframe的对象：当对象跨越不同的iframe时，使用instanceof检测时会返回false，这是因为不同的iframe拥有不同的全局环境。</li><li>instanceof无法检测自定义对象：如果没有正确地实现对象的原型链，那么使用instanceof检测时可能会出现错误的结果。</li></ol><h2 id="如何根据元素的class提取元素？"><a href="#如何根据元素的class提取元素？" class="headerlink" title="如何根据元素的class提取元素？"></a>如何根据元素的class提取元素？</h2><ol><li><p>getElementByClassName方法：这个方法可以通过class名称获取一组元素，返回的是一个类数组对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;class-name&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>querySelectorAll方法：这个方法可以通过CSS选择器获取一组元素，返回的是一个NodeList对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.class-name&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>getElementsByTagname方法结合class属性：这个方法可以通过标签名获取一组元素，然后结合class属性进行筛选。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-keyword">var</span> result = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; elements.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-keyword">if</span> (elements[i].<span class="hljs-property">className</span> === <span class="hljs-string">&#x27;class-name&#x27;</span>) &#123;<br>    result.<span class="hljs-title function_">push</span>(elements[i]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="递归有什么缺陷？"><a href="#递归有什么缺陷？" class="headerlink" title="递归有什么缺陷？"></a>递归有什么缺陷？</h2><ol><li>内存消耗大：递归需要在执行过程中不断地压入和弹出栈帧，这会消耗大量的内存空间。如果递归层数过多，可能会导致栈溢出。</li><li>性能低下：递归需要不断地进行函数调用和返回，这会消耗大量的CPU时间。如果递归次数过多，可能会导致程序运行缓慢。</li><li>可读性差：递归算法通常比较难理解和调试，代码可读性较差。</li><li>可能导致死循环：如果递归函数没有正确地终止条件，可能会导致死循环，使程序无法正常运行。</li></ol><h2 id="如何解决递归的缺陷？"><a href="#如何解决递归的缺陷？" class="headerlink" title="如何解决递归的缺陷？"></a>如何解决递归的缺陷？</h2><ol><li>限制递归深度：通过限制递归深度，可以避免栈溢出的问题。可以在递归函数中加入一个计数器或者设置一个最大深度，当达到指定深度时，停止递归。</li><li>尾递归优化：尾递归是一种特殊的递归形式，在尾递归中，递归调用是函数体中的最后一条语句。尾递归可以通过将当前状态作为参数传递给递归函数，从而避免不必要的栈帧压入和弹出操作，从而提高了效率。</li><li>使用迭代代替递归：在某些情况下，可以使用循环等其他算法代替递归，从而提高效率和可读性。</li><li>优化递归算法：对递归算法进行优化，如使用记忆化搜索等技术，可以大幅提高递归算法的效率。</li></ol><h2 id="事件循环中的宏任务和微任务分别有哪些？"><a href="#事件循环中的宏任务和微任务分别有哪些？" class="headerlink" title="事件循环中的宏任务和微任务分别有哪些？"></a>事件循环中的宏任务和微任务分别有哪些？</h2><p>宏任务（macro task）：</p><ol><li>script（整体代码）</li><li>setTimeout</li><li>setInterval</li><li>setImmediate（仅在IE和Edge浏览器中支持）</li><li>I&#x2F;O操作</li><li>UI交互事件（如click、keyup等）</li><li>requestAnimationFrame（动画效果）</li></ol><p>微任务（micro task）：</p><ol><li>Promise.then&#x2F;catch&#x2F;finally</li><li>MutationObserver</li><li>process.nextTick（仅在Node.js环境中支持）</li></ol><p>在事件循环中，每次执行完一个宏任务后，会先执行所有的微任务，然后再执行下一个宏任务。因此，微任务的执行优先级高于宏任务。</p><p>需要注意的是，虽然Promise.then&#x2F;catch&#x2F;finally属于微任务，但是Promise的构造函数是属于宏任务的。当创建一个Promise对象时，Promise的构造函数会立即执行，而then&#x2F;catch&#x2F;finally中的回调函数则是微任务。</p><h2 id="什么是混入？"><a href="#什么是混入？" class="headerlink" title="什么是混入？"></a>什么是混入？</h2><p>混入（Mixin）是一种在面向对象编程中，通过将多个类的属性和方法“混合”到一个类中来扩展该类功能的方式。</p><p>混入可以在不修改原有类的情况下，为该类添加新的功能。在JavaScript中，混入可以通过对象的复制、原型继承、类继承等方式来实现。</p><p>具体来说，混入可以通过以下几个步骤来实现：</p><ol><li>定义一个混入对象，该对象包含要混入的属性和方法。</li><li>在需要混入的类中，通过复制、继承等方式将混入对象的属性和方法“混合”到该类中。</li><li>使用混入后的类，即可享受到混入对象中扩展的功能。</li></ol><p>混入可以使代码更加模块化、灵活，可以避免代码冗余和重复。但是，在使用混入时，需要注意命名冲突和属性覆盖等问题，避免出现不必要的错误和bug。</p><h2 id="为什么typeof-NaN返回的是Number"><a href="#为什么typeof-NaN返回的是Number" class="headerlink" title="为什么typeof NaN返回的是Number?"></a>为什么typeof NaN返回的是Number?</h2><p>因为NaN是一种特殊的数值，它表示一个非数值的数值（Not-a-Number）。虽然NaN不是一个有效的数值，但它仍然属于数值类型，因此typeof NaN返回的是Number。</p><p>需要注意的是，虽然NaN属于数值类型，但它与任何值都不相等，包括它本身。这是因为NaN与任何值都不相等的特殊规定。因此，在比较值是否相等时，需要特别注意NaN的情况。可以使用isNaN函数来判断一个值是否为NaN。</p><h2 id="JS中Number的最大值返回的是什么？"><a href="#JS中Number的最大值返回的是什么？" class="headerlink" title="JS中Number的最大值返回的是什么？"></a>JS中Number的最大值返回的是什么？</h2><p>Number类型的最大值可以通过Number.MAX_VALUE常量获取，该常量的值接近于1.79e+308。超过这个值的数值将被表示为Infinity（正无穷）。</p><p>例如，可以使用以下代码来检查Number类型的最大值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span>); <span class="hljs-comment">// 输出1.7976931348623157e+308</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 输出Infinity</span><br></code></pre></td></tr></table></figure><p>需要注意的是，JavaScript中的Number类型是一种双精度浮点数，它的表示范围和精度是有限的，不能精确表示所有的数值。在进行数值计算时，需要特别注意数值的精度和范围，避免出现不必要的错误。</p><h2 id="对JS中继承的理解？"><a href="#对JS中继承的理解？" class="headerlink" title="对JS中继承的理解？"></a>对JS中继承的理解？</h2><p>一个对象（子类）可以从另一个对象（父类）继承属性和方法。子类可以使用父类的方法和属性，也可以添加自己的方法和属性。JS中的继承可以通过原型链实现，子类的原型指向父类的实例，这样子类就可以继承父类的属性和方法。另外，ES6中也提供了class关键字来实现继承。子类通过extends关键字继承父类，并可以使用super关键字来调用父类的方法和属性。继承在JS中是非常常见的概念，它可以提高代码的复用性和可维护性。</p><h2 id="实现继承有哪些方式？"><a href="#实现继承有哪些方式？" class="headerlink" title="实现继承有哪些方式？"></a>实现继承有哪些方式？</h2><ol><li><p>原型链继承</p><p>原型链继承是通过将父类的实例作为子类的原型来实现继承。这种方法的缺点是子类实例共享父类实例的属性和方法，无法实现多继承。</p></li><li><p>借用构造函数继承</p><p>借用构造函数继承是通过在子类构造函数中调用父类构造函数来实现继承。这种方法的缺点是无法继承父类原型上的属性和方法。</p></li><li><p>组合继承</p><p>组合继承是通过将原型链继承和借用构造函数继承结合起来实现继承。这种方法的缺点是在创建子类实例时会调用两次父类构造函数，造成一定的性能浪费。</p></li><li><p>原型式继承</p><p>原型式继承是通过创建一个临时的构造函数，将父类实例作为该构造函数的原型，然后返回该构造函数的实例来实现继承。这种方法的缺点是无法传递参数，无法实现多继承。</p></li><li><p>寄生式继承</p><p>寄生式继承是通过在原型式继承的基础上，对实例进行扩展来实现继承。这种方法的缺点也是无法传递参数，无法实现多继承。</p></li><li><p>寄生组合式继承</p><p>寄生组合式继承是通过在组合继承的基础上，优化父类构造函数的调用，来实现继承。这种方法的优点是既能够继承父类原型上的属性和方法，又能够避免调用两次父类构造函数，性能更优。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识点整理(4)</title>
    <link href="/2023/04/10/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-4/"/>
    <url>/2023/04/10/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-4/</url>
    
    <content type="html"><![CDATA[<h1 id="知识点整理-4"><a href="#知识点整理-4" class="headerlink" title="知识点整理(4)"></a>知识点整理(4)</h1><h2 id="颜色转换-十六进制转换RGB格式"><a href="#颜色转换-十六进制转换RGB格式" class="headerlink" title="颜色转换: 十六进制转换RGB格式"></a>颜色转换: 十六进制转换RGB格式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">hexToRgb</span> = (<span class="hljs-params">hex</span>) =&gt; &#123;<br>    hex = hex.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^#/</span>, <span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 去除前面的#</span><br>    <span class="hljs-keyword">const</span> r = <span class="hljs-built_in">parseInt</span>(hex.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>), <span class="hljs-number">16</span>); <br>    <span class="hljs-keyword">const</span> g = <span class="hljs-built_in">parseInt</span>(hex.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>), <span class="hljs-number">16</span>);<br>    <span class="hljs-keyword">const</span> b = <span class="hljs-built_in">parseInt</span>(hex.<span class="hljs-title function_">substring</span>(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>), <span class="hljs-number">16</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`rgb(<span class="hljs-subst">$&#123;r&#125;</span>, <span class="hljs-subst">$&#123;g&#125;</span>, <span class="hljs-subst">$&#123;b&#125;</span>)`</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="替换字符串内容"><a href="#替换字符串内容" class="headerlink" title="替换字符串内容"></a>替换字符串内容</h2><p>给你一个字符串<code>Hello #1#, Is&#39;s a #2# day</code>和一个数组<code>[&quot;Jack&quot;, &quot;sunny&quot;]</code>，将字符串中井号之间的索引换成在字符串中的对应元素。</p><blockquote><p>substr是从起始索引号开始提取指定长度的字符串</p><p>substring是提取字符串中两个指定索引号之间的</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">matchKeywords</span> = (<span class="hljs-params">str, arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> matchs = str.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/#(\d+)#/g</span>); <span class="hljs-comment">// 获取所有#index#占位符</span><br>    <span class="hljs-keyword">let</span> result = str;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; matchs.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-comment">// 获取matchs[i]对应的数组元素</span><br>        <span class="hljs-keyword">const</span> index = <span class="hljs-built_in">parseInt</span>(matchs[i].<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>, matchs[i].<span class="hljs-property">length</span> - <span class="hljs-number">2</span>)) - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 进行替换</span><br>        result = result.<span class="hljs-title function_">replace</span>(matchs[i], arr[index]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="useRef的返回值是什么？"><a href="#useRef的返回值是什么？" class="headerlink" title="useRef的返回值是什么？"></a>useRef的返回值是什么？</h2><p><code>useRef</code>的返回值是一个可变的<code>ref</code>对象，且只有一个current属性，其中 <code>current</code> 属性指向一个可变的值。可以通过修改 <code>current</code> 属性来更新这个值，而不会触发组件的重新渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>Focus<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="用useState可以实现useRef的效果吗？"><a href="#用useState可以实现useRef的效果吗？" class="headerlink" title="用useState可以实现useRef的效果吗？"></a>用useState可以实现useRef的效果吗？</h2><p>不能。</p><p>虽然 <code>useState</code> 和 <code>useRef</code> 都可以用来存储组件中的数据，但是它们的实现方式不同，因此不能完全替代彼此。</p><p><code>useState</code> 用于存储组件的状态，每次更新状态都会触发组件的重新渲染。而 <code>useRef</code> 用于存储组件中的数据，不会触发组件的重新渲染。</p><p>虽然 <code>useState</code> 可以用来存储组件中的数据，但是每次更新状态都会触发组件的重新渲染，这可能会导致性能问题。而 <code>useRef</code> 可以在不触发组件重新渲染的情况下存储数据，因此更适合用来存储不需要触发重新渲染的数据。</p><p>例如，<code>useRef</code> 可以用来存储 DOM 元素的引用，而 <code>useState</code> 则不适合用来存储 DOM 元素的引用，因为每次更新状态都会触发组件的重新渲染，从而导致 DOM 元素的重新创建和销毁。</p><h2 id="useMemo返回的是什么？"><a href="#useMemo返回的是什么？" class="headerlink" title="useMemo返回的是什么？"></a>useMemo返回的是什么？</h2><p>在 React 中，<code>useMemo</code> 是一个 Hook 函数，用于优化组件的性能。它的作用是在组件渲染过程中缓存计算结果，以避免重复计算，从而提高组件的渲染速度。<code>useMemo</code> 的返回值是缓存的计算结果。</p><p>当组件重新渲染时，<code>useMemo</code> 会检查依赖项列表中的值是否发生了变化。<strong>如果依赖项的值没有发生变化，则 <code>useMemo</code> 直接返回缓存的计算结果，而不会重新计算；如果依赖项的值发生了变化，则 <code>useMemo</code> 会重新计算并返回新的计算结果。</strong></p><h2 id="React如何减少渲染次数？"><a href="#React如何减少渲染次数？" class="headerlink" title="React如何减少渲染次数？"></a>React如何减少渲染次数？</h2><ol><li>使用 <code>React.memo</code> 或 <code>PureComponent</code>：这些方法可以帮助组件实现浅比较，当组件的 props 没有发生变化时，避免不必要的重新渲染。</li><li>使用 <code>useCallback</code>：当需要将函数作为 props 传递给子组件时，可以使用 <code>useCallback</code> 缓存函数，避免在每次重新渲染时都创建新的函数。</li><li>尽可能地将组件拆分成更小的组件：这样可以避免不必要的重新渲染，提高组件的复用性。</li><li>避免在 <code>render</code> 方法中执行复杂的计算或操作：将复杂的计算或操作移到组件外部，或者使用 <code>useMemo</code> 或 <code>useEffect</code> 缓存计算结果。</li><li>避免在 <code>render</code> 方法中使用匿名函数：使用匿名函数会导致组件的重新渲染，因此尽可能地避免在 <code>render</code> 方法中使用匿名函数。</li></ol><h2 id="有哪些Hooks可以减少渲染次数？"><a href="#有哪些Hooks可以减少渲染次数？" class="headerlink" title="有哪些Hooks可以减少渲染次数？"></a>有哪些Hooks可以减少渲染次数？</h2><ol><li><code>React.memo</code>：这个 Hook 可以帮助函数组件进行浅比较，避免不必要的重新渲染。它接受一个组件作为参数，并返回一个新的组件，新组件会对原组件的 props 进行浅比较，当 props 没有发生变化时，避免不必要的重新渲染。</li><li><code>useCallback</code>：这个 Hook 可以缓存函数，避免在每次重新渲染时都创建新的函数。它接受一个函数和依赖项列表作为参数，并返回一个新的函数。当依赖项的值没有发生变化时，返回缓存的函数，否则返回新的函数。</li><li><code>useMemo</code>：这个 Hook 可以缓存计算结果，避免在每次重新渲染时都重新计算。它接受一个计算函数和依赖项列表作为参数，并返回计算结果。当依赖项的值没有发生变化时，返回缓存的计算结果，否则重新计算并返回新的结果。</li><li><code>useReducer</code>：这个 Hook 可以帮助管理组件的状态，并避免不必要的重新渲染。它接受一个 reducer 函数、初始状态和一个初始化函数作为参数，并返回一个包含状态和 dispatch 函数的数组。当状态发生变化时，只会重新渲染与状态相关的部分。</li><li><code>useMemoOne</code>：这个 Hook 可以缓存计算结果，避免在每次重新渲染时都重新计算。它类似于 <code>useMemo</code>，但是可以在渲染期间多次调用计算函数，并缓存计算结果。它接受一个计算函数和依赖项列表作为参数，并返回计算结果。</li></ol><h2 id="React单向数据流？"><a href="#React单向数据流？" class="headerlink" title="React单向数据流？"></a>React单向数据流？</h2><p>React的单向数据流是指数据的流动方向是单向的，从父组件流向子组件。父组件通过props将数据传递给子组件，子组件不能直接修改父组件传递过来的数据，只能通过触发事件或调用父组件传递过来的回调函数来修改数据。这样做的好处是保证了数据的一致性，<strong>避免了组件之间的相互影响，提高了应用的可维护性</strong>。</p><p>React的单向数据流也是React的核心思想之一，它使得组件之间的数据传递变得简单明了，也方便了组件的重用和组合。在React应用中，每个组件都是一个独立的单元，它只关心自己的数据和UI展示，而不需要考虑其他组件的状态和行为。这种组件化的思想也是React的另一个重要特点。</p><h2 id="hash路由和history路由的区别？"><a href="#hash路由和history路由的区别？" class="headerlink" title="hash路由和history路由的区别？"></a>hash路由和history路由的区别？</h2><ul><li><p>hash路由是通过触发并监听hashChange事件来实现前端路由的，改变hash可以直接通过location.hash &#x3D; xxx来改变；而history路由是通过history的各种API (history.pushState、history.replaceState) 等实现url的改变的，监听url的变化可以通过自定义事件触发实现。</p></li><li><p>hash路由兼容性好，支持所有的浏览器，而且可以实现前端路由的核心功能 (IE8以上)，但是ur不够美观；history路由url美观，可以利用浏览器的前进、后退等基本功能，但是兼容性不好(IE10以上)，需要浏览器支持HTML5的history API，同时需要服务器端支持，否则刷新页面会出现404错误。</p></li><li><p>history pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中。</p></li><li><p>history 进行刷新页面时，无法找到url对应的页面，会出现 404 问题。因为域名后面的路由是由前端控制的，后端只能保留域名部分，所以就会造成页面丢失的问题。</p></li></ul><h2 id="React中什么时候用history路由，什么时候用hash路由？"><a href="#React中什么时候用history路由，什么时候用hash路由？" class="headerlink" title="React中什么时候用history路由，什么时候用hash路由？"></a>React中什么时候用history路由，什么时候用hash路由？</h2><ul><li>如果需要兼容更老的路由，建议使用hash路由，history的兼容性较差。</li><li>如果希望url看起来更美观，建议使用history路由，不会在url中添加#字符。</li><li>如果需要更好的SEO(搜索引擎优化)，建议使用history路由，因为搜索引擎对hash路由中的#字符处理不太友好。</li><li>服务端渲染：如果需要在服务端渲染应用程序，建议使用history路由，因为服务端渲染需要在服务器上匹配URL。</li><li>前进&#x2F;后退：如果需要利用浏览器的前进&#x2F;后退等基本功能，建议使用history路由，因为hash路由中的#字符不会被浏览器记录到历史记录中。</li></ul><h2 id="React中hash路由与history路由的实现原理？"><a href="#React中hash路由与history路由的实现原理？" class="headerlink" title="React中hash路由与history路由的实现原理？"></a>React中hash路由与history路由的实现原理？</h2><p>Hash路由：通过监听<code>hashChange</code>事件，感知hash的变化，改变hash可以直接通过<code>location.hash = xxx</code>进行改变。</p><p>History路由：改变url需要通过<code>history.pushState</code>和<code>history.replaceState</code>等，会将url压入堆栈，同时能够适应<code>history.go()</code>等API，监听url的改变可以通过自定义事件触发实现。</p><h2 id="React的diffing算法-比如从ABCD变为BADC，具体是移动还是销毁？"><a href="#React的diffing算法-比如从ABCD变为BADC，具体是移动还是销毁？" class="headerlink" title="React的diffing算法 比如从ABCD变为BADC，具体是移动还是销毁？"></a>React的diffing算法 比如从ABCD变为BADC，具体是移动还是销毁？</h2><p>如果节点没有发生变化，只是位置发生了变化，会对它们进行移动而不是销毁。</p><p><strong>React允许开发者对同一层级的同组子节点，添加唯一 key 进行区分。</strong></p><p>当同一层级的某个节点添加了对于其他同级节点唯一的key属性，当它在<strong>当前层级</strong>的位置发生了变化后。react diff算法通过新旧节点比较后，<strong>如果发现了key值相同的新旧节点，就会执行移动操作（然后依然按原策略深入节点内部的差异对比更新），而不会执行原策略的删除旧节点，创建新节点的操作。</strong>这无疑大大提高了React性能和渲染效率。</p><p>在具体的执行过程中，首先会对新集合中的节点进行遍历循环，通过唯一的key判断新旧节点中是否存在相同的节点，如果存在则进行移动操作，但是在移动操作之前需要将当前节点在旧几个中的位置与lastIndex进行比较 <code>if(child._mountIndex &lt; lastIndex)</code>，否则不执行该操作。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe044edaaf28439c9d4afba753690eb9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="同一层级中所有节点只发生了位置变化"></p><p>按新集合中顺序开始遍历</p><ol><li>B在新集合中 lastIndex(类似浮标) &#x3D; 0, 在旧集合中 index &#x3D; 1，index &gt; lastIndex 就认为 B 对于集合中其他元素位置无影响，不进行移动，之后lastIndex &#x3D; max(index, lastIndex) &#x3D; 1</li><li>A在旧集合中 index &#x3D; 0， 此时 lastIndex &#x3D; 1, 满足 index &lt; lastIndex, 则对A进行移动操作，此时lastIndex &#x3D; max(Index, lastIndex) &#x3D; 1</li><li>D和B操作相同，同(1)，不进行移动，此时lastIndex&#x3D;max(index, lastIndex) &#x3D; 3</li><li>C和A操作相同，同(2)，进行移动，此时lastIndex &#x3D; max(index, lastIndex) &#x3D; 3</li></ol><p>如果同一层级中的节点不仅发生了位置变化，还发生了节点增删：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83a71d590dce4999a0320e7d7ba7bacd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="不仅发生了位置变化，还发生了节点增删"></p><ol><li>同上面那种情形，B不进行移动，lastIndex&#x3D;1</li><li>新集合中取得E,发现旧中不存在E，在 lastIndex处<strong>创建</strong>E，lastIndex++</li><li>在旧集合中取到C，C不移动，lastIndex&#x3D;2</li><li>在旧集合中取到A，A移动到新集合中的位置，lastIndex&#x3D;2</li><li>完成新集合中所有节点diff后，对旧集合进行循环遍历，寻找新集合中不存在但就集合中的节点(此例中为D)，删除D节点。</li></ol><p><strong>是否推荐使用遍历时的index作为key属性值？</strong></p><p>React官方建议不要用遍历的index作为这种场景下的节点的key属性值。比如当前遍历的所有节点类型都相同，其内部文本不同，在用index作key的情况下，当我们对原始的数据list进行了某些元素的顺序改变操作，导致了新旧集合中在进行diff比较时，相同index所对应的新旧的节点其文本不一致了，就会出现一些节点需要更新渲染文本，而如果用了其他稳定的唯一标识符作为key，则只会发生位置顺序变化，无需更新渲染文本，提升了性能。</p><p><strong>key机制的缺陷：</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce6eb05a24674c51943127fcde856d34~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="只有D节点位置变化"></p><p>如图 所示，若新集合的节点更新为 D、A、 B、C，与旧集合相比只有 D 节点移动，而 A、B、C 仍然保持原有的顺序，理论上 diff 应该只需对 D 执行移动操作，然而由于 D 在旧集合中的位置是最大的，导致其他节点的 _mountIndex &lt;lastIndex，造成 D 没有执行移动操作，而是 A、B、C 全部移动到 D 节点后面的现象。</p><p><strong>在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作。当节点数量过大或更新操作过于频繁时，这在一定程度上会影响 React 的渲染性能。</strong></p><p><strong>key使用注意事项：</strong></p><ol><li>如果遍历的列表子节是作为纯展示，而不涉及到列表元素顺序的动态变更，那使用index作为key还是没有问题的。</li><li>key只是针对同一层级的节点进行了diff比较优化，而跨层级的节点互相之间的key值没有影响</li><li>大部分情况下，通过遍历的同一层级的使用了key属性的元素节点其节点类型是相同的（比如都是span元素或者同一个组件）。如果存在新旧集合中，相同的key值所对应的节点类型不同（比如从span变成div），这相当于完全替换了旧节点，删除了旧节点，创建了新节点。</li><li>如果新集合中，出现了旧集合没有存在过的key值。例如某个节点的key之前为1，现在为100，但旧集合中其他节点也没有使用100这个key值。说明没发生过移动操作，此时diff算法会对对应的节点进行销毁并重新创建。这在一些场景中会比较有用（比如重置某个组件的状态）</li><li>key值在比较之前都会被执行toString()操作，所以尽量不要使用object类型的值作为key，会导致同一层级出现key值相同的节点。key值重复的同一类型的节点或组件很可能出现拷贝重复内部子元素的问题。</li></ol><p>参考：<a href="https://juejin.cn/post/6967626390380216334#comment">React虚拟DOM、Diff算法与Key机制</a></p><h2 id="CSS中padding和margin的百分比写法是相对于谁的？"><a href="#CSS中padding和margin的百分比写法是相对于谁的？" class="headerlink" title="CSS中padding和margin的百分比写法是相对于谁的？"></a>CSS中padding和margin的百分比写法是相对于谁的？</h2><p>相对于父元素的宽度来进行计算。</p><p>例如，如果一个元素的父元素宽度为100px，将padding-left设置为20%，则左边padding宽度为20px。</p><h2 id="绝对定位是相对于谁进行定位的？"><a href="#绝对定位是相对于谁进行定位的？" class="headerlink" title="绝对定位是相对于谁进行定位的？"></a>绝对定位是相对于谁进行定位的？</h2><p>相对于其最近的已定位 (position属性值不为static) 的父元素进行定位的。如果没有已定位的父元素，则相对于最初的包含块(根元素)进行定位。</p><p>当一个元素被设置为绝对定位时，它会被从文档流中移除，因此它不占据文档中的空间。它的位置由top、bottom、left和right属性来指定，这些属性定义了元素相对于其父元素的偏移量。如果没有给这些属性指定值，元素将会被放置在其父元素的左上角。</p><h2 id="flex布局？"><a href="#flex布局？" class="headerlink" title="flex布局？"></a>flex布局？</h2><p>flex弹性布局，为盒模型提供了最大的灵活性，设置为flex布局后，子元素的float、clear和vertical-align属性将失效。它的所有子元素自动成为容器成员，称为flex项目。容器默认两条轴：水平主轴(main axis)和垂直的交叉轴(cross axis)，项目默认沿水平主轴排列。</p><p>常见属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-direction</span> <span class="hljs-comment">/* 决定主轴方向 */</span><br><span class="hljs-attribute">flex-wrap</span> <span class="hljs-comment">/* 如果一条轴线排不下，如何换行 */</span><br><span class="hljs-attribute">flex-flow</span> <span class="hljs-comment">/* flex-direction和flex-wrap属性简写，默认为row nowrap */</span><br><span class="hljs-attribute">justify-content</span> <span class="hljs-comment">/* 项目在主轴上的对齐方式 */</span><br><span class="hljs-attribute">align-items</span> <span class="hljs-comment">/* 项目在交叉轴上的对其方式 */</span><br><span class="hljs-attribute">align-content</span> <span class="hljs-comment">/* 多根轴线时的对齐方式，如果只有一条轴线则不起作用 */</span><br><span class="hljs-attribute">align-self</span>  <span class="hljs-comment">/* 允许单个项目与其他项目不一样的对齐方式，可以覆盖align-items属性，默认为auto，表示继承父元素align-items属性，如果没有父元素则等同于stretch */</span> <br></code></pre></td></tr></table></figure><p><code>flex: 1</code>代表什么含义？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;<br><span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">1</span>;<br><span class="hljs-attribute">flex-basis</span>: <span class="hljs-number">0%</span>;<br></code></pre></td></tr></table></figure><p><code>flex: auto</code>代表什么含义？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;<br><span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">1</span>;<br><span class="hljs-attribute">flex-basis</span>: auto;  <span class="hljs-comment">/*元素根据剩余空间自动调整自身大小*/</span><br></code></pre></td></tr></table></figure><h2 id="node-js框架Express常用API？"><a href="#node-js框架Express常用API？" class="headerlink" title="node.js框架Express常用API？"></a>node.js框架Express常用API？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title function_">express</span>(); <span class="hljs-comment">// 创建一个express应用程序实例</span><br>app.<span class="hljs-title function_">use</span>(); <span class="hljs-comment">// 使用中间件函数，可以用来处理HTTP请求、响应和错误</span><br>app.<span class="hljs-title function_">set</span>(); <span class="hljs-comment">// 设置应用程序级别变量</span><br>app.<span class="hljs-title function_">get</span>(); <span class="hljs-comment">// 获取应用级别的变量</span><br>app.<span class="hljs-title function_">listen</span>(); <span class="hljs-comment">// 启动express应用程序并指定监听端口</span><br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>();<br>router.<span class="hljs-title function_">get</span>(); <span class="hljs-comment">// 创建HTTP GET路由</span><br>router.<span class="hljs-title function_">post</span>(); <span class="hljs-comment">// 创建HTTP POST路由</span><br>res.<span class="hljs-title function_">send</span>(); <span class="hljs-comment">// 将HTTP响应发送给客户端</span><br>res.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// 将JSON格式的HTTP响应发送给客户端</span><br>res.<span class="hljs-title function_">render</span>(); <span class="hljs-comment">// 将模板渲染成HTML，并将其发送给客户端</span><br>req.<span class="hljs-property">params</span>; <span class="hljs-comment">// 获取路由参数</span><br>req.<span class="hljs-property">query</span>; <span class="hljs-comment">// 获取查询参数</span><br>req.<span class="hljs-property">body</span>; <span class="hljs-comment">// 获取请求体的内容</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识点整理(3)</title>
    <link href="/2023/04/09/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-3/"/>
    <url>/2023/04/09/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-3/</url>
    
    <content type="html"><![CDATA[<h1 id="知识点整理-3"><a href="#知识点整理-3" class="headerlink" title="知识点整理(3)"></a>知识点整理(3)</h1><h2 id="原生JS实现图片拖拽"><a href="#原生JS实现图片拖拽" class="headerlink" title="原生JS实现图片拖拽"></a>原生JS实现图片拖拽</h2><p><img src="https://pic.imgdb.cn/item/6432ac210d2dde5777840625.png" alt="图片拖拽"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-id">#box</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position: relative;overflow: hidden;&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 将要被拖拽的元素, 设置为绝对定位 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;img src=&quot;https://pic.imgdb.cn/item/64326d120d2dde57772c4eab.png&quot; alt=&quot;&quot; id=&quot;box&quot; /&gt; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;box&quot;</span>); <span class="hljs-comment">// 获取目标元素</span></span><br><span class="language-javascript">            <span class="hljs-comment">// 鼠标按下事件</span></span><br><span class="language-javascript">            box.<span class="hljs-property">onmousedown</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">let</span> e = ev || event;</span><br><span class="language-javascript">                <span class="hljs-comment">// 鼠标到元素左边缘距离 = 鼠标到屏幕左边缘距离 - 元素到屏幕左边缘距离</span></span><br><span class="language-javascript">                <span class="hljs-keyword">let</span> x = e.<span class="hljs-property">clientX</span> - box.<span class="hljs-property">offsetLeft</span>;</span><br><span class="language-javascript">                <span class="hljs-comment">// 鼠标到元素上边缘距离 = 鼠标到屏幕上边缘距离 - 元素到屏幕上边缘距离</span></span><br><span class="language-javascript">                <span class="hljs-keyword">let</span> y = e.<span class="hljs-property">clientY</span> - box.<span class="hljs-property">offsetTop</span>;</span><br><span class="language-javascript">                <span class="hljs-comment">// 鼠标移动事件</span></span><br><span class="language-javascript">                <span class="hljs-variable language_">document</span>.<span class="hljs-property">onmousemove</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>) &#123;</span><br><span class="language-javascript">                    <span class="hljs-keyword">let</span> e = ev || event;</span><br><span class="language-javascript">                    box.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = ev.<span class="hljs-property">clientX</span> - x + <span class="hljs-string">&quot;px&quot;</span>;</span><br><span class="language-javascript">                    box.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = ev.<span class="hljs-property">clientY</span> - y + <span class="hljs-string">&quot;px&quot;</span>;</span><br><span class="language-javascript">                    <span class="hljs-comment">// 鼠标距离浏览器窗口左边缘和上边缘的距离</span></span><br><span class="language-javascript">                    <span class="hljs-keyword">let</span> bodyScreenX = ev.<span class="hljs-property">screenX</span>, bodyScreenY = ev.<span class="hljs-property">screenY</span>;</span><br><span class="language-javascript">                    <span class="hljs-comment">// 屏幕的宽度和高度</span></span><br><span class="language-javascript">                    <span class="hljs-keyword">let</span> bodyClientWidth = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientWidth</span>,</span><br><span class="language-javascript">                        bodyClientHeight = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientHeight</span>;</span><br><span class="language-javascript">                    <span class="hljs-comment">// 鼠标松开事件</span></span><br><span class="language-javascript">                    <span class="hljs-variable language_">document</span>.<span class="hljs-property">onmouseup</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>) &#123;</span><br><span class="language-javascript">                        <span class="hljs-comment">// 判断松开的时候元素是否在屏幕中</span></span><br><span class="language-javascript">                        <span class="hljs-keyword">if</span>(ev.<span class="hljs-property">clientX</span> - x &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="language-javascript">                            <span class="hljs-comment">// 如果超出屏幕左边缘, 将元素放回屏幕最左边</span></span><br><span class="language-javascript">                            box.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = <span class="hljs-number">0</span>;</span><br><span class="language-javascript">                        &#125;</span><br><span class="language-javascript">                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bodyScreenX &gt; bodyClientWidth) &#123;</span><br><span class="language-javascript">                            <span class="hljs-comment">// 如果超出屏幕右边缘, 将元素放回屏幕最右边</span></span><br><span class="language-javascript">                            box.<span class="hljs-property">style</span>.<span class="hljs-property">right</span> = <span class="hljs-number">0</span>;</span><br><span class="language-javascript">                            box.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = bodyClientWidth - <span class="hljs-number">100</span> + <span class="hljs-string">&quot;px&quot;</span>;</span><br><span class="language-javascript">                        &#125;</span><br><span class="language-javascript">                        <span class="hljs-variable language_">document</span>.<span class="hljs-property">onmousemove</span> = <span class="hljs-literal">null</span>;</span><br><span class="language-javascript">                        <span class="hljs-variable language_">document</span>.<span class="hljs-property">onmouseup</span> = <span class="hljs-literal">null</span>;</span><br><span class="language-javascript">                    &#125;</span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="z-index在什么情况下会失效？"><a href="#z-index在什么情况下会失效？" class="headerlink" title="z-index在什么情况下会失效？"></a>z-index在什么情况下会失效？</h2><ul><li><p>元素设置了浮动</p></li><li><p><del>父元素的<code>position</code>为<code>relative</code>时，子元素的<code>z-index</code>会失效。</del></p></li><li><p>元素的<code>position</code>不是<code>relative</code>、<code>absolute</code>或者<code>fixed</code>时。</p></li></ul><h2 id="npm包会自己发送请求吗？"><a href="#npm包会自己发送请求吗？" class="headerlink" title="npm包会自己发送请求吗？"></a>npm包会自己发送请求吗？</h2><p>一般而言，npm包本身并不会发送请求。npm包只是一些代码和资源的打包，用于在项目中引用和使用。然而，<u>一些npm包可能会包含与第三方服务进行交互的代码，这些代码可能会发送请求</u>。</p><p>例如，一些npm包可能会包含用于访问API的代码，或包含用于从CDN加载资源的代码。</p><h2 id="如何使用原生JS发送HTTP请求？"><a href="#如何使用原生JS发送HTTP请求？" class="headerlink" title="如何使用原生JS发送HTTP请求？"></a>如何使用原生JS发送HTTP请求？</h2><p>使用JS内置的<code>XMLHttpRequest</code>发送请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建一个xhr对象</span><br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">// 使用open方法设置请求方法、url和是否异步</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;http://test.com&quot;</span>, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 设置请求头(可选)</span><br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>);<br><span class="hljs-comment">// 状态监听函数</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 请求成功</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-title function_">handle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 请求失败时的监听函数</span><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>&#125;<br><span class="hljs-comment">// 发送请求</span><br>xhr.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><h2 id="JS的引用数据类型有哪些？"><a href="#JS的引用数据类型有哪些？" class="headerlink" title="JS的引用数据类型有哪些？"></a>JS的引用数据类型有哪些？</h2><p>对象(Object)、数组(Array)和函数(Function)</p><h2 id="在给DOM元素做事件委托的时候，如何判断要对哪个子元素进行操作处理？"><a href="#在给DOM元素做事件委托的时候，如何判断要对哪个子元素进行操作处理？" class="headerlink" title="在给DOM元素做事件委托的时候，如何判断要对哪个子元素进行操作处理？"></a>在给DOM元素做事件委托的时候，如何判断要对哪个子元素进行操作处理？</h2><p>通过event.target实时获取到用户点击的子元素，并对该子元素进行操作处理。</p><h2 id="如何实现进入页面同时发送两个请求？"><a href="#如何实现进入页面同时发送两个请求？" class="headerlink" title="如何实现进入页面同时发送两个请求？"></a>如何实现进入页面同时发送两个请求？</h2><p><code>Promise.all()</code>方法</p><h2 id="使用Promise-all时，当一个请求失败时，如何获取剩余请求的结果？"><a href="#使用Promise-all时，当一个请求失败时，如何获取剩余请求的结果？" class="headerlink" title="使用Promise.all时，当一个请求失败时，如何获取剩余请求的结果？"></a>使用Promise.all时，当一个请求失败时，如何获取剩余请求的结果？</h2><p><code>Promise.all()</code>进行实现，对传入的数组进行<code>map</code>处理。</p><p>核心内容是<code>map</code>方法，<code>map</code>的每一项都是<code>promise</code>，**<code>catch</code>方法返回值会被<code>promise.resolve()</code>包裹**，这样传进<code>promise.all</code>的数据都是<code>resolved</code>状态的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">let</span> p4 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">4</span>);<br><span class="hljs-keyword">let</span> p5 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;error&quot;</span>);<br><br><span class="hljs-keyword">let</span> arr = [p1, p2, p3, p4, p5];<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e))) <span class="hljs-comment">// rejected的Promise会被处理并用resolve包裹成一个新的Promise</span><br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求成功: &quot;</span>, res);<br>&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求失败: &quot;</span>, err);<br>&#125;)<br><br><span class="hljs-comment">// 请求成功:  [ 1, 2, 3, 4, &#x27;error&#x27; ]</span><br></code></pre></td></tr></table></figure><h2 id="Promise内部是如何实现的？"><a href="#Promise内部是如何实现的？" class="headerlink" title="Promise内部是如何实现的？"></a>Promise内部是如何实现的？</h2><p><code>Promise</code> 是基于 <strong>观察者的设计模式</strong> 实现的，<code>then</code> 函数要执行的函数会被塞入观察者数组中，当 <code>Promise</code> 状态变化的时候，就去执行观察组数组中的所有函数。</p><blockquote><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。</p></blockquote><p><code>Promise</code> 有三个状态：</p><ul><li><code>pending</code>：等待中</li><li><code>resolved</code>：已成功</li><li><code>rejected</code>：已失败</li></ul><p>在 <code>Promise</code> 的状态改变只有两种可能：从 <code>pending</code> 变为 <code>resolved</code> 或者从 <code>pending</code> 变为 <code>rejected</code>。</p><p><img src="https://pic.imgdb.cn/item/6432ac3c0d2dde57778423f8.png" alt="promise-states"></p><p>每一个 <code>promise</code> 都一个 <code>then</code> 方法，这个是当 <code>promise</code> 返回结果之后，需要执行的回调函数，他有两个可选参数：</p><ul><li><code>onFulfilled</code>：成功的回调；</li><li><code>onRejected</code>：失败的回调；</li></ul><p><img src="https://pic.imgdb.cn/item/6434061e0d2dde5777204f05.png" alt="Then Catch flow"></p><h2 id="Async如何进行错误捕获？原理是什么？"><a href="#Async如何进行错误捕获？原理是什么？" class="headerlink" title="Async如何进行错误捕获？原理是什么？"></a>Async如何进行错误捕获？原理是什么？</h2><p>在<code>async</code>函数中可以使用<code>try...catch</code>捕获错误，如果在<code>async</code>函数中发生了错误，它将会被抛出并将被<code>catch</code>捕获。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">doSomething</span>();<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>    &#125;<br>    <span class="hljs-keyword">catch</span>(error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>async/await</code>是基于Promise的语法糖，它背后的原理与Promise类似。在<code>async</code>函数中，如果发生错误，它将返回一个被拒绝的Promise对象，其错误原因就是抛出的错误。我们可以使用<code>try...catch</code>来捕获这个错误，就像捕获普通的Promise一样。在<code>catch</code>块中，我们可以处理这个错误，或者将它重新抛出，以便于在async函数的代码中继续处理它。</p><h2 id="try…catch是如何捕获异常的？"><a href="#try…catch是如何捕获异常的？" class="headerlink" title="try…catch是如何捕获异常的？"></a>try…catch是如何捕获异常的？</h2><p>首先执行<code>try</code>代码块中的代码。</p><p>如果<code>try</code>代码块中的代码没有发生任何异常，那么<code>catch</code>块中的代码不会被执行，程序将继续执行<code>try...catch</code>块后面的代码。</p><p>如果<code>try</code>块中发生了异常，那么程序将立即跳转到<code>catch</code>块中，并执行其中的代码。<code>catch</code>块中的代码将处理异常，并且可以使用异常对象来获取异常的详细信息。</p><p>如果<code>catch</code>中的代码成功处理了异常，那么程序将继续执行<code>try...catch</code>后面的代码。</p><p>如果<code>catch</code>中的代码没有成功处理异常，或抛出了新的异常，那么程序将被终止，并将新的异常抛出到调用栈中，直到被捕获或导致程序崩溃。</p><h2 id="异常是如何被抛出的？"><a href="#异常是如何被抛出的？" class="headerlink" title="异常是如何被抛出的？"></a>异常是如何被抛出的？</h2><p>当程序发生错误或意外情况的时候，将创建一个异常对象。</p><p>异常对象将被抛出到当前函数的调用栈中，直到被捕获或导致程序崩溃。</p><p>当异常现象被抛出的时候，当前函数的执行将立即停止，并且将控制权传递给调用栈中的上一级函数。</p><p>如果异常对象没有被捕获，将继续向上传递，直到到达程序的顶层，或者导致程序崩溃。</p><p>如果异常对象被捕获了，那么它将被传递给相应的catch块，直到catch块中的代码被执行。</p><h2 id="如何定义错误对象？"><a href="#如何定义错误对象？" class="headerlink" title="如何定义错误对象？"></a>如何定义错误对象？</h2><p>使用Error对象来定义错误对象。Error是JS内置对象，它包含一些属性和方法，用于描述和处理错误。我们可以通过创建一个新的Error对象来定义一个错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">consr error = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;This is a error message.&quot;</span>);<br></code></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个新的Error对象，并传递了一个错误消息作为参数。这个错误消息将被包含在Error对象中，并且可以在抛出错误时被输出到控制台或日志中。</p><p>除了Error对象之外，JavaScript还提供了其他一些内置的错误类型，例如SyntaxError、TypeError和ReferenceError等，它们都继承自Error对象，并且具有不同的属性和方法，用于描述和处理特定类型的错误。</p><p>我们还可以自定义对象类型，继承自Error对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Error</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">message</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(message);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;MyError&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个名为MyError的错误类型，它继承自Error对象。我们重写了构造函数，以便在创建MyError对象时设置错误消息和错误名称。我们可以像使用内置的Error对象一样使用MyError对象来抛出和处理错误。</p><h2 id="JS的Error对象有哪些内置的属性和方法？"><a href="#JS的Error对象有哪些内置的属性和方法？" class="headerlink" title="JS的Error对象有哪些内置的属性和方法？"></a>JS的Error对象有哪些内置的属性和方法？</h2><ul><li><strong>name</strong>: 错误类型的名称，如”Error”、”SyntaxError”等。</li><li><strong>message</strong>: 错误信息的描述。</li><li><strong>stack</strong>: 错误堆栈的跟踪信息。</li><li><strong>toString()</strong>: 返回错误类型和错误信息的字符串表示形式。</li></ul><p>参考：[MDN Error](<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error">Error - JavaScript | MDN (mozilla.org)</a>)</p><h2 id="HTTPS的加密过程？"><a href="#HTTPS的加密过程？" class="headerlink" title="HTTPS的加密过程？"></a>HTTPS的加密过程？</h2><ol><li>客户端向服务器发送HTTPS请求。请求中包含了客户端支持的加密算法列表和随机数（ClientHello）。</li><li>服务器从客户端发送的加密算法列表中选择一种加密算法，并向客户端发送服务器的证书，证书中包含了服务器的公钥和证书的签名（ServerHello）。</li><li>客户端验证服务器的证书是否有效，包括证书是否过期、证书是否被吊销、证书中的域名是否和服务器的域名匹配等。如果验证通过，客户端生成一个随机数，并使用服务器的公钥加密这个随机数（ClientKeyExchange）。</li><li>服务器使用自己的私钥解密客户端发送的随机数，并使用这个随机数生成对称密钥（ServerKeyExchange）。</li><li>客户端和服务器使用这个对称密钥进行通信，将通信内容加密后发送给对方。</li></ol><p>在这个过程中，客户端和服务器使用非对称加密算法（如RSA）来完成证书的验证和随机数的加密，使用对称加密算法（如AES）来加密通信内容。这样可以保证通信过程中传输的数据是加密的，同时也保证了通信双方的身份和数据的完整性，防止数据被篡改或窃取。</p><h2 id="CSS常用的垂直对齐方式属性？"><a href="#CSS常用的垂直对齐方式属性？" class="headerlink" title="CSS常用的垂直对齐方式属性？"></a>CSS常用的垂直对齐方式属性？</h2><ol><li><code>vertical-align</code>：用于控制元素的垂直对齐方式。该属性可以应用于行内元素和表格单元格元素。取值可以是基线（baseline）、顶部（top）、底部（bottom）、中间（middle）等。</li><li><code>line-height</code>：用于设置行高。行高决定了行内元素在垂直方向上的位置和间距。可以使用具体的像素值或百分比值来设置行高。</li></ol><h2 id="如何设置rem单位等于窗口高度？"><a href="#如何设置rem单位等于窗口高度？" class="headerlink" title="如何设置rem单位等于窗口高度？"></a>如何设置rem单位等于窗口高度？</h2><p>要将<code>rem</code>单位设置为等于窗口高度，可以使用JavaScript计算窗口高度，并将其值设置为<code>html</code>元素的<code>font-size</code>属性值。这样，<code>rem</code>单位的大小就会随着窗口高度的变化而变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取窗口高区 </span><br><span class="hljs-comment">// const windowHeight = window.innerHeight; 包含滚动条高度</span><br><span class="hljs-keyword">const</span> windowHeight = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span>;<br><span class="hljs-comment">// 将窗口高度设置为html元素的fonr-size属性值</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = windowHeight + <span class="hljs-string">&quot;px&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="如何将ES6转为ES5？"><a href="#如何将ES6转为ES5？" class="headerlink" title="如何将ES6转为ES5？"></a>如何将ES6转为ES5？</h2><p>babel-loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">module</span>: &#123;<br>  <span class="hljs-attr">rules</span>: [<br>    &#123;<br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.m?js$/</span>,<br>      <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/(node_modules|bower_components)/</span>,<br>      <span class="hljs-attr">use</span>: &#123;<br>        <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>        <span class="hljs-attr">options</span>: &#123;<br>          <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>]<br>        &#125;<br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="手写数组扁平化"><a href="#手写数组扁平化" class="headerlink" title="手写数组扁平化"></a>手写数组扁平化</h2><p>递归实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">flat</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> newArr = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> arr) &#123;<br>        <span class="hljs-keyword">if</span>(item <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) &#123;<br>            newArr = newArr.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">flat</span>(item));<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            newArr.<span class="hljs-title function_">push</span>(item);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newArr;<br>&#125;<br></code></pre></td></tr></table></figure><p>reduce迭代实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">flat</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, item</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> prev.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item) ? <span class="hljs-title function_">flat</span>(item) : item);<br>    &#125;, [])<br>&#125;<br></code></pre></td></tr></table></figure><p>split和toString</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">flat</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;,&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>JSON.stringify和JSON.parse</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">flat</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> str = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(arr);<br>    str = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(\[|\])/g</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    str = <span class="hljs-string">&quot;[&quot;</span> + str + <span class="hljs-string">&quot;]&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="AJAX中的readyState从0到4分别代表什么含义？"><a href="#AJAX中的readyState从0到4分别代表什么含义？" class="headerlink" title="AJAX中的readyState从0到4分别代表什么含义？"></a>AJAX中的readyState从0到4分别代表什么含义？</h2><ul><li>0：请求未初始化。XMLHttpRequest对象已创建，但是尚未调用open方法。</li><li>1：服务器连接已建立。open方法已经调用，但是send方法未调用。请求已经建立，但是还未发送。</li><li>2：请求已接收。send方法已经调用，并且服务器已经返回了响应头。</li><li>3：请求处理中。响应体部分已经被接收，但是仍然没有完全接收。</li><li>4：请求已完成，且响应已就绪。响应体已经被完全接收，可以通过responseText或responseXML获取完整的响应数据。</li></ul><p>readyState属性只表示请求&#x2F;响应的状态，不能代表请求&#x2F;响应的结果。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈的应用</title>
    <link href="/2023/04/08/%E5%8D%95%E8%B0%83%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2023/04/08/%E5%8D%95%E8%B0%83%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>单调栈是始终保持单调递增或递减的栈，一般用于寻找数组中某个元素的下一个更大元素</p></blockquote><p>进栈过程：</p><ul><li>对于单调递增栈，如果当前进栈元素为<code>e</code>，从栈顶开始遍历元素，把小于<code>e</code>或者等于<code>e</code>的元素弹出栈，直到遇到一个大于<code>e</code>的元素或者栈空位置，然后再把<code>e</code>压入栈中。</li><li>对于单调递减栈，则每次弹出的是大于<code>e</code>或者等于<code>e</code>的元素。</li></ul><h2 id="例题1：下一个更大元素I"><a href="#例题1：下一个更大元素I" class="headerlink" title="例题1：下一个更大元素I"></a>例题1：下一个更大元素I</h2><p>题目地址: <a href="https://leetcode.cn/problems/next-greater-element-i/">下一个更大元素 I</a></p><p><code>nums1</code> 中数字 x 的 下一个更大元素 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 右侧 的 第一个 比 <code>x</code> 大的元素。</p><p>给你两个 没有重复元素 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <code>0</code> 开始计数，其中<code>nums1</code> 是 <code>nums2</code>的子集。</p><p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足<code>nums1[i] == nums2[j]</code>的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p><p>返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 下一个更大元素 。</p><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @单调栈</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums1</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums2</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> nextGreaterElement = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums1, nums2</span>) &#123;<br>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(); <br>    <span class="hljs-keyword">const</span> stack = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = nums2.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">const</span> num = nums2[i]; <span class="hljs-comment">// 取出当前数字</span><br>        <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span> &amp;&amp; num &gt;= stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]) &#123;<br>            stack.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 当栈顶元素小于num的时候,将其出栈(保证栈中元素递减)</span><br>        &#125;<br>        <span class="hljs-comment">// 找到下一个更大元素(如果栈为空,说明没有下一个更大元素,查询答案是-1)</span><br>        map.<span class="hljs-title function_">set</span>(num, stack.<span class="hljs-property">length</span> ? stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] : -<span class="hljs-number">1</span>);<br>        stack.<span class="hljs-title function_">push</span>(num); <span class="hljs-comment">// 将当前元素存入栈中</span><br>    &#125;<br>    <span class="hljs-comment">// 取出哈希表中nums1中每个元素对应的下一个更大元素</span><br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(nums1.<span class="hljs-property">length</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">_, index</span>) =&gt;</span> map.<span class="hljs-title function_">get</span>(nums1[index]));<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="例题2：商品折扣后的最终价格"><a href="#例题2：商品折扣后的最终价格" class="headerlink" title="例题2：商品折扣后的最终价格"></a>例题2：商品折扣后的最终价格</h2><p>题目地址:<a href="https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/">商品折扣后的最终价格</a></p><p>给你一个数组 <code>prices</code>，其中 <code>prices[i]</code> 是商店里第 <code>i</code> 件商品的价格。</p><p>商店里正在进行促销活动，如果你要买第 <code>i</code> 件商品，那么你可以得到与 <code>prices[j]</code> 相等的折扣，其中 <code>j</code> 是满足 <code>j &gt; i</code> 且 <code>prices[j] &lt;= prices[i]</code> 的 最小下标 ，如果没有满足条件的 <code>j</code> ，你将没有任何折扣。</p><p>请你返回一个数组，数组中第 <code>i</code> 个元素是折扣后你购买商品 <code>i</code> 最终需要支付的价格。</p><p>代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">prices</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> finalPrices = <span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) &#123;<br>    <span class="hljs-keyword">const</span> stack = []; <span class="hljs-comment">// 单调递增栈</span><br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(prices.<span class="hljs-property">length</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 存储最终价格的数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = prices.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">while</span>(stack.<span class="hljs-property">length</span> &amp;&amp; stack[stack.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>] &gt; prices[i])&#123;<br>            stack.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 如果后面元素大于当前元素,出栈</span><br>        &#125;<br>        <span class="hljs-comment">// 如果没有找到满足条件的j,则折扣为0</span><br>        res[i] = stack.<span class="hljs-property">length</span> ? prices[i] - stack[stack.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>] : prices[i];<br>        stack.<span class="hljs-title function_">push</span>(prices[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="例题3：下一个更大元素II"><a href="#例题3：下一个更大元素II" class="headerlink" title="例题3：下一个更大元素II"></a>例题3：下一个更大元素II</h2><p>题目地址:<a href="https://leetcode.cn/problems/next-greater-element-ii/">下一个更大元素 II</a></p><p>给定一个循环数组 <code>nums</code> （ <code>nums[nums.length - 1]</code> 的下一个元素是<code>nums[0]</code> ），返回 <code>nums</code> 中每个元素的 下一个更大元素 。</p><p>数字 <code>x</code> 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出<code>-1</code> 。</p><p>代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> nextGreaterElements = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">const</span> n = nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(-<span class="hljs-number">1</span>); <span class="hljs-comment">// 存储结果的数组</span><br>    <span class="hljs-keyword">const</span> stack = []; <span class="hljs-comment">// 单调栈(存储元素下标)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">2</span>*n-<span class="hljs-number">1</span>; i++)&#123; <span class="hljs-comment">// 相当于在数组之后再次进行了拼接</span><br>        <span class="hljs-keyword">const</span> num = nums[i % n]; <span class="hljs-comment">// 取出当前元素</span><br>        <span class="hljs-comment">// 当栈中有元素并且当前元素大于前面的元素,则前面元素的下一个更大数就是当前元素</span><br>        <span class="hljs-keyword">while</span>(stack.<span class="hljs-property">length</span> &amp;&amp; nums[stack[stack.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>]] &lt; num)&#123;<br>            res[stack[stack.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>]] = num; <span class="hljs-comment">// 存储下一个更大数</span><br>            stack.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 将小于等于num的数字弹出栈</span><br>        &#125;<br>        stack.<span class="hljs-title function_">push</span>(i % n); <span class="hljs-comment">// 存储元素下标</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker运行项目报错</title>
    <link href="/2023/04/08/Docker%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99/"/>
    <url>/2023/04/08/Docker%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<p>打开页面发现报错如下：</p><p><img src="http://dawning.fun/wp-content/uploads/2022/09/3160a97269cb1e4c9553081ad2b053b.png" alt="img"></p><p>进入服务器运行<code>docker ps -a</code>发现8080端口的服务处于停止状态</p><p><img src="http://dawning.fun/wp-content/uploads/2022/09/image-20220903145254986.png" alt="img"></p><p>尝试通过<code>docker start xld-front</code>启动服务失败,根据报错信息得知,8080端口被占用,无法启动服务</p><p><img src="http://dawning.fun/wp-content/uploads/2022/09/image-20220903145404282.png" alt="img"></p><p>运行<code>netstat -tanlp</code>查看端口被哪个程序占用</p><p><img src="http://dawning.fun/wp-content/uploads/2022/09/image-20220903145504171.png" alt="img"></p><p>执行指令<code>kill 659</code>(kill PID)关掉指令后重新启动</p><p><img src="http://dawning.fun/wp-content/uploads/2022/09/image-20220903145559017.png" alt="img"></p><p>启动成功！</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Docker上通过Nginx上传项目</title>
    <link href="/2023/04/08/%E5%9C%A8Docker%E4%B8%8A%E9%80%9A%E8%BF%87Nginx%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/"/>
    <url>/2023/04/08/%E5%9C%A8Docker%E4%B8%8A%E9%80%9A%E8%BF%87Nginx%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p>查看Docker中有没有Nginx镜像</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker image<br></code></pre></td></tr></table></figure><p>如果存在Nginx镜像,如图,则不需要再下载</p><p><img src="https://dawning.fun/wp-content/uploads/2022/08/image-20220816151239658.png" alt="img"></p><p>否则通过docker pull nginx指令下载Nginx镜像</p><p>创建用于存储Nginx容器相关的文件夹</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir -p <span class="hljs-regexp">/home/</span>dockers<span class="hljs-regexp">/nginx/</span>&#123;log,conf,html&#125;<br><span class="hljs-comment"># log用于存储日志</span><br><span class="hljs-comment"># conf用于存储配置文件</span><br><span class="hljs-comment"># html用于存储需要展示的文件</span><br></code></pre></td></tr></table></figure><p>创建Nginx镜像</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> <span class="hljs-comment">--name my-nginx -d nginx</span><br></code></pre></td></tr></table></figure><p>拷贝Nginx配置文件</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">docker cp my-nginx:<span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/nginx.conf /</span>home<span class="hljs-regexp">/dockers/</span>nginx<span class="hljs-regexp">/conf/</span><br>docker cp my-nginx:<span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/conf.d/</span><span class="hljs-keyword">default</span>.conf <span class="hljs-regexp">/home/</span>dockers<span class="hljs-regexp">/nginx/</span>conf<br></code></pre></td></tr></table></figure><p>进行配置文件的备份</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cp</span> default.<span class="hljs-keyword">conf</span> default.bak.<span class="hljs-keyword">conf</span><br><span class="hljs-keyword">cp</span> nginx.<span class="hljs-keyword">conf</span> nginx.bak.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><p>停掉并删除之前创建的Nginx容器</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">docker stop my-nginx<br>docker rm my-nginx<br></code></pre></td></tr></table></figure><p>用挂载的方式重新创建并运行容器</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run --privileged --name my-nginx -it -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> -v <span class="hljs-regexp">/home/</span>dockers<span class="hljs-regexp">/nginx/</span>conf<span class="hljs-regexp">/nginx.conf:/</span>etc<span class="hljs-regexp">/nginx/</span>nginx.conf:ro -v <span class="hljs-regexp">/home/</span>dockers<span class="hljs-regexp">/nginx/</span>conf<span class="hljs-regexp">/default.conf:/</span>etc<span class="hljs-regexp">/nginx/</span>conf.d<span class="hljs-regexp">/default.conf:ro -v /</span>home<span class="hljs-regexp">/dockers/</span>nginx<span class="hljs-regexp">/html:/u</span>sr<span class="hljs-regexp">/share/</span>nginx<span class="hljs-regexp">/html:rw -v /</span>home<span class="hljs-regexp">/dockers/</span>nginx<span class="hljs-regexp">/log:/</span>var<span class="hljs-regexp">/log/</span>nginx -d nginx<br></code></pre></td></tr></table></figure><p>命令解释:</p><p><strong>–privileged</strong></p><p> 使用该参数，[container]内的root拥有真正的root权限。<br>​ 否则，container内的root只是外部的一个普通用户权限。<br>​ privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。<br>​ 甚至允许你在docker容器中启动docker容器。</p><p><strong>–name</strong></p><p> 设置nginx容器的名称</p><p><strong>-p 80:80</strong></p><p> 设置访问端口和Nginx容器的监听端口的映射关系</p><p> 第一个80是访问的端口</p><p> 第二个80是Docker的Nginx配置文件监听端口</p><p><strong>-d</strong> </p><p>后台挂载运行nginx</p><p><strong>-v &#x2F;home&#x2F;dockers&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf:ro<br>-v &#x2F;home&#x2F;dockers&#x2F;nginx&#x2F;conf&#x2F;default.conf:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf:ro<br>-v &#x2F;home&#x2F;dockers&#x2F;nginx&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html:rw<br>-v &#x2F;home&#x2F;dockers&#x2F;nginx&#x2F;log:&#x2F;var&#x2F;log&#x2F;nginx</strong></p><p> 将docker容器nginx的配置文件目录、日志目录、服务访问目录和挂载到容器外</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识点整理(2)</title>
    <link href="/2023/04/08/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-2/"/>
    <url>/2023/04/08/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-2/</url>
    
    <content type="html"><![CDATA[<h1 id="整理总结-2"><a href="#整理总结-2" class="headerlink" title="整理总结(2)"></a>整理总结(2)</h1><h2 id="常见的Web安全问题有哪些？"><a href="#常见的Web安全问题有哪些？" class="headerlink" title="常见的Web安全问题有哪些？"></a>常见的Web安全问题有哪些？</h2><ul><li><p>注入漏洞</p><p>注入漏洞会让攻击者方便将恶意代码植入到目标应用系统(如解析器中)。如果你的Web应用允许用户将其输入的信息插入到后端数据库，或使用shell命令对操作系统进行调用，那么您的应用就可能会受到注入漏洞的影响。</p><p>当然，您可以通过检查应用的源代码，或对应用进行彻底的渗透测试，来发现此类漏洞。注入漏洞最常见的类型是SQL注入。攻击者会在SQL查询中，插入恶意代码，并将其转发到后端数据库服务器上，实施远程盗窃或攻击。</p><p>除常见的SQL注入之外，目前还有LDAP注入、XML注入、XPATH注入、OS命令注入、以及HTML注入。我们通常可以通过适当、及时地检查与清理用户的输入，来防范此类威胁。</p></li><li><p>身份认证失败</p><p>身份验证失败是由身份验证和会话管理控件的实施不当而引起的。如果攻击者能够成功的识别和利用那些与身份验证相关的漏洞，那么他们就能直接访问各种敏感数据和功能。</p><p>为了利用身份验证漏洞，攻击者需要通过采用诸如：凭证填充、会话劫持、密码暴力破解、以及会话ID URL重写等方法，来模拟应用程序的合法用户。</p><p>我们可以通过实施健全的会话管理控制、多因素身份验证、限制和监视失败的登录尝试，来防范此类攻击。</p></li><li><p>敏感数据泄露</p><p>当Web应用不能充分保护诸如：会话ID、密码、财务信息以及客户信息等敏感信息时，数据泄露就会发生。</p><p>此类泄漏的内部原因主要包括：未对敏感数据实施加密，仅采用了弱加密方式，软件应用的本身漏洞，以及操作员将数据上传至错误的数据库等方面。而外部攻击因素则包括：SQL注入、身份验证与访问控制的破坏、网络钓鱼攻击、以及针对明文协议HTTP、FTP和SMTP传输数据等网络级别的攻击。</p><p>为了应对此类泄漏，我们可以采取的主要措施包括：彻底检查应用程序的源代码与IT环境，尤其是正在使用安全密码算法等方面。</p></li><li><p>XML外部实体</p><p>XML外部实体注入(通常被称为XML External Entity，XXE)可以让攻击者通过Web应用的漏洞，干扰应用对于XML数据的处理。此类攻击往往会导致诸如拒绝服务、数据泄露、服务器端请求伪造等问题。</p><p>我们可以通过实施服务器端的输入验证，修补和升级所有XML处理器，以及使用SAST工具来分析源代码等方法，来有效地防止XML外部实体注入。</p></li><li><p>受损的访问控制</p><p>从概念上说，访问控制机制就是要确定用户是否可以执行，与之身份和权限相符的操作。而当用户可以在其预期权限之外执行某项操作时，那么就出现了访问控制的破坏。</p><p>受损的访问控制通常会导致：未经授权的信息泄露、数据被直接修改或破坏、以及业务功能偏离预期用途等情况。我们可以通过在受信任的服务器端代码中、或无服务器的API中，强制使用完备的访问控制机制，来防止攻击者修改元数据(metadata)，或绕过正常的访问控制检查。</p></li></ul><h2 id="如何保护Web应用程序的安全？"><a href="#如何保护Web应用程序的安全？" class="headerlink" title="如何保护Web应用程序的安全？"></a>如何保护Web应用程序的安全？</h2><ul><li>定义并采用合适的网络安全框架</li><li>跟踪资产并进行安全评估</li><li>遵循安全编码标准</li><li>部署企业级安全解决方案</li><li>尽可能自动化</li><li>对数据进行加密</li><li>渗透测试</li></ul><p>Web安全相关：<a href="https://zhuanlan.zhihu.com/p/363791438#:~:text=5%E5%A4%A7Web%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81%E4%B8%8E7%E5%A4%A7%E9%98%B2%E6%8A%A4%E6%8E%AA%E6%96%BD%201%201.%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%202%202.%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E5%A4%B1%E8%B4%A5%203%203.%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E6%B3%84%E6%BC%8F%204,5.%E5%8F%97%E6%8D%9F%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%206%201.%E5%AE%9A%E4%B9%89%E5%B9%B6%E9%87%87%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%207%202.%E8%B7%9F%E8%B8%AA%E6%82%A8%E7%9A%84%E8%B5%84%E4%BA%A7%E5%B9%B6%E8%BF%9B%E8%A1%8C%E5%A8%81%E8%83%81%E8%AF%84%E4%BC%B0%208%203.%E9%81%B5%E5%AE%88%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%20%E6%9B%B4%E5%A4%9A%E9%A1%B9%E7%9B%AE">5大Web应用安全威胁与7大防护措施</a></p><h2 id="什么是前端工程化？"><a href="#什么是前端工程化？" class="headerlink" title="什么是前端工程化？"></a>什么是前端工程化？</h2><p>对前端进行一些流程的标准化，让开发变得更有效率，且更好的做产品交付。前端工程化是使用软件工程的技术和方法来进行前端的开发流程、技术、工具、经验等规范化、标准化，其主要目的是为了提高效率和降低成本，即提高开发过程中的开发效率，减少不必要的重复工作时间。</p><p><a href="https://zhuanlan.zhihu.com/p/588483704">前端工程化指的是什么？</a></p><h2 id="如何实现模块懒加载？"><a href="#如何实现模块懒加载？" class="headerlink" title="如何实现模块懒加载？"></a>如何实现模块懒加载？</h2><p>模块懒加载是指在需要模块的时候才进行加载，而不是在应用启动时就加载所有的模块，这样可以提高应用的启动速度与性能。实现模块懒加载的方法由很多，比如：</p><ul><li>Webpack实现</li><li>ES6 import()</li></ul><h2 id="Http3-0更新了什么？"><a href="#Http3-0更新了什么？" class="headerlink" title="Http3.0更新了什么？"></a>Http3.0更新了什么？</h2><ul><li><p><strong>使用UDP代替TCP，不需要复杂的创建连接和关闭连接的成本</strong></p></li><li><p><strong>基于传输层的多路复用，避免队头阻塞</strong></p></li><li><p><strong>向前纠错</strong> (每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传)</p><p>向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间（包括确认数据包丢失、请求重传、等待新数据包等步骤的时间消耗）。</p></li><li><p><strong>加密认证的报文</strong></p><p>TCP协议头部没有经过任何加密和认证，所以在传输的过程中很容易被中间网络设备篡改、注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也可能是主动攻击。</p><p>但是QUIC的packet除了个别报文比如说PUBLIC_RESET和CHLO，所有的报文头部都是经过认证的，报文体都是经过加密的。</p><p>这样只要对QUIC报文进行任何修改，接收端都能够及时发现，有效地降低了安全风险。</p></li></ul><p>参考：<a href="https://limeii.github.io/2019/06/http2-http3/">Http3.0更新了什么</a></p><h2 id="前端常见的安全问题？"><a href="#前端常见的安全问题？" class="headerlink" title="前端常见的安全问题？"></a>前端常见的安全问题？</h2><ul><li>跨站脚本攻击(XSS)</li><li>跨站请求伪造(CSRF)</li><li>点击劫持(Click Jacking)</li><li>HTTP严格传输安全(HSTS)</li><li>CDN劫持</li><li>SQL注入攻击</li></ul><h2 id="如何进行防范？"><a href="#如何进行防范？" class="headerlink" title="如何进行防范？"></a>如何进行防范？</h2><ul><li>输入检查：对用户输入的数据进行检查和过滤，防止XSS和SQL注入等攻击。</li><li>输出攻击：对输出到页面上的数据进行检查和过滤，防止XSS攻击。</li><li>防范CSRF攻击：在请求中添加随机数或者验证码。</li><li>防止点击劫持：使用X-FRAME-OPTIONS头部或者JS脚本防止点击劫持</li><li>防止HTTP劫持：使用HTTPS协议或HTTP严格传输安全(HSTS)协议防范HTTP劫持</li><li>防止CDN劫持：使用SRI，为了防止校验资源完整性来判断是否被篡改。它通过验证文件的哈希值是否与你提供的哈希值一样来判断资源是否被篡改。</li></ul><h2 id="XSS与CSRF的攻击场景？"><a href="#XSS与CSRF的攻击场景？" class="headerlink" title="XSS与CSRF的攻击场景？"></a>XSS与CSRF的攻击场景？</h2><p>XSS：跨站脚本攻击，攻击者将恶意脚本嵌入到被攻击网站中，当用户访问该网站时，恶意脚本会被执行，从而达到获取用户信息、窃取Cookie等目的。</p><p>攻击场景：评论区、搜索框、留言板、聊天室。</p><p>CSRF：跨站请求伪造。攻击者通过某种方法诱导用户访问被攻击网站，从而在用户不知情的情况下发起恶意请求，如转账、修改密码等。</p><p>攻击场景：点击链接、打开图片、访问网页等。</p><h2 id="如果通过-html-标签内的-src-属性攻击-只能攻击到-GET-请求-如何攻击到-POST-请求？"><a href="#如果通过-html-标签内的-src-属性攻击-只能攻击到-GET-请求-如何攻击到-POST-请求？" class="headerlink" title="如果通过 html 标签内的 src 属性攻击, 只能攻击到 GET 请求, 如何攻击到 POST 请求？"></a>如果通过 html 标签内的 src 属性攻击, 只能攻击到 GET 请求, 如何攻击到 POST 请求？</h2><p>如果攻击者想要攻击POST请求，可以使用类似XSS攻击的方式，即通过在HTML标签内嵌入恶意代码，从而实现攻击。例如，攻击者在一个表单中插入一个隐藏的iframe，然后将表单的提交地址修改为攻击者的服务器地址，当用户提交表单的时候，iframe自动向被攻击网站发起POST请求，从而实现CSRF攻击。</p><h2 id="多进程编程的难点和解决方案？"><a href="#多进程编程的难点和解决方案？" class="headerlink" title="多进程编程的难点和解决方案？"></a>多进程编程的难点和解决方案？</h2><p>多线程编程的难点主要有以下几个方面：线程安全、死锁、资源竞争、线程间通信等。</p><p>其中，线程安全是多线程编程中最重要的问题之一，它涉及到<strong>多个线程同时访问同一个共享资源时的数据一致性问题</strong>。</p><p>死锁是指两个或多个进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法继续执行下去。</p><p>资源竞争是指多个线程同时访问同一个共享资源时，由于访<strong>问顺序不当而导致程序出现错误</strong>。</p><p>线程间通信是指多个线程之间相互协作完成任务的过程，包括等待通知机制、管道机制、信号量机制等。</p><h2 id="script的引入方式有哪些？"><a href="#script的引入方式有哪些？" class="headerlink" title="script的引入方式有哪些？"></a>script的引入方式有哪些？</h2><p>script的引入方式有三种：行内式、嵌入式和外链式。</p><ul><li><p>行内式是将JavaScript代码作为HTML标签的属性值使用。</p></li><li><p>嵌入式使用<code>&lt;script&gt;</code>标签包裹JavaScript代码，直接编写到HTML文件中，通常将其放到<code>&lt;head&gt;</code>标签或<code>&lt;body&gt;</code>标签中。</p></li><li><p>外链式是将JavaScript代码写在一个单独的文件中，一般使用<code>.js</code>作为文件的扩展名，在HTML页面中使用<code>&lt;script&gt;</code>标签的<code>src</code>属性引入<code>.js</code>文件。外链式适合<code>JS</code>代码量较多的情况。</p></li></ul><h2 id="localStorage和Cookie存储如果不注意的话，会有什么安全问题？"><a href="#localStorage和Cookie存储如果不注意的话，会有什么安全问题？" class="headerlink" title="localStorage和Cookie存储如果不注意的话，会有什么安全问题？"></a>localStorage和Cookie存储如果不注意的话，会有什么安全问题？</h2><p>Cookie容易受到跨站脚本攻击(XSS)和跨站请求伪造(CSRF)的攻击；而localStorage容易受到跨站脚本攻击(XSS)的攻击。</p><ul><li><p>对于Cookie，可以使用HttpOnly标志来防止XSS攻击，使其无法通过JS进行访问；使用SameSite标志来防止CSRF攻击。</p></li><li><p>对于localStorage，尽量不要存储敏感信息，或者使用sessionStorage进行替代。</p></li></ul><h2 id="首屏加载、白屏时间长可能是哪些原因导致的？"><a href="#首屏加载、白屏时间长可能是哪些原因导致的？" class="headerlink" title="首屏加载、白屏时间长可能是哪些原因导致的？"></a>首屏加载、白屏时间长可能是哪些原因导致的？</h2><ul><li>打包后的js和css文件过大，浏览器初始访问网站时，会先加载该项目的js和css文件，加载完成后才会进行页面渲染。如果打包的文件过大，加载时间就会变长，出现视觉上的页面白屏，可以使用webpack进行代码分割、懒加载等优化，减小入口文件体积。</li><li>网络延迟：网络延迟是影响首屏加载速度的主要因素之一。可以通过使用CDN、DNS预解析等方式来减少网络延迟时间。</li><li>资源重复请求加载：可以使用Webpack的splitChunks进行公共代码抽离，避免重复请求。</li><li>加载脚本的过程中，渲染堵塞：可以使用defer、async等属性来异步加载脚本，避免渲染堵塞。</li></ul><h2 id="页面响应式布局方式？"><a href="#页面响应式布局方式？" class="headerlink" title="页面响应式布局方式？"></a>页面响应式布局方式？</h2><p>媒体查询、弹性布局、rem布局、自适应布局、百分比布局、grid布局</p><h2 id="如何实现CSS的渐变？"><a href="#如何实现CSS的渐变？" class="headerlink" title="如何实现CSS的渐变？"></a>如何实现CSS的渐变？</h2><p>CSS渐变可以让你在两个或多个指定的颜色之间显示平稳的过渡。CSS定义了两种渐变类型：线性渐变和径向渐变。线性渐变是从一个方向到另一个方向的颜色过渡，而径向渐变是从一个中心点到另一个中心点的颜色过渡。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(red, yellow); <span class="hljs-comment">/* 从上到下(默认)渐变 */</span><br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(to right, red , yellow); <span class="hljs-comment">/* 从左到右渐变 */</span><br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(to bottom right, red, yellow); <span class="hljs-comment">/* 从坐上到右下线性渐变 */</span><br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(angle, color-stop1, color-stop2); <span class="hljs-comment">/* angle指定水平线与渐变线之间的角度 */</span><br></code></pre></td></tr></table></figure><h2 id="forEach和map的区别？"><a href="#forEach和map的区别？" class="headerlink" title="forEach和map的区别？"></a>forEach和map的区别？</h2><p>forEach会针对每个元素执行提供的操作，该方法没有返回值。</p><p>如果对数据进行操作，如果是基础数据类型，不会有效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    item *= <span class="hljs-number">2</span>;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1,2,3,4,5]</span><br></code></pre></td></tr></table></figure><p>但如果是引用数据类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<br>    &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;001&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;LiHua&quot;</span><br>    &#125;, <br>    &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;002&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;XiaoMei&quot;</span><br>    &#125;<br>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(item.<span class="hljs-property">id</span> === <span class="hljs-string">&quot;001&quot;</span>) &#123;<br>        item.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;LiQiang&quot;</span>;<br>    &#125;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [ &#123; id: &#x27;001&#x27;, name: &#x27;LiQiang&#x27; &#125;, &#123; id: &#x27;002&#x27;, name: &#x27;XiaoMei&#x27; &#125; ]</span><br></code></pre></td></tr></table></figure><p>这是因为forEach中的item并不是真正的数组中的项，而是对数组中项的复制，因此如果是原始数据类型，修改它的复制元素并不会影响到它本身，而对于引用数据类型，复制的是对数据的引用，<strong>因此修改item的属性，对应的原始值的属性也会变化</strong>，但是直接修改item，将其指向另一个数据的话也不行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<br>    &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;001&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;LiHua&quot;</span><br>    &#125;, <br>    &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;002&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;XiaoMei&quot;</span><br>    &#125;<br>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(item.<span class="hljs-property">id</span> === <span class="hljs-string">&quot;001&quot;</span>) &#123;<br>        item = &#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&quot;003&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;XiaoMei&quot;</span>&#125;;<br>    &#125;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [ &#123; id: &#x27;001&#x27;, name: &#x27;LiHua&#x27; &#125;, &#123; id: &#x27;002&#x27;, name: &#x27;XiaoMei&#x27; &#125; ]</span><br></code></pre></td></tr></table></figure><p>而如果是下面的方法，原始数据类型和引用数据类型都能被修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>    arr[index] = item * <span class="hljs-number">2</span>;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [2,4,6,8,10]</span><br></code></pre></td></tr></table></figure><p>forEach使用return方法只能跳出本次循环，要想跳出整个循环需要抛出错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(item === <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-comment">// return;</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;你好&quot;</span>)<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>&#125;)<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * forEach跳出循环：抛出错误</span><br><span class="hljs-comment"> * 跳出本次循环：return</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>map方法会改变原数组的值，返回一个新的数组，新数组中的值为原数组调用函数处理后的值。</p><h2 id="for…in和for…of的区别？"><a href="#for…in和for…of的区别？" class="headerlink" title="for…in和for…of的区别？"></a>for…in和for…of的区别？</h2><p>for…of是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构(对象、数组等)并返回各项的值，二者区别如下：</p><ul><li>for…of遍历获取的是对象的键值，而for…in获取的是对象的键名</li><li>for…in会遍历对象的整个原型链，性能非常差不推荐使用，而for…of只会遍历当前对象不会遍历原型链</li><li>对数组的遍历，for…in会返回数组中所有可枚举对象(包括原型链上的可枚举对象)，for…of只返回数组下标对应的属性值。</li></ul><h2 id="如何使用for…of遍历对象？"><a href="#如何使用for…of遍历对象？" class="headerlink" title="如何使用for…of遍历对象？"></a>如何使用for…of遍历对象？</h2><ul><li>如果是类数组对象，使用Array.from进行转换</li><li>如果不是，添加[Symbol.iterator]属性，并指向一个迭代器即可 (yield进行添加) 。</li></ul><h2 id="Webpack中热更新-HMR-的原理是什么？"><a href="#Webpack中热更新-HMR-的原理是什么？" class="headerlink" title="Webpack中热更新(HMR)的原理是什么？"></a>Webpack中热更新(HMR)的原理是什么？</h2><p><code>HMR</code>全称 <code>Hot Module Replacement</code>，可以理解为模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用。</p><p>开启热更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>)<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-comment">// 开启 HMR 特性</span><br>    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span><br>    <span class="hljs-comment">// hotOnly: true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/1725635059c3e804~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ul><li>Webpack Compile：将 JS 源代码编译成 bundle.js</li><li>HMR Server：用来将热更新的文件输出给 HMR Runtime</li><li>Bundle Server：静态资源文件服务器，提供文件访问路径</li><li>HMR Runtime：socket服务器，会被注入到浏览器，更新文件的变化</li><li>bundle.js：构建输出的文件</li><li>在HMR Runtime 和 HMR Server之间建立 websocket，即图上4号线，用于实时更新文件变化</li></ul><p>热更新的两个过程</p><ul><li><p>启动阶段 1 - 2 - A - B</p><p>首先我们在文件系统便写完代码之后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server，Bundle Server 是一个服务器，这样在浏览器里就可以以服务的方式访问文件。</p></li><li><p>更新阶段 1 - 2 - 3 - 4</p><p>当我们在文件系统更新文件之后，还是会经过 Webpack Compile 的编译，Webpack Compile 会将编译后的结果传递给 HMR Server，HMR Server 会比较哪些文件发生了变化，因为服务端的 HMR Server 会和客户端的 HMR Runtime 建立起一条 websocket 链接，所以 HMR Server 会以 json 的形式通知给 HMR Runtime 文件做出了哪些变化。</p></li></ul><p><strong>总结：</strong></p><ul><li>通过<code>webpack-dev-server</code>创建两个服务器：提供静态资源的服务（express）和Socket服务</li><li>express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）</li><li>socket server 是一个 websocket 的长连接，双方可以通信</li><li>当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）</li><li>通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）</li><li>浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新</li></ul><p>参考：<a href="https://juejin.cn/post/6844904134697549832">https://juejin.cn/post/6844904134697549832</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识点整理(1)</title>
    <link href="/2023/04/08/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-1/"/>
    <url>/2023/04/08/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-1/</url>
    
    <content type="html"><![CDATA[<h1 id="整理总结-1"><a href="#整理总结-1" class="headerlink" title="整理总结(1)"></a>整理总结(1)</h1><h2 id="Vite比Webpack快的原因？"><a href="#Vite比Webpack快的原因？" class="headerlink" title="Vite比Webpack快的原因？"></a>Vite比Webpack快的原因？</h2><p>Vite比Webpack快的原因的因为Vite在开发阶段使用了浏览器原生ES模块导入，而不是想Wepkack一样使用打包后的文件。这使得Vite在开发阶段的热更新速度更快，因为它不需要重新打包整个应用程序，而只需要更新更改的部分。</p><h2 id="前端如何判断内存泄漏？如何处理？"><a href="#前端如何判断内存泄漏？如何处理？" class="headerlink" title="前端如何判断内存泄漏？如何处理？"></a>前端如何判断内存泄漏？如何处理？</h2><p>检测方法：</p><ul><li><p>使用Chrome的开发者工具profiles来进行快照对比。</p><ul><li>打开Chrome浏览器，进入开发者工具。</li><li>点击Profiles选项卡，选择Take Heap Snapshot或Take Allocation Profile。</li><li>进行操作后，再次点击Profiles选项卡，选择Compare Snapshots或Compare Allocation Profiles。</li><li>选择两个快照进行比较，即可看到两个快照之间的差异。</li></ul></li><li><p>在Node环境下，可以使用Node提供的<code>process.memoryUsage()</code>方法来检查内存泄漏。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">process.<span class="hljs-title function_">memoryUsage</span>();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">res: 2366456,</span><br><span class="hljs-comment">heapTotal: 9232384,</span><br><span class="hljs-comment">heapUsed: 5019712,</span><br><span class="hljs-comment">external: 8776</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li><p>res: (Resident Set Size)操作系统分配给进程的总的内存大小。</p></li><li><p>heapTotal：堆的总大小，包括3个部分，</p><ul><li>已分配的内存，用于对象的创建和存储，对应于heapUsed</li><li>未分配的但可用于分配的内存</li><li>未分配的但不能分配的内存，例如在垃圾收集（GC）之前对象之间的内存碎片</li></ul></li><li><p>heapUsed: 已分配的内存，即堆中所有对象的总大小，是heapTotal的子集</p></li><li><p>external: 进程使用到的系统链接库所占用的内存</p></li></ul><p>判断内存泄漏以heapUsed为准</p></li><li><p>利用Performance录制页面性能变化，若内存下限不断升高，则可能发生了内存泄漏</p></li></ul><p>如何处理内存泄漏？</p><p>变量导致的内存泄漏，将变量清除为null即可</p><p>事件导致的内存泄漏，监听后移除即可。</p><h2 id="为什么Redux要设计action等工具，而不是允许用户直接进行修改？"><a href="#为什么Redux要设计action等工具，而不是允许用户直接进行修改？" class="headerlink" title="为什么Redux要设计action等工具，而不是允许用户直接进行修改？"></a>为什么Redux要设计action等工具，而不是允许用户直接进行修改？</h2><p>设计action等工具是为了更好的管理状态。通过使用action，可以确保状态的变化是可预测的，因为它们只能通过dispatch函数进行更改，这样可以避免在应用程序中出现意外的状态变化，从而使代码更具有可维护性和可测试性。此外，使用action还可以使我们更好的跟踪应用程序中发生的事情，因为每个action都有唯一的标识符，可以轻松跟踪它们。</p><h2 id="组件库是如何实现让用户按需加载的？"><a href="#组件库是如何实现让用户按需加载的？" class="headerlink" title="组件库是如何实现让用户按需加载的？"></a>组件库是如何实现让用户按需加载的？</h2><p>通过支持基于ES模块的tree shaking来实现按需加载。只需要直接引入需要的组件，就可以实现按需加载的效果。</p><h2 id="axios的二次封装一般封装了什么？"><a href="#axios的二次封装一般封装了什么？" class="headerlink" title="axios的二次封装一般封装了什么？"></a>axios的二次封装一般封装了什么？</h2><p>设置超时事件、请求头、请求方法、错误处理，请求拦截器和响应拦截器等操作，如果重复进行劳动会浪费时间并使得代码变得冗余难以维护。</p><p>在请求拦截器中可以统一添加超时处理或取消请求等需要在请求前执行的事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 每次发送请求之前判断是否存在token</span><br>    <span class="hljs-comment">// 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况，此处token一般是用户完成登录后储存到localstorage里的</span><br>    token &amp;&amp; (config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = token)<br>    <span class="hljs-keyword">return</span> config<br>  &#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>&#125;)<br></code></pre></td></tr></table></figure><p>响应拦截器可以在接收到响应后先做一层操作，如根据状态码判断登陆状态、授权等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 响应拦截器</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据</span><br>  <span class="hljs-comment">// 否则的话抛出错误</span><br>  <span class="hljs-keyword">if</span> (response.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-keyword">if</span> (response.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> === <span class="hljs-number">511</span>) &#123;<br>      <span class="hljs-comment">// 未授权调取授权接口</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (response.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> === <span class="hljs-number">510</span>) &#123;<br>      <span class="hljs-comment">// 未登录跳转登录页</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(response)<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(response)<br>  &#125;<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 我们可以在这里对异常状态作统一处理</span><br>  <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span>) &#123;<br>    <span class="hljs-comment">// 处理请求失败的情况</span><br>    <span class="hljs-comment">// 对不同返回码对相应处理</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error.<span class="hljs-property">response</span>)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="Tree-Shaking的实现原理？"><a href="#Tree-Shaking的实现原理？" class="headerlink" title="Tree-Shaking的实现原理？"></a>Tree-Shaking的实现原理？</h2><p>Tree-Shaking是一种基于ES Module规范的Dead Code Elimination技术，它会在运行过程中静态分析模块之间的导入导出，确定ESM模块中的哪些导出值未曾被其他模块使用，并将其删除，以此实现打包产物的优化。</p><ul><li>Make阶段，收集模块导出变量并记录到模块依赖关系图ModuleGraph变量中</li><li>Seal阶段，遍历ModuleGraph标记模块导出变量有没有被使用</li><li>生成产物时，若变量没有被其他模块使用则删除对应的导出语言</li></ul><blockquote><p>标记功能需要配置 <code>optimization.usedExports = true</code> 开启</p></blockquote><h2 id="手写图片懒加载"><a href="#手写图片懒加载" class="headerlink" title="手写图片懒加载"></a>手写图片懒加载</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">lazyload</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> imgs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;img&#x27;</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> len = imgs.<span class="hljs-property">length</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> viewHeight = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span>;</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> scrollHeight = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span>;</span><br><span class="language-javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> offsetHeight = imgs[i].<span class="hljs-property">offsetTop</span>;</span><br><span class="language-javascript">            <span class="hljs-keyword">if</span> (offsetHeight &lt; viewHeight + scrollHeight) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">const</span> src = imgs[i].<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>;</span><br><span class="language-javascript">                imgs[i].<span class="hljs-property">src</span> = src;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, lazyload);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="针对弱网环境如何从Http的角度去做前端优化？"><a href="#针对弱网环境如何从Http的角度去做前端优化？" class="headerlink" title="针对弱网环境如何从Http的角度去做前端优化？"></a>针对弱网环境如何从Http的角度去做前端优化？</h2><ul><li>使用CDN加速，避免弱网环境下资源加载过慢</li><li>使用HTTP Cache、Service Worker和Cache Storage API等技术进行缓存资源，避免重复请求</li><li>对于移动端，可以使用SSR、CSR、预渲染等技术，提升网页首帧优化，从而优化白屏问题，提升用户体验</li></ul><h2 id="Webpack打包原理"><a href="#Webpack打包原理" class="headerlink" title="Webpack打包原理"></a>Webpack打包原理</h2><p>Webpack处理应用程序时，它会递归的构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle。Webpack的打包原理就是将所有的模块霸道成一个或多个Bundle，以便于在浏览器中加载和使用。</p><p>Webpack就像是一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有当完成当前处理后才能交给下一个流程去处理。而插件就像是插入到生产线中的一个功能，在特定的时机对生产线上的资源进行处理。</p><p>Webpack打包原理：<a href="https://zhuanlan.zhihu.com/p/101541041">https://zhuanlan.zhihu.com/p/101541041</a></p><h2 id="Webpack打包流程？"><a href="#Webpack打包流程？" class="headerlink" title="Webpack打包流程？"></a>Webpack打包流程？</h2><ol><li>解析配置文件：Webpack会读取并解析配置文件(通常为webpack.config.js文件)。并根据配置生成一个Compiler对象。</li><li>读取入口文件：Webpack会根据配置中的入口文件，读取这些文件及其依赖的模块，并将它们组成一个依赖图。</li><li>解析模块依赖：Webpack会根据模块之间的依赖关系，递归的解析它们的依赖。直到所有的依赖都被解析完毕。</li><li>加载模块：Webpack会根据模块的路径，使用相应的Loader加载模块的源代码，并将其转换成Webpack可以处理的形式。</li><li>转换代码：Webpack会根据配置中的插件，对加载的模块进行一系列的转换操作，比如压缩，优化等。</li><li>生成代码：Webpack会将所有模块转换后的代码都合并到一个或多个文件中并输出到指定目录中。</li></ol><p>Webpack打包流程：<a href="https://juejin.cn/post/7210756376309203005">简析Webpack打包流程 - 掘金 (juejin.cn)</a></p><h2 id="useRef有哪些作用？"><a href="#useRef有哪些作用？" class="headerlink" title="useRef有哪些作用？"></a>useRef有哪些作用？</h2><p>React中的useRef是一个Hook，它返回一个可变的ref对象，它的<code>.current</code>属性被初始化为传入的参数(initialValue)。useRef可以用来存储任何可变值，就像在类数组中使用实例属性一样。</p><p>useRef返回的对象在组件的整个生命周期中保持不变，因此可以用来存储哪些 不需要触发重新渲染的值，例如定时器或其他引用类型的值。另外，useRef还可以用来获取DOM元素或者其他组件的实例。</p><p>作用：</p><ul><li>存储状态</li><li>获取DOM元素或其他组件实例</li></ul><h2 id="如何在父组件中执行子组件内部的方法-不知道这个子组件内部方法的名称-？"><a href="#如何在父组件中执行子组件内部的方法-不知道这个子组件内部方法的名称-？" class="headerlink" title="如何在父组件中执行子组件内部的方法(不知道这个子组件内部方法的名称)？"></a>如何在父组件中执行子组件内部的方法(不知道这个子组件内部方法的名称)？</h2><p>使用useRef进行解决</p><h2 id="React中父组件如何向子孙组件传值？"><a href="#React中父组件如何向子孙组件传值？" class="headerlink" title="React中父组件如何向子孙组件传值？"></a>React中父组件如何向子孙组件传值？</h2><ul><li>props</li><li>useContext</li></ul><h2 id="子孙组件如何修改通过useContext获取到的值？"><a href="#子孙组件如何修改通过useContext获取到的值？" class="headerlink" title="子孙组件如何修改通过useContext获取到的值？"></a>子孙组件如何修改通过useContext获取到的值？</h2><p>在父组件中定义一个state，然后将state和其更新方法一起传递给context对象，然后再需要的时候调用该函数修改state。</p><p>例如：在App.jsx中定义count，并将其传递给Context</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; createContext, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Father</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Father&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> C = <span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">C.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;count,</span> <span class="hljs-attr">setCount</span>&#125;&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Father</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">C.Provider</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在Father组件中引用Son组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../Son&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Son</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Son</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>最终在子组件中展示count以及修改count</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; C &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../App&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;count, setCount&#125; = <span class="hljs-title function_">useContext</span>(C);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>count的值为&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count+1)&#125;&gt;点我+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="context封装的值改变了，会触发组件的重新渲染吗？"><a href="#context封装的值改变了，会触发组件的重新渲染吗？" class="headerlink" title="context封装的值改变了，会触发组件的重新渲染吗？"></a>context封装的值改变了，会触发组件的重新渲染吗？</h2><p>在 React 中，当一个组件被包裹在一个 Context Provider 中时，只有当该组件<strong>直接依赖于该 Context 数据</strong>时，才会在 Context 数据发生变化时重新渲染。</p><p>如果一个组件被包裹在一个 Context Provider 中，但是它并没有使用该 Context 数据，那么该组件不会在 Context 数据发生变化时重新渲染。</p><p>这是因为 React 使用了优化算法来避免不必要的重新渲染，也就是说，只有当组件的 props 或者 state 发生变化时，才会触发重新渲染。而对于 Context 数据的变化，只有当该 Context 数据被使用的组件才会重新渲染。</p><p><del>当<code>Context</code>中某一个值改变，所有<strong>使用了该<code>Context</code>的组件</strong>一定都会更新。</del></p><p><del>如果想要避免组件重新渲染，可以使用React.memo。</del></p><p><del>如果组件没有使用Context，但是被Context包裹，当Context封装的值改变时，React不会重新渲染该组件。</del></p><p><del>如果一个组件没有使用Context，但是被Context包裹，当Context封装的值改变时，React会重新渲染该组件。这是因为React会检查组件的所有祖先节点是否有更新，如果有更新，React会重新渲染这些组件。因此，即使一个组件没有使用Context，但是它被Context包裹，当Context封装的值改变时，React也会重新渲染该组件。</del></p><h2 id="假如在某个子孙组件中-使用了-useEffect-其依赖项中记录了某个-context-当-context-值变了-会触发-useEffect-内包裹的函数执行吗-会触发该组件的重新渲染吗"><a href="#假如在某个子孙组件中-使用了-useEffect-其依赖项中记录了某个-context-当-context-值变了-会触发-useEffect-内包裹的函数执行吗-会触发该组件的重新渲染吗" class="headerlink" title="假如在某个子孙组件中, 使用了 useEffect, 其依赖项中记录了某个 context, 当 context 值变了, 会触发 useEffect 内包裹的函数执行吗? 会触发该组件的重新渲染吗?"></a>假如在某个子孙组件中, 使用了 useEffect, 其依赖项中记录了某个 context, 当 context 值变了, 会触发 useEffect 内包裹的函数执行吗? 会触发该组件的重新渲染吗?</h2><p>使用useEffect包裹context的值，当context的值发生变化会触发useEffect包裹的函数执行，即使props和state没有发生变化，也会导致该组件的重新渲染，但是如果使用React.memo包裹就不会导致组件重新渲染了。<del>但是不会触发该组件的重新渲染。</del></p><h2 id="Http-301和302状态码的区别？"><a href="#Http-301和302状态码的区别？" class="headerlink" title="Http 301和302状态码的区别？"></a>Http 301和302状态码的区别？</h2><p>二者都是重定向状态码，都代表着某个URL发生了转移。不同支持在于，301表示永久性转移，表示请求的资源分配了新的URL，以后应使用新的URL；而302表示暂时性转移，请求的资源临时分配了新的URL，本次请求暂且使用新URL，重定向的URL可能还会改变。</p><h2 id="在触发301状态码的时候，浏览器会把更新的url存放在何处？"><a href="#在触发301状态码的时候，浏览器会把更新的url存放在何处？" class="headerlink" title="在触发301状态码的时候，浏览器会把更新的url存放在何处？"></a>在触发301状态码的时候，浏览器会把更新的url存放在何处？</h2><p>当浏览器收到301状态码时，会把更新的URL存放在响应头的Location字段中，浏览器会自动重定向到该URL，301状态码表示永久性转移，所以浏览器会记住这个URL，下次访问该URL，浏览器会直接访问新的URL，不再请求旧的URL。</p><h2 id="Promise的优点和缺点？"><a href="#Promise的优点和缺点？" class="headerlink" title="Promise的优点和缺点？"></a>Promise的优点和缺点？</h2><p>优点：</p><p>将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数，提供了统一的接口，使得控制异步操作更加容易。</p><p>缺点：</p><p>无法取消Promise，一旦新建后它就会立即执行，无法中途取消；如果不设置回调函数，Promise内部抛出错误不会反应到外部；当处于Pending状态时，无法得知现在处于哪个阶段(刚刚开始还是即将完成)。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算及其应用</title>
    <link href="/2023/04/08/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <url>/2023/04/08/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="判断一个整数n是否为负数"><a href="#判断一个整数n是否为负数" class="headerlink" title="判断一个整数n是否为负数"></a>判断一个整数n是否为负数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 判断n是负数还是非负数</span><br><span class="hljs-comment"> * if n是非负数,返回1</span><br><span class="hljs-comment"> * if n是负数,返回0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">sign</span> = (<span class="hljs-params">n</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>-((n &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="比较两个数的大小"><a href="#比较两个数的大小" class="headerlink" title="比较两个数的大小"></a>比较两个数的大小</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 位运算获取较的大值</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getMax1</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> c = a-b; <span class="hljs-comment">// a&gt;=b时,c&gt;=0;否则c&lt;0</span><br>    <span class="hljs-keyword">let</span> scA = <span class="hljs-title function_">sign</span>(c); <span class="hljs-comment">// a-b为非负,scA为1,a-b为负,scA为0(当scA为1的时候,a比较大)</span><br>    <span class="hljs-keyword">let</span> scB = <span class="hljs-number">1</span>-scA; <span class="hljs-comment">// 当scB为1的时候,b比较大</span><br>    <span class="hljs-comment">// 当scA为0的时候,scB一定为1,当scA为1的时候,scB一定为0</span><br>    <span class="hljs-comment">// (若scA为1,返回a,若scB为1,返回b)</span><br>    <span class="hljs-keyword">return</span> a*scA + b*scB;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码有一个缺点,即当a,b异号且相差较大的时候,c可能溢出</p><p>改善后的代码为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 优化后</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getMax2</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> c = a-b; <span class="hljs-comment">// a&gt;=b时,c&gt;=0;否则c&lt;0</span><br>    <span class="hljs-keyword">let</span> sa = <span class="hljs-title function_">sign</span>(a); <span class="hljs-comment">// a&gt;=0时sa=1,否则sa=0</span><br>    <span class="hljs-keyword">let</span> sb = <span class="hljs-title function_">sign</span>(b); <span class="hljs-comment">// b&gt;=0时sb=1,否则sb=0</span><br>    <span class="hljs-keyword">let</span> sc = <span class="hljs-title function_">sign</span>(c); <span class="hljs-comment">// c&gt;=0时sc=1,否则sc=0</span><br>    <span class="hljs-comment">// 异或运算,判断a,b是否同号</span><br>    <span class="hljs-keyword">let</span> difSab = sa ^ sb; <span class="hljs-comment">// a和b的符號不同为1,相同为0</span><br>    <span class="hljs-keyword">let</span> sameSab = <span class="hljs-number">1</span> - difSab; <span class="hljs-comment">// a和b的符号一样为1,不一样为0</span><br>    <span class="hljs-comment">// 当二者不同号且a&gt;=0时,returnA=1,当二者同号且a&gt;=b(c&gt;=0)时,returnA为1,否则为0</span><br>    <span class="hljs-keyword">let</span> returnA = difSab * sa + sameSab * sc;<br>    <span class="hljs-keyword">let</span> returnB = <span class="hljs-number">1</span> - returnA;<br>    <span class="hljs-comment">// 返回较大的数</span><br>    <span class="hljs-keyword">return</span> a*returnA + b*returnB;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="判断一个32位正数是不是2的幂-4的幂"><a href="#判断一个32位正数是不是2的幂-4的幂" class="headerlink" title="判断一个32位正数是不是2的幂,4的幂"></a>判断一个32位正数是不是2的幂,4的幂</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 判断一个32位正数是不是2的幂</span><br><span class="hljs-comment"> * 思路:</span><br><span class="hljs-comment"> * 如果一个正数是2的幂,则它的二进制上只有一个1</span><br><span class="hljs-comment"> * 00001 -&gt; 2^0</span><br><span class="hljs-comment"> * 00010 -&gt; 2^1</span><br><span class="hljs-comment"> * 00100 -&gt; 2^2</span><br><span class="hljs-comment"> * 01000 -&gt; 2^3</span><br><span class="hljs-comment"> * 10000 -&gt; 2^4</span><br><span class="hljs-comment"> * .....</span><br><span class="hljs-comment"> * 当最后一位为1时,num-1 = 0</span><br><span class="hljs-comment"> * 其他情况下,1会被打散 </span><br><span class="hljs-comment"> * 2^1-1 -&gt; 00001</span><br><span class="hljs-comment"> * 2^2-1 = 000011</span><br><span class="hljs-comment"> * ......</span><br><span class="hljs-comment"> * 因此,num &amp; (num-1)=0时.就是2的幂</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 判断一个32位正数是不是4的幂</span><br><span class="hljs-comment"> * 同理,二进制只能有一个1,且必须在0,2,4,6...位上</span><br><span class="hljs-comment"> * 1. num &amp; (num-1) = 0 (只有一个1)</span><br><span class="hljs-comment"> * 2. num &amp; 01010101...01 !== 0(1在偶数位上)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 判断一个数是不是2的幂</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">is2Power</span> = (<span class="hljs-params">n</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> n &amp; (n-<span class="hljs-number">1</span>) === <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 判断一个数是不是4的幂</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">is4Power</span> = (<span class="hljs-params">n</span>) =&gt; &#123;<br>    <span class="hljs-comment">//                               ...1010101</span><br>    <span class="hljs-keyword">return</span> (n &amp; (n-<span class="hljs-number">1</span>)) === <span class="hljs-number">0</span> &amp;&amp; (n &amp; <span class="hljs-number">0x55555555</span>) != <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="位运算实现加减乘除"><a href="#位运算实现加减乘除" class="headerlink" title="位运算实现加减乘除"></a>位运算实现加减乘除</h2><p>给定两个有符号32位整数a和b,不能使用算术运算符,分别实现a和b的加,减,乘,除运算</p><p><strong>[要求]</strong></p><p>如果给定a,b执行加减乘除的运算结果就会导致数据溢出,那你实现的函数不必对此负责,除此之外请保证计算过程不发生溢出</p><h3 id="两个数的二进制进行相加"><a href="#两个数的二进制进行相加" class="headerlink" title="两个数的二进制进行相加"></a>两个数的二进制进行相加</h3><p>进行异或运算,得到的结果就是<strong>二者相加后无进位的值</strong></p><p>通过与运算能获取要进位的数</p><p>与运算向左移一位,得到的就是<strong>进位结果</strong></p><p>然后将异或运算得到的结果和与运算得到的结果再进行如上运算</p><p>直到与运算的结果为0(没有进位了)</p><p><img src="http://dawning.fun/wp-content/uploads/2022/06/image-20220513203808367.png" alt="img"> 进行异或运算和与运算得到结果</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//@ 加法</span><br><span class="hljs-comment">// 如果用户传入的参数,a+b就是溢出的,那结果就可能出错</span><br>const add = <span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> &#123;<br>    let <span class="hljs-built_in">sum</span> = a;<br>    <span class="hljs-keyword">while</span>(b ^= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 当与运算的值不为0,一直进行循环</span><br>        <span class="hljs-built_in">sum</span> = a ^ b; <span class="hljs-comment">// 无进位相加的结果</span><br>        b = (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 进位信息</span><br>        a = <span class="hljs-built_in">sum</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两个数的二进制进行相减"><a href="#两个数的二进制进行相减" class="headerlink" title="两个数的二进制进行相减"></a>两个数的二进制进行相减</h3><p>a-b即为a加上b的相反数(a-(-b))</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">negNum</span> = (<span class="hljs-params">n</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 计算n取反后与1相加的结果(即为n的相反数-n)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">add</span>(~n,<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">minus</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 计算a与-b相加的结果</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">add</span>(a,<span class="hljs-title function_">negNum</span>(b));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两个数的二进制进行相乘"><a href="#两个数的二进制进行相乘" class="headerlink" title="两个数的二进制进行相乘"></a>两个数的二进制进行相乘</h3><p>两个二进制相乘的时候,直接使用二进制的每一位互相乘(和十进制乘法相同),最后将结果相加即可</p><p><img src="http://dawning.fun/wp-content/uploads/2022/06/16524503131.png" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//@ 二进制计算两个数相乘</span><br><span class="hljs-comment">// 如果用户传入的参数中,a*b就是溢出的,那结果肯定会出错</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">mulit</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(b !== <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>((b &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// b的最后一位不为0</span><br>            res = <span class="hljs-title function_">add</span>(res,a);<br>        &#125; <br>        a &lt;&lt;= <span class="hljs-number">1</span>;<br>        b &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两个数的二进制进行相除"><a href="#两个数的二进制进行相除" class="headerlink" title="两个数的二进制进行相除"></a>两个数的二进制进行相除</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isNeg</span> = (<span class="hljs-params">n</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> n &lt; <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//@ 二进制计算两个数相除</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">div</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">isNeg</span>(a) ? <span class="hljs-title function_">negNum</span>(a) : a;<br>    <span class="hljs-keyword">let</span> y = <span class="hljs-title function_">isNeg</span>(b) ? <span class="hljs-title function_">negNum</span>(b) : b;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">31</span>;i &gt; -<span class="hljs-number">1</span>;i = <span class="hljs-title function_">minus</span>(i,<span class="hljs-number">1</span>))&#123;<br>        <span class="hljs-keyword">if</span>((x &gt;&gt; i) &gt;= y)&#123;<br>            res |= (<span class="hljs-number">1</span> &lt;&lt; i);<br>            x = <span class="hljs-title function_">minus</span>(x,y &lt;&lt; i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">isNeg</span>(a) ^ <span class="hljs-title function_">isNeg</span>(b) ? <span class="hljs-title function_">negNum</span>(res) : res;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">divide</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span>(b === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 分母不能为0</span><br>    <span class="hljs-keyword">if</span>(a === <span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_VALUE</span> &amp;&amp; b === <span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_VALUE</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b === <span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_VALUE</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a === <span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_VALUE</span>)&#123;<br>        <span class="hljs-keyword">let</span> res = <span class="hljs-title function_">div</span>(<span class="hljs-title function_">add</span>(a,<span class="hljs-number">1</span>),b);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">add</span>(req,<span class="hljs-title function_">div</span>(<span class="hljs-title function_">minus</span>(a,<span class="hljs-title function_">mulit</span>(res,b)),b));<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">div</span>(a,b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>携程一面</title>
    <link href="/2023/04/08/%E6%90%BA%E7%A8%8B%E4%B8%80%E9%9D%A2/"/>
    <url>/2023/04/08/%E6%90%BA%E7%A8%8B%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="携程一面"><a href="#携程一面" class="headerlink" title="携程一面"></a>携程一面</h1><h2 id="介绍项目"><a href="#介绍项目" class="headerlink" title="介绍项目"></a>介绍项目</h2><h2 id="Redux的实现原理？"><a href="#Redux的实现原理？" class="headerlink" title="Redux的实现原理？"></a>Redux的实现原理？</h2><p><code>Redux</code> 的实现原理可以概括为：单一数据源、状态不可变、纯函数更新状态。</p><p>具体来说，<code>Redux</code> 将应用程序的状态存储在一个单一的对象中，称为<code>store</code>。这个<code>store</code>对象是只读的，应用程序的状态只能通过派发“action”来改变。每个“action”描述了应用程序中发生的某个事件，它包含一个类型和一些数据。当派发一个<code>action</code>时，<code>Redux</code> 会将当前的状态和“action”一起传递给一个“reducer”函数，这个函数根据“action”的类型来更新状态，并返回一个新的状态对象。<code>Redux</code> 的状态更新是纯函数式的，它不会直接修改原来的状态，而是返回一个新的状态对象，从而保证了状态的不可变性。</p><p><code>Redux</code> 还提供了一些辅助函数，如<code>connect</code>和<code>mapStateToProps</code>，用于将<code>store</code>中的状态映射到组件的属性中，并在状态变化时自动更新组件。这些函数也是基于纯函数的原理实现的。</p><h2 id="React-Hooks是什么？"><a href="#React-Hooks是什么？" class="headerlink" title="React Hooks是什么？"></a>React Hooks是什么？</h2><p>React Hooks 是 React 16.8 引入的新特性，它可以让函数组件拥有类组件的一些特性，如状态管理、副作用处理等。</p><p>在 React 16.7 之前，函数组件只能通过 props 传递数据和方法，无法保存状态，也无法使用类组件的生命周期方法和其他特性。但是，函数组件具有代码简洁、易于测试和重构的优势，因此在实际开发中使用较多。React Hooks 的出现，使得函数组件也能够方便地管理状态、访问上下文和处理副作用。</p><h2 id="React官方为什么推荐使用Hooks？"><a href="#React官方为什么推荐使用Hooks？" class="headerlink" title="React官方为什么推荐使用Hooks？"></a>React官方为什么推荐使用Hooks？</h2><p>React 官方推荐使用 Hooks 的原因主要有以下几点：</p><ol><li>更好的代码复用：使用 Hooks 可以将组件之间的状态和逻辑进行复用，避免了 HOC 和 render props 带来的嵌套和重复。</li><li>更好的组件结构：使用 Hooks 可以将组件的状态和逻辑进行拆分，使组件的结构更加清晰和简洁。</li><li>更好的性能优化：使用 Hooks 可以避免不必要的渲染，从而提高组件的性能。</li><li>更好的测试性：使用 Hooks 可以更方便地进行单元测试，避免了类组件中需要使用 Enzyme 等工具进行测试的情况。</li><li>更好的开发体验：使用 Hooks 可以减少代码量，提高开发效率，使代码更加易读、易懂。</li></ol><h2 id="为什么React-Hooks对代码的可维护性更强？"><a href="#为什么React-Hooks对代码的可维护性更强？" class="headerlink" title="为什么React Hooks对代码的可维护性更强？"></a>为什么React Hooks对代码的可维护性更强？</h2><p>React Hooks 可以提高代码的可读性、可维护性、可测试性和性能优化，从而使得项目的可维护性更强。</p><h2 id="常见的React-Hooks"><a href="#常见的React-Hooks" class="headerlink" title="常见的React Hooks?"></a>常见的React Hooks?</h2><ul><li>useState</li><li>useEffect</li><li>useRef</li><li>useContext</li><li>useReducer</li><li>useCallback</li><li>useMemo</li></ul><h2 id="为什么要在项目中使用useMemo？"><a href="#为什么要在项目中使用useMemo？" class="headerlink" title="为什么要在项目中使用useMemo？"></a>为什么要在项目中使用useMemo？</h2><p>在项目中使用 useMemo 的主要原因是优化组件的性能，避免不必要的计算和渲染，从而提高项目性能和用户体验。</p><p>useMemo 是一个 Hooks API，它可以缓存计算结果，只有在依赖项发生变化时才重新计算。这样可以避免在每次渲染时都进行昂贵的计算，从而提高组件的性能。</p><p>在项目中，使用 useMemo 可以优化以下情况：</p><ol><li>计算昂贵的函数结果：如果一个函数的计算结果很昂贵，但是这个结果只在某些依赖项发生变化时才需要重新计算，这时就可以使用 useMemo 缓存计算结果，避免不必要的计算。</li><li>避免不必要的渲染：如果一个组件的某个属性是通过复杂计算得到的，但是这个属性并不是组件状态的一部分，这时可以使用 useMemo 缓存属性值，避免不必要的渲染。</li><li>优化子组件的渲染：如果一个组件的某个属性是一个函数，这个函数返回一个组件，但是这个函数并不是组件状态的一部分，这时可以使用 useMemo 缓存函数结果，避免不必要的子组件渲染。</li></ol><h2 id="useMemo相当于是对状态进行了一次缓存吗？"><a href="#useMemo相当于是对状态进行了一次缓存吗？" class="headerlink" title="useMemo相当于是对状态进行了一次缓存吗？"></a>useMemo相当于是对状态进行了一次缓存吗？</h2><p>是的，useMemo 可以看作是对计算结果进行缓存，仅在依赖项发生变化时才会重新计算。</p><p>useMemo 接收两个参数：一个是计算函数，另一个是依赖项数组。当依赖项数组中的任意一个依赖项发生变化时，useMemo 会重新计算计算函数的结果。如果依赖项数组中的依赖项没有发生变化，则 useMemo 返回上一次缓存的结果。</p><p>通过使用 useMemo，可以避免在每次渲染时都进行昂贵的计算，提高组件的性能。在某些情况下，如果没有使用 useMemo，组件可能会进行大量的重复计算，导致性能下降。</p><p>此外，虽然 useMemo 可以优化组件的性能，但是过度使用 useMemo 也会带来一些问题，如增加内存占用和代码复杂度等。因此，在使用 useMemo 时需要根据实际情况进行权衡和调整。</p><h2 id="useEffect和useLayoutEffect的区别？"><a href="#useEffect和useLayoutEffect的区别？" class="headerlink" title="useEffect和useLayoutEffect的区别？"></a>useEffect和useLayoutEffect的区别？</h2><p>useEffect 和 useLayoutEffect 都是 React 的 Hooks API，它们的主要区别在于执行的时机和是否会阻塞浏览器渲染。</p><ol><li>执行时机：useEffect 是在组件渲染完成后、在浏览器完成布局和绘制之后异步执行的，而 useLayoutEffect 是在组件渲染完成后、页面绘制和布局前同步执行的。因此，useLayoutEffect 的执行优先级更高。</li><li>是否阻塞浏览器渲染：useEffect 不会阻塞浏览器渲染，而 useLayoutEffect 会阻塞浏览器渲染。因此，在使用 useLayoutEffect 时要注意避免长时间的计算和操作，以免影响用户体验。</li><li>使用场景：useEffect 适合处理副作用，如数据获取、订阅事件等。而 useLayoutEffect 适合处理需要同步更新 DOM 的操作，如计算 DOM 元素的大小和位置等。</li></ol><p>综上所述，useEffect 和 useLayoutEffect 在执行时机和是否阻塞浏览器渲染方面有所不同，需要根据实际情况选择使用。一般来说，如果需要同步更新 DOM，可以使用 useLayoutEffect，否则可以使用 useEffect。</p><h2 id="Node-js在搭建服务器的时候起了哪些作用？"><a href="#Node-js在搭建服务器的时候起了哪些作用？" class="headerlink" title="Node.js在搭建服务器的时候起了哪些作用？"></a>Node.js在搭建服务器的时候起了哪些作用？</h2><p>在搭建服务端时，Node.js 起到了以下几个作用：</p><ol><li>提供 Web 服务器：Node.js 提供了内置的 HTTP 模块，可以用来创建 Web 服务器。开发者可以使用该模块创建 HTTP 服务器，接收和处理客户端请求，并返回响应。</li><li>处理请求和响应：Node.js 可以用来处理客户端请求，解析请求头和请求体，提取参数和数据等。同时，Node.js 也可以用来构建响应，设置响应头和响应体，返回数据给客户端。</li><li>实现业务逻辑：Node.js 可以用来实现业务逻辑，如处理数据、验证用户信息、调用其他服务等。同时，Node.js 也可以用来调用第三方库和 API，实现更丰富的业务功能。</li><li>数据库交互：Node.js 可以用来与数据库进行交互，执行查询、插入、更新和删除操作等。Node.js 支持多种数据库，如 MongoDB、MySQL、PostgreSQL 等，可以根据实际需求选择合适的数据库。</li><li>处理并发请求：Node.js 的事件驱动和非阻塞 I&#x2F;O 特性，可以处理大量并发请求，提高服务器的性能和吞吐量。</li></ol><h2 id="JS的基本数据类型有哪些？"><a href="#JS的基本数据类型有哪些？" class="headerlink" title="JS的基本数据类型有哪些？"></a>JS的基本数据类型有哪些？</h2><p>Null、Undefined、Number、String、Boolean、Symbol、BigInt、Object。</p><h2 id="判断数据类型的方式有哪些？"><a href="#判断数据类型的方式有哪些？" class="headerlink" title="判断数据类型的方式有哪些？"></a>判断数据类型的方式有哪些？</h2><ul><li>typeof</li><li>constructor</li><li>instanceof</li><li>Object.prototype.toString.call</li></ul><h2 id="什么是原型？"><a href="#什么是原型？" class="headerlink" title="什么是原型？"></a>什么是原型？</h2><p>在JavaScript中，每个对象都有一个原型。原型是一个对象，它包含着对象的属性和方法。当我们访问一个对象的属性或方法时，如果该对象本身没有该属性或方法，JavaScript引擎会沿着对象的原型链查找，直到找到该属性或方法为止。原型是JavaScript实现继承的基础，可以通过原型链实现属性和方法的继承。</p><h2 id="new一个对象发生了什么？"><a href="#new一个对象发生了什么？" class="headerlink" title="new一个对象发生了什么？"></a>new一个对象发生了什么？</h2><ol><li>首先创建一个空的对象</li><li>将该对象的原型指向构造函数的prototype属性</li><li>将构造函数的this指向该对象并执行构造函数</li><li>如果构造函数返回一个基本数据类型，则返回这个对象，否则返回构造函数返回的引用数据类型对象。</li></ol><h2 id="引入模块的两种方式？"><a href="#引入模块的两种方式？" class="headerlink" title="引入模块的两种方式？"></a>引入模块的两种方式？</h2><ul><li><p>ES6导入导出模块方式：<code>import</code>和<code>export</code>。</p><ul><li><p><code>import</code>：在一个模块中引入另一个模块的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> defaultExport <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> name <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; export1 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; export1 <span class="hljs-keyword">as</span> alias1 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; export1 , export2 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; export1 , export2 <span class="hljs-keyword">as</span> alias2 , [...] &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> defaultExport, &#123; export1 [ , [...] ] &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> defaultExport, * <span class="hljs-keyword">as</span> name <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li><code>defaultExport</code>表示模块的默认输出</li><li><code>name</code>表示模块的命名输出</li><li><code>export1</code>表示模块的具名输出</li></ul></li><li><p><code>export</code>：用于在一个模块中导出内容，让其他模块可以引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> expression;<br><span class="hljs-keyword">export</span> &#123; name1, name2, …, nameN &#125;;<br><span class="hljs-keyword">export</span> &#123; variable1 <span class="hljs-keyword">as</span> name1, variable2 <span class="hljs-keyword">as</span> name2, …, nameN &#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> name1, name2, …, nameN; <span class="hljs-comment">// also var</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> name1 = value1, name2 = value2, …, nameN = valueN;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span> &#123;...&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">FunctionName</span>(<span class="hljs-params"></span>)&#123;...&#125;<br></code></pre></td></tr></table></figure><ul><li><code>defalut</code>表示模块的默认输出</li><li><code>name</code>等表示模块的具名输出</li></ul></li></ul></li><li><p>CommonJS主要用于服务端的JS编程，<code>require()</code>导入模块，<code>module.exports</code>或<code>exports</code>导出模块。</p><ul><li><p><code>require()</code>导入模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;module-name&quot;</span>);<br></code></pre></td></tr></table></figure><p><code>module-name</code>为要导出的模块名</p></li><li><p><code>module.exports</code>或<code>exports</code>导出模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = value;<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">name</span> = values;<br></code></pre></td></tr></table></figure><p>其中<code>value</code>为要导出的值，可以是任意类型的值，包括对象、函数、字符串、数字等。</p></li></ul><p>需要注意的是，<code>module.exports</code>是直接将一个对象赋值给<code>exports</code>，而<code>exports</code>只是对<code>module.exports</code>的一个引用，因此可以使用<code>exports</code>导出多个属性，但不能使用<code>exports</code>直接覆盖<code>module.exports</code>。</p></li></ul><h2 id="ES6和CommonJS引入模块的区别？"><a href="#ES6和CommonJS引入模块的区别？" class="headerlink" title="ES6和CommonJS引入模块的区别？"></a>ES6和CommonJS引入模块的区别？</h2><ol><li><p>语法不同：</p><p>ES6使用<code>import</code>和<code>export</code>来导入和导出模块，而CommonJS使用<code>require()</code>和<code>module.exports</code>或<code>exports</code>来导入和导出模块。</p></li><li><p>加载方式不同：</p><p>ES6采用静态编译方式，在编译时就确定模块的依赖关系，然后再进行模块的加载。而CommonJS采用动态加载方式，在运行时根据代码需要动态加载模块。</p></li><li><p>可以导出的内容不同：</p><p>ES6中可以导出的内容包括变量、函数、类等，而CommonJS中只能导出对象。</p></li><li><p>作用域不同：</p><p>ES6中的模块是静态的，每个模块都有自己的作用域，不会污染全局作用域，而CommonJS中的模块是动态的，导出的对象是引用类型，会污染全局作用域。</p></li></ol><h2 id="ES6有哪些新特性？"><a href="#ES6有哪些新特性？" class="headerlink" title="ES6有哪些新特性？"></a>ES6有哪些新特性？</h2><ul><li><p>块级作用域：let和const</p></li><li><p>箭头函数</p></li><li><p>模板字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;XiaoMing&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`My name is <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br></code></pre></td></tr></table></figure></li><li><p>拓展运算符</p></li><li><p>类和继承 (<code>class</code>)</p></li><li><p>模块化：<code>import</code>和<code>export</code></p></li><li><p>Promise和async&#x2F;await</p></li><li><p>Symbol、BigInt</p></li><li><p>数组新增方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>() <span class="hljs-comment">// 将类数组对象or可迭代对象转换为数组</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>() <span class="hljs-comment">// 根据传入的参数创建一个数组</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">find</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">findIndex</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">fill</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">keys</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">values</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">includes</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">copyWithin</span>() <span class="hljs-comment">// 将数组的一部分复制到另一部分</span><br></code></pre></td></tr></table></figure></li><li><p>对象新增方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>()<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>()<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>()<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entires</span>() <span class="hljs-comment">// 返回一个数组，包含自身所有可枚举属性的键值对</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>() <span class="hljs-comment">// 返回一个对象，包含指定对象所有属性的描述符</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>() <span class="hljs-comment">// 冻结对象，使其属性不可修改、添加或删除</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">seal</span>() <span class="hljs-comment">// 封闭对象，使其属性不可添加或删除，但是可以修改</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>() <span class="hljs-comment">// 用于比较两个值是否完全相同</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="移动端epx-移动端适配-问题如何解决？"><a href="#移动端epx-移动端适配-问题如何解决？" class="headerlink" title="移动端epx(移动端适配)问题如何解决？"></a>移动端epx(移动端适配)问题如何解决？</h2><ul><li>使用em&#x2F;rem等单位设置元素尺寸</li><li>使用vw和vh单位</li><li>第三方库(lib-flexible、amfe-fiexible等)进行解决，这些库会根据屏幕像素密度和屏幕尺寸等信息自动计算出合适的rem值，从而解决移动端epx问题。</li></ul><h2 id="HTTP和HTTPS的区别？"><a href="#HTTP和HTTPS的区别？" class="headerlink" title="HTTP和HTTPS的区别？"></a>HTTP和HTTPS的区别？</h2><ul><li>HTTP是超文本传输协议，采用明文传输，而HTTPS采用SSL进行了数据加密，保证了数据的安全性</li><li>HTTP使用的是80端口，HTTPS是443端口</li><li>HTTPS需要数字证书，用于验证服务器身份和保证通信安全性</li><li>HTTPS加密和解密过程需要消耗更多计算资源，更加消耗性能</li><li>HTTPS的数据不容易被存储，因为每个请求和响应都需要加密和解密，而HTTP的数据易于被存储，可以提高访问速度。</li></ul><h2 id="302状态码是什么意思？和301有什么区别？"><a href="#302状态码是什么意思？和301有什么区别？" class="headerlink" title="302状态码是什么意思？和301有什么区别？"></a>302状态码是什么意思？和301有什么区别？</h2><p>302表示临时重定向，表示所请求的资源临时转移到了另一个URL上面。</p><p>301状态码表示永久重定向，告诉客户端所请求的资源已经被永久移动到了新的位置，以后应该使用新的URL访问，它会在响应头的Location字段中存储新的URL，浏览器收到后会对新的URL进行缓存，在以后的请求中会自动使用新的URL而不是旧的URL。</p><p>302状态码表示临时重定向，告诉客户端所请求的资源已经被临时移动到了新的位置，但以后还是应该使用原来的URL访问，浏览器在以后的请求中仍然会使用原来的URL，需要再次请求服务器获取新的URL。</p><h2 id="什么是防抖和节流？"><a href="#什么是防抖和节流？" class="headerlink" title="什么是防抖和节流？"></a>什么是防抖和节流？</h2><p>防抖：一个事件在触发n秒之后再进行执行，如果重复进行请求则重新进行计时。</p><p>节流：一个事件在一段时间内只能执行一次，如果多次触发也只会执行一次。</p><h2 id="手写防抖"><a href="#手写防抖" class="headerlink" title="手写防抖"></a>手写防抖</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> args = [...<span class="hljs-variable language_">arguments</span>], context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">if</span>(timer) &#123;<br>            <span class="hljs-built_in">clearTimeout</span>(timer);<br>            timer = <span class="hljs-literal">null</span>;<br>        &#125;<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            fn.<span class="hljs-title function_">apply</span>(context, args);<br>        &#125;, wait);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueArr</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">const</span> newArr = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(arr.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item1</span> =&gt;</span> item1 === item) === index) &#123;<br>            <span class="hljs-keyword">return</span> item;<br>        &#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> newArr;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端|面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法总结</title>
    <link href="/2023/04/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="常见的排序算法"><a href="#常见的排序算法" class="headerlink" title="常见的排序算法"></a>常见的排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><blockquote><p>冒泡排序(Bubble Sort)是一种最基础的排序方式，它的每个元素都可以像小气泡一样，根据自身大小一点点向数组的一侧移动</p></blockquote><p>冒泡排序<strong>每次比较相邻的两个节点</strong>，如果两个节点排序错误，将两个节点的位置调换，重复此步骤直到所有的元素归位。</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 冒泡排序</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">bubbleSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> len = arr.<span class="hljs-property">length</span>;<br>  <span class="hljs-comment">// 将元素按照从小到大的顺序排序</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; len;i++)&#123; <br>    <span class="hljs-comment">// 每次排序能确定一个元素的位置</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>;j &lt; len-i;j++)&#123;<br>      <span class="hljs-comment">// 当前面节点大于后面节点的时候</span><br>      <span class="hljs-comment">// 当一轮交换结束的时候，最大的元素一定在最后一位</span><br>      <span class="hljs-keyword">if</span>(arr[j-<span class="hljs-number">1</span>] &gt; arr[j])&#123;<br>          <span class="hljs-keyword">const</span> tmp = arr[j-<span class="hljs-number">1</span>];<br>          arr[j-<span class="hljs-number">1</span>] = arr[j];<br>          arr[j] = tmp;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。</p></blockquote><p>每次都从待排序的数据元素中选择出最小(或最大)的一个元素作为首元素，直到所有元素都排列完毕。</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">selectionSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> minIndex, temp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len-<span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-comment">// 在每次遍历中,将第一个元素设置为最小的元素</span><br>        minIndex = i;<br>        <span class="hljs-comment">// 遍历后面的元素,如果有比当前元素更小的元素,将其下标赋值给minIndex</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i+<span class="hljs-number">1</span>; j &lt; len; j++) &#123;<br>            <span class="hljs-keyword">if</span>(arr[j] &lt; arr[minIndex]) &#123;<br>                minIndex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果头一个元素不是最小元素,将其与后面最小元素交换位置</span><br>        <span class="hljs-keyword">if</span>(minIndex !== i) &#123;<br>            temp = arr[i];<br>            arr[i] = arr[minIndex];<br>            arr[minIndex] = temp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 返回排好序的arr</span><br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>插入排序，一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。</p></blockquote><p>每一步都将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素位置。</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">insertSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">// 每次进行排序的时候,0~i-1位置上一定是有序的</span><br>    <span class="hljs-comment">// 将当前元素进行比较并插入合适的位置</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">let</span> preIndex = i-<span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">let</span> current = arr[i]; <span class="hljs-comment">// 记录当前元素的值</span><br>        <span class="hljs-comment">// 将大于current的元素依次往后移,找到插入current的合适位置的时候停止</span><br>        <span class="hljs-keyword">while</span>(preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;<br>            arr[preIndex+<span class="hljs-number">1</span>] = arr[preIndex];<br>            preIndex--;<br>        &#125;<br>        <span class="hljs-comment">// 将current插入到合适的位置</span><br>        arr[preIndex+<span class="hljs-number">1</span>] = current;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p></blockquote><p>核心思想：分治，采用自上而下的递归方法</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">mergeSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> len = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">// 如果长度&lt;2, 无需进行排序</span><br>    <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr; <br>    <span class="hljs-comment">// 将数组从中间进行切割</span><br>    <span class="hljs-keyword">const</span> middle = len &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">const</span> left = arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, middle), right = arr.<span class="hljs-title function_">slice</span>(middle);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(<span class="hljs-title function_">mergeSort</span>(left), <span class="hljs-title function_">mergeSort</span>(right));<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">merge</span> = (<span class="hljs-params">left, right</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 存储最终结果的数组</span><br>    <span class="hljs-keyword">const</span> result = [];<br>    <span class="hljs-comment">// 比较left和right中的元素并将较小的先存入result中</span><br>    <span class="hljs-keyword">while</span>(left.<span class="hljs-property">length</span> &amp;&amp; right.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">if</span>(left[<span class="hljs-number">0</span>] &lt;= right[<span class="hljs-number">0</span>]) &#123;<br>            result.<span class="hljs-title function_">push</span>(left.<span class="hljs-title function_">shift</span>());<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            result.<span class="hljs-title function_">push</span>(right.<span class="hljs-title function_">shift</span>());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(left.<span class="hljs-property">length</span>) &#123;<br>        result.<span class="hljs-title function_">push</span>(left.<span class="hljs-title function_">shift</span>());<br>    &#125;<br>    <span class="hljs-keyword">while</span>(right.<span class="hljs-property">length</span>) &#123;<br>        result.<span class="hljs-title function_">push</span>(right.<span class="hljs-title function_">shift</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><blockquote><p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O(nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p></blockquote><p>根据键值的每位数字来分配桶</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">radixSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> []);<br>    <span class="hljs-keyword">let</span> maxDigit = (<span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...arr))).<span class="hljs-title function_">toString</span>().<span class="hljs-property">length</span> <span class="hljs-comment">// 取最大位数</span><br>    <span class="hljs-keyword">let</span> m = <span class="hljs-number">10</span>,n = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 取最大的数字的位数长度</span><br>    <span class="hljs-keyword">while</span>(maxDigit--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; arr.<span class="hljs-property">length</span>;i++)&#123;<br>            <span class="hljs-keyword">let</span> bucket = <span class="hljs-built_in">parseInt</span>((arr[i] % m) / n); <span class="hljs-comment">// 获取需要的位数</span><br>            ans[bucket].<span class="hljs-title function_">push</span>(arr[i]);<br>        &#125;<br>        <span class="hljs-keyword">let</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 将数组中的数字排序后重新放入arr数组中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; ans.<span class="hljs-property">length</span>;i++)&#123;<br>            <span class="hljs-keyword">let</span> value = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span>(ans[i].<span class="hljs-property">length</span> !== <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">while</span>((value = ans[i].<span class="hljs-title function_">shift</span>()) != <span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-comment">// 当ans[i]中还有值</span><br>                    arr[pos++] = value;<br>                &#125;<br>            &#125;<br>        &#125;<br>        m *= <span class="hljs-number">10</span>;<br>        n *= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><blockquote><p>桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后依次把各个桶中的记录列出来记得到有序序列。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ(n)）。但桶排序并不是比较排序，他不受到O(n log n)下限的影响。</p></blockquote><p>将元素分布在桶中：</p><p><img src="http://dawning.fun/wp-content/uploads/2022/11/Bucket_sort_1.svg_.png" alt="img"></p><p>然后，将每个桶中的元素进行排序：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_2.svg_.png" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">bucketSort</span> = (<span class="hljs-params">arr, bucketSize</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-keyword">let</span> minValue = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> maxValue = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 获取数据的最大值和最小值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span>(arr[i] &lt; minValue) &#123;<br>            minValue = arr[i];<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[i] &gt; maxValue) &#123;<br>            maxValue = arr[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 进行桶的初始化</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DEFAULT_BUCKET_SIZE</span> = <span class="hljs-number">5</span>; <span class="hljs-comment">// 设置桶的默认数量为5</span><br>    bucketSize = bucketSize || <span class="hljs-variable constant_">DEFAULT_BUCKET_SIZE</span>; <span class="hljs-comment">// 如果函数没有传值就将桶的默认数量设置为5</span><br>    <span class="hljs-keyword">const</span> bucketCount = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((maxValue - minValue) / bucketSize) + <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">const</span> buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(bucketCount).<span class="hljs-title function_">fill</span>([]);<br>    <span class="hljs-comment">// 利用映射函数将数据分配到各个桶中</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>        buckets[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((arr[i] - minValue) / bucketSize)].<span class="hljs-title function_">push</span>(arr[i]);<br>    &#125;<br>    arr.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; buckets.<span class="hljs-property">length</span>; i++)&#123;<br>        <span class="hljs-title function_">insertSort</span>(buckets[i]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; bucketCount[i].<span class="hljs-property">length</span>; i++) &#123;<br>            arr.<span class="hljs-title function_">push</span>(buckets[i][j]);;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序由于排序效率在同为<code>O(N*logN)</code>的几种排序方法中效率较高，因此经常被采用。快速排序的思想为——分治法。在快速排序中，一般选中第一个元素作为基准点<code>pivot</code>，定义<code>l</code>和<code>r</code>两个指针分别从数组的两边遍历，当从右边找到比<code>pivot</code>大的数字时，停止移动，再从左边找到比<code>pivot</code>小的元素，将两者进行交换，然后继续移动指针。</p><p>当移动到同一位置的时候，将该位置与基准点元素<code>pivot</code>进行交换，然后对<code>pivot</code>两边的元素进行如上遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @每次找一个基准点pivot，小于pivot的放在左边，大于pivot的放在右边，然后对左右进行同样的操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number[]</span>&#125; arr </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">quickSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-title function_">quick</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">quick</span> = (<span class="hljs-params">arr, start, end</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span>(start &gt; end) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">const</span> pivot = arr[start];<br>    <span class="hljs-keyword">let</span> l = start, r = end;<br>    <span class="hljs-keyword">while</span>(l !== r) &#123;<br>        <span class="hljs-keyword">while</span>(arr[r] &gt;= pivot &amp;&amp; l !== r) r--;<br>        <span class="hljs-keyword">while</span>(arr[l] &lt;= pivot &amp;&amp; l !== r) l++;<br>        <span class="hljs-keyword">if</span>(l !== r) &#123;<br>            <span class="hljs-keyword">const</span> temp = arr[l];<br>            arr[l] = arr[r];<br>            arr[r] = temp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(arr[l] &gt; pivot) l--;<br>    arr[start] = arr[l];<br>    arr[l] = pivot;<br>    <span class="hljs-title function_">quick</span>(arr, start, l-<span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">quick</span>(arr, l+<span class="hljs-number">1</span>, end);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单边快速排序"><a href="#单边快速排序" class="headerlink" title="单边快速排序"></a>单边快速排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; start </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; end </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">quickSort</span> = (<span class="hljs-params">arr, start, end</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span>(start &gt;= end) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 排序并得到基准元素</span><br>    <span class="hljs-keyword">let</span> pivotIndex = <span class="hljs-title function_">partition</span>(arr, start, end);<br>    <span class="hljs-comment">// 根据基准元素分成两部分并进行递归排序</span><br>    <span class="hljs-title function_">quickSort</span>(arr, start, pivotIndex-<span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">quickSort</span>(arr, pivotIndex+<span class="hljs-number">1</span>, end);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; start </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; end </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">partition</span> = (<span class="hljs-params">arr, start, end</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 取第一个位置的元素作为基准点</span><br>    <span class="hljs-keyword">let</span> pivot = arr[start];<br>    <span class="hljs-keyword">let</span> mark = start; <span class="hljs-comment">// 标记元素,用于交换</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = start+<span class="hljs-number">1</span>; i &lt;= end; i++) &#123;<br>        <span class="hljs-keyword">if</span>(arr[i] &lt; pivot) &#123; <span class="hljs-comment">// 当遍历到比基准元素小的元素,mark+1,将当前元素和基准元素交换位置</span><br>            mark++;<br>            <span class="hljs-keyword">let</span> tmp = arr[mark];<br>            arr[mark] = arr[i];<br>            arr[i] = tmp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 遍历完毕的时候,mark及其左边元素都小于基准点,mark右边都大于基准点</span><br>    arr[start] = arr[mark];<br>    arr[mark] = pivot;<br>    <span class="hljs-keyword">return</span> mark;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">main</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-title function_">quickSort</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h2><p>鸡尾酒排序又称双向冒泡排序、鸡尾酒搅拌排序、搅拌排序、涟漪排序、来回排序或快乐小时排序, 是冒泡排序的一种变形。该算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。</p><p><img src="https://pic4.zhimg.com/v2-f9716c786a05cb28547440f12e337a0b_b.webp" alt="动图"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @鸡尾酒排序与冒泡排序类似，不同的是冒泡排序是按照一种顺序进行是，而鸡尾酒是从两边轮流进行交换</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">cocktailSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(arr.<span class="hljs-property">length</span>/<span class="hljs-number">2</span>); i++) &#123;<br>        <span class="hljs-comment">// 使用isSorted标记是否进行交换顺序，如果没有进行交换，说明顺序已经符合要求，直接跳出循环</span><br>        <span class="hljs-keyword">let</span> isSorted = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 奇数轮的遍历，从左往右进行比较</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j &lt; arr.<span class="hljs-property">length</span>-i-<span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;<br>                tmp = arr[j];<br>                arr[j] = arr[j+<span class="hljs-number">1</span>];<br>                arr[j+<span class="hljs-number">1</span>] = tmp;<br>                isSorted = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        isSorted = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 重置isSorted</span><br>        <span class="hljs-comment">// 偶数轮的遍历，从右往左进行比较</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = arr.<span class="hljs-property">length</span>-i-<span class="hljs-number">1</span>; j &gt;= i; j--) &#123;<br>            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j-<span class="hljs-number">1</span>]) &#123;<br>                tmp = arr[j];<br>                arr[j] = arr[j-<span class="hljs-number">1</span>];<br>                arr[j-<span class="hljs-number">1</span>] = tmp;<br>                isSorted = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isSorted) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序（HeapSort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p><img src="https://pic3.zhimg.com/v2-b7907d351809293c60658b0b87053c66_b.webp" alt="动图"></p><p>传入一个数组，将其从最下面的非叶子结点进行排序，依次向上调整为最大堆，每次将顶上最大的数取出来放在数组res中，然后重新调整为最大堆，再取出最大的数放在res中…重复以上过程直到arr为空。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @堆排序</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr 要进行排序的数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">main</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> res = []; <span class="hljs-comment">// 存储排序后的结果</span><br>    <span class="hljs-title function_">buildHeap</span>(arr); <span class="hljs-comment">// 构建大根堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = n-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-title function_">swap</span>(arr, <span class="hljs-number">0</span>, i); <span class="hljs-comment">// 将最大值(顶点)交换到最后一个位置</span><br>        res.<span class="hljs-title function_">unshift</span>(arr.<span class="hljs-title function_">pop</span>()); <span class="hljs-comment">// 将最大值取出</span><br>        <span class="hljs-title function_">heapify</span>(arr, <span class="hljs-number">0</span>); <span class="hljs-comment">// 对大根堆进行自上而下重新调整(下一个最大值一定是根节点的两个孩子之一，因此从顶点进行调整即可)</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @构建大根堆</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr 要构建大根堆的数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">buildHeap</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">// 自下而上进行调整</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(n/<span class="hljs-number">2</span>)-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-title function_">heapify</span>(arr, i);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @调整大根堆</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr 进行大根堆调整的数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; index 要调整的节点下标</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">heapify</span> = (<span class="hljs-params">arr, index</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前节点的左子节点</span><br>    <span class="hljs-keyword">while</span>(left &lt; n) &#123;<br>        <span class="hljs-keyword">let</span> largest = index; <span class="hljs-comment">// 记录最大值下标,初始设置为当前节点</span><br>        <span class="hljs-comment">// 比较左右节点找出较大的节点</span><br>        largest = (left+<span class="hljs-number">1</span> &lt; n &amp;&amp; arr[left+<span class="hljs-number">1</span>] &gt; arr[left]) ? left+<span class="hljs-number">1</span> : left;<br>        <span class="hljs-comment">// 比较左右节点中较大的一个和当前节点</span><br>        largest = arr[largest] &gt; arr[index] ? largest : index;<br>        <span class="hljs-keyword">if</span>(largest === index) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 当前堆为大根堆，不需要继续调整 </span><br>        <span class="hljs-comment">// 子节点中存在比index节点大的值,继续向下调整</span><br>        <span class="hljs-title function_">swap</span>(arr, index, largest);<br>        index = largest;<br>        left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @对数组两个位置的值进行交换</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; i </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; j </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">swap</span> = (<span class="hljs-params">arr, i, j</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> tmp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>小根堆进行排序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">main</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-title function_">buildHeap</span>(arr);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = n-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-title function_">swap</span>(arr, <span class="hljs-number">0</span>, i);<br>        res.<span class="hljs-title function_">unshift</span>(arr.<span class="hljs-title function_">pop</span>());<br>        <span class="hljs-title function_">heapify</span>(arr, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">buildHeap</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(n/<span class="hljs-number">2</span>)-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-title function_">heapify</span>(arr, i);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; index </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">heapify</span> = (<span class="hljs-params">arr, index</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt; n) &#123;<br>        <span class="hljs-keyword">let</span> least = index;<br>        least = (left+<span class="hljs-number">1</span> &lt; n &amp;&amp; arr[left+<span class="hljs-number">1</span>] &lt; arr[left]) ? left+<span class="hljs-number">1</span> : left;<br>        least = (arr[least] &lt; arr[index]) ? least : index;<br>        <span class="hljs-keyword">if</span>(least === index) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-title function_">swap</span>(arr, index, least);<br>        index = least;<br>        left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @对数组两个位置的值进行交换</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; i </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; j </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">swap</span> = (<span class="hljs-params">arr, i, j</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> tmp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结(3.1)</title>
    <link href="/2023/04/08/%E6%80%BB%E7%BB%93-3-1/"/>
    <url>/2023/04/08/%E6%80%BB%E7%BB%93-3-1/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS常见的行内元素和块级元素？它们有什么区别？"><a href="#CSS常见的行内元素和块级元素？它们有什么区别？" class="headerlink" title="CSS常见的行内元素和块级元素？它们有什么区别？"></a>CSS常见的行内元素和块级元素？它们有什么区别？</h2><p><strong>行内元素：</strong>行内元素与其他行内元素并排，不能设置宽高，宽度默认为文字的宽度。</p><p><strong>块级元素：</strong>块级元素霸占一行，不能与其他任何元素并列，能接受宽高，如果不设置宽度，那么宽度将默认变为父级的100%。</p><p>常见的行内元素有：button、input、label、select、textarea、a、img、span、script等。</p><p>常见的块级元素有：div、section、p、table、form、header、footer、h1~h6、aside、canvas、ol、ul等。</p><p>CSS中，块级元素和行内元素的区别在于：</p><ul><li>块级元素独占一行，不能与其他任何元素并列；行内元素可以与其他行内元素并排。</li><li>块级元素可以设置宽高，而行内元素不能设置宽高，宽度由内容撑开。</li></ul><h2 id="什么是回流和重绘？"><a href="#什么是回流和重绘？" class="headerlink" title="什么是回流和重绘？"></a>什么是回流和重绘？</h2><p>回流：当DOM节点中的部分或全部元素的尺寸、结构、布局等发生变化的时候，浏览器就会重新渲染部分或全部文档，这个过程称为回流。</p><p>重绘：页面中元素的样式发生变化，但是不影响其在文档流中的位置，浏览器就会对该元素进行重绘。</p><p>发生回流一定会引起重绘，但是重绘不一定会引起回流。</p><h2 id="在什么情况下会触发回流？"><a href="#在什么情况下会触发回流？" class="headerlink" title="在什么情况下会触发回流？"></a>在什么情况下会触发回流？</h2><ul><li>添加或删除可见的DOM元素</li><li>元素位置、尺寸(包括外边距、内边距、边框大小、高度和宽度等)发生变化</li><li>内容发生变化(例如文本变化或图片被另一个不同尺寸的图片取代)</li><li>页面一开始渲染</li><li>浏览器窗口尺寸变化(因为回流是根据视口的大小来计算元素的位置和大小的)</li></ul><h2 id="获取元素的offsetHeight等会触发回流吗？"><a href="#获取元素的offsetHeight等会触发回流吗？" class="headerlink" title="获取元素的offsetHeight等会触发回流吗？"></a>获取元素的offsetHeight等会触发回流吗？</h2><p>会。</p><p><code>offsetHeight</code> 是一个元素的实时高度，必须重排重绘以后才能得到，如果不提前进行重排重绘，<code>offsetHeight</code> 有可能拿到的是浏览器缓存队列没执行完的时候的值。</p><h2 id="什么是flex布局？"><a href="#什么是flex布局？" class="headerlink" title="什么是flex布局？"></a>什么是flex布局？</h2><p>flex为”弹性布局”，可以简便、完整、响应式的实现各种页面布局。它的所有子元素自动成为容器成员，称为flex项目的item。</p><p>容器中默认存在两条轴，主轴和交叉轴，呈90°的关系。项目默认沿主轴排列，通过<code>flelx-direction</code>来决定主轴方向。</p><h2 id="flex-1具体指的是什么？"><a href="#flex-1具体指的是什么？" class="headerlink" title="flex: 1具体指的是什么？"></a>flex: 1具体指的是什么？</h2><ul><li><code>flex-grow: 1</code> (默认为0) ：表示元素的放大比例</li><li><code>flex-shrink: 1</code> (默认为1) ：表示元素的缩小比例</li><li><code>flex-basis: 0%</code> (默认为auto) ：元素本身的大小，这个属性定义了在分配多余空间之前，元素占据的主轴空间。浏览器根据这个属性计算是否有多余空间。</li></ul><h2 id="如何进行移动端适配？"><a href="#如何进行移动端适配？" class="headerlink" title="如何进行移动端适配？"></a>如何进行移动端适配？</h2><ul><li>rem布局</li><li>vw&#x2F;vh布局</li><li>百分比布局</li><li>响应式布局</li></ul><h2 id="em和rem的区别？"><a href="#em和rem的区别？" class="headerlink" title="em和rem的区别？"></a>em和rem的区别？</h2><p>em和rem都是相对单位长度</p><p>em是相对于父元素的字体大小来计算元素的大小</p><p>rem是相对于根元素的字体大小来计算元素的大小</p><h2 id="什么是vw和vh"><a href="#什么是vw和vh" class="headerlink" title="什么是vw和vh?"></a>什么是vw和vh?</h2><p>vw和vh是CSS3引入的视口单位，是相对于视口的宽度和高度来计算元素的大小。</p><p>1vw等于视口宽度的1%，1vh等于视口高度的1%。除了vw和vh，还有vmin和vmax两个单位，vmin是vw和vh中较小的那个，vmax是vw和vh中较大的那个。</p><h2 id="什么是JS的事件机制？"><a href="#什么是JS的事件机制？" class="headerlink" title="什么是JS的事件机制？"></a>什么是JS的事件机制？</h2><p>JavaScript 事件机制描述的是事件在 DOM 里面的传递顺序，以及我们可以对这些事件做出如何的响应。</p><p>DOM事件流（event flow ）存在三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。</p><p>事件捕获（event capturing）： 通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始<strong>由外到内</strong>进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。</p><p>事件冒泡（dubbed bubbling）： 与事件捕获恰恰相反，事件冒泡顺序是<strong>由内到外</strong>进行事件传播，直到根节点。无论是事件捕获还是事件冒泡，它们都有一个共同的行为，就是事件传播，它就像一跟引线，只有通过引线才能将绑在引线上的鞭炮（事件监听器）引爆。</p><p>DOM标准事件流的触发的先后顺序为 ：<strong>先捕获再冒泡，即当触发dom事件时，会先进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡</strong>。</p><h2 id="代码输出"><a href="#代码输出" class="headerlink" title="代码输出"></a>代码输出</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">fun2</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br><br><span class="hljs-title function_">fun1</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);<br>&#125;, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>);<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">7</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="Promise常用的API？"><a href="#Promise常用的API？" class="headerlink" title="Promise常用的API？"></a>Promise常用的API？</h2><p>Promise.then、Promise.catch、Promise.finally、Promise.all、Promise.race</p><h2 id="Promise-all和Promise-race的区别？"><a href="#Promise-all和Promise-race的区别？" class="headerlink" title="Promise.all和Promise.race的区别？"></a>Promise.all和Promise.race的区别？</h2><p>Promise.all()和Promise.race()都是Promise的静态方法，用于处理多个Promise对象。它们的区别在于：</p><ul><li>Promise.all()会在多个promise全部resolve之后执行.then，而Promise.race()会在任何一个promise resolve后就会执行.then。</li><li>Promise.all()会等待所有的promise对象都resolve或有一个reject后才会执行.then，而Promise.race()只要有一个promise对象resolve或reject就会执行.then。</li><li>Promise.all()会返回所有Promise resolved后的结果数组或第一个rejected的Promise对象的报错信息。</li></ul><h2 id="Promise的错误在哪里进行捕捉"><a href="#Promise的错误在哪里进行捕捉" class="headerlink" title="Promise的错误在哪里进行捕捉?"></a>Promise的错误在哪里进行捕捉?</h2><p>Promise发生的错误可以在try…catch中捕获，也可以在.catch()中捕获。如果在try…catch中捕获，需要在Promise对象前加await关键字，否则无法捕获异步错误。如果在.catch()中捕获，需要在Promise对象后加.catch()方法。</p><h2 id="假设一个function中有多个Promise任务，然后有某个Promise发生了异常，如何准确判断是哪个Promise发生了异常？"><a href="#假设一个function中有多个Promise任务，然后有某个Promise发生了异常，如何准确判断是哪个Promise发生了异常？" class="headerlink" title="假设一个function中有多个Promise任务，然后有某个Promise发生了异常，如何准确判断是哪个Promise发生了异常？"></a>假设一个function中有多个Promise任务，然后有某个Promise发生了异常，如何准确判断是哪个Promise发生了异常？</h2><p>在reject()中进行处理</p><h2 id="bind、call和apply的区别？"><a href="#bind、call和apply的区别？" class="headerlink" title="bind、call和apply的区别？"></a>bind、call和apply的区别？</h2><ul><li><code>apply</code>接受两个参数，第一个参数是<code>this</code>的指向，第二个参数是函数接受的参数，以数组的形式传入，改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次。</li><li><code>call</code>方法的第一个参数也是<code>this</code>的指向，后面传入的是一个参数列表，跟<code>apply</code>一样，改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次。</li><li>bind方法和call很相似，第一参数也是<code>this</code>的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)，改变<code>this</code>指向后不会立即执行，而是返回一个永久改变<code>this</code>指向的函数。</li></ul><h2 id="箭头函数和普通函数的区别？"><a href="#箭头函数和普通函数的区别？" class="headerlink" title="箭头函数和普通函数的区别？"></a>箭头函数和普通函数的区别？</h2><ul><li>箭头函数不绑定this，会捕获其所在上下文的this作为自己的this。</li><li>箭头函数没有arguments对象，只能通过rest参数获取参数。</li><li>箭头函数不能使用yield命令，不能用作Generator函数。</li><li>箭头函数是匿名函数，不能用作构造函数，不可以使用new命令。</li></ul><h2 id="React函数组件和类组件的区别？"><a href="#React函数组件和类组件的区别？" class="headerlink" title="React函数组件和类组件的区别？"></a>React函数组件和类组件的区别？</h2><ul><li>类组件有生命周期，函数组件无生命周期</li><li>类组件调用setStatet管理state状态，函数组件使用useState</li><li>函数组件调用即是执行函数，类组件需要先将组件实例化，再调用实例对象的render方法</li><li>函数组件更加简洁易懂，容易被开发、理解和测试。</li></ul><h2 id="函数式组件用哪个hook模拟声明周期"><a href="#函数式组件用哪个hook模拟声明周期" class="headerlink" title="函数式组件用哪个hook模拟声明周期"></a>函数式组件用哪个hook模拟声明周期</h2><p>useEffect</p><h2 id="React-state更新机制"><a href="#React-state更新机制" class="headerlink" title="React state更新机制"></a>React state更新机制</h2><p>React中类组件的state是通过setState()方法来更新的。当执行setState()时，会将需要更新的state合并后放入状态队列，不会立即更新。React也正是通过状态队列实现了setState的异步更新，避免频繁的重复更新state。当React需要更新组件时，会将状态队列中的state合并后一次性更新组件，这样可以提高性能。</p><p>React函数组件中的state是通过useState()方法来更新的。useState()方法返回一个数组，第一个元素是当前state的值，第二个元素是更新state的函数。当执行更新state的函数时，会将需要更新的state合并后放入状态队列，不会立即更新。React也正是通过状态队列实现了useState的异步更新，避免频繁的重复更新state。当React需要更新组件时，会将状态队列中的state合并后一次性更新组件，这样可以提高性能。</p><p>在React18优化了批处理之后，state的更新都表现为异步的。</p><h2 id="React虚拟DOM的Diff算法？"><a href="#React虚拟DOM的Diff算法？" class="headerlink" title="React虚拟DOM的Diff算法？"></a>React虚拟DOM的Diff算法？</h2><p>React中的虚拟DOM和diff算法是为了提高渲染效率而设计的。虚拟DOM是一种编程概念，UI以一种理想化的、或者说“虚拟的”表现形式存在于内存中，而不是真实的DOM树。当状态发生变化时，React会通过diff算法比较新旧虚拟DOM树的差异，然后只更新需要更新的部分，从而避免了全量渲染，提高了渲染效率。</p><p>React中的diff算法是通过比较新旧虚拟DOM树的差异来确定需要更新的节点。diff算法会遍历新旧虚拟DOM树，对比它们的节点，然后根据节点的变化情况来更新真实DOM。React中的diff算法是基于两个假设：同一层级的两个节点可以通过唯一的id进行区分；同一层级的节点可以通过位置进行区分。React中的diff算法是一个递归算法，它会递归遍历新旧虚拟DOM树，对比它们的节点，然后根据节点的变化情况来更新真实DOM。如果两个节点不同，则会直接替换掉旧节点，如果两个节点相同，则会更新该节点。</p><p><strong>查找需要更新的节点是从尾节点找还是头节点找还是中间二分择半？</strong></p><p>React的Diff算法进行虚拟节点比较是从头部开始，然后依次向后比较，直到找到不同的节点位置。如果新旧虚拟节点的数量不同，则从尾部开始比较，直到找到不同的节点为止。</p><h2 id="useMemo和useCallback的区别？"><a href="#useMemo和useCallback的区别？" class="headerlink" title="useMemo和useCallback的区别？"></a>useMemo和useCallback的区别？</h2><p>二者都是用于缓存数据，优化性能的，它们接受到的参数是一样的，第一个参数表示回调函数，第二个参数表示依赖的数据。</p><p>共同作用：在依赖数据发生变化的时候，才会调用传进去的回调函数去重新计算结果，起到缓冲的作用。</p><p>区别：</p><ul><li><code>useMemo</code>缓存的结果是回调函数中return回来的值，主要用于缓存计算结果的值，应用场景如需要计算的状态。</li><li><code>useCallback</code>缓存的结果是函数，主要用于缓存函数，应用场景如需要缓存的函数，因为函数式组件每次任何一个state发生变化都会触发整个组件更新，一些函数是没有必要更新的，此时就应该缓存起来，提高性能，减少对资源的浪费。<code>useCallback</code>应该和<code>React.memo</code>配套使用，缺少一个可能会导致性能不升反降。</li></ul><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useState, useMemo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Info</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">const</span> [info, setInfo] = <span class="hljs-title function_">useState</span>(&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;LiHua&quot;</span>,<br>        <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;male&quot;</span><br>    &#125;);<br>    <span class="hljs-comment">// 翻译性别的函数</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">formatGender</span> = (<span class="hljs-params">gender</span>) =&gt; &#123;<br>        <span class="hljs-keyword">return</span> gender === <span class="hljs-string">&quot;male&quot;</span> ? <span class="hljs-string">&quot;男&quot;</span> : <span class="hljs-string">&quot;女&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果不使用useMemo,修改其他属性，也会导致formatGender方法的调用，浪费计算资源</span><br>    <span class="hljs-comment">// const gender = formatGender(info.gender);</span><br>    <span class="hljs-comment">// 仅当info.gender发生变化的时候才调用formatGender</span><br>    <span class="hljs-keyword">const</span> gender = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">formatGender</span>(info.<span class="hljs-property">gender</span>);<br>    &#125;, [info.<span class="hljs-property">gender</span>]);<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        姓名：&#123;info.name&#125; - 性别：&#123;gender&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onClick</span> = <span class="hljs-string">&#123;()</span> =&gt;</span> setInfo(...info, name: &quot;XiaoMing&quot;)&#125;</span><br><span class="language-xml">        &gt;点击修改姓名<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>useCallback是设计初衷是为了<strong>减少子组件的不必要重读渲染</strong>，优化思路主要有以下两种：</p><ul><li>减少render的次数</li><li>减少计算量</li></ul><p>在如下场景中</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-comment">// 不使用useCallback和memo的时候</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Comp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [dataA, setDataA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> [dataB, setDataB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickA</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataA</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickB</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataB</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Cheap</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickA&#125;</span>&gt;</span>组件Cheap: &#123;dataA&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Cheap</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Expensive</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickB&#125;</span>&gt;</span>组件Expensive: &#123;dataB&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Expensive</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述组件中，每当点击Cheap组件的时候，Expensive组件也会重新渲染，即使dataB没有发生变化，原因就是onClickB被重新定义，导致React在diff新旧组件的时候判定了组件发生了变化。</p><p>此时，useCallback和memo就发挥作用了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useCallback, useState, memo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Expensive</span>(<span class="hljs-params">&#123;onClick, name&#125;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Expensive渲染&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><span class="hljs-keyword">const</span> memoExpensive = <span class="hljs-title function_">memo</span>(<span class="hljs-title class_">Expensive</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cheap</span>(<span class="hljs-params">&#123;onClick, name&#125;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Cheap渲染&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Comp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [dataA, setDataA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> [dataB, setDataB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickA</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataA</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> onClickB = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">setDataB</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;, [])<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Cheap</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickA&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">组件Cheap:</span> $&#123;<span class="hljs-attr">dataA</span>&#125;`&#125; /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Expensive</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickB&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">组件Expensive:</span> $&#123;<span class="hljs-attr">data</span>&#125;`&#125; /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>memo与PureComponent类似，对传入组件的新旧数据进行浅比较，如果相同则不会触发渲染。</p><p>useCallback保证onClickB不会发生变化，此时点击Cheap组件不会触发Expensive组件的刷新，只有点击Expensive组件才会触发。在实现减少不必要渲染的优化过程中，useCallback和memo是一对利器。</p><h2 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h2><p>要求：使用React的hook实现一个useRequest</p><ul><li>展示loading效果后告诉用户后台正在处理请求</li><li>接口异常时要进行错误处理</li><li>缓存同一请求(非结果)</li></ul><h2 id="Redux使用流程及场景？"><a href="#Redux使用流程及场景？" class="headerlink" title="Redux使用流程及场景？"></a>Redux使用流程及场景？</h2><ol><li>安装Redux。</li><li>创建一个store，store是一个对象，它有四个方法：dispatch、subscribe、getState和replaceReducer。</li><li>定义action，action是一个普通的JavaScript对象，用来描述发生了什么。</li><li>定义reducer，reducer是一个纯函数，接收旧的state和action，返回新的state。</li><li>使用combineReducers将多个reducer合并成一个根reducer。</li><li>使用Provider组件将store传递给子组件。</li><li>在组件中使用connect函数连接store和组件。</li></ol><h2 id="有没有了解Mobx"><a href="#有没有了解Mobx" class="headerlink" title="有没有了解Mobx?"></a>有没有了解Mobx?</h2><h2 id="Webpack如何进行配置？"><a href="#Webpack如何进行配置？" class="headerlink" title="Webpack如何进行配置？"></a>Webpack如何进行配置？</h2><p>主要配置过相关loader</p><h2 id="Webpack中loader和plugin的区别？"><a href="#Webpack中loader和plugin的区别？" class="headerlink" title="Webpack中loader和plugin的区别？"></a>Webpack中loader和plugin的区别？</h2><ul><li>loader是一种打包方案，对于某一种类型文件它知道如何打包，帮助Webpack完成打包工作。loader就是一个单纯的文件转化过程。</li><li>plugin是一个扩展器，丰富Webpack本身，增强功能，针对的是在loader结束之后，Webpack打包的整个过程。plugin并不直接操作文件，而是基于事件机制工作，会监听Webpack打包过程中的某些事件钩子，执行任务。</li></ul><h2 id="浏览器缓存机制？"><a href="#浏览器缓存机制？" class="headerlink" title="浏览器缓存机制？"></a>浏览器缓存机制？</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>Cache-Control &#x2F; Expires</p><p> expires <code>http1.0</code>控制网页缓存的字段，其值为服务器返回该请求结果的到期时间，即再次发送请求，如果客户端的时间小于expires的值时，直接使用缓存结果</p><p> cache-control(优先级更大) http1.1中控制网页缓存，是最重要的规则</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>Etag If-None-Match &#x2F; Last-Midified If-Midified-Since</p><p> <code>Last-Modified / If-Modified-Since</code> 和 <code>Etag / If-None-Match</code> (后者优先级更高)</p><p> Last-Modified 服务器响应请求时，返回该文件资源在服务器内最后被修改的时间</p><p> If-Modified-Since 客户端再次发起请求时，携带上次请求返回的Last-Modified值，通过此字段告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据此字段值与该资源在服务器的最后被修改的时间做对比，若服务器的资源最后被修改的时间大于If-Modified-Since字段值，则重新返回资源，状态码为200；否则返回304，代表资源无更新，可继续使用缓存文件</p><p> Etag 是服务区响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)</p><p> If-None-Match 服务器再次发起请求时，携带上次请求返回的唯一标识Etag，通过此字段告诉服务器该资源上次请求返回的唯一标识，服务器收到该请求后，发现请求头中含有If-None-Match的字段与该资源在服务器的Etag值进行比对，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码200</p><h2 id="前端常见的优化手段？"><a href="#前端常见的优化手段？" class="headerlink" title="前端常见的优化手段？"></a>前端常见的优化手段？</h2><p>常见的前端性能优化手段包括：减少请求数量、减小资源大小、优化网络连接、优化资源加载、减少重绘回流、使用性能更好的API和构建优化等。</p><p>其中，减少请求数量可以通过合并CSS和JS文件、使用CSS Sprites技术、使用字体图标等方式来实现；减小资源大小可以通过压缩CSS、JS和图片等方式来实现；优化网络连接可以通过使用CDN、开启Gzip压缩等方式来实现；优化资源加载可以通过使用预加载、懒加载等方式来实现；减少重绘回流可以通过避免频繁操作DOM、使用CSS3动画等方式来实现；使用性能更好的API可以通过使用requestAnimationFrame代替setTimeout、使用Web Workers等方式来实现；构建优化可以通过使用Webpack等打包工具进行代码分割、按需加载等方式来实现。</p><p>七大优化手段：<a href="https://juejin.cn/post/7016868803069886471">https://juejin.cn/post/7016868803069886471</a></p><h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>闭包是指一个函数能够访问其他函数内部变量的函数。在JavaScript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数”。</p><p>闭包的优点是可以保护变量不被污染，同时也可以实现数据私有化。缺点是会占用更多的内存空间，同时也会增加代码的复杂度。</p><h2 id="React过期闭包了解过吗？"><a href="#React过期闭包了解过吗？" class="headerlink" title="React过期闭包了解过吗？"></a>React过期闭包了解过吗？</h2><p>React过期闭包是指在使用React Hook时，由于函数组件多次render之间，函数的闭包可能会包住过期的上下文，也就是之前render时的上下文。这个问题在应用Hooks更突出。</p><p>React解决过期闭包问题的方法是依赖数组。针对过期state，可以使用函数的方法更新值。React确保通过更新函数可以得到最新的state值。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端|面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结(2.1)</title>
    <link href="/2023/04/08/%E6%80%BB%E7%BB%93-2-1/"/>
    <url>/2023/04/08/%E6%80%BB%E7%BB%93-2-1/</url>
    
    <content type="html"><![CDATA[<h2 id="进程和线程的概念及区别"><a href="#进程和线程的概念及区别" class="headerlink" title="进程和线程的概念及区别"></a>进程和线程的概念及区别</h2><p>进程是对正在运行中的程序的一个抽象，是系统进行资源分配和调度的基本单位。</p><p>线程是CPU任务调度和执行的基本单位。</p><p>区别：</p><ul><li>进程可以看作是一个独立应用，而线程不能。</li><li>进行是CPU进行资源分配的最小单位，而线程是CPU调度的最小单位。</li><li>线程间可以直接共享同一进程中的资源，而进程通信需要借助<strong>进程间通信</strong>。</li><li>进行切换的开销比线程切换的开销要大。线程的切换不会引起进程的切换，但某个进程中的线程切换到另一个进程中的线程会引起进程的切换。</li><li>撤销或创建进程的时候，系统要为之分配或回收资源，开销远大于创建或撤销线程时的开销。同样，进程切换的时候涉及到<strong>当前进程的CPU环境还有各种各样状态的保存及新调度进程状态的设置</strong>，而线程切换只需要保存和设置少量的寄存器内容，开销较小。</li></ul><h2 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h2><ul><li><p>管道通信</p><p>操作系统在内核中开辟一段缓冲区，进程A可以将需要交互的数据拷贝到这段缓冲区中，进程B就可以读取了。(只能单向通信，并只能在有血缘关系的进程间通信)</p></li><li><p>消息队列队列通信</p><p>消息队列就是一个消息的列表，用户可以在消息队列中添加消息、读取消息等。它提供了一种从一个进程向另一个进程发送数据块的方法。每个数据块都被认为含有一个类型，接收进程可以独立的接受含有不同类型的数据结构。但消息队列与命名管道一样，每个数据块都有一个<strong>最大长度的限制</strong>。</p></li><li><p>共享内存通信</p><p>共享内存就是映射了一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问(使多个进程可以访问同一块内存空间)。</p></li><li><p>信号量通信</p><p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。</p></li><li><p>信号通信</p><p>Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件(一组事件中的一个)，它也是用户进程间通信和同步的一种原始机制。</p></li><li><p>套接字通信</p><p>是计算机之间进行通信的一种约定或一种方式。</p></li></ul><h2 id="进程的状态有哪些？"><a href="#进程的状态有哪些？" class="headerlink" title="进程的状态有哪些？"></a>进程的状态有哪些？</h2><p>进程的状态通常分为五种基本状态：创建态、就绪态、运行态、阻塞态和终止态。</p><ul><li>创建态：进程刚被创建，但是还没有被操作系统调度执行。</li><li>就绪态：进程已经准备好运行，但是还没有被操作系统调度执行。</li><li>运行态：进程正在被操作系统调度执行。</li><li>阻塞态：进程因为某些原因而暂停执行，等待外部事件的发生。</li><li>终止态：进程已经完成了它的任务，或者因为某些原因被操作系统强制终止。</li></ul><h2 id="操作系统进程调度有哪几种？"><a href="#操作系统进程调度有哪几种？" class="headerlink" title="操作系统进程调度有哪几种？"></a>操作系统进程调度有哪几种？</h2><p>操作系统的进程调度的常见策略：</p><ul><li>先来先服务调度算法(FCFS)：按照进程到达的先后顺序进行调度，先到达的进程限制性，后到达的进程后执行。</li><li>短作业优先调度算法(SJF)：按照进程需要的CPU时间长短进行调度，即需要CPU时间最短的进程先执行。</li><li>优先级调度算法：按照进程的优先级进行调度，即优先级高的进程先执行。</li><li>时间片轮转调度算法：按照时间片轮流分配CPU时间进行调度，即每个进程分配一个时间片，当时间片用完后，该进程被挂起，等到下一次轮到它的时候再继续执行。</li><li>多级反馈队列算法：将就绪队列分成多个队列，每个队列有不同的优先级，每个队列采用不同的调度算法。新到达的进程首先放在第一级队列，如果该队列中没有可执行的进程，则将该队列放入第二级队列中等待执行。如果第一级队列中有可执行的进程，则按照时间片轮转调度算法去进行调度。如果一个进程再第一级队列中运行了一段时间仍然没有完成，则将其移动到第二级队列中等待执行，以此类推，直到该进程完成或被强制终止。</li></ul><h2 id="操作系统的堆区和栈区"><a href="#操作系统的堆区和栈区" class="headerlink" title="操作系统的堆区和栈区"></a>操作系统的堆区和栈区</h2><p>操作系统中的堆和栈都是指内存空间，不同的是堆为按需申请、动态分配，例如 C 中的 malloc 函数和 C++ 中的 new 操作。而栈是由编译器自动分配释放，存放函数的参数值，局部变量的值等。<br>堆和栈之间的区别主要有以下几点：</p><ul><li><p>分配方式：堆是动态分配的，而栈是静态分配的。</p></li><li><p>空间大小：堆的空间大小不确定，而栈的空间大小固定。</p></li><li><p>空间分配方式：堆是由程序员手动申请和释放，而栈是由编译器自动分配和释放。</p></li><li><p>空间使用方式：堆的空间可以随时申请和释放，而栈的空间只能在函数调用时申请，在函数返回时释放。</p></li></ul><h2 id="常见的数据结构有哪些？"><a href="#常见的数据结构有哪些？" class="headerlink" title="常见的数据结构有哪些？"></a>常见的数据结构有哪些？</h2><ul><li>数组 (Array)</li><li>队列 (Queue)</li><li>链表 (Linked List)</li><li>栈 (Stack)</li><li>树 (Tree)</li><li>散列表(Hash)</li><li>堆(Heap)</li><li>图 (Graph)</li></ul><h2 id="在JS中如何实现图结构？"><a href="#在JS中如何实现图结构？" class="headerlink" title="在JS中如何实现图结构？"></a>在JS中如何实现图结构？</h2><p>在JavaScript中，可以使用邻接表或邻接矩阵来实现图结构。其中，邻接表是一种链式存储方式，它将每个顶点的所有邻居顶点都存储在一个链表中。而邻接矩阵则是一个二维数组，其中每个元素表示两个顶点之间是否有边。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span> = []；<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()；<br>  &#125;<br><br>  <span class="hljs-title function_">addVertex</span>(<span class="hljs-params">v</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-title function_">push</span>(v)；<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">set</span>(v, [])；<br>  &#125;<br><br>  <span class="hljs-title function_">addEdge</span>(<span class="hljs-params">v, w</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(v).<span class="hljs-title function_">push</span>(w)；<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(w).<span class="hljs-title function_">push</span>(v)；<br>  &#125;<br><br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;&#x27;</span>；<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>； i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-property">length</span>； i++) &#123;<br>      s += <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.vertices[i]&#125;</span> -&gt; `</span>；<br>      <span class="hljs-keyword">const</span> neighbors = <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>[i])；<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>； j &lt; neighbors.<span class="hljs-property">length</span>； j++) &#123;<br>        s += <span class="hljs-string">`<span class="hljs-subst">$&#123;neighbors[j]&#125;</span> `</span>；<br>      &#125;<br>      s += <span class="hljs-string">&#x27;\n&#x27;</span>；<br>    &#125;<br>    <span class="hljs-keyword">return</span> s；<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Graph</span>()；<br><span class="hljs-keyword">const</span> vertices = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>]；<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>； i &lt; vertices.<span class="hljs-property">length</span>； i++) &#123;<br>  graph.<span class="hljs-title function_">addVertex</span>(vertices[i])；<br>&#125;<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;H&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>)；<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(graph.<span class="hljs-title function_">toString</span>())；<br></code></pre></td></tr></table></figure><h2 id="JS-DOM树用什么数据结构进行存储？"><a href="#JS-DOM树用什么数据结构进行存储？" class="headerlink" title="JS DOM树用什么数据结构进行存储？"></a>JS DOM树用什么数据结构进行存储？</h2><p>JavaScript的DOM树是以多叉树的形式存储的。DOM模型用一个逻辑树来表示一个文档，树的每个分支的终点都是一个节点(node)，每人节点都包含着对象(Obiects)。</p><h2 id="什么是哈希冲突？"><a href="#什么是哈希冲突？" class="headerlink" title="什么是哈希冲突？"></a>什么是哈希冲突？</h2><p>哈希冲突是指，当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象。在哈希表中，每个关键字都对应一个位置，但是不同的关键字可能会对应到相同的位置，这就是哈希冲突。哈希冲突的解决方法有很多种，其中比较常见的有链地址法和开放地址法。链地址法是将相同hash值的对象组织成一个链表放在hash值对应的槽位；开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。</p><h2 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h2><p>数组和链表是两种常见的数据结构。数组是一种线性数据结构，它在内存中占用一段连续的空间，每个元素都可以通过下标来访问。而链表则是一种非线性数据结构，它的元素在内存中不一定是连续的，每个元素都包含了指向下一个元素的指针。</p><p>因此，数组和链表有以下区别：</p><ul><li>数组在内存中占用一段连续的空间，而链表的元素在内存中不一定是连续的。</li><li>数组的元素可以通过下标来访问，而链表的元素只能通过指针来访问。</li><li>数组的大小是固定的，而链表的大小可以动态改变。</li><li>数组的插入和删除操作需要移动其他元素，时间复杂度为O(n)，而链表只需要改变指针指向，时间复杂度为0(1)。</li></ul><h2 id="数组和链表在内存分配上的区别？"><a href="#数组和链表在内存分配上的区别？" class="headerlink" title="数组和链表在内存分配上的区别？"></a>数组和链表在内存分配上的区别？</h2><p>数组和链表在内存分配上的区别是：</p><p>数组静态分配内存，链表动态分配内存；数组在内存中连续，链表不连续；数组元素在栈区，链表元素在堆区。此外，数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)； 数组插入或删除元素的时间复杂度0(n)，链表的时间复杂度0(1)。</p><h2 id="在使用JS进行开发的时候，什么情况下用数组存储数据-什么情况下用链表存储数据"><a href="#在使用JS进行开发的时候，什么情况下用数组存储数据-什么情况下用链表存储数据" class="headerlink" title="在使用JS进行开发的时候，什么情况下用数组存储数据? 什么情况下用链表存储数据?"></a>在使用JS进行开发的时候，什么情况下用数组存储数据? 什么情况下用链表存储数据?</h2><p>在使用JS进行开发时</p><p>使用数组存储数据的情况包括：需要快速访问元素，需要按照顺序存储元素，需要对元素进行排序或者操作，需要在数组中存储不同类型的数据等。</p><p>使用链表存储据的情况包括：需要动态添加或删除元素，不需要按照顺序存储元素，不需要快速访问元素等。</p><h2 id="JS中二叉树通过什么数据结构进行实现？"><a href="#JS中二叉树通过什么数据结构进行实现？" class="headerlink" title="JS中二叉树通过什么数据结构进行实现？"></a>JS中二叉树通过什么数据结构进行实现？</h2><p>在实现二叉树时，采用的存储结构为链式存储结构，链式结构的意思是采用一个链表来存储一颗二叉树，二叉树中每一个节点用链表的一个节点来存储，在二叉树中，节点结构至少有三个域：数据域data，左指针域left，右指针域right。</p><h2 id="栈和队列的特点及区别"><a href="#栈和队列的特点及区别" class="headerlink" title="栈和队列的特点及区别?"></a>栈和队列的特点及区别?</h2><p>栈和队列都是线性结构，但它们的特点和应用场景不同。栈是一种后进先出(LIFO)的数据结构，而队列是一种先进先出 (FIFO) 的数据结构。</p><p>栈和队列的区别在于它们的出入方式不同。栈是后进先出，队列是先进先出。在具体实现的时候操作的位置也不同:因为栈是后进先出，它在一端进行操作；而队列是先进先出，实现的时候在两端进行操作。</p><h2 id="OSI七层网络协议"><a href="#OSI七层网络协议" class="headerlink" title="OSI七层网络协议"></a>OSI七层网络协议</h2><p>OSI七层网络协议是一种通信协议的标准，它将计算机网络体系结构分为七个层次，每个层次都有自己的功能和任务。这些层次分别是：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p><p>物理层：负责传输比特流，即由1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换。<br>数据链路层：在计算机网络中由于各种干扰的存在，物理链路是不可靠的。该层的主要功能就是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。<br>网络层：负责数据包从源到宿的传递和网际互连。<br>传输层：负责向两台主机进程之间提供端到端的可靠数据传输服务。<br>会话层：负责建立、管理和终止会话。<br>表示层：负责数据格式转换、加密解密等。<br>应用层：为用户提供各种应用服务。</p><h3 id="HTTP属于哪层协议？"><a href="#HTTP属于哪层协议？" class="headerlink" title="HTTP属于哪层协议？"></a>HTTP属于哪层协议？</h3><p>应用层</p><h3 id="TCP和UDP属于哪层协议？"><a href="#TCP和UDP属于哪层协议？" class="headerlink" title="TCP和UDP属于哪层协议？"></a>TCP和UDP属于哪层协议？</h3><p>传输层</p><h2 id="TCP和UDP的区别？"><a href="#TCP和UDP的区别？" class="headerlink" title="TCP和UDP的区别？"></a>TCP和UDP的区别？</h2><p>TCP和UDP的区别如下:</p><ul><li>TCP是面向连接的，UDP是无连接的</li><li>TCP提供可靠的服务，UDP则不保证可靠交付数据 </li><li>TCP是一对一的两点服务，即一条连接只有两个端点。UDP支持一对一、一对多、多对多的交互通信</li><li>TCP有拥塞控制和流量控制机制，保证数据传输的安全性。UDP则没有，即使网络非常拥堵了，也不会影响UDP的发送速率</li><li>TCP首部长度较长，会有一定的开销，首部在没有使用[选项，字段时是20个字节，如果使用了[选项]字段则会变长。UDP首部只有8个字节，并且是固定不变的，开销较小。</li></ul><h2 id="TCP和UDP的应用场景？"><a href="#TCP和UDP的应用场景？" class="headerlink" title="TCP和UDP的应用场景？"></a>TCP和UDP的应用场景？</h2><p>TCP和UDP是两种不同的传输协议。TCP是面向连接的协议，而UDP是无连接的协议。TCP提供交付保证，这意味着一个使用TCP协议发送的消息是保证交付给客户端的，如果消息在传输过程中丢失，那么它将重发。而UDP不提供这种保证。因此，TCP适用于对准确性要求相对高的场景，如文件传输、发送或接收邮件、远程登录等，而UDP适用于对准确性要求相对低但速度要求相对高的场景，如即时通信、在线视频、网络语音电话等。</p><h2 id="TCP的三次挥手"><a href="#TCP的三次挥手" class="headerlink" title="TCP的三次挥手"></a>TCP的三次挥手</h2><p>TCP三次握手是TCP协议中用于在客户端和服务器之间建立连接的过程。三次握手的过程如下：</p><ol><li><p>客户端向服务器发送一个SYN包，其中标志位为SYN，表示请求建立连接，序号为Seq&#x3D;x(一般取随机数)。</p></li><li><p>服务器接收到客户端发来的SYN包后，对该包进行确认后结束LISTEN阶段，并返回一段TCP报文，其中标志位为SYN和ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接，序号为Seq&#x3D;y。</p></li><li><p>客户端接收到服务器发来的TCP报文后，对该报文进行确认，其中标志位为ACK，表示确认服务器的报文Seq序号有效，客户端能正常接收服务器发送的数据，并向服务器发送一段TCP报文，其中标志位为ACK，表示确认服务器的报文Seq序号有效。</p></li></ol><h2 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h2><p>TCP四次挥手是TCP协议中用于在客户端和服务器之间断开连接的过程。四次挥手的过程如下：</p><ol><li><p>客户端向服务器发送一个FIN包，其中标志位为FIN，表示请求断开连接，序号为Seq&#x3D;u。</p></li><li><p>服务器接收到客户端发来的FIN包后，对该包进行确认后结束ESTABLISHED阶段，并返回一段TCP抵文，其中标志位为ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并告诉客户端：我知道你想断开连接的请求了。</p></li><li><p>服务器向客户端发送一个FIN包，其中标志位为FIN，表示请求断开连接，序号为Seq&#x3D;V。</p></li><li><p>客户端接收到服务器发来的TCP报文后，对该报文进行确认，其中标志位为ACK，表示确认服务器的报文Seq序号有效，客户端能正常接收服务器发送的数据，并向服务器发送一段TCP报文，其中标志位为ACK，表示确认服务器的报文Seq序号有效。</p></li></ol><h2 id="TCP的三次握手为什么不能改成两次？"><a href="#TCP的三次握手为什么不能改成两次？" class="headerlink" title="TCP的三次握手为什么不能改成两次？"></a>TCP的三次握手为什么不能改成两次？</h2><p>TCP三次握手是TCP协议中用于在客户端和服务器之间建立连接的过程。其中，第一次握手是客户端向服务器发送一个SYN包，其中标志位为SYN，表示请求建立连接，序号为Seq&#x3D;x；</p><p>第二次握手是服务器接收到客户端发来的SYN包后，对该包进行确认后结束SYN_RECEIVED阶段，并返回一段TCP报文，其中标志位为SYN&#x2F;ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并告诉客户端:我知道你想建立连接的请求了，我的序号是Seq&#x3D;y；</p><p>第三次握手是客户端接收到服务器发来的TCP报文后，对该报文进行确认，其中标志位为ACK，表示确认服务器的报文Seq序号有效，客户端能正常接收服务器发送的数据，并告诉服务器:我知道你想建立连接的请求了，我的序号是Seq&#x3D;x+1。这样就完成了TCP三次握手过程。</p><p>如果采用两次握手，则<strong>只能确定从客户端到服务端的网络是可达的，但无法保证从服务端到客户端的网络是可达的</strong>。</p><p>此外，在采用两次握手时，如果已失效的连接请求报文段突然又传到了服务端，则会导致双方不一致，造成资源浪费。</p><h2 id="浏览器中输入网址并发起网络请求后都经历了什么？"><a href="#浏览器中输入网址并发起网络请求后都经历了什么？" class="headerlink" title="浏览器中输入网址并发起网络请求后都经历了什么？"></a>浏览器中输入网址并发起网络请求后都经历了什么？</h2><ol><li><p>首先判断输入的内容是否为合法的域名，如果不是则作为关键字交给搜索引擎进行处理；如果域名中有非法字符则进行转义。</p></li><li><p>首先判断浏览器中是否有所需资源的缓存，如果有则直接使用，否则进行DNS查询获取域名对应的IP地址。</p></li><li><p>DNS查询</p><ol><li><p>判断本地的DNS缓存中是否有该IP地址，如果命中则返回</p></li><li><p>如果还是没有命中，则将域名发送到本地域名服务器，本地域名服务器采用递归查询自己的DNS服务器，查找成功则返回。</p></li><li><p>如果本地域名服务器的DNS缓存没有命中，则向上级域名服务器进行迭代查询</p><ul><li><p>首先本地域名服务器向根域名服务器进行请求，获取顶级域名服务器的地址给本地服务器。</p></li><li><p>本地域名服务器拿到这个顶级域名服务器后就想起发送请求，获取权威域名服务器的地址。</p></li><li><p>本地域名服务器向权威域名服务器发送请求，获取域名对应的IP地址。</p></li></ul></li><li><p>本地域名服务器将得到的IP地址发送给操作系统，同时自己将IP地址缓存起来。</p></li><li><p>操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来。</p></li><li><p>至此，浏览器得到了域名对应的IP地址，并将IP地址缓存起来。</p></li></ol></li><li><p>通过IP地址与本地的子网掩码相与，判断是否与请求主机在一个子网中，如果在一个子网中，则使用ARP协议获取目标主机的MAC地址，如果不在一个子网中，那么请求应该转发给网关，由它代为转发，此时同样可以通过ARP协议获取网关MAC地址，此时目的主机的MAC地址应该为网关地址。</p></li><li><p>进行TCP的三次握手</p></li><li><p>进行HTTPS握手</p></li><li><p><strong>返回数据</strong>：将网页请求发送至服务器端，服务器端返回一个html文件作为响应。浏览器接受响应后，开始对html文件进行解析并开始页面的渲染过程。</p></li><li><p><strong>页面渲染</strong>：根据html文件构建DOM树，根据解析到的css构建CSSOM树，如果遇到script标签，则判断有无async和defer属性，否则script的加载和执行会造成页面渲染的阻塞。当DOM树和CSSOM树建立好后，根据他们构建渲染树。渲染树构建好后，根据渲染树进行布局，然后使用浏览器的UI接口对页面进行绘制。此时整个页面就显示出来了。</p></li><li><p>TCP四次挥手</p></li></ol><h2 id="什么是数据库的索引？"><a href="#什么是数据库的索引？" class="headerlink" title="什么是数据库的索引？"></a>什么是数据库的索引？</h2><p>数据库索引是一种数据结构，用于提高数据库表中数据的查询效率。索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。</p><p>在数据库中，索引类似于书籍的目录。如果您想查找书籍中的某个主题，您可以查找目录以找到该主题的页码，而不必翻阅整本书。同样，如果您想查找数据库表中的某个值，则可以使用索引来快速查找该值所在的行，而不必扫描整个表。</p><p>索引可以大大提高查询效率，但也会增加写入操作的时间和空间开销。因此，在设计数据库时，需要权衡查询效率和写入效率之间的平衡。</p><h2 id="数据库的索引有哪几种类型？"><a href="#数据库的索引有哪几种类型？" class="headerlink" title="数据库的索引有哪几种类型？"></a>数据库的索引有哪几种类型？</h2><p>数据库索引有多种类型，包括: 普通索引、唯一索引、主键索引、组合索引和全文索引等。</p><ul><li>普通索引：基本的索引类型，没有唯一性的限制，允许为NULL值。</li><li>唯一索引：数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</li><li>主键索引：主键是一种特殊的唯一索引，不允许为NULL值，一个表只能有一个主键</li><li>组合索引：将多个列作为一个索引建立，可以提高查询效率。</li><li>全文索引：用于全文搜索的特殊类型的索引。</li></ul><h2 id="什么是MySQL关联查询？"><a href="#什么是MySQL关联查询？" class="headerlink" title="什么是MySQL关联查询？"></a>什么是MySQL关联查询？</h2><p>MySQL关联查询是指在查询时，需要同时操作多张表来查询数据，即关联查询。MySQL关联查询的语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column name(s)<br>FROM tablel<br>JOIN table2<br>ON table1.column_name = table2.column_name;<br></code></pre></td></tr></table></figure><p>其中，<code>table1</code> 和 <code>table2</code> 是要连接的表的名称，column_name 是要检索的列的名称。JOIN关键字用于指定要连接的表，而关键字用于指定连接条件。</p><p>MySQL支持多种类型的关联查询，包括：内连接、左连接、右连接和全连接等。</p><h2 id="关系型数据库和非关系型数据库的区别？"><a href="#关系型数据库和非关系型数据库的区别？" class="headerlink" title="关系型数据库和非关系型数据库的区别？"></a>关系型数据库和非关系型数据库的区别？</h2><p>关系型数据库和非关系型数据库的区别在于，关系型数据库一般都是有固定的表结构，并且需要通知DDL语句来修改表结构，不是很容易进行扩展；而非关系型数据库的存储机制就有很多了，比如基于文档的，K-V键值对的，还有基于图的等，对于数据的格式十分灵活没有固定的表结构，方便扩展。因此<u>如果业务的数据结构并不是固定的或者经常变动比较大的，那么非关系型数据库是个好的选择</u>。</p><h2 id="关系型数据库与文档型数据库的区别？"><a href="#关系型数据库与文档型数据库的区别？" class="headerlink" title="关系型数据库与文档型数据库的区别？"></a>关系型数据库与文档型数据库的区别？</h2><p>关系型数据库（Relational Database）是建立在关系模型基础上的数据库，借助于几何代数等数学概念和方法来处理数据库中的数据。所谓关系模型是一对一、一对多或者多对多等关系，常见的关系型数据库有Oracle、SQL Server、DB2、MySQL等。</p><p>而文档型数据库是一种非关系型数据库，非关系型数据库（Not Only SQL，NoSQL）正好与关系型数据库相反，它不是建立在“关系模型”上的数据库。文档型数据库的典型代表是MongoDB。</p><h2 id="MongoDB和MySQL的区别"><a href="#MongoDB和MySQL的区别" class="headerlink" title="MongoDB和MySQL的区别"></a>MongoDB和MySQL的区别</h2><p>MongoDB是一种文档型数据库，而MySQL是一种关系型数据库。</p><p>MongoDB可以处理大量和非结构化数据量，而MySQL则<strong>缺乏处理大数据量的速度</strong>。因此，对于拥有较小数据库并寻求更通用解决方案的公司来说，MySQL可以胜任。</p><p>另外，MongoDB以一种直观文档的方式来完成数据的存储，它很像JavaScript中定义的JSON格式，不过数据在存储的时候MongoDB数据库为文档增加了序列化的操作，最终存进磁盘的其实是一种叫做BSON的格式，即Binary-JSON。</p><p>MySQL在<strong>处理关系数据方面具有更好的优势</strong>，而MongoDB则更能满足现代应用程序的需求。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端|面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结(1.1)</title>
    <link href="/2023/04/08/%E6%80%BB%E7%BB%93-1-1/"/>
    <url>/2023/04/08/%E6%80%BB%E7%BB%93-1-1/</url>
    
    <content type="html"><![CDATA[<h2 id="React函数组件的优势"><a href="#React函数组件的优势" class="headerlink" title="React函数组件的优势"></a>React函数组件的优势</h2><ul><li>函数式组件没有this困扰且代码简洁</li><li>不涉及到复杂的state和生命周期</li><li>类组件过于冗余不宜拆分</li></ul><h2 id="常用的React-Hooks"><a href="#常用的React-Hooks" class="headerlink" title="常用的React Hooks"></a>常用的React Hooks</h2><blockquote><p>Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数</p><p>Hook使用规则：</p><ul><li>只能在<strong>函数最外层</strong>调用Hook。不能在循环、条件判断或子函数中调用。</li><li>只能在React的<strong>函数组件</strong>中调用Hook。不能在其他JavaScript函数中调用。</li></ul></blockquote><ul><li><p>State Hook</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">count</span>, setCount] = useState(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li><p>Effect Hook</p><blockquote><p><code>useEffect</code>就是一个Effect Hook，给函数组件增加了操作副作用的能力。它跟class组件中的<code>componentDidMount</code>、<code>componentDidUpdate</code>和<code>componentWillUnMount</code>具有相同的用途，只不过被合并成了一个<code>API</code>。</p></blockquote><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 模拟componentDidMount</span><br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>   <span class="hljs-comment">// 第一次渲染时调用 </span><br>&#125;, [])<br><br><span class="hljs-comment">// 模拟componentDidUpdate</span><br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 任意属性发生改变该属性就会改变</span><br>&#125;)<br><br><span class="hljs-comment">// 模拟componentWillUnmount useEffect会在状态变化的时候进行解绑</span><br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    const timer = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;, <span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <span class="hljs-comment">// 返回的函数是用于清除副作用的</span><br>        <span class="hljs-comment">// 执行卸载操作</span><br>        clearInterval(timer);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>自定义Hooks</p><p>例如：自定义一个订阅好友在线状态的Hook</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">import React, &#123; useEffect, useState &#125; from <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> use<span class="hljs-constructor">FriendStatus(<span class="hljs-params">friendID</span>)</span> &#123;<br>    const <span class="hljs-literal">[<span class="hljs-identifier">isOnline</span>, <span class="hljs-identifier">setIsOnlone</span>]</span> = use<span class="hljs-constructor">State(<span class="hljs-params">null</span>)</span>;<br>    const handleStatusChange =<span class="hljs-function"> (<span class="hljs-params">status</span>) =&gt;</span> &#123;<br>        set<span class="hljs-constructor">IsOnline(<span class="hljs-params">status</span>)</span>;<br>    &#125;<br>    use<span class="hljs-constructor">Effect(()</span> =&gt; &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChatAPI</span>.</span></span>subscribe<span class="hljs-constructor">ToFriendStatus(<span class="hljs-params">friendId</span>, <span class="hljs-params">handleStatusChange</span>)</span>; <span class="hljs-comment">// 订阅好友在线状态</span><br>        return<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChatAPI</span>.</span></span>unsubscribe<span class="hljs-constructor">ToFriend(<span class="hljs-params">friendId</span>, <span class="hljs-params">handleStatusChange</span>)</span>; <span class="hljs-comment">// 解绑对好友在线状态的订阅</span><br>        &#125;<br>    &#125;)<br>    return isOnline;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们可以在别的组件中使用它</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">FriendStatus(<span class="hljs-params">props</span>)</span> &#123;<br>    const isOnline = use<span class="hljs-constructor">FriendStatus(<span class="hljs-params">props</span>.<span class="hljs-params">friend</span>.<span class="hljs-params">id</span>)</span>;<br>    <span class="hljs-keyword">if</span>(isOnline<span class="hljs-operator"> === </span>null) &#123;<br>        return <span class="hljs-string">&quot;Loading...&quot;</span>;<br>    &#125;<br>    return isOnline ? <span class="hljs-string">&quot;onLine&quot;</span> : <span class="hljs-string">&quot;OffLine&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>useContext</p><p>不使用组件嵌套就可以订阅React的Context</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">function Example() &#123;<br>    const locale <span class="hljs-operator">=</span> useContext(LocaleContext)<span class="hljs-comment">;</span><br>    const theme <span class="hljs-operator">=</span> useContext(ThemeContext)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>useReducer</p><p>通过reducer管理本地复杂的state</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Todos()</span> &#123;<br>    const <span class="hljs-literal">[<span class="hljs-identifier">todos</span>, <span class="hljs-identifier">setTodos</span>]</span> = use<span class="hljs-constructor">Reducer(<span class="hljs-params">todosReducer</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="React为什么推荐用Hook而不是生命周期"><a href="#React为什么推荐用Hook而不是生命周期" class="headerlink" title="React为什么推荐用Hook而不是生命周期"></a>React为什么推荐用Hook而不是生命周期</h2><p>生命周期不利于逻辑相关的状态的管理。</p><p>side effect相关逻辑被分散到不同的函数中可能会导致bug的出现和产生数据不一致的情况；我们也可能会在组件的同一生命周期中放很多不相关的side effect逻辑。</p><p>使用Hook可以将某个side effect相关的逻辑都放在同一个函数中，方便代码的维护，方便组件的复用。</p><h2 id="为什么不能在循环、条件或嵌套函数中调用React-Hook"><a href="#为什么不能在循环、条件或嵌套函数中调用React-Hook" class="headerlink" title="为什么不能在循环、条件或嵌套函数中调用React Hook"></a>为什么不能在循环、条件或嵌套函数中调用React Hook</h2><p>React是使用链表来存储Hook的，每次Hook的调用都对应着一个全局的index索引，通过这个索引运行当前组件上的_hooks数组查找保存的值，也就是Hook返回的<code>[state, useState]</code></p><p>假设如下代码：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">function Example() &#123;<br>    <span class="hljs-keyword">const</span> [state1, <span class="hljs-built_in">set</span>State1] = useState(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> [state2, <span class="hljs-built_in">set</span>State2] = useState(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">const</span> [state3, <span class="hljs-built_in">set</span>State3] = useState(<span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/5/166e20d92aa52108~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="react-hooks"></p><p>在执行函数组件的时候，第一次执行<code>useState</code>是时候，它会对应Fiber对象上的<code>memoizedState</code>，这个属性原来是设计来存储类组件的state的，因为在类组件中state是一整个对象，所以可以和<code>memoizedState</code>一一对应。</p><p>但是在Hooks中，React并不知道我们调用了几次<code>useState</code>，所以在保存state这件事上，React提出了另一种解决方案，即调用<code>useState</code>之后在<code>memoizedState</code>上的对象设计成如下样式：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">&#123;<br><span class="hljs-built_in">    baseState,</span><br><span class="hljs-built_in">    next,</span><br><span class="hljs-built_in">    baseUpdate,</span><br><span class="hljs-built_in">    queue,</span><br>    memoizedState<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将其称为Hook对象。这里最需要关心的是<code>memoizedState</code>和<code>next</code>，<code>memoizedState</code>用来记录该<code>useState</code>应该返回的结果，而<code>next</code>指向下一次<code>useState</code>对应的Hook对象。</p><p>即：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">hook1</span> <span class="hljs-operator">=</span>&gt; Fiber.memoizedState<br><span class="hljs-attribute">state1</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> hook1.memoizedState<br>hook1.next <span class="hljs-operator">=</span>&gt; hook2<br><span class="hljs-attribute">state2</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> hook2.memoizedState<br>hook2.next <span class="hljs-operator">=</span>&gt; hook3<br><span class="hljs-attribute">state3</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> hook3.memoizedState<br></code></pre></td></tr></table></figure><p>React按照执行顺序以类似链表的数据格式存放在<code>Fiber.memoizedState</code>上</p><p>由于按照这种方式存储state，因此<code>useState</code>(包括其他Hooks)都必须在函数组件的根作用域声明，而不能再条件或循环中声明。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if(something) &#123;<br>    const [state1] <span class="hljs-operator">=</span> useState(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>&#125;<br>// or<br>for(something) &#123;<br>    const [state2] <span class="hljs-operator">=</span> useState(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们无法保证条件语句每次执行的次数是一样的，也就是说如果第一次render创建了<code>state1 =&gt; hook1, state2 =&gt; hook2, state3 =&gt; hook3</code>这样的对应关系，再次render的时候因为<code>something</code>未达成，导致<code>useState(1)</code>没有执行的话，那么执行<code>useState(2)</code>的时候，拿到的hook对象是<code>state1</code>的，那么逻辑就会混乱，因此该条件必须遵守。</p><p>更新state的时候，调用<code>useState</code>的返回方法如下：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">var</span> dispatch = <span class="hljs-built_in">queue</span>.dispatch = dispatchAction.bind(<span class="hljs-built_in">null</span>, currentlyRenderingFiber$<span class="hljs-number">1</span>, <span class="hljs-built_in">queue</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-meta">[</span>workInProgressHook.memoizedState, dispatch<span class="hljs-meta">]</span>;<br></code></pre></td></tr></table></figure><p>调用该方法会创建一个update</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">var</span> <span class="hljs-string">update</span> <span class="hljs-string">=</span> &#123;<br>  <span class="hljs-attr">expirationTime:</span> <span class="hljs-string">_expirationTime</span>,<br>  <span class="hljs-attr">action:</span> <span class="hljs-string">action</span>,<br>  <span class="hljs-attr">callback:</span> <span class="hljs-string">callback</span> <span class="hljs-type">!==</span> <span class="hljs-string">undefined</span> <span class="hljs-string">?</span> <span class="hljs-attr">callback :</span> <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">next:</span> <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的action是调用<code>setState(1)</code>传入的值，而这个update会被加入到queue上，因此可能存在一次性调用多次setState1的情况。</p><p>在收集完这所有<code>update</code>之后，会调度一次<code>React</code>的更新，在更新的过程中，肯定会执行到函数组件，那么就会执行到对应的<code>useState</code>，然后就拿到了<code>Hook</code>对象，它保存了<code>queue</code>对象表示有哪些更新存在，然后依次进行更新，拿到最新的<code>state</code>保存在<code>memoizedState</code>上，并且返回，最终达到了<code>setState</code>的效果。</p><p>参考文档：<a href="https://juejin.cn/post/6844903704437456909">https://juejin.cn/post/6844903704437456909</a></p><h2 id="useMemo和useCallback的区别"><a href="#useMemo和useCallback的区别" class="headerlink" title="useMemo和useCallback的区别"></a>useMemo和useCallback的区别</h2><p>二者都是用于缓存数据，优化性能的，它们接受到的参数是一样的，第一个参数表示回调函数，第二个参数表示依赖的数据。</p><p>共同作用：在依赖数据发生变化的时候，才会调用传进去的回调函数去重新计算结果，起到缓冲的作用。</p><p>区别：</p><ul><li><code>useMemo</code>缓存的结果是回调函数中return回来的值，主要用于缓存计算结果的值，应用场景如需要计算的状态。</li><li><code>useCallback</code>缓存的结果是函数，主要用于缓存函数，应用场景如需要缓存的函数，因为函数式组件每次任何一个state发生变化都会触发整个组件更新，一些函数是没有必要更新的，此时就应该缓存起来，提高性能，减少对资源的浪费。<code>useCallback</code>应该和<code>React.memo</code>配套使用，缺少一个可能会导致性能不升反降。</li></ul><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useState, useMemo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Info</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">const</span> [info, setInfo] = <span class="hljs-title function_">useState</span>(&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;LiHua&quot;</span>,<br>        <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;male&quot;</span><br>    &#125;);<br>    <span class="hljs-comment">// 翻译性别的函数</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">formatGender</span> = (<span class="hljs-params">gender</span>) =&gt; &#123;<br>        <span class="hljs-keyword">return</span> gender === <span class="hljs-string">&quot;male&quot;</span> ? <span class="hljs-string">&quot;男&quot;</span> : <span class="hljs-string">&quot;女&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果不使用useMemo,修改其他属性，也会导致formatGender方法的调用，浪费计算资源</span><br>    <span class="hljs-comment">// const gender = formatGender(info.gender);</span><br>    <span class="hljs-comment">// 仅当info.gender发生变化的时候才调用formatGender</span><br>    <span class="hljs-keyword">const</span> gender = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">formatGender</span>(info.<span class="hljs-property">gender</span>);<br>    &#125;, [info.<span class="hljs-property">gender</span>]);<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        姓名：&#123;info.name&#125; - 性别：&#123;gender&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onClick</span> = <span class="hljs-string">&#123;()</span> =&gt;</span> setInfo(...info, name: &quot;XiaoMing&quot;)&#125;</span><br><span class="language-xml">        &gt;点击修改姓名<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>useCallback是设计初衷是为了<strong>减少子组件的不必要重读渲染</strong>，优化思路主要有以下两种：</p><ul><li>减少render的次数</li><li>减少计算量</li></ul><p>在如下场景中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-comment">// 不使用useCallback和memo的时候</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Comp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [dataA, setDataA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> [dataB, setDataB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickA</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataA</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickB</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataB</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Cheap</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickA&#125;</span>&gt;</span>组件Cheap: &#123;dataA&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Cheap</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Expensive</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickB&#125;</span>&gt;</span>组件Expensive: &#123;dataB&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Expensive</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述组件中，每当点击Cheap组件的时候，Expensive组件也会重新渲染，即使dataB没有发生变化，原因就是onClickB被重新定义，导致React在diff新旧组件的时候判定了组件发生了变化。</p><p>此时，useCallback和memo就发挥作用了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useCallback, useState, memo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Expensive</span>(<span class="hljs-params">&#123;onClick, name&#125;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Expensive渲染&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><span class="hljs-keyword">const</span> memoExpensive = <span class="hljs-title function_">memo</span>(<span class="hljs-title class_">Expensive</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cheap</span>(<span class="hljs-params">&#123;onClick, name&#125;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Cheap渲染&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Comp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [dataA, setDataA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> [dataB, setDataB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickA</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataA</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> onClickB = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">setDataB</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;, [])<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Cheap</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickA&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">组件Cheap:</span> $&#123;<span class="hljs-attr">dataA</span>&#125;`&#125; /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Expensive</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickB&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">组件Expensive:</span> $&#123;<span class="hljs-attr">data</span>&#125;`&#125; /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>memo与PureComponent类似，对传入组件的新旧数据进行浅比较，如果相同则不会触发渲染。</p><p>useCallback保证onClickB不会发生变化，此时点击Cheap组件不会触发Expensive组件的刷新，只有点击Expensive组件才会触发。在实现减少不必要渲染的优化过程中，useCallback和memo是一对利器。</p><h2 id="函数组件模拟componentWillUnmount组件"><a href="#函数组件模拟componentWillUnmount组件" class="headerlink" title="函数组件模拟componentWillUnmount组件"></a>函数组件模拟componentWillUnmount组件</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 执行卸载操作</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="项目：根据用户权限实现路由权限管理"><a href="#项目：根据用户权限实现路由权限管理" class="headerlink" title="项目：根据用户权限实现路由权限管理"></a>项目：根据用户权限实现路由权限管理</h2><p>在编写React路由列表的时候为每一个路由赋一个id值，在用户登录之后将用户的权限列表存储起来，并根据用户权限列表对路由列表进行筛选和展示，根据筛选后的结果部署系统的导航栏。</p><p>当用户想要通过直接输入url的方式访问某个页面的时候，在Route组件的render函数中根据url匹配到路由对应的id值，然后判断用户权限列表中是否存在该id值，如果存在则允许访问，否则警告用户没有权限并返回首页。</p><p>……</p><h2 id="为什么使用Redux进行状态管理"><a href="#为什么使用Redux进行状态管理" class="headerlink" title="为什么使用Redux进行状态管理"></a>为什么使用Redux进行状态管理</h2><ul><li><strong>Redux使状态可预测。</strong>传递相同的状态和动作传递给减速器，总会产生相同的结果，因为减速器是纯函数。</li><li><strong>Redux方便维护。</strong>Redux对代码的组织方式很严格，结构更容易理解，维护更加方便。同时有利于用户将业务逻辑与组件树分离。</li><li><strong>Redux调试简单。</strong>Redux使调试程序变得简单，通过记录操作和状态，很容易理解编码错误、网络错误和生产过程中出现的其他形式的错误。</li><li><strong>Redux有性能优势。</strong>Redux内部实现了很多优化，因此我们自己的连接组件仅在实际需要时才重新渲染。</li><li><strong>数据持久化。</strong></li><li><strong>Redux还能用于服务端渲染。</strong>我们可以通过将应用程序的状态连同它对服务器请求的响应发送到服务器来处理应用程序的初始呈现，然后所需组件以HTML格式呈现并发送到客户端。</li></ul><h2 id="哪些数据需要使用Redux进行存储？"><a href="#哪些数据需要使用Redux进行存储？" class="headerlink" title="哪些数据需要使用Redux进行存储？"></a>哪些数据需要使用Redux进行存储？</h2><p>全局公共数据用Redux进行管理，局部状态用state和props即可。</p><h2 id="浏览器的垃圾回收机制"><a href="#浏览器的垃圾回收机制" class="headerlink" title="浏览器的垃圾回收机制"></a>浏览器的垃圾回收机制</h2><p>JS代码运行时，需要分配内存空间来存储变量和值。当变量不再参与运行时，就需要回收被占用的空间，这就是垃圾回收。</p><p><strong>垃圾回收的方式</strong></p><ul><li><p><strong>标记清除</strong></p><p>当变量进入执行环境时，标记该变量”进入幻境”，此时变量不能回收。当变量离开环境的时候，就会被标记为”离开环境”，会被内存释放</p></li><li><p><strong>引用计数</strong></p><p>跟踪每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量的时候，这个值的引用次数就是1。当包含对该值引用的变量指向另一个值的时候，引用次数减1。当引用次数变为0的时候，说明该值已经没有利用价值，这个变量占用的内存空间就会被释放出来。</p><p>弊端：可能会引起<strong>循环引用</strong>的问题，例如：obj1和obj2通过属性互相进行引用，那么二者的引用次数永远不会归零，函数执行完结束后，两个变量仍然会继续存在，引用次数永远不为0，会引起循环引用。</p></li></ul><p><strong>减少垃圾回收的方式</strong></p><ul><li>对数组进行优化：清空一个数组的时候将其长度设为0</li><li>对对象进行优化：不再使用的时候将其设置为null</li><li>对函数进行优化：在循环中的函数表达式，如果可以复用则尽量放在外面</li></ul><h2 id="实现JS的深拷贝"><a href="#实现JS的深拷贝" class="headerlink" title="实现JS的深拷贝"></a>实现JS的深拷贝</h2><ul><li><p>使用JSON.stringify和JSON.parse实现</p></li><li><p>for…in + Object.assign</p></li><li><p>for…in + 拓展运算符</p></li><li><p><strong>Object.create</strong></p></li><li><p><strong>jQuery.extend(deep, target, obj1, …)</strong></p></li><li><p>函数库lodash</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;lodash&quot;</span>;<br><span class="hljs-keyword">const</span> obj = &#123;a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span>&#125;;<br><span class="hljs-keyword">const</span> deep = _.cloneDeep(obj);<br></code></pre></td></tr></table></figure></li></ul><h2 id="JS作用域是在什么时候创建的"><a href="#JS作用域是在什么时候创建的" class="headerlink" title="JS作用域是在什么时候创建的"></a>JS作用域是在什么时候创建的</h2><p>全局作用域在window对象创建的时候产生。</p><p>局部作用域在函数执行时产生，函数执行完毕后，如果子作用域不需要使用它声明的变量就销毁，如果使用就形成闭包保存下来。</p><h2 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h2><p>有权访问另一个函数作用域内变量的函数</p><h2 id="宏任务和微任务的区别"><a href="#宏任务和微任务的区别" class="headerlink" title="宏任务和微任务的区别"></a>宏任务和微任务的区别</h2><p>宏任务一般是：整体代码script、setTimeout、setInterval、I&#x2F;O、UI render</p><p>微任务主要是：Promise、Object.observe、MutationObserver</p><p>二者都是异步。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端|面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
