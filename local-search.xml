<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>总结(3.1)</title>
    <link href="/2023/04/08/%E6%80%BB%E7%BB%93-3-1/"/>
    <url>/2023/04/08/%E6%80%BB%E7%BB%93-3-1/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS常见的行内元素和块级元素？它们有什么区别？"><a href="#CSS常见的行内元素和块级元素？它们有什么区别？" class="headerlink" title="CSS常见的行内元素和块级元素？它们有什么区别？"></a>CSS常见的行内元素和块级元素？它们有什么区别？</h2><p><strong>行内元素：</strong>行内元素与其他行内元素并排，不能设置宽高，宽度默认为文字的宽度。</p><p><strong>块级元素：</strong>块级元素霸占一行，不能与其他任何元素并列，能接受宽高，如果不设置宽度，那么宽度将默认变为父级的100%。</p><p>常见的行内元素有：button、input、label、select、textarea、a、img、span、script等。</p><p>常见的块级元素有：div、section、p、table、form、header、footer、h1~h6、aside、canvas、ol、ul等。</p><p>CSS中，块级元素和行内元素的区别在于：</p><ul><li>块级元素独占一行，不能与其他任何元素并列；行内元素可以与其他行内元素并排。</li><li>块级元素可以设置宽高，而行内元素不能设置宽高，宽度由内容撑开。</li></ul><h2 id="什么是回流和重绘？"><a href="#什么是回流和重绘？" class="headerlink" title="什么是回流和重绘？"></a>什么是回流和重绘？</h2><p>回流：当DOM节点中的部分或全部元素的尺寸、结构、布局等发生变化的时候，浏览器就会重新渲染部分或全部文档，这个过程称为回流。</p><p>重绘：页面中元素的样式发生变化，但是不影响其在文档流中的位置，浏览器就会对该元素进行重绘。</p><p>发生回流一定会引起重绘，但是重绘不一定会引起回流。</p><h2 id="在什么情况下会触发回流？"><a href="#在什么情况下会触发回流？" class="headerlink" title="在什么情况下会触发回流？"></a>在什么情况下会触发回流？</h2><ul><li>添加或删除可见的DOM元素</li><li>元素位置、尺寸(包括外边距、内边距、边框大小、高度和宽度等)发生变化</li><li>内容发生变化(例如文本变化或图片被另一个不同尺寸的图片取代)</li><li>页面一开始渲染</li><li>浏览器窗口尺寸变化(因为回流是根据视口的大小来计算元素的位置和大小的)</li></ul><h2 id="获取元素的offsetHeight等会触发回流吗？"><a href="#获取元素的offsetHeight等会触发回流吗？" class="headerlink" title="获取元素的offsetHeight等会触发回流吗？"></a>获取元素的offsetHeight等会触发回流吗？</h2><p>会。</p><p><code>offsetHeight</code> 是一个元素的实时高度，必须重排重绘以后才能得到，如果不提前进行重排重绘，<code>offsetHeight</code> 有可能拿到的是浏览器缓存队列没执行完的时候的值。</p><h2 id="什么是flex布局？"><a href="#什么是flex布局？" class="headerlink" title="什么是flex布局？"></a>什么是flex布局？</h2><p>flex为”弹性布局”，可以简便、完整、响应式的实现各种页面布局。它的所有子元素自动成为容器成员，称为flex项目的item。</p><p>容器中默认存在两条轴，主轴和交叉轴，呈90°的关系。项目默认沿主轴排列，通过<code>flelx-direction</code>来决定主轴方向。</p><h2 id="flex-1具体指的是什么？"><a href="#flex-1具体指的是什么？" class="headerlink" title="flex: 1具体指的是什么？"></a>flex: 1具体指的是什么？</h2><ul><li><code>flex-grow: 1</code> (默认为0) ：表示元素的放大比例</li><li><code>flex-shrink: 1</code> (默认为1) ：表示元素的缩小比例</li><li><code>flex-basis: 0%</code> (默认为auto) ：元素本身的大小，这个属性定义了在分配多余空间之前，元素占据的主轴空间。浏览器根据这个属性计算是否有多余空间。</li></ul><h2 id="如何进行移动端适配？"><a href="#如何进行移动端适配？" class="headerlink" title="如何进行移动端适配？"></a>如何进行移动端适配？</h2><ul><li>rem布局</li><li>vw&#x2F;vh布局</li><li>百分比布局</li><li>响应式布局</li></ul><h2 id="em和rem的区别？"><a href="#em和rem的区别？" class="headerlink" title="em和rem的区别？"></a>em和rem的区别？</h2><p>em和rem都是相对单位长度</p><p>em是相对于父元素的字体大小来计算元素的大小</p><p>rem是相对于根元素的字体大小来计算元素的大小</p><h2 id="什么是vw和vh"><a href="#什么是vw和vh" class="headerlink" title="什么是vw和vh?"></a>什么是vw和vh?</h2><p>vw和vh是CSS3引入的视口单位，是相对于视口的宽度和高度来计算元素的大小。</p><p>1vw等于视口宽度的1%，1vh等于视口高度的1%。除了vw和vh，还有vmin和vmax两个单位，vmin是vw和vh中较小的那个，vmax是vw和vh中较大的那个。</p><h2 id="什么是JS的事件机制？"><a href="#什么是JS的事件机制？" class="headerlink" title="什么是JS的事件机制？"></a>什么是JS的事件机制？</h2><p>JavaScript 事件机制描述的是事件在 DOM 里面的传递顺序，以及我们可以对这些事件做出如何的响应。</p><p>DOM事件流（event flow ）存在三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。</p><p>事件捕获（event capturing）： 通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始<strong>由外到内</strong>进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。</p><p>事件冒泡（dubbed bubbling）： 与事件捕获恰恰相反，事件冒泡顺序是<strong>由内到外</strong>进行事件传播，直到根节点。无论是事件捕获还是事件冒泡，它们都有一个共同的行为，就是事件传播，它就像一跟引线，只有通过引线才能将绑在引线上的鞭炮（事件监听器）引爆。</p><p>DOM标准事件流的触发的先后顺序为 ：<strong>先捕获再冒泡，即当触发dom事件时，会先进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡</strong>。</p><h2 id="代码输出"><a href="#代码输出" class="headerlink" title="代码输出"></a>代码输出</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">fun2</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br><br><span class="hljs-title function_">fun1</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);<br>&#125;, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>);<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">7</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="Promise常用的API？"><a href="#Promise常用的API？" class="headerlink" title="Promise常用的API？"></a>Promise常用的API？</h2><p>Promise.then、Promise.catch、Promise.finally、Promise.all、Promise.race</p><h2 id="Promise-all和Promise-race的区别？"><a href="#Promise-all和Promise-race的区别？" class="headerlink" title="Promise.all和Promise.race的区别？"></a>Promise.all和Promise.race的区别？</h2><p>Promise.all()和Promise.race()都是Promise的静态方法，用于处理多个Promise对象。它们的区别在于：</p><ul><li>Promise.all()会在多个promise全部resolve之后执行.then，而Promise.race()会在任何一个promise resolve后就会执行.then。</li><li>Promise.all()会等待所有的promise对象都resolve或有一个reject后才会执行.then，而Promise.race()只要有一个promise对象resolve或reject就会执行.then。</li><li>Promise.all()会返回所有Promise resolved后的结果数组或第一个rejected的Promise对象的报错信息。</li></ul><h2 id="Promise的错误在哪里进行捕捉"><a href="#Promise的错误在哪里进行捕捉" class="headerlink" title="Promise的错误在哪里进行捕捉?"></a>Promise的错误在哪里进行捕捉?</h2><p>Promise发生的错误可以在try…catch中捕获，也可以在.catch()中捕获。如果在try…catch中捕获，需要在Promise对象前加await关键字，否则无法捕获异步错误。如果在.catch()中捕获，需要在Promise对象后加.catch()方法。</p><h2 id="假设一个function中有多个Promise任务，然后有某个Promise发生了异常，如何准确判断是哪个Promise发生了异常？"><a href="#假设一个function中有多个Promise任务，然后有某个Promise发生了异常，如何准确判断是哪个Promise发生了异常？" class="headerlink" title="假设一个function中有多个Promise任务，然后有某个Promise发生了异常，如何准确判断是哪个Promise发生了异常？"></a>假设一个function中有多个Promise任务，然后有某个Promise发生了异常，如何准确判断是哪个Promise发生了异常？</h2><p>在reject()中进行处理</p><h2 id="bind、call和apply的区别？"><a href="#bind、call和apply的区别？" class="headerlink" title="bind、call和apply的区别？"></a>bind、call和apply的区别？</h2><ul><li><code>apply</code>接受两个参数，第一个参数是<code>this</code>的指向，第二个参数是函数接受的参数，以数组的形式传入，改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次。</li><li><code>call</code>方法的第一个参数也是<code>this</code>的指向，后面传入的是一个参数列表，跟<code>apply</code>一样，改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次。</li><li>bind方法和call很相似，第一参数也是<code>this</code>的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)，改变<code>this</code>指向后不会立即执行，而是返回一个永久改变<code>this</code>指向的函数。</li></ul><h2 id="箭头函数和普通函数的区别？"><a href="#箭头函数和普通函数的区别？" class="headerlink" title="箭头函数和普通函数的区别？"></a>箭头函数和普通函数的区别？</h2><ul><li>箭头函数不绑定this，会捕获其所在上下文的this作为自己的this。</li><li>箭头函数没有arguments对象，只能通过rest参数获取参数。</li><li>箭头函数不能使用yield命令，不能用作Generator函数。</li><li>箭头函数是匿名函数，不能用作构造函数，不可以使用new命令。</li></ul><h2 id="React函数组件和类组件的区别？"><a href="#React函数组件和类组件的区别？" class="headerlink" title="React函数组件和类组件的区别？"></a>React函数组件和类组件的区别？</h2><ul><li>类组件有生命周期，函数组件无生命周期</li><li>类组件调用setStatet管理state状态，函数组件使用useState</li><li>函数组件调用即是执行函数，类组件需要先将组件实例化，再调用实例对象的render方法</li><li>函数组件更加简洁易懂，容易被开发、理解和测试。</li></ul><h2 id="函数式组件用哪个hook模拟声明周期"><a href="#函数式组件用哪个hook模拟声明周期" class="headerlink" title="函数式组件用哪个hook模拟声明周期"></a>函数式组件用哪个hook模拟声明周期</h2><p>useEffect</p><h2 id="React-state更新机制"><a href="#React-state更新机制" class="headerlink" title="React state更新机制"></a>React state更新机制</h2><p>React中类组件的state是通过setState()方法来更新的。当执行setState()时，会将需要更新的state合并后放入状态队列，不会立即更新。React也正是通过状态队列实现了setState的异步更新，避免频繁的重复更新state。当React需要更新组件时，会将状态队列中的state合并后一次性更新组件，这样可以提高性能。</p><p>React函数组件中的state是通过useState()方法来更新的。useState()方法返回一个数组，第一个元素是当前state的值，第二个元素是更新state的函数。当执行更新state的函数时，会将需要更新的state合并后放入状态队列，不会立即更新。React也正是通过状态队列实现了useState的异步更新，避免频繁的重复更新state。当React需要更新组件时，会将状态队列中的state合并后一次性更新组件，这样可以提高性能。</p><p>在React18优化了批处理之后，state的更新都表现为异步的。</p><h2 id="React虚拟DOM的Diff算法？"><a href="#React虚拟DOM的Diff算法？" class="headerlink" title="React虚拟DOM的Diff算法？"></a>React虚拟DOM的Diff算法？</h2><p>React中的虚拟DOM和diff算法是为了提高渲染效率而设计的。虚拟DOM是一种编程概念，UI以一种理想化的、或者说“虚拟的”表现形式存在于内存中，而不是真实的DOM树。当状态发生变化时，React会通过diff算法比较新旧虚拟DOM树的差异，然后只更新需要更新的部分，从而避免了全量渲染，提高了渲染效率。</p><p>React中的diff算法是通过比较新旧虚拟DOM树的差异来确定需要更新的节点。diff算法会遍历新旧虚拟DOM树，对比它们的节点，然后根据节点的变化情况来更新真实DOM。React中的diff算法是基于两个假设：同一层级的两个节点可以通过唯一的id进行区分；同一层级的节点可以通过位置进行区分。React中的diff算法是一个递归算法，它会递归遍历新旧虚拟DOM树，对比它们的节点，然后根据节点的变化情况来更新真实DOM。如果两个节点不同，则会直接替换掉旧节点，如果两个节点相同，则会更新该节点。</p><p><strong>查找需要更新的节点是从尾节点找还是头节点找还是中间二分择半？</strong></p><p>React的Diff算法进行虚拟节点比较是从头部开始，然后依次向后比较，直到找到不同的节点位置。如果新旧虚拟节点的数量不同，则从尾部开始比较，直到找到不同的节点为止。</p><h2 id="useMemo和useCallback的区别？"><a href="#useMemo和useCallback的区别？" class="headerlink" title="useMemo和useCallback的区别？"></a>useMemo和useCallback的区别？</h2><p>二者都是用于缓存数据，优化性能的，它们接受到的参数是一样的，第一个参数表示回调函数，第二个参数表示依赖的数据。</p><p>共同作用：在依赖数据发生变化的时候，才会调用传进去的回调函数去重新计算结果，起到缓冲的作用。</p><p>区别：</p><ul><li><code>useMemo</code>缓存的结果是回调函数中return回来的值，主要用于缓存计算结果的值，应用场景如需要计算的状态。</li><li><code>useCallback</code>缓存的结果是函数，主要用于缓存函数，应用场景如需要缓存的函数，因为函数式组件每次任何一个state发生变化都会触发整个组件更新，一些函数是没有必要更新的，此时就应该缓存起来，提高性能，减少对资源的浪费。<code>useCallback</code>应该和<code>React.memo</code>配套使用，缺少一个可能会导致性能不升反降。</li></ul><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useState, useMemo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Info</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">const</span> [info, setInfo] = <span class="hljs-title function_">useState</span>(&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;LiHua&quot;</span>,<br>        <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;male&quot;</span><br>    &#125;);<br>    <span class="hljs-comment">// 翻译性别的函数</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">formatGender</span> = (<span class="hljs-params">gender</span>) =&gt; &#123;<br>        <span class="hljs-keyword">return</span> gender === <span class="hljs-string">&quot;male&quot;</span> ? <span class="hljs-string">&quot;男&quot;</span> : <span class="hljs-string">&quot;女&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果不使用useMemo,修改其他属性，也会导致formatGender方法的调用，浪费计算资源</span><br>    <span class="hljs-comment">// const gender = formatGender(info.gender);</span><br>    <span class="hljs-comment">// 仅当info.gender发生变化的时候才调用formatGender</span><br>    <span class="hljs-keyword">const</span> gender = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">formatGender</span>(info.<span class="hljs-property">gender</span>);<br>    &#125;, [info.<span class="hljs-property">gender</span>]);<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        姓名：&#123;info.name&#125; - 性别：&#123;gender&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onClick</span> = <span class="hljs-string">&#123;()</span> =&gt;</span> setInfo(...info, name: &quot;XiaoMing&quot;)&#125;</span><br><span class="language-xml">        &gt;点击修改姓名<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>useCallback是设计初衷是为了<strong>减少子组件的不必要重读渲染</strong>，优化思路主要有以下两种：</p><ul><li>减少render的次数</li><li>减少计算量</li></ul><p>在如下场景中</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-comment">// 不使用useCallback和memo的时候</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Comp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [dataA, setDataA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> [dataB, setDataB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickA</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataA</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickB</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataB</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Cheap</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickA&#125;</span>&gt;</span>组件Cheap: &#123;dataA&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Cheap</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Expensive</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickB&#125;</span>&gt;</span>组件Expensive: &#123;dataB&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Expensive</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述组件中，每当点击Cheap组件的时候，Expensive组件也会重新渲染，即使dataB没有发生变化，原因就是onClickB被重新定义，导致React在diff新旧组件的时候判定了组件发生了变化。</p><p>此时，useCallback和memo就发挥作用了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useCallback, useState, memo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Expensive</span>(<span class="hljs-params">&#123;onClick, name&#125;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Expensive渲染&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><span class="hljs-keyword">const</span> memoExpensive = <span class="hljs-title function_">memo</span>(<span class="hljs-title class_">Expensive</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cheap</span>(<span class="hljs-params">&#123;onClick, name&#125;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Cheap渲染&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Comp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [dataA, setDataA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> [dataB, setDataB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickA</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataA</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> onClickB = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">setDataB</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;, [])<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Cheap</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickA&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">组件Cheap:</span> $&#123;<span class="hljs-attr">dataA</span>&#125;`&#125; /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Expensive</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickB&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">组件Expensive:</span> $&#123;<span class="hljs-attr">data</span>&#125;`&#125; /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>memo与PureComponent类似，对传入组件的新旧数据进行浅比较，如果相同则不会触发渲染。</p><p>useCallback保证onClickB不会发生变化，此时点击Cheap组件不会触发Expensive组件的刷新，只有点击Expensive组件才会触发。在实现减少不必要渲染的优化过程中，useCallback和memo是一对利器。</p><h2 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h2><p>要求：使用React的hook实现一个useRequest</p><ul><li>展示loading效果后告诉用户后台正在处理请求</li><li>接口异常时要进行错误处理</li><li>缓存同一请求(非结果)</li></ul><h2 id="Redux使用流程及场景？"><a href="#Redux使用流程及场景？" class="headerlink" title="Redux使用流程及场景？"></a>Redux使用流程及场景？</h2><ol><li>安装Redux。</li><li>创建一个store，store是一个对象，它有四个方法：dispatch、subscribe、getState和replaceReducer。</li><li>定义action，action是一个普通的JavaScript对象，用来描述发生了什么。</li><li>定义reducer，reducer是一个纯函数，接收旧的state和action，返回新的state。</li><li>使用combineReducers将多个reducer合并成一个根reducer。</li><li>使用Provider组件将store传递给子组件。</li><li>在组件中使用connect函数连接store和组件。</li></ol><h2 id="有没有了解Mobx"><a href="#有没有了解Mobx" class="headerlink" title="有没有了解Mobx?"></a>有没有了解Mobx?</h2><h2 id="Webpack如何进行配置？"><a href="#Webpack如何进行配置？" class="headerlink" title="Webpack如何进行配置？"></a>Webpack如何进行配置？</h2><p>主要配置过相关loader</p><h2 id="Webpack中loader和plugin的区别？"><a href="#Webpack中loader和plugin的区别？" class="headerlink" title="Webpack中loader和plugin的区别？"></a>Webpack中loader和plugin的区别？</h2><ul><li>loader是一种打包方案，对于某一种类型文件它知道如何打包，帮助Webpack完成打包工作。loader就是一个单纯的文件转化过程。</li><li>plugin是一个扩展器，丰富Webpack本身，增强功能，针对的是在loader结束之后，Webpack打包的整个过程。plugin并不直接操作文件，而是基于事件机制工作，会监听Webpack打包过程中的某些事件钩子，执行任务。</li></ul><h2 id="浏览器缓存机制？"><a href="#浏览器缓存机制？" class="headerlink" title="浏览器缓存机制？"></a>浏览器缓存机制？</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>Cache-Control &#x2F; Expires</p><p> expires <code>http1.0</code>控制网页缓存的字段，其值为服务器返回该请求结果的到期时间，即再次发送请求，如果客户端的时间小于expires的值时，直接使用缓存结果</p><p> cache-control(优先级更大) http1.1中控制网页缓存，是最重要的规则</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>Etag If-None-Match &#x2F; Last-Midified If-Midified-Since</p><p> <code>Last-Modified / If-Modified-Since</code> 和 <code>Etag / If-None-Match</code> (后者优先级更高)</p><p> Last-Modified 服务器响应请求时，返回该文件资源在服务器内最后被修改的时间</p><p> If-Modified-Since 客户端再次发起请求时，携带上次请求返回的Last-Modified值，通过此字段告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据此字段值与该资源在服务器的最后被修改的时间做对比，若服务器的资源最后被修改的时间大于If-Modified-Since字段值，则重新返回资源，状态码为200；否则返回304，代表资源无更新，可继续使用缓存文件</p><p> Etag 是服务区响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)</p><p> If-None-Match 服务器再次发起请求时，携带上次请求返回的唯一标识Etag，通过此字段告诉服务器该资源上次请求返回的唯一标识，服务器收到该请求后，发现请求头中含有If-None-Match的字段与该资源在服务器的Etag值进行比对，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码200</p><h2 id="前端常见的优化手段？"><a href="#前端常见的优化手段？" class="headerlink" title="前端常见的优化手段？"></a>前端常见的优化手段？</h2><p>常见的前端性能优化手段包括：减少请求数量、减小资源大小、优化网络连接、优化资源加载、减少重绘回流、使用性能更好的API和构建优化等。</p><p>其中，减少请求数量可以通过合并CSS和JS文件、使用CSS Sprites技术、使用字体图标等方式来实现；减小资源大小可以通过压缩CSS、JS和图片等方式来实现；优化网络连接可以通过使用CDN、开启Gzip压缩等方式来实现；优化资源加载可以通过使用预加载、懒加载等方式来实现；减少重绘回流可以通过避免频繁操作DOM、使用CSS3动画等方式来实现；使用性能更好的API可以通过使用requestAnimationFrame代替setTimeout、使用Web Workers等方式来实现；构建优化可以通过使用Webpack等打包工具进行代码分割、按需加载等方式来实现。</p><p>七大优化手段：<a href="https://juejin.cn/post/7016868803069886471">https://juejin.cn/post/7016868803069886471</a></p><h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>闭包是指一个函数能够访问其他函数内部变量的函数。在JavaScript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数”。</p><p>闭包的优点是可以保护变量不被污染，同时也可以实现数据私有化。缺点是会占用更多的内存空间，同时也会增加代码的复杂度。</p><h2 id="React过期闭包了解过吗？"><a href="#React过期闭包了解过吗？" class="headerlink" title="React过期闭包了解过吗？"></a>React过期闭包了解过吗？</h2><p>React过期闭包是指在使用React Hook时，由于函数组件多次render之间，函数的闭包可能会包住过期的上下文，也就是之前render时的上下文。这个问题在应用Hooks更突出。</p><p>React解决过期闭包问题的方法是依赖数组。针对过期state，可以使用函数的方法更新值。React确保通过更新函数可以得到最新的state值。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结(2.1)</title>
    <link href="/2023/04/08/%E6%80%BB%E7%BB%93-2-1/"/>
    <url>/2023/04/08/%E6%80%BB%E7%BB%93-2-1/</url>
    
    <content type="html"><![CDATA[<h2 id="进程和线程的概念及区别"><a href="#进程和线程的概念及区别" class="headerlink" title="进程和线程的概念及区别"></a>进程和线程的概念及区别</h2><p>进程是对正在运行中的程序的一个抽象，是系统进行资源分配和调度的基本单位。</p><p>线程是CPU任务调度和执行的基本单位。</p><p>区别：</p><ul><li>进程可以看作是一个独立应用，而线程不能。</li><li>进行是CPU进行资源分配的最小单位，而线程是CPU调度的最小单位。</li><li>线程间可以直接共享同一进程中的资源，而进程通信需要借助<strong>进程间通信</strong>。</li><li>进行切换的开销比线程切换的开销要大。线程的切换不会引起进程的切换，但某个进程中的线程切换到另一个进程中的线程会引起进程的切换。</li><li>撤销或创建进程的时候，系统要为之分配或回收资源，开销远大于创建或撤销线程时的开销。同样，进程切换的时候涉及到<strong>当前进程的CPU环境还有各种各样状态的保存及新调度进程状态的设置</strong>，而线程切换只需要保存和设置少量的寄存器内容，开销较小。</li></ul><h2 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h2><ul><li><p>管道通信</p><p>操作系统在内核中开辟一段缓冲区，进程A可以将需要交互的数据拷贝到这段缓冲区中，进程B就可以读取了。(只能单向通信，并只能在有血缘关系的进程间通信)</p></li><li><p>消息队列队列通信</p><p>消息队列就是一个消息的列表，用户可以在消息队列中添加消息、读取消息等。它提供了一种从一个进程向另一个进程发送数据块的方法。每个数据块都被认为含有一个类型，接收进程可以独立的接受含有不同类型的数据结构。但消息队列与命名管道一样，每个数据块都有一个<strong>最大长度的限制</strong>。</p></li><li><p>共享内存通信</p><p>共享内存就是映射了一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问(使多个进程可以访问同一块内存空间)。</p></li><li><p>信号量通信</p><p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。</p></li><li><p>信号通信</p><p>Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件(一组事件中的一个)，它也是用户进程间通信和同步的一种原始机制。</p></li><li><p>套接字通信</p><p>是计算机之间进行通信的一种约定或一种方式。</p></li></ul><h2 id="进程的状态有哪些？"><a href="#进程的状态有哪些？" class="headerlink" title="进程的状态有哪些？"></a>进程的状态有哪些？</h2><p>进程的状态通常分为五种基本状态：创建态、就绪态、运行态、阻塞态和终止态。</p><ul><li>创建态：进程刚被创建，但是还没有被操作系统调度执行。</li><li>就绪态：进程已经准备好运行，但是还没有被操作系统调度执行。</li><li>运行态：进程正在被操作系统调度执行。</li><li>阻塞态：进程因为某些原因而暂停执行，等待外部事件的发生。</li><li>终止态：进程已经完成了它的任务，或者因为某些原因被操作系统强制终止。</li></ul><h2 id="操作系统进程调度有哪几种？"><a href="#操作系统进程调度有哪几种？" class="headerlink" title="操作系统进程调度有哪几种？"></a>操作系统进程调度有哪几种？</h2><p>操作系统的进程调度的常见策略：</p><ul><li>先来先服务调度算法(FCFS)：按照进程到达的先后顺序进行调度，先到达的进程限制性，后到达的进程后执行。</li><li>短作业优先调度算法(SJF)：按照进程需要的CPU时间长短进行调度，即需要CPU时间最短的进程先执行。</li><li>优先级调度算法：按照进程的优先级进行调度，即优先级高的进程先执行。</li><li>时间片轮转调度算法：按照时间片轮流分配CPU时间进行调度，即每个进程分配一个时间片，当时间片用完后，该进程被挂起，等到下一次轮到它的时候再继续执行。</li><li>多级反馈队列算法：将就绪队列分成多个队列，每个队列有不同的优先级，每个队列采用不同的调度算法。新到达的进程首先放在第一级队列，如果该队列中没有可执行的进程，则将该队列放入第二级队列中等待执行。如果第一级队列中有可执行的进程，则按照时间片轮转调度算法去进行调度。如果一个进程再第一级队列中运行了一段时间仍然没有完成，则将其移动到第二级队列中等待执行，以此类推，直到该进程完成或被强制终止。</li></ul><h2 id="操作系统的堆区和栈区"><a href="#操作系统的堆区和栈区" class="headerlink" title="操作系统的堆区和栈区"></a>操作系统的堆区和栈区</h2><p>操作系统中的堆和栈都是指内存空间，不同的是堆为按需申请、动态分配，例如 C 中的 malloc 函数和 C++ 中的 new 操作。而栈是由编译器自动分配释放，存放函数的参数值，局部变量的值等。<br>堆和栈之间的区别主要有以下几点：</p><ul><li><p>分配方式：堆是动态分配的，而栈是静态分配的。</p></li><li><p>空间大小：堆的空间大小不确定，而栈的空间大小固定。</p></li><li><p>空间分配方式：堆是由程序员手动申请和释放，而栈是由编译器自动分配和释放。</p></li><li><p>空间使用方式：堆的空间可以随时申请和释放，而栈的空间只能在函数调用时申请，在函数返回时释放。</p></li></ul><h2 id="常见的数据结构有哪些？"><a href="#常见的数据结构有哪些？" class="headerlink" title="常见的数据结构有哪些？"></a>常见的数据结构有哪些？</h2><ul><li>数组 (Array)</li><li>队列 (Queue)</li><li>链表 (Linked List)</li><li>栈 (Stack)</li><li>树 (Tree)</li><li>散列表(Hash)</li><li>堆(Heap)</li><li>图 (Graph)</li></ul><h2 id="在JS中如何实现图结构？"><a href="#在JS中如何实现图结构？" class="headerlink" title="在JS中如何实现图结构？"></a>在JS中如何实现图结构？</h2><p>在JavaScript中，可以使用邻接表或邻接矩阵来实现图结构。其中，邻接表是一种链式存储方式，它将每个顶点的所有邻居顶点都存储在一个链表中。而邻接矩阵则是一个二维数组，其中每个元素表示两个顶点之间是否有边。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span> = []；<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()；<br>  &#125;<br><br>  <span class="hljs-title function_">addVertex</span>(<span class="hljs-params">v</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-title function_">push</span>(v)；<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">set</span>(v, [])；<br>  &#125;<br><br>  <span class="hljs-title function_">addEdge</span>(<span class="hljs-params">v, w</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(v).<span class="hljs-title function_">push</span>(w)；<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(w).<span class="hljs-title function_">push</span>(v)；<br>  &#125;<br><br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;&#x27;</span>；<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>； i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-property">length</span>； i++) &#123;<br>      s += <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.vertices[i]&#125;</span> -&gt; `</span>；<br>      <span class="hljs-keyword">const</span> neighbors = <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>[i])；<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>； j &lt; neighbors.<span class="hljs-property">length</span>； j++) &#123;<br>        s += <span class="hljs-string">`<span class="hljs-subst">$&#123;neighbors[j]&#125;</span> `</span>；<br>      &#125;<br>      s += <span class="hljs-string">&#x27;\n&#x27;</span>；<br>    &#125;<br>    <span class="hljs-keyword">return</span> s；<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Graph</span>()；<br><span class="hljs-keyword">const</span> vertices = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>]；<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>； i &lt; vertices.<span class="hljs-property">length</span>； i++) &#123;<br>  graph.<span class="hljs-title function_">addVertex</span>(vertices[i])；<br>&#125;<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;H&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>)；<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(graph.<span class="hljs-title function_">toString</span>())；<br></code></pre></td></tr></table></figure><h2 id="JS-DOM树用什么数据结构进行存储？"><a href="#JS-DOM树用什么数据结构进行存储？" class="headerlink" title="JS DOM树用什么数据结构进行存储？"></a>JS DOM树用什么数据结构进行存储？</h2><p>JavaScript的DOM树是以多叉树的形式存储的。DOM模型用一个逻辑树来表示一个文档，树的每个分支的终点都是一个节点(node)，每人节点都包含着对象(Obiects)。</p><h2 id="什么是哈希冲突？"><a href="#什么是哈希冲突？" class="headerlink" title="什么是哈希冲突？"></a>什么是哈希冲突？</h2><p>哈希冲突是指，当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象。在哈希表中，每个关键字都对应一个位置，但是不同的关键字可能会对应到相同的位置，这就是哈希冲突。哈希冲突的解决方法有很多种，其中比较常见的有链地址法和开放地址法。链地址法是将相同hash值的对象组织成一个链表放在hash值对应的槽位；开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。</p><h2 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h2><p>数组和链表是两种常见的数据结构。数组是一种线性数据结构，它在内存中占用一段连续的空间，每个元素都可以通过下标来访问。而链表则是一种非线性数据结构，它的元素在内存中不一定是连续的，每个元素都包含了指向下一个元素的指针。</p><p>因此，数组和链表有以下区别：</p><ul><li>数组在内存中占用一段连续的空间，而链表的元素在内存中不一定是连续的。</li><li>数组的元素可以通过下标来访问，而链表的元素只能通过指针来访问。</li><li>数组的大小是固定的，而链表的大小可以动态改变。</li><li>数组的插入和删除操作需要移动其他元素，时间复杂度为O(n)，而链表只需要改变指针指向，时间复杂度为0(1)。</li></ul><h2 id="数组和链表在内存分配上的区别？"><a href="#数组和链表在内存分配上的区别？" class="headerlink" title="数组和链表在内存分配上的区别？"></a>数组和链表在内存分配上的区别？</h2><p>数组和链表在内存分配上的区别是：</p><p>数组静态分配内存，链表动态分配内存；数组在内存中连续，链表不连续；数组元素在栈区，链表元素在堆区。此外，数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)； 数组插入或删除元素的时间复杂度0(n)，链表的时间复杂度0(1)。</p><h2 id="在使用JS进行开发的时候，什么情况下用数组存储数据-什么情况下用链表存储数据"><a href="#在使用JS进行开发的时候，什么情况下用数组存储数据-什么情况下用链表存储数据" class="headerlink" title="在使用JS进行开发的时候，什么情况下用数组存储数据? 什么情况下用链表存储数据?"></a>在使用JS进行开发的时候，什么情况下用数组存储数据? 什么情况下用链表存储数据?</h2><p>在使用JS进行开发时</p><p>使用数组存储数据的情况包括：需要快速访问元素，需要按照顺序存储元素，需要对元素进行排序或者操作，需要在数组中存储不同类型的数据等。</p><p>使用链表存储据的情况包括：需要动态添加或删除元素，不需要按照顺序存储元素，不需要快速访问元素等。</p><h2 id="JS中二叉树通过什么数据结构进行实现？"><a href="#JS中二叉树通过什么数据结构进行实现？" class="headerlink" title="JS中二叉树通过什么数据结构进行实现？"></a>JS中二叉树通过什么数据结构进行实现？</h2><p>在实现二叉树时，采用的存储结构为链式存储结构，链式结构的意思是采用一个链表来存储一颗二叉树，二叉树中每一个节点用链表的一个节点来存储，在二叉树中，节点结构至少有三个域：数据域data，左指针域left，右指针域right。</p><h2 id="栈和队列的特点及区别"><a href="#栈和队列的特点及区别" class="headerlink" title="栈和队列的特点及区别?"></a>栈和队列的特点及区别?</h2><p>栈和队列都是线性结构，但它们的特点和应用场景不同。栈是一种后进先出(LIFO)的数据结构，而队列是一种先进先出 (FIFO) 的数据结构。</p><p>栈和队列的区别在于它们的出入方式不同。栈是后进先出，队列是先进先出。在具体实现的时候操作的位置也不同:因为栈是后进先出，它在一端进行操作；而队列是先进先出，实现的时候在两端进行操作。</p><h2 id="OSI七层网络协议"><a href="#OSI七层网络协议" class="headerlink" title="OSI七层网络协议"></a>OSI七层网络协议</h2><p>OSI七层网络协议是一种通信协议的标准，它将计算机网络体系结构分为七个层次，每个层次都有自己的功能和任务。这些层次分别是：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p><p>物理层：负责传输比特流，即由1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换。<br>数据链路层：在计算机网络中由于各种干扰的存在，物理链路是不可靠的。该层的主要功能就是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。<br>网络层：负责数据包从源到宿的传递和网际互连。<br>传输层：负责向两台主机进程之间提供端到端的可靠数据传输服务。<br>会话层：负责建立、管理和终止会话。<br>表示层：负责数据格式转换、加密解密等。<br>应用层：为用户提供各种应用服务。</p><h3 id="HTTP属于哪层协议？"><a href="#HTTP属于哪层协议？" class="headerlink" title="HTTP属于哪层协议？"></a>HTTP属于哪层协议？</h3><p>应用层</p><h3 id="TCP和UDP属于哪层协议？"><a href="#TCP和UDP属于哪层协议？" class="headerlink" title="TCP和UDP属于哪层协议？"></a>TCP和UDP属于哪层协议？</h3><p>传输层</p><h2 id="TCP和UDP的区别？"><a href="#TCP和UDP的区别？" class="headerlink" title="TCP和UDP的区别？"></a>TCP和UDP的区别？</h2><p>TCP和UDP的区别如下:</p><ul><li>TCP是面向连接的，UDP是无连接的</li><li>TCP提供可靠的服务，UDP则不保证可靠交付数据 </li><li>TCP是一对一的两点服务，即一条连接只有两个端点。UDP支持一对一、一对多、多对多的交互通信</li><li>TCP有拥塞控制和流量控制机制，保证数据传输的安全性。UDP则没有，即使网络非常拥堵了，也不会影响UDP的发送速率</li><li>TCP首部长度较长，会有一定的开销，首部在没有使用[选项，字段时是20个字节，如果使用了[选项]字段则会变长。UDP首部只有8个字节，并且是固定不变的，开销较小。</li></ul><h2 id="TCP和UDP的应用场景？"><a href="#TCP和UDP的应用场景？" class="headerlink" title="TCP和UDP的应用场景？"></a>TCP和UDP的应用场景？</h2><p>TCP和UDP是两种不同的传输协议。TCP是面向连接的协议，而UDP是无连接的协议。TCP提供交付保证，这意味着一个使用TCP协议发送的消息是保证交付给客户端的，如果消息在传输过程中丢失，那么它将重发。而UDP不提供这种保证。因此，TCP适用于对准确性要求相对高的场景，如文件传输、发送或接收邮件、远程登录等，而UDP适用于对准确性要求相对低但速度要求相对高的场景，如即时通信、在线视频、网络语音电话等。</p><h2 id="TCP的三次挥手"><a href="#TCP的三次挥手" class="headerlink" title="TCP的三次挥手"></a>TCP的三次挥手</h2><p>TCP三次握手是TCP协议中用于在客户端和服务器之间建立连接的过程。三次握手的过程如下：</p><ol><li><p>客户端向服务器发送一个SYN包，其中标志位为SYN，表示请求建立连接，序号为Seq&#x3D;x(一般取随机数)。</p></li><li><p>服务器接收到客户端发来的SYN包后，对该包进行确认后结束LISTEN阶段，并返回一段TCP报文，其中标志位为SYN和ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接，序号为Seq&#x3D;y。</p></li><li><p>客户端接收到服务器发来的TCP报文后，对该报文进行确认，其中标志位为ACK，表示确认服务器的报文Seq序号有效，客户端能正常接收服务器发送的数据，并向服务器发送一段TCP报文，其中标志位为ACK，表示确认服务器的报文Seq序号有效。</p></li></ol><h2 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h2><p>TCP四次挥手是TCP协议中用于在客户端和服务器之间断开连接的过程。四次挥手的过程如下：</p><ol><li><p>客户端向服务器发送一个FIN包，其中标志位为FIN，表示请求断开连接，序号为Seq&#x3D;u。</p></li><li><p>服务器接收到客户端发来的FIN包后，对该包进行确认后结束ESTABLISHED阶段，并返回一段TCP抵文，其中标志位为ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并告诉客户端：我知道你想断开连接的请求了。</p></li><li><p>服务器向客户端发送一个FIN包，其中标志位为FIN，表示请求断开连接，序号为Seq&#x3D;V。</p></li><li><p>客户端接收到服务器发来的TCP报文后，对该报文进行确认，其中标志位为ACK，表示确认服务器的报文Seq序号有效，客户端能正常接收服务器发送的数据，并向服务器发送一段TCP报文，其中标志位为ACK，表示确认服务器的报文Seq序号有效。</p></li></ol><h2 id="TCP的三次握手为什么不能改成两次？"><a href="#TCP的三次握手为什么不能改成两次？" class="headerlink" title="TCP的三次握手为什么不能改成两次？"></a>TCP的三次握手为什么不能改成两次？</h2><p>TCP三次握手是TCP协议中用于在客户端和服务器之间建立连接的过程。其中，第一次握手是客户端向服务器发送一个SYN包，其中标志位为SYN，表示请求建立连接，序号为Seq&#x3D;x；</p><p>第二次握手是服务器接收到客户端发来的SYN包后，对该包进行确认后结束SYN_RECEIVED阶段，并返回一段TCP报文，其中标志位为SYN&#x2F;ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并告诉客户端:我知道你想建立连接的请求了，我的序号是Seq&#x3D;y；</p><p>第三次握手是客户端接收到服务器发来的TCP报文后，对该报文进行确认，其中标志位为ACK，表示确认服务器的报文Seq序号有效，客户端能正常接收服务器发送的数据，并告诉服务器:我知道你想建立连接的请求了，我的序号是Seq&#x3D;x+1。这样就完成了TCP三次握手过程。</p><p>如果采用两次握手，则<strong>只能确定从客户端到服务端的网络是可达的，但无法保证从服务端到客户端的网络是可达的</strong>。</p><p>此外，在采用两次握手时，如果已失效的连接请求报文段突然又传到了服务端，则会导致双方不一致，造成资源浪费。</p><h2 id="浏览器中输入网址并发起网络请求后都经历了什么？"><a href="#浏览器中输入网址并发起网络请求后都经历了什么？" class="headerlink" title="浏览器中输入网址并发起网络请求后都经历了什么？"></a>浏览器中输入网址并发起网络请求后都经历了什么？</h2><ol><li><p>首先判断输入的内容是否为合法的域名，如果不是则作为关键字交给搜索引擎进行处理；如果域名中有非法字符则进行转义。</p></li><li><p>首先判断浏览器中是否有所需资源的缓存，如果有则直接使用，否则进行DNS查询获取域名对应的IP地址。</p></li><li><p>DNS查询</p><ol><li><p>判断本地的DNS缓存中是否有该IP地址，如果命中则返回</p></li><li><p>如果还是没有命中，则将域名发送到本地域名服务器，本地域名服务器采用递归查询自己的DNS服务器，查找成功则返回。</p></li><li><p>如果本地域名服务器的DNS缓存没有命中，则向上级域名服务器进行迭代查询</p><ul><li><p>首先本地域名服务器向根域名服务器进行请求，获取顶级域名服务器的地址给本地服务器。</p></li><li><p>本地域名服务器拿到这个顶级域名服务器后就想起发送请求，获取权威域名服务器的地址。</p></li><li><p>本地域名服务器向权威域名服务器发送请求，获取域名对应的IP地址。</p></li></ul></li><li><p>本地域名服务器将得到的IP地址发送给操作系统，同时自己将IP地址缓存起来。</p></li><li><p>操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来。</p></li><li><p>至此，浏览器得到了域名对应的IP地址，并将IP地址缓存起来。</p></li></ol></li><li><p>通过IP地址与本地的子网掩码相与，判断是否与请求主机在一个子网中，如果在一个子网中，则使用ARP协议获取目标主机的MAC地址，如果不在一个子网中，那么请求应该转发给网关，由它代为转发，此时同样可以通过ARP协议获取网关MAC地址，此时目的主机的MAC地址应该为网关地址。</p></li><li><p>进行TCP的三次握手</p></li><li><p>进行HTTPS握手</p></li><li><p><strong>返回数据</strong>：将网页请求发送至服务器端，服务器端返回一个html文件作为响应。浏览器接受响应后，开始对html文件进行解析并开始页面的渲染过程。</p></li><li><p><strong>页面渲染</strong>：根据html文件构建DOM树，根据解析到的css构建CSSOM树，如果遇到script标签，则判断有无async和defer属性，否则script的加载和执行会造成页面渲染的阻塞。当DOM树和CSSOM树建立好后，根据他们构建渲染树。渲染树构建好后，根据渲染树进行布局，然后使用浏览器的UI接口对页面进行绘制。此时整个页面就显示出来了。</p></li><li><p>TCP四次挥手</p></li></ol><h2 id="什么是数据库的索引？"><a href="#什么是数据库的索引？" class="headerlink" title="什么是数据库的索引？"></a>什么是数据库的索引？</h2><p>数据库索引是一种数据结构，用于提高数据库表中数据的查询效率。索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。</p><p>在数据库中，索引类似于书籍的目录。如果您想查找书籍中的某个主题，您可以查找目录以找到该主题的页码，而不必翻阅整本书。同样，如果您想查找数据库表中的某个值，则可以使用索引来快速查找该值所在的行，而不必扫描整个表。</p><p>索引可以大大提高查询效率，但也会增加写入操作的时间和空间开销。因此，在设计数据库时，需要权衡查询效率和写入效率之间的平衡。</p><h2 id="数据库的索引有哪几种类型？"><a href="#数据库的索引有哪几种类型？" class="headerlink" title="数据库的索引有哪几种类型？"></a>数据库的索引有哪几种类型？</h2><p>数据库索引有多种类型，包括: 普通索引、唯一索引、主键索引、组合索引和全文索引等。</p><ul><li>普通索引：基本的索引类型，没有唯一性的限制，允许为NULL值。</li><li>唯一索引：数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</li><li>主键索引：主键是一种特殊的唯一索引，不允许为NULL值，一个表只能有一个主键</li><li>组合索引：将多个列作为一个索引建立，可以提高查询效率。</li><li>全文索引：用于全文搜索的特殊类型的索引。</li></ul><h2 id="什么是MySQL关联查询？"><a href="#什么是MySQL关联查询？" class="headerlink" title="什么是MySQL关联查询？"></a>什么是MySQL关联查询？</h2><p>MySQL关联查询是指在查询时，需要同时操作多张表来查询数据，即关联查询。MySQL关联查询的语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column name(s)<br>FROM tablel<br>JOIN table2<br>ON table1.column_name = table2.column_name;<br></code></pre></td></tr></table></figure><p>其中，<code>table1</code> 和 <code>table2</code> 是要连接的表的名称，column_name 是要检索的列的名称。JOIN关键字用于指定要连接的表，而关键字用于指定连接条件。</p><p>MySQL支持多种类型的关联查询，包括：内连接、左连接、右连接和全连接等。</p><h2 id="关系型数据库和非关系型数据库的区别？"><a href="#关系型数据库和非关系型数据库的区别？" class="headerlink" title="关系型数据库和非关系型数据库的区别？"></a>关系型数据库和非关系型数据库的区别？</h2><p>关系型数据库和非关系型数据库的区别在于，关系型数据库一般都是有固定的表结构，并且需要通知DDL语句来修改表结构，不是很容易进行扩展；而非关系型数据库的存储机制就有很多了，比如基于文档的，K-V键值对的，还有基于图的等，对于数据的格式十分灵活没有固定的表结构，方便扩展。因此<u>如果业务的数据结构并不是固定的或者经常变动比较大的，那么非关系型数据库是个好的选择</u>。</p><h2 id="关系型数据库与文档型数据库的区别？"><a href="#关系型数据库与文档型数据库的区别？" class="headerlink" title="关系型数据库与文档型数据库的区别？"></a>关系型数据库与文档型数据库的区别？</h2><p>关系型数据库（Relational Database）是建立在关系模型基础上的数据库，借助于几何代数等数学概念和方法来处理数据库中的数据。所谓关系模型是一对一、一对多或者多对多等关系，常见的关系型数据库有Oracle、SQL Server、DB2、MySQL等。</p><p>而文档型数据库是一种非关系型数据库，非关系型数据库（Not Only SQL，NoSQL）正好与关系型数据库相反，它不是建立在“关系模型”上的数据库。文档型数据库的典型代表是MongoDB。</p><h2 id="MongoDB和MySQL的区别"><a href="#MongoDB和MySQL的区别" class="headerlink" title="MongoDB和MySQL的区别"></a>MongoDB和MySQL的区别</h2><p>MongoDB是一种文档型数据库，而MySQL是一种关系型数据库。</p><p>MongoDB可以处理大量和非结构化数据量，而MySQL则<strong>缺乏处理大数据量的速度</strong>。因此，对于拥有较小数据库并寻求更通用解决方案的公司来说，MySQL可以胜任。</p><p>另外，MongoDB以一种直观文档的方式来完成数据的存储，它很像JavaScript中定义的JSON格式，不过数据在存储的时候MongoDB数据库为文档增加了序列化的操作，最终存进磁盘的其实是一种叫做BSON的格式，即Binary-JSON。</p><p>MySQL在<strong>处理关系数据方面具有更好的优势</strong>，而MongoDB则更能满足现代应用程序的需求。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结(1.1)</title>
    <link href="/2023/04/08/%E6%80%BB%E7%BB%93-1-1/"/>
    <url>/2023/04/08/%E6%80%BB%E7%BB%93-1-1/</url>
    
    <content type="html"><![CDATA[<h2 id="React函数组件的优势"><a href="#React函数组件的优势" class="headerlink" title="React函数组件的优势"></a>React函数组件的优势</h2><ul><li>函数式组件没有this困扰且代码简洁</li><li>不涉及到复杂的state和生命周期</li><li>类组件过于冗余不宜拆分</li></ul><h2 id="常用的React-Hooks"><a href="#常用的React-Hooks" class="headerlink" title="常用的React Hooks"></a>常用的React Hooks</h2><blockquote><p>Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数</p><p>Hook使用规则：</p><ul><li>只能在<strong>函数最外层</strong>调用Hook。不能在循环、条件判断或子函数中调用。</li><li>只能在React的<strong>函数组件</strong>中调用Hook。不能在其他JavaScript函数中调用。</li></ul></blockquote><ul><li><p>State Hook</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">count</span>, setCount] = useState(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li><p>Effect Hook</p><blockquote><p><code>useEffect</code>就是一个Effect Hook，给函数组件增加了操作副作用的能力。它跟class组件中的<code>componentDidMount</code>、<code>componentDidUpdate</code>和<code>componentWillUnMount</code>具有相同的用途，只不过被合并成了一个<code>API</code>。</p></blockquote><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 模拟componentDidMount</span><br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>   <span class="hljs-comment">// 第一次渲染时调用 </span><br>&#125;, [])<br><br><span class="hljs-comment">// 模拟componentDidUpdate</span><br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 任意属性发生改变该属性就会改变</span><br>&#125;)<br><br><span class="hljs-comment">// 模拟componentWillUnmount useEffect会在状态变化的时候进行解绑</span><br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    const timer = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;, <span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <span class="hljs-comment">// 返回的函数是用于清除副作用的</span><br>        <span class="hljs-comment">// 执行卸载操作</span><br>        clearInterval(timer);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>自定义Hooks</p><p>例如：自定义一个订阅好友在线状态的Hook</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">import React, &#123; useEffect, useState &#125; from <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> use<span class="hljs-constructor">FriendStatus(<span class="hljs-params">friendID</span>)</span> &#123;<br>    const <span class="hljs-literal">[<span class="hljs-identifier">isOnline</span>, <span class="hljs-identifier">setIsOnlone</span>]</span> = use<span class="hljs-constructor">State(<span class="hljs-params">null</span>)</span>;<br>    const handleStatusChange =<span class="hljs-function"> (<span class="hljs-params">status</span>) =&gt;</span> &#123;<br>        set<span class="hljs-constructor">IsOnline(<span class="hljs-params">status</span>)</span>;<br>    &#125;<br>    use<span class="hljs-constructor">Effect(()</span> =&gt; &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChatAPI</span>.</span></span>subscribe<span class="hljs-constructor">ToFriendStatus(<span class="hljs-params">friendId</span>, <span class="hljs-params">handleStatusChange</span>)</span>; <span class="hljs-comment">// 订阅好友在线状态</span><br>        return<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChatAPI</span>.</span></span>unsubscribe<span class="hljs-constructor">ToFriend(<span class="hljs-params">friendId</span>, <span class="hljs-params">handleStatusChange</span>)</span>; <span class="hljs-comment">// 解绑对好友在线状态的订阅</span><br>        &#125;<br>    &#125;)<br>    return isOnline;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们可以在别的组件中使用它</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">FriendStatus(<span class="hljs-params">props</span>)</span> &#123;<br>    const isOnline = use<span class="hljs-constructor">FriendStatus(<span class="hljs-params">props</span>.<span class="hljs-params">friend</span>.<span class="hljs-params">id</span>)</span>;<br>    <span class="hljs-keyword">if</span>(isOnline<span class="hljs-operator"> === </span>null) &#123;<br>        return <span class="hljs-string">&quot;Loading...&quot;</span>;<br>    &#125;<br>    return isOnline ? <span class="hljs-string">&quot;onLine&quot;</span> : <span class="hljs-string">&quot;OffLine&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>useContext</p><p>不使用组件嵌套就可以订阅React的Context</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">function Example() &#123;<br>    const locale <span class="hljs-operator">=</span> useContext(LocaleContext)<span class="hljs-comment">;</span><br>    const theme <span class="hljs-operator">=</span> useContext(ThemeContext)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>useReducer</p><p>通过reducer管理本地复杂的state</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Todos()</span> &#123;<br>    const <span class="hljs-literal">[<span class="hljs-identifier">todos</span>, <span class="hljs-identifier">setTodos</span>]</span> = use<span class="hljs-constructor">Reducer(<span class="hljs-params">todosReducer</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="React为什么推荐用Hook而不是生命周期"><a href="#React为什么推荐用Hook而不是生命周期" class="headerlink" title="React为什么推荐用Hook而不是生命周期"></a>React为什么推荐用Hook而不是生命周期</h2><p>生命周期不利于逻辑相关的状态的管理。</p><p>side effect相关逻辑被分散到不同的函数中可能会导致bug的出现和产生数据不一致的情况；我们也可能会在组件的同一生命周期中放很多不相关的side effect逻辑。</p><p>使用Hook可以将某个side effect相关的逻辑都放在同一个函数中，方便代码的维护，方便组件的复用。</p><h2 id="为什么不能在循环、条件或嵌套函数中调用React-Hook"><a href="#为什么不能在循环、条件或嵌套函数中调用React-Hook" class="headerlink" title="为什么不能在循环、条件或嵌套函数中调用React Hook"></a>为什么不能在循环、条件或嵌套函数中调用React Hook</h2><p>React是使用链表来存储Hook的，每次Hook的调用都对应着一个全局的index索引，通过这个索引运行当前组件上的_hooks数组查找保存的值，也就是Hook返回的<code>[state, useState]</code></p><p>假设如下代码：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">function Example() &#123;<br>    <span class="hljs-keyword">const</span> [state1, <span class="hljs-built_in">set</span>State1] = useState(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> [state2, <span class="hljs-built_in">set</span>State2] = useState(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">const</span> [state3, <span class="hljs-built_in">set</span>State3] = useState(<span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/5/166e20d92aa52108~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="react-hooks"></p><p>在执行函数组件的时候，第一次执行<code>useState</code>是时候，它会对应Fiber对象上的<code>memoizedState</code>，这个属性原来是设计来存储类组件的state的，因为在类组件中state是一整个对象，所以可以和<code>memoizedState</code>一一对应。</p><p>但是在Hooks中，React并不知道我们调用了几次<code>useState</code>，所以在保存state这件事上，React提出了另一种解决方案，即调用<code>useState</code>之后在<code>memoizedState</code>上的对象设计成如下样式：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">&#123;<br><span class="hljs-built_in">    baseState,</span><br><span class="hljs-built_in">    next,</span><br><span class="hljs-built_in">    baseUpdate,</span><br><span class="hljs-built_in">    queue,</span><br>    memoizedState<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将其称为Hook对象。这里最需要关心的是<code>memoizedState</code>和<code>next</code>，<code>memoizedState</code>用来记录该<code>useState</code>应该返回的结果，而<code>next</code>指向下一次<code>useState</code>对应的Hook对象。</p><p>即：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">hook1</span> <span class="hljs-operator">=</span>&gt; Fiber.memoizedState<br><span class="hljs-attribute">state1</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> hook1.memoizedState<br>hook1.next <span class="hljs-operator">=</span>&gt; hook2<br><span class="hljs-attribute">state2</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> hook2.memoizedState<br>hook2.next <span class="hljs-operator">=</span>&gt; hook3<br><span class="hljs-attribute">state3</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> hook3.memoizedState<br></code></pre></td></tr></table></figure><p>React按照执行顺序以类似链表的数据格式存放在<code>Fiber.memoizedState</code>上</p><p>由于按照这种方式存储state，因此<code>useState</code>(包括其他Hooks)都必须在函数组件的根作用域声明，而不能再条件或循环中声明。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if(something) &#123;<br>    const [state1] <span class="hljs-operator">=</span> useState(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>&#125;<br>// or<br>for(something) &#123;<br>    const [state2] <span class="hljs-operator">=</span> useState(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们无法保证条件语句每次执行的次数是一样的，也就是说如果第一次render创建了<code>state1 =&gt; hook1, state2 =&gt; hook2, state3 =&gt; hook3</code>这样的对应关系，再次render的时候因为<code>something</code>未达成，导致<code>useState(1)</code>没有执行的话，那么执行<code>useState(2)</code>的时候，拿到的hook对象是<code>state1</code>的，那么逻辑就会混乱，因此该条件必须遵守。</p><p>更新state的时候，调用<code>useState</code>的返回方法如下：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">var</span> dispatch = <span class="hljs-built_in">queue</span>.dispatch = dispatchAction.bind(<span class="hljs-built_in">null</span>, currentlyRenderingFiber$<span class="hljs-number">1</span>, <span class="hljs-built_in">queue</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-meta">[</span>workInProgressHook.memoizedState, dispatch<span class="hljs-meta">]</span>;<br></code></pre></td></tr></table></figure><p>调用该方法会创建一个update</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">var</span> <span class="hljs-string">update</span> <span class="hljs-string">=</span> &#123;<br>  <span class="hljs-attr">expirationTime:</span> <span class="hljs-string">_expirationTime</span>,<br>  <span class="hljs-attr">action:</span> <span class="hljs-string">action</span>,<br>  <span class="hljs-attr">callback:</span> <span class="hljs-string">callback</span> <span class="hljs-type">!==</span> <span class="hljs-string">undefined</span> <span class="hljs-string">?</span> <span class="hljs-attr">callback :</span> <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">next:</span> <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的action是调用<code>setState(1)</code>传入的值，而这个update会被加入到queue上，因此可能存在一次性调用多次setState1的情况。</p><p>在收集完这所有<code>update</code>之后，会调度一次<code>React</code>的更新，在更新的过程中，肯定会执行到函数组件，那么就会执行到对应的<code>useState</code>，然后就拿到了<code>Hook</code>对象，它保存了<code>queue</code>对象表示有哪些更新存在，然后依次进行更新，拿到最新的<code>state</code>保存在<code>memoizedState</code>上，并且返回，最终达到了<code>setState</code>的效果。</p><p>参考文档：<a href="https://juejin.cn/post/6844903704437456909">https://juejin.cn/post/6844903704437456909</a></p><h2 id="useMemo和useCallback的区别"><a href="#useMemo和useCallback的区别" class="headerlink" title="useMemo和useCallback的区别"></a>useMemo和useCallback的区别</h2><p>二者都是用于缓存数据，优化性能的，它们接受到的参数是一样的，第一个参数表示回调函数，第二个参数表示依赖的数据。</p><p>共同作用：在依赖数据发生变化的时候，才会调用传进去的回调函数去重新计算结果，起到缓冲的作用。</p><p>区别：</p><ul><li><code>useMemo</code>缓存的结果是回调函数中return回来的值，主要用于缓存计算结果的值，应用场景如需要计算的状态。</li><li><code>useCallback</code>缓存的结果是函数，主要用于缓存函数，应用场景如需要缓存的函数，因为函数式组件每次任何一个state发生变化都会触发整个组件更新，一些函数是没有必要更新的，此时就应该缓存起来，提高性能，减少对资源的浪费。<code>useCallback</code>应该和<code>React.memo</code>配套使用，缺少一个可能会导致性能不升反降。</li></ul><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useState, useMemo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Info</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">const</span> [info, setInfo] = <span class="hljs-title function_">useState</span>(&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;LiHua&quot;</span>,<br>        <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;male&quot;</span><br>    &#125;);<br>    <span class="hljs-comment">// 翻译性别的函数</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">formatGender</span> = (<span class="hljs-params">gender</span>) =&gt; &#123;<br>        <span class="hljs-keyword">return</span> gender === <span class="hljs-string">&quot;male&quot;</span> ? <span class="hljs-string">&quot;男&quot;</span> : <span class="hljs-string">&quot;女&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果不使用useMemo,修改其他属性，也会导致formatGender方法的调用，浪费计算资源</span><br>    <span class="hljs-comment">// const gender = formatGender(info.gender);</span><br>    <span class="hljs-comment">// 仅当info.gender发生变化的时候才调用formatGender</span><br>    <span class="hljs-keyword">const</span> gender = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">formatGender</span>(info.<span class="hljs-property">gender</span>);<br>    &#125;, [info.<span class="hljs-property">gender</span>]);<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        姓名：&#123;info.name&#125; - 性别：&#123;gender&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onClick</span> = <span class="hljs-string">&#123;()</span> =&gt;</span> setInfo(...info, name: &quot;XiaoMing&quot;)&#125;</span><br><span class="language-xml">        &gt;点击修改姓名<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>useCallback是设计初衷是为了<strong>减少子组件的不必要重读渲染</strong>，优化思路主要有以下两种：</p><ul><li>减少render的次数</li><li>减少计算量</li></ul><p>在如下场景中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-comment">// 不使用useCallback和memo的时候</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Comp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [dataA, setDataA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> [dataB, setDataB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickA</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataA</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickB</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataB</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Cheap</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickA&#125;</span>&gt;</span>组件Cheap: &#123;dataA&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Cheap</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Expensive</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickB&#125;</span>&gt;</span>组件Expensive: &#123;dataB&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Expensive</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述组件中，每当点击Cheap组件的时候，Expensive组件也会重新渲染，即使dataB没有发生变化，原因就是onClickB被重新定义，导致React在diff新旧组件的时候判定了组件发生了变化。</p><p>此时，useCallback和memo就发挥作用了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useCallback, useState, memo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Expensive</span>(<span class="hljs-params">&#123;onClick, name&#125;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Expensive渲染&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><span class="hljs-keyword">const</span> memoExpensive = <span class="hljs-title function_">memo</span>(<span class="hljs-title class_">Expensive</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cheap</span>(<span class="hljs-params">&#123;onClick, name&#125;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Cheap渲染&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Comp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [dataA, setDataA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> [dataB, setDataB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickA</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataA</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> onClickB = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">setDataB</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;, [])<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Cheap</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickA&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">组件Cheap:</span> $&#123;<span class="hljs-attr">dataA</span>&#125;`&#125; /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Expensive</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickB&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">组件Expensive:</span> $&#123;<span class="hljs-attr">data</span>&#125;`&#125; /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>memo与PureComponent类似，对传入组件的新旧数据进行浅比较，如果相同则不会触发渲染。</p><p>useCallback保证onClickB不会发生变化，此时点击Cheap组件不会触发Expensive组件的刷新，只有点击Expensive组件才会触发。在实现减少不必要渲染的优化过程中，useCallback和memo是一对利器。</p><h2 id="函数组件模拟componentWillUnmount组件"><a href="#函数组件模拟componentWillUnmount组件" class="headerlink" title="函数组件模拟componentWillUnmount组件"></a>函数组件模拟componentWillUnmount组件</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 执行卸载操作</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="项目：根据用户权限实现路由权限管理"><a href="#项目：根据用户权限实现路由权限管理" class="headerlink" title="项目：根据用户权限实现路由权限管理"></a>项目：根据用户权限实现路由权限管理</h2><p>在编写React路由列表的时候为每一个路由赋一个id值，在用户登录之后将用户的权限列表存储起来，并根据用户权限列表对路由列表进行筛选和展示，根据筛选后的结果部署系统的导航栏。</p><p>当用户想要通过直接输入url的方式访问某个页面的时候，在Route组件的render函数中根据url匹配到路由对应的id值，然后判断用户权限列表中是否存在该id值，如果存在则允许访问，否则警告用户没有权限并返回首页。</p><p>……</p><h2 id="为什么使用Redux进行状态管理"><a href="#为什么使用Redux进行状态管理" class="headerlink" title="为什么使用Redux进行状态管理"></a>为什么使用Redux进行状态管理</h2><ul><li><strong>Redux使状态可预测。</strong>传递相同的状态和动作传递给减速器，总会产生相同的结果，因为减速器是纯函数。</li><li><strong>Redux方便维护。</strong>Redux对代码的组织方式很严格，结构更容易理解，维护更加方便。同时有利于用户将业务逻辑与组件树分离。</li><li><strong>Redux调试简单。</strong>Redux使调试程序变得简单，通过记录操作和状态，很容易理解编码错误、网络错误和生产过程中出现的其他形式的错误。</li><li><strong>Redux有性能优势。</strong>Redux内部实现了很多优化，因此我们自己的连接组件仅在实际需要时才重新渲染。</li><li><strong>数据持久化。</strong></li><li><strong>Redux还能用于服务端渲染。</strong>我们可以通过将应用程序的状态连同它对服务器请求的响应发送到服务器来处理应用程序的初始呈现，然后所需组件以HTML格式呈现并发送到客户端。</li></ul><h2 id="哪些数据需要使用Redux进行存储？"><a href="#哪些数据需要使用Redux进行存储？" class="headerlink" title="哪些数据需要使用Redux进行存储？"></a>哪些数据需要使用Redux进行存储？</h2><p>全局公共数据用Redux进行管理，局部状态用state和props即可。</p><h2 id="浏览器的垃圾回收机制"><a href="#浏览器的垃圾回收机制" class="headerlink" title="浏览器的垃圾回收机制"></a>浏览器的垃圾回收机制</h2><p>JS代码运行时，需要分配内存空间来存储变量和值。当变量不再参与运行时，就需要回收被占用的空间，这就是垃圾回收。</p><p><strong>垃圾回收的方式</strong></p><ul><li><p><strong>标记清除</strong></p><p>当变量进入执行环境时，标记该变量”进入幻境”，此时变量不能回收。当变量离开环境的时候，就会被标记为”离开环境”，会被内存释放</p></li><li><p><strong>引用计数</strong></p><p>跟踪每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量的时候，这个值的引用次数就是1。当包含对该值引用的变量指向另一个值的时候，引用次数减1。当引用次数变为0的时候，说明该值已经没有利用价值，这个变量占用的内存空间就会被释放出来。</p><p>弊端：可能会引起<strong>循环引用</strong>的问题，例如：obj1和obj2通过属性互相进行引用，那么二者的引用次数永远不会归零，函数执行完结束后，两个变量仍然会继续存在，引用次数永远不为0，会引起循环引用。</p></li></ul><p><strong>减少垃圾回收的方式</strong></p><ul><li>对数组进行优化：清空一个数组的时候将其长度设为0</li><li>对对象进行优化：不再使用的时候将其设置为null</li><li>对函数进行优化：在循环中的函数表达式，如果可以复用则尽量放在外面</li></ul><h2 id="实现JS的深拷贝"><a href="#实现JS的深拷贝" class="headerlink" title="实现JS的深拷贝"></a>实现JS的深拷贝</h2><ul><li><p>使用JSON.stringify和JSON.parse实现</p></li><li><p>for…in + Object.assign</p></li><li><p>for…in + 拓展运算符</p></li><li><p><strong>Object.create</strong></p></li><li><p><strong>jQuery.extend(deep, target, obj1, …)</strong></p></li><li><p>函数库lodash</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;lodash&quot;</span>;<br><span class="hljs-keyword">const</span> obj = &#123;a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span>&#125;;<br><span class="hljs-keyword">const</span> deep = _.cloneDeep(obj);<br></code></pre></td></tr></table></figure></li></ul><h2 id="JS作用域是在什么时候创建的"><a href="#JS作用域是在什么时候创建的" class="headerlink" title="JS作用域是在什么时候创建的"></a>JS作用域是在什么时候创建的</h2><p>全局作用域在window对象创建的时候产生。</p><p>局部作用域在函数执行时产生，函数执行完毕后，如果子作用域不需要使用它声明的变量就销毁，如果使用就形成闭包保存下来。</p><h2 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h2><p>有权访问另一个函数作用域内变量的函数</p><h2 id="宏任务和微任务的区别"><a href="#宏任务和微任务的区别" class="headerlink" title="宏任务和微任务的区别"></a>宏任务和微任务的区别</h2><p>宏任务一般是：整体代码script、setTimeout、setInterval、I&#x2F;O、UI render</p><p>微任务主要是：Promise、Object.observe、MutationObserver</p><p>二者都是异步。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
