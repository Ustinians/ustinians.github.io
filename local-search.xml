<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>知识点整理(7)</title>
    <link href="/2023/04/13/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-7/"/>
    <url>/2023/04/13/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-7/</url>
    
    <content type="html"><![CDATA[<h1 id="知识点整理-7"><a href="#知识点整理-7" class="headerlink" title="知识点整理(7)"></a>知识点整理(7)</h1><h2 id="git-amend的作用？"><a href="#git-amend的作用？" class="headerlink" title="git amend的作用？"></a>git amend的作用？</h2><p>git amend命令用于修改最近一次的提交记录。它允许您添加、删除或修改之前提交的文件、提交消息等。</p><p>使用git amend命令，您可以：</p><ol><li>修改上一次提交的提交消息。</li><li>将一些忘记添加到上一次提交中的文件添加到该提交中。</li><li>修改上一次提交中的某些文件。</li><li>将上一次提交中的某些文件删除。</li></ol><p>使用git amend命令修改最近一次提交记录有以下两种方式：</p><p><strong>修改最近一次提交记录的提交消息：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git commit --amend -m &quot;New commit message&quot;<br></code></pre></td></tr></table></figure><p>这个命令将会修改最近一次提交记录的提交消息。</p><p><strong>添加、删除或修改最近一次提交记录中的文件：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs git">git add &lt;file&gt;  # 添加文件到暂存区<br>git rm &lt;file&gt;   # 从暂存区和工作目录中删除文件<br>git reset &lt;file&gt;   # 从暂存区中删除文件，但不删除工作目录中的文件<br>git commit --amend   # 修改最近一次提交记录<br></code></pre></td></tr></table></figure><p>注意：使用git amend修改提交记录时，只能修改最近一次提交记录，如果要修改更早的提交记录，需要使用git rebase等其他命令。</p><h2 id="Websocket承载的上限，能同时接受多少个客户端连接？"><a href="#Websocket承载的上限，能同时接受多少个客户端连接？" class="headerlink" title="Websocket承载的上限，能同时接受多少个客户端连接？"></a>Websocket承载的上限，能同时接受多少个客户端连接？</h2><p>WebSocket承载的上限取决于多个因素，包括服务器的硬件和软件配置、网络带宽、同时连接的客户端数量、客户端发送和接收数据的频率等。因此，无法给出一个具体的答案来回答能同时接受多少个客户端连接。</p><p>一般来说，WebSocket的性能通常比HTTP长连接更好，因为它使用的是基于事件的模型，可以在服务器和客户端之间实现实时的双向通信。但是，在实际应用中，如果同时连接的客户端数量过多，可能会导致服务器的负载过高，从而影响WebSocket的性能和可靠性。</p><p>为了提高WebSocket的性能和可靠性，可以采取一些优化措施，例如使用负载均衡、优化服务器端代码、增加服务器硬件配置、限制每个客户端的连接数量等。同时，也需要根据实际情况进行测试和调整，以确保WebSocket在高并发情况下的稳定性和性能。</p><h2 id="操作系统的功能有哪些？"><a href="#操作系统的功能有哪些？" class="headerlink" title="操作系统的功能有哪些？"></a>操作系统的功能有哪些？</h2><ol><li><p>进程管理：操作系统管理计算机上运行的所有进程，包括进程的创建、调度、终止、通信等。</p></li><li><p>内存管理：操作系统管理计算机内存的分配和释放，确保程序能够访问到所需的内存空间。</p></li><li><p>文件系统：操作系统管理计算机上的文件和目录，包括文件的创建、读取、写入、复制、删除等。</p></li><li><p>设备管理：操作系统管理计算机上的各种设备，包括输入输出设备、存储设备、网络设备等。</p></li><li><p>用户接口：操作系统提供了用户与计算机交互的接口，包括命令行接口、图形用户界面等。</p></li><li><p>安全性管理：操作系统确保计算机系统的安全性，包括用户身份验证、访问控制、病毒防护等。</p></li><li><p>网络管理：操作系统提供了网络通信的支持，包括TCP&#x2F;IP协议栈、网络驱动程序等。</p></li></ol><h2 id="并发和并行的区别？"><a href="#并发和并行的区别？" class="headerlink" title="并发和并行的区别？"></a>并发和并行的区别？</h2><p>并发和并行都是多任务处理的概念，但是它们的含义不同。</p><p>并发是指在同一时间段内，有多个任务在交替执行，这些任务可能在同一个处理器上交替执行，也可能在多个处理器上并行执行。在并发执行中，每个任务都会分配一定的时间片，轮流执行，但是在任意时刻只有一个任务在执行。</p><p>并行是指在同一时刻，有多个任务在同时执行，这些任务可以在多个处理器上并行执行，也可以在同一处理器上通过多核心并行执行。在并行执行中，多个任务同时执行，每个任务都能够分配到独立的处理器或处理器核心。</p><p>简单来说，如果是在同一个处理器上，任务是交替执行的，就是并发；如果是在多个处理器上或者是多核心并行执行，就是并行。</p><p>总之，并发和并行都是提高计算机系统效率的重要手段，但是它们的实现方式和效果不同。在实际应用中，需要根据具体情况选择并发或并行的方式来处理任务。</p><h2 id="Websocket使用的是TCP还是UDP协议？为什么？"><a href="#Websocket使用的是TCP还是UDP协议？为什么？" class="headerlink" title="Websocket使用的是TCP还是UDP协议？为什么？"></a>Websocket使用的是TCP还是UDP协议？为什么？</h2><p>Websocket使用的是TCP协议，而不是UDP协议。</p><p>TCP协议是一种面向连接的、可靠的、有序的协议，它在数据传输过程中提供了数据完整性、可靠性和有序性的保证。Websocket需要<strong>保证数据的可靠性和有序性</strong>，因此选择了TCP协议作为底层传输协议。</p><p>相比之下，UDP协议是一种无连接的、不可靠的、无序的协议，它不提供数据的可靠性和有序性保证，适合于一些实时性要求高、数据量小、可丢失的应用，如在线游戏、音视频传输等。但是Websocket需要保证数据的可靠性和有序性，因此不适合使用UDP协议作为底层传输协议。</p><p>综上所述，Websocket使用TCP协议作为底层传输协议，可以保证数据的可靠性和有序性，适用于需要保证数据完整性和可靠性的应用。</p><h2 id="TCP在连接时会出现拥塞和粘包的问题，要怎么解决粘包的问题？"><a href="#TCP在连接时会出现拥塞和粘包的问题，要怎么解决粘包的问题？" class="headerlink" title="TCP在连接时会出现拥塞和粘包的问题，要怎么解决粘包的问题？"></a>TCP在连接时会出现拥塞和粘包的问题，要怎么解决粘包的问题？</h2><p>TCP协议在传输过程中会出现拥塞和粘包的问题，其中粘包问题是由于<strong>发送端发送的数据大小与接收端接收的数据大小不一致，导致多个数据包被粘在一起，从而造成接收端解析数据时出现错误</strong>。解决粘包问题的方法如下：</p><ol><li>使用消息定长：在发送端每次发送固定长度的数据，接收端每次接收相同长度的数据，这样就能避免粘包问题。</li><li>使用消息分隔符：在发送端每次发送数据时，在每个数据包的末尾添加一个特定的分隔符，接收端根据分隔符将数据包分开处理。</li><li>使用消息长度：在发送端每次发送数据时，在数据包的头部添加一个表示数据长度的字段，接收端根据字段的值来判断每个数据包的长度。</li><li>应用层协议处理：在应用层协议中定义数据格式和处理方式，例如HTTP协议中使用头部信息和分隔符来处理请求和响应数据。</li></ol><p>综上所述，通过使用消息定长、消息分隔符、消息长度和应用层协议处理等方法，可以有效解决TCP协议中的粘包问题。</p><h2 id="什么是全双工通信？"><a href="#什么是全双工通信？" class="headerlink" title="什么是全双工通信？"></a>什么是全双工通信？</h2><p>全双工通信是指在通信的两端，数据可以同时双向传输，即两端都可以同时发送和接收数据。全双工通信可以实现双向通信，通信效率高，通信质量稳定。与半双工通信和单工通信相比，全双工通信具有更高的带宽利用率和更快的数据传输速度。</p><p>在全双工通信中，通信双方可以同时发送和接收数据，而且在发送和接收数据时不需要等待对方的响应。这种通信方式可以在同一信道上实现双向通信，例如电话通信、视频会议、网络通信等都可以采用全双工通信方式。</p><p>在全双工通信中，通信双方需要使用专门的设备进行通信，例如全双工电缆、全双工网卡等。这些设备可以同时进行发送和接收数据，并且能够处理来自对方的数据，从而实现双向通信。</p><p>因此，全双工通信可以提高通信效率和通信质量，广泛应用于各种通信场景中。</p><h2 id="Http的报文格式？"><a href="#Http的报文格式？" class="headerlink" title="Http的报文格式？"></a>Http的报文格式？</h2><p>HTTP（超文本传输协议）的报文格式分为请求报文和响应报文两种类型。</p><p><strong>请求报文格式</strong></p><p>请求报文由三个部分组成：请求行、请求头和请求体。</p><p>请求行格式：METHOD URL HTTP&#x2F;版本号</p><p>例如：GET &#x2F;index.html HTTP&#x2F;1.1</p><p>请求头格式：键值对，每个键值对用冒号分隔，每个键值对占一行，最后一行用空行表示请求头结束。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Host</span>: www.<span class="hljs-property">example</span>.<span class="hljs-property">com</span> <span class="hljs-title class_">User</span>-<span class="hljs-title class_">Agent</span>: <span class="hljs-title class_">Mozilla</span>/<span class="hljs-number">5.0</span> (<span class="hljs-title class_">Windows</span> <span class="hljs-variable constant_">NT</span> <span class="hljs-number">10.0</span>; <span class="hljs-title class_">Win64</span>; x64) <span class="hljs-title class_">AppleWebKit</span>/<span class="hljs-number">537.36</span> (<span class="hljs-variable constant_">KHTML</span>, like <span class="hljs-title class_">Gecko</span>) <span class="hljs-title class_">Chrome</span>/<span class="hljs-number">58.0</span><span class="hljs-number">.3029</span><span class="hljs-number">.110</span> <span class="hljs-title class_">Safari</span>/<span class="hljs-number">537.36</span> <span class="hljs-title class_">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0.9</span>,image/webp,*<span class="hljs-comment">/*;q=0.8</span><br></code></pre></td></tr></table></figure><p>请求体格式：用于传输数据，可以为空。</p><p><strong>响应报文格式</strong></p><p>响应报文也由三个部分组成：状态行、响应头和响应体。</p><p>状态行格式：HTTP&#x2F;版本号 状态码 状态码的原因短语</p><p>例如：HTTP&#x2F;1.1 200 OK</p><p>响应头格式：键值对，每个键值对用冒号分隔，每个键值对占一行，最后一行用空行表示响应头结束。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Type</span>: text/html; charset=utf-<span class="hljs-number">8</span> <span class="hljs-title class_">Server</span>: <span class="hljs-title class_">Apache</span>/<span class="hljs-number">2.4</span><span class="hljs-number">.18</span> (<span class="hljs-title class_">Ubuntu</span>) <span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Length</span>: <span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><p>响应体格式：用于传输数据，可以为空。</p><h2 id="Http状态码1-5代表什么含义"><a href="#Http状态码1-5代表什么含义" class="headerlink" title="Http状态码1-5代表什么含义?"></a>Http状态码1-5代表什么含义?</h2><p>HTTP状态码是服务器响应HTTP请求时返回的3位数字代码。这些代码分为5类，每类都代表了不同的含义。</p><p>1xx（信息性状态码）：表示请求已经被接收，继续处理。这个类别的状态码通常是在客户端发送请求时使用，用于提示客户端请求是否被服务器接收。</p><p>2xx（成功状态码）：表示请求已经被成功接收、理解、接受和处理。这个类别的状态码意味着服务器已经成功地处理了请求。</p><p>3xx（重定向状态码）：表示客户端需要进一步操作才能完成请求。这个类别的状态码通常用于重定向，即让客户端请求另一个URL。</p><p>4xx（客户端错误状态码）：表示客户端发送的请求有错误，服务器无法处理该请求。这个类别的状态码通常是由于客户端发送的请求有误、缺少参数或权限等原因引起的。</p><p>5xx（服务器错误状态码）：表示服务器在处理请求时发生了错误。这个类别的状态码通常是由于服务器无法处理请求、服务器内部错误或服务器过载等原因引起的。</p><p>以下是HTTP状态码的具体含义：</p><ul><li>1xx：信息性状态码<ul><li>100：Continue</li><li>101：Switching Protocols</li></ul></li><li>2xx：成功状态码<ul><li>200：OK</li><li>201：Created</li><li>202：Accepted</li><li>204：No Content</li></ul></li><li>3xx：重定向状态码<ul><li>301：Moved Permanently</li><li>302：Found</li><li>303：See Other</li><li>304：Not Modified</li><li>307：Temporary Redirect</li></ul></li><li>4xx：客户端错误状态码<ul><li>400：Bad Request</li><li>401：Unauthorized</li><li>403：Forbidden</li><li>404：Not Found</li><li>405：Method Not Allowed</li><li>408：Request Timeout</li><li>409：Conflict</li><li>410：Gone</li><li>413：Payload Too Large</li><li>414：URI Too Long</li><li>415：Unsupported Media Type</li><li>429：Too Many Requests</li></ul></li><li>5xx：服务器错误状态码<ul><li>500：Internal Server Error</li><li>501：Not Implemented</li><li>502：Bad Gateway</li><li>503：Service Unavailable</li><li>504：Gateway Timeout</li><li>505：HTTP Version Not Supported</li></ul></li></ul><h2 id="前端如何解决跨域？"><a href="#前端如何解决跨域？" class="headerlink" title="前端如何解决跨域？"></a>前端如何解决跨域？</h2><ol><li><p>JSONP</p><p>JSONP是一种跨域解决方案，它利用了script标签的跨域特性来实现。</p></li><li><p>CORS</p><p>CORS是一种新的跨域解决方案，它需要服务器端进行配置。通过在响应头中添加Access-Control-Allow-Origin字段，允许指定的域名跨域访问。</p></li><li><p>代理</p><p>通过在服务器端设置代理，将前端请求发送到后端服务器，然后由后端服务器发送请求到目标服务器，最后将结果返回给前端。</p></li></ol><h2 id="跨域相关的HTTP请求头有哪些？"><a href="#跨域相关的HTTP请求头有哪些？" class="headerlink" title="跨域相关的HTTP请求头有哪些？"></a>跨域相关的HTTP请求头有哪些？</h2><ol><li><p>Access-Control-Allow-Origin</p><p>该字段用于允许哪些域名可以跨域访问资源。可以设置为*，表示允许所有域名访问。</p></li><li><p>Access-Control-Allow-Methods</p><p>该字段用于允许哪些HTTP方法可以跨域访问资源。例如GET、POST、PUT、DELETE等。</p></li><li><p>Access-Control-Allow-Headers</p><p>该字段用于允许哪些HTTP头可以跨域访问资源。例如Content-Type、Authorization等。</p></li></ol><h2 id="Http缓存，由哪些header控制？"><a href="#Http缓存，由哪些header控制？" class="headerlink" title="Http缓存，由哪些header控制？"></a>Http缓存，由哪些header控制？</h2><p>强缓存：Cache-Control、Expires</p><p>协商缓存：Etag&#x2F;If-None-Match、Last-Mpdified&#x2F;If-Modified-Since</p><h2 id="Node中的事件循环机制？"><a href="#Node中的事件循环机制？" class="headerlink" title="Node中的事件循环机制？"></a>Node中的事件循环机制？</h2><p>Node.js的事件循环机制是其异步非阻塞I&#x2F;O的核心，它是基于事件驱动的非阻塞I&#x2F;O模型实现的。</p><p>在Node.js中，事件循环机制分为6个阶段，分别是：</p><ol><li>timers阶段：处理setTimeout和setInterval等定时器的回调函数。</li><li>I&#x2F;O callbacks阶段：处理一些系统I&#x2F;O操作的回调函数，如网络请求的回调函数。</li><li>idle, prepare阶段：只在内部使用，可以忽略。</li><li>poll阶段：等待I&#x2F;O事件完成，如网络请求的响应、文件读写完成等。</li><li>check阶段：处理setImmediate()的回调函数。</li><li>close callbacks阶段：处理一些关闭事件的回调函数，如socket连接关闭的回调函数。</li></ol><p>事件循环机制的流程如下：</p><ol><li>进入循环：Node.js会在事件循环开始时，进入timers阶段。</li><li>执行timers：Node.js会执行所有定时器的回调函数。</li><li>进入I&#x2F;O callbacks阶段：处理所有I&#x2F;O事件的回调函数。</li><li>进入poll阶段：等待I&#x2F;O事件完成。</li><li>执行check阶段：处理setImmediate()的回调函数。</li><li>执行close callbacks阶段：处理所有关闭事件的回调函数。</li><li>等待下一个循环：事件循环会等待新的事件被触发，然后再次进入循环。</li></ol><p>事件循环机制的核心是事件队列，所有的回调函数都会被加入到事件队列中，事件循环机制会不断地从事件队列中取出待执行的回调函数，按照一定的顺序执行。</p><p>总之，Node.js的事件循环机制是其异步非阻塞I&#x2F;O的核心，通过不断地循环执行事件队列中的回调函数，实现了高效的异步非阻塞I&#x2F;O模型。</p><p>小根堆的概念？作用？</p><p>小根堆（Min Heap）是一种基于树形结构的数据结构，它满足以下两个条件：</p><ol><li>堆中每个节点的值都小于或等于其子节点的值。</li><li>堆是一棵完全二叉树。</li></ol><p>小根堆的作用：</p><ol><li>堆排序：小根堆可以用来进行堆排序，堆排序是一种高效的排序算法，时间复杂度为O(nlogn)。</li><li>优先队列：小根堆可以用来实现优先队列，优先队列是一种数据结构，它可以按照优先级来处理元素，小根堆可以实现按照元素值的大小来进行优先级排序。</li><li>最小值查询：小根堆可以用来查询最小值，由于小根堆的性质，堆顶元素始终是堆中的最小值。</li><li>贪心算法：小根堆可以用来实现贪心算法，贪心算法是一种基于贪心思想的算法，它每次选择当前最优的方案，小根堆可以用来找到当前最优的方案。</li></ol><p>总之，小根堆是一种非常实用的数据结构，它可以用来实现堆排序、优先队列、最小值查询和贪心算法等。</p><h2 id="TCP可靠的原因是什么？依靠了哪些机制？"><a href="#TCP可靠的原因是什么？依靠了哪些机制？" class="headerlink" title="TCP可靠的原因是什么？依靠了哪些机制？"></a>TCP可靠的原因是什么？依靠了哪些机制？</h2><ol><li>应答机制：TCP在发送数据之后，会等待接收方的应答，以确认数据是否已经到达。如果接收方未能及时应答，TCP会进行重传，直到接收到应答为止。</li><li>序列号和确认应答：TCP会为每个数据包分配一个序列号，用于标识数据包的顺序和完整性。接收方在收到数据包后，会发送一个确认应答，其中包含期望接收的下一个序列号，用于告诉发送方哪些数据已经接收到了。</li><li>数据包校验和：TCP会对每个数据包进行校验和计算，以检测数据在传输过程中是否发生了损坏或丢失。如果校验和不匹配，TCP会进行重传，以确保数据的完整性。</li><li>滑动窗口：TCP使用滑动窗口机制来控制数据流量，以避免网络拥塞。发送方和接收方都有一个窗口大小，用于控制发送和接收的数据量。发送方会根据接收方的窗口大小来控制发送的数据量，以避免数据包的丢失或拥塞。</li></ol><h2 id="网络层的协议有哪些？"><a href="#网络层的协议有哪些？" class="headerlink" title="网络层的协议有哪些？"></a>网络层的协议有哪些？</h2><ol><li>IP协议（Internet Protocol）：IP是互联网中最重要的协议之一，负责将数据包从源地址传输到目的地址，并通过路由选择算法选择最优路径。IPv4和IPv6是最常用的IP协议版本。</li><li>ICMP协议（Internet Control Message Protocol）：ICMP是IP协议的附属协议，用于传输网络控制信息和错误报文。常用的功能包括ping命令和traceroute命令。</li><li>ARP协议（Address Resolution Protocol）：ARP是用于将IP地址转换为MAC地址的协议，通过查询本地网络中的ARP缓存表或广播ARP请求来查找目标MAC地址。</li><li>RARP协议（Reverse Address Resolution Protocol）：RARP是ARP的反向协议，用于将MAC地址转换为IP地址。现在已经很少使用。</li><li>OSPF协议（Open Shortest Path First）：OSPF是一种开放的链路状态路由协议，用于在局域网和广域网中选择最短路径，实现路由的自适应和动态变化。</li><li>BGP协议（Border Gateway Protocol）：BGP是一种自治系统间的路由协议，用于在不同自治系统之间传输路由信息，实现互联网中的全球路由选择。</li><li>RIP协议（Routing Information Protocol）：RIP是一种基于距离向量的内部网关协议，用于在小型网络中选择最短路径，实现路由的自适应和动态变化。</li></ol><h2 id="如何获取URL中的参数？"><a href="#如何获取URL中的参数？" class="headerlink" title="如何获取URL中的参数？"></a>如何获取URL中的参数？</h2><p>获取URL中的参数可以使用JavaScript中的URLSearchParams对象。以下是一个简单的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取当前URL中的参数</span><br><span class="hljs-keyword">let</span> params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">search</span>);<br><br><span class="hljs-comment">// 获取特定参数的值</span><br><span class="hljs-keyword">let</span> id = params.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-keyword">let</span> name = params.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;name&quot;</span>);<br><br><span class="hljs-comment">// 打印参数值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id); <span class="hljs-comment">// 输出参数id的值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// 输出参数name的值</span><br></code></pre></td></tr></table></figure><p>上述代码中，首先使用<code>URLSearchParams</code>对象获取当前URL中的参数。然后使用<code>get</code>方法获取特定参数的值。最后使用<code>console.log</code>方法打印参数值。</p><p>字符串分割方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getAllParams</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 获取当前URL</span><br>  <span class="hljs-keyword">let</span> url = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>;<br><br>  <span class="hljs-comment">// 获取参数部分</span><br>  <span class="hljs-keyword">let</span> params = url.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;?&quot;</span>)[<span class="hljs-number">1</span>];<br><br>  <span class="hljs-comment">// 分割参数</span><br>  <span class="hljs-keyword">let</span> paramArr = params.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&amp;&quot;</span>);<br><br>  <span class="hljs-comment">// 创建一个空对象，用于存储参数</span><br>  <span class="hljs-keyword">let</span> paramObj = &#123;&#125;;<br><br>  <span class="hljs-comment">// 遍历参数数组，将参数存储到对象中</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; paramArr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> param = paramArr[i].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;=&quot;</span>);<br><br>    <span class="hljs-comment">// 将参数名和参数值存储到对象中</span><br>    paramObj[param[<span class="hljs-number">0</span>]] = param[<span class="hljs-number">1</span>];<br>  &#125;<br><br>  <span class="hljs-comment">// 返回参数对象</span><br>  <span class="hljs-keyword">return</span> paramObj;<br>&#125;<br><br><span class="hljs-comment">// 获取所有参数</span><br><span class="hljs-keyword">let</span> params = <span class="hljs-title function_">getAllParams</span>();<br><br><span class="hljs-comment">// 打印参数对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params);<br></code></pre></td></tr></table></figure><h2 id="手写JS计算m的n次方，要求时间复杂度O-logN-？"><a href="#手写JS计算m的n次方，要求时间复杂度O-logN-？" class="headerlink" title="手写JS计算m的n次方，要求时间复杂度O(logN)？"></a>手写JS计算m的n次方，要求时间复杂度O(logN)？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">power</span>(<span class="hljs-params">m, n</span>) &#123;<br>  <span class="hljs-comment">// 如果n等于0，返回1</span><br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果n是负数，将m变为倒数，n变为相反数</span><br>  <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br>    m = <span class="hljs-number">1</span> / m;<br>    n = -n;<br>  &#125;<br><br>  <span class="hljs-comment">// 用二分法计算m的n次方</span><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 如果n是奇数，将结果乘上m</span><br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) &#123;<br>      result *= m;<br>    &#125;<br>    <span class="hljs-comment">// 将m平方，将n除以2</span><br>    m *= m;<br>    n = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(n / <span class="hljs-number">2</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 返回结果</span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 计算2的10次方</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">power</span>(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>)); <span class="hljs-comment">// 输出1024</span><br></code></pre></td></tr></table></figure><h2 id="什么是bem？"><a href="#什么是bem？" class="headerlink" title="什么是bem？"></a>什么是bem？</h2><p>BEM是一种CSS命名规范，全称为Block-Element-Modifier，即块-元素-修饰符。它的核心思想是将页面中的组件或模块抽象成一个个块（Block），块内部可以包含多个元素（Element），而元素可以包含多个修饰符（Modifier），从而实现了对页面组件的精细化管理和命名。</p><p>具体来说，BEM的命名规则如下：</p><ul><li>Block（块）：代表一个独立的组件或模块，使用单个单词或短语命名，使用连字符(-)连接单词，例如：.navbar、.card、.header。</li><li>Element（元素）：代表块内部的一个组成部分，使用双下划线(__)连接块名和元素名，例如：.card__title、.navbar__menu。</li><li>Modifier（修饰符）：代表块或元素的状态或变体，使用单个单词或短语命名，使用单下划线(_)连接块名或元素名和修饰符名，例如：.card__title_highlighted、.navbar__menu_visible。</li></ul><p>BEM的优点是可以使CSS代码更加清晰、易于维护和扩展，同时可以避免CSS命名冲突和样式耦合的问题。</p><h2 id="什么是shadow-dom？"><a href="#什么是shadow-dom？" class="headerlink" title="什么是shadow dom？"></a>什么是shadow dom？</h2><p>Shadow DOM是一项Web标准技术，用于创建封装的组件和Web应用程序，使得组件的样式和行为不会受到外部CSS样式的干扰。Shadow DOM通过创建一个隔离的DOM树来实现这个目标，这个DOM树被称为“Shadow Tree”，它的内容和结构都不会影响到页面上的其他元素。</p><p>Shadow DOM可以被看作是一种Web组件技术，它可以将HTML、CSS和JavaScript封装在一个独立的组件内部，从而使得组件的样式和行为可以完全独立于页面的其他元素。Shadow DOM还提供了一些特殊的API，如：ShadowRoot、Element.attachShadow()和Element.shadowRoot，用于创建和管理Shadow Tree。</p><p>Shadow DOM的优点是可以实现组件的封装、复用和可维护性，同时也可以提高Web应用程序的性能和安全性。在Web开发中，Shadow DOM被广泛用于构建Web组件库、单页面应用程序和桌面应用程序等。</p><h2 id="TCP客户端和服务端同时发出断开请求后续会怎么样？"><a href="#TCP客户端和服务端同时发出断开请求后续会怎么样？" class="headerlink" title="TCP客户端和服务端同时发出断开请求后续会怎么样？"></a>TCP客户端和服务端同时发出断开请求后续会怎么样？</h2><p>在 TCP 连接中，当客户端和服务端都发出断开请求时，会发生以下情况：</p><ol><li>服务端先收到断开请求：服务端会发送一个 ACK 确认客户端的断开请求，并关闭连接。此时客户端还没有收到服务端的 ACK，仍然处于等待状态。</li><li>客户端先收到断开请求：客户端会发送一个 ACK 确认服务端的断开请求，并关闭连接。此时服务端还没有收到客户端的 ACK，仍然处于等待状态。</li><li>客户端和服务端同时收到断开请求：客户端和服务端都会发送一个 ACK 确认对方的断开请求，并关闭连接。此时连接会立即断开，双方都不会处于等待状态。</li></ol><p>总之，在 TCP 连接中，任何一方发送断开请求后，都需要等待对方的确认，才能真正关闭连接。如果双方同时发出断开请求，则连接会立即断开，否则需要等待对方的确认。</p><h2 id="Http1-0时候发起一个http请求会开启一个TCP连接吗？"><a href="#Http1-0时候发起一个http请求会开启一个TCP连接吗？" class="headerlink" title="Http1.0时候发起一个http请求会开启一个TCP连接吗？"></a>Http1.0时候发起一个http请求会开启一个TCP连接吗？</h2><p>在 HTTP&#x2F;1.0 中，每次发起 HTTP 请求都会建立一个新的 TCP 连接。这是因为 HTTP&#x2F;1.0 中每个请求和响应都是独立的，没有复用连接的机制。</p><p>在 HTTP&#x2F;1.0 中，每个 TCP 连接只能处理一个请求和响应，因此在处理多个请求和响应时，需要建立多个 TCP 连接。这样会导致建立和关闭连接的开销比较大，影响了 HTTP 请求的性能。</p><p>为了解决这个问题，HTTP&#x2F;1.1 引入了持久连接，允许在同一个 TCP 连接上发送多个请求和响应。这样可以减少建立和关闭连接的开销，提高 HTTP 请求的性能。</p><h2 id="一般的发Http请求的流程是什么样的？"><a href="#一般的发Http请求的流程是什么样的？" class="headerlink" title="一般的发Http请求的流程是什么样的？"></a>一般的发Http请求的流程是什么样的？</h2><p>一般的发 Http 请求的流程如下：</p><ol><li>构建请求：构建 HTTP 请求报文，包括请求方法、请求 URL、请求头以及请求体等信息。</li><li>建立连接：通过 TCP 协议与服务器建立连接，可以使用 HTTP&#x2F;1.0 中的短连接或者 HTTP&#x2F;1.1 中的长连接。</li><li>发送请求：将构建好的 HTTP 请求报文发送给服务器。</li><li>接收响应：等待服务器返回响应报文，接收响应数据。</li><li>处理响应：对服务器返回的响应数据进行处理，包括状态码、响应头以及响应体等信息。</li><li>断开连接：根据 HTTP&#x2F;1.0 或者 HTTP&#x2F;1.1 的规定，关闭 TCP 连接。</li></ol><p>其中，建立连接和断开连接的过程是比较耗时的，影响了 HTTP 请求的性能。因此，为了提高 HTTP 请求的性能，可以使用 HTTP&#x2F;1.1 中的持久连接或者 HTTP&#x2F;2 中的多路复用等技术。</p><h2 id="Http-keep-alive会引起其他的什么问题？"><a href="#Http-keep-alive会引起其他的什么问题？" class="headerlink" title="Http keep-alive会引起其他的什么问题？"></a>Http keep-alive会引起其他的什么问题？</h2><p>HTTP Keep-Alive 是一种 HTTP&#x2F;1.1 中的持久连接技术，可以使客户端和服务器在同一个 TCP 连接上发送多个 HTTP 请求和响应，从而减少连接建立和关闭的开销，提高性能。</p><p>然而，HTTP Keep-Alive 也可能引起以下问题：</p><ol><li>服务器资源占用：当客户端和服务器之间的连接不关闭时，服务器需要一直维护这个连接，占用一定的资源。如果同时有大量客户端连接服务器，会导致服务器资源占用过多，影响服务器的性能。</li><li>网络拥塞：当客户端和服务器之间的连接不关闭时，会占用网络带宽，可能导致网络拥塞，影响网络性能。</li><li>安全性问题：HTTP Keep-Alive 可能会导致安全性问题，例如，当客户端和服务器之间的连接不关闭时，可能会被黑客利用进行攻击，例如，利用长连接进行 DoS 攻击或者发送恶意请求等。</li></ol><p>因此，在使用 HTTP Keep-Alive 技术时，需要合理设置连接的超时时间，以及采取一定的安全措施，避免出现以上问题。</p><h2 id="层叠上下文是什么？会展现什么效果？它的原理是什么呢？"><a href="#层叠上下文是什么？会展现什么效果？它的原理是什么呢？" class="headerlink" title="层叠上下文是什么？会展现什么效果？它的原理是什么呢？"></a>层叠上下文是什么？会展现什么效果？它的原理是什么呢？</h2><p>层叠上下文（stacking context）是指在 HTML 中，每个元素在页面上都有一个层级，而层叠上下文就是在这个层级中，某些元素在层叠上下文中拥有更高的优先级，能够覆盖在其他元素之上。</p><p>层叠上下文的出现会影响元素的显示效果，例如：</p><ol><li>z-index 属性：如果两个元素重叠在一起，可以通过设置它们的 z-index 值来确定哪个元素在上面显示，z-index 值越高的元素会覆盖在 z-index 值较低的元素之上。</li><li>透明度：如果父元素设置了透明度，那么子元素也会继承父元素的透明度，这时就需要用到层叠上下文来控制子元素的透明度。</li><li>position 属性：某些情况下，通过设置元素的 position 属性可以创建一个新的层叠上下文，从而影响元素的显示效果。</li></ol><p>层叠上下文的原理是：在 HTML 中，每个元素都有一个 z-index 属性，它用于控制元素在层级中的位置。当两个元素重叠在一起时，会根据它们的 z-index 值来确定哪个元素在上面显示。但是，有些元素会创建新的层叠上下文，它们的 z-index 值不再是与父元素的 z-index 值相对应，而是相对于整个页面的 z-index 值。这样，就可以通过设置元素的层叠上下文来控制元素在页面上的显示效果。</p><h2 id="什么是GPU加速？"><a href="#什么是GPU加速？" class="headerlink" title="什么是GPU加速？"></a>什么是GPU加速？</h2><p>GPU加速是指利用计算机的图形处理器（GPU）来加速图形和多媒体应用程序的运行。GPU加速可以提高应用程序的性能，减少CPU的负载，从而提高整个系统的响应速度。</p><p>在GPU加速中，GPU负责处理图形和多媒体数据，而CPU则负责处理其他计算任务。这样可以使系统资源得到更好的利用，提高系统的整体性能。</p><p>GPU加速的实现方式有多种，其中最常见的是使用OpenGL或DirectX等图形库来与GPU进行交互。另外，一些Web浏览器也支持GPU加速，可以加速网页的渲染和动画效果。</p><p>GPU加速可以应用于许多领域，例如游戏开发、视频编辑、3D建模等。随着计算机硬件和软件的不断发展，GPU加速的应用范围也越来越广泛。</p><h2 id="假如有个小球-每一秒往右移动1px，一是直接改margin-left，二是position：absolute-一点点加left，三是transition-translate-横轴一点点加，这三种哪一种性能最好？"><a href="#假如有个小球-每一秒往右移动1px，一是直接改margin-left，二是position：absolute-一点点加left，三是transition-translate-横轴一点点加，这三种哪一种性能最好？" class="headerlink" title="假如有个小球 每一秒往右移动1px，一是直接改margin-left，二是position：absolute 一点点加left，三是transition translate 横轴一点点加，这三种哪一种性能最好？"></a>假如有个小球 每一秒往右移动1px，一是直接改margin-left，二是position：absolute 一点点加left，三是transition translate 横轴一点点加，这三种哪一种性能最好？</h2><p>在这种情况下，使用 <code>transform</code> 和 <code>transition</code> 来移动小球的性能最好。因为这种方式利用了GPU加速，可以避免重排和重绘，从而提高了性能。相比之下，改变 <code>margin-left</code> 和使用 <code>position: absolute</code> 来移动小球，需要进行重排和重绘，性能较差。</p><h2 id="什么是变量提升？原理是什么？"><a href="#什么是变量提升？原理是什么？" class="headerlink" title="什么是变量提升？原理是什么？"></a>什么是变量提升？原理是什么？</h2><p>在JavaScript中，变量提升是指变量和函数的声明会被提升到作用域的顶部，无论实际声明的位置在哪里，这也被称为“提升到顶部”。也就是说，在执行代码之前，JavaScript引擎会扫描整个作用域，找出所有的变量和函数声明，并将它们提升到作用域的顶部，这样在代码执行时就可以访问它们了。</p><p>变量提升的原理是JavaScript引擎在解析代码时，会先处理变量和函数的声明，将它们存储在内存中，然后再执行代码。这样就可以让变量和函数在声明之前就可以被使用了。但是需要注意的是，只有声明会被提升，而不是赋值。因此，如果一个变量在声明之前被使用，它的值将为undefined。</p><h2 id="产生变量提升的原因？"><a href="#产生变量提升的原因？" class="headerlink" title="产生变量提升的原因？"></a>产生变量提升的原因？</h2><p>产生变量提升的原因是JavaScript引擎在解析代码时，会先处理变量和函数的声明，将它们存储在内存中，然后再执行代码。这是由于JavaScript的执行顺序是自上而下的，而变量和函数的声明在代码中可能出现在后面的位置。如果不进行变量提升，那么在使用变量或函数之前必须要先声明，否则会报错。通过变量提升，JavaScript引擎可以在代码执行之前就将变量和函数的声明提前到作用域的顶部，从而让变量和函数在声明之前就可以被使用了。</p><h2 id="什么是执行上下文？"><a href="#什么是执行上下文？" class="headerlink" title="什么是执行上下文？"></a>什么是执行上下文？</h2><p>JavaScript执行上下文是指JavaScript代码在执行时所处的环境，包括变量、函数声明、作用域链、this指向等。每当JavaScript代码开始执行时，都会创建一个新的执行上下文，并将其压入执行上下文栈（Execution Context Stack）中。当代码执行完成后，该执行上下文会被弹出栈并销毁。</p><p>执行上下文包括三种类型：</p><ol><li>全局执行上下文：在代码执行之前就会被创建，它是默认的最外层的执行上下文。</li><li>函数执行上下文：每当一个函数被调用时，都会创建一个新的函数执行上下文。</li><li>Eval执行上下文：eval()函数会在当前作用域中创建一个新的执行上下文。</li></ol><p>执行上下文中包含了当前代码所处的作用域链、变量对象、this指向等信息，这些信息会在代码执行时被用到，从而影响到代码的执行结果。</p><h2 id="词法作用域是什么？"><a href="#词法作用域是什么？" class="headerlink" title="词法作用域是什么？"></a>词法作用域是什么？</h2><p>词法作用域（Lexical Scope），也叫静态作用域，是指<strong>变量的作用域是在代码书写的时候就确定好的，而不是在运行时确定的</strong>。JavaScript就是一种基于词法作用域的语言。</p><p>在词法作用域中，变量的作用域是由函数嵌套关系来决定的。当函数被创建时，它的作用域链就被创建了，作用域链中包含了当前函数和所有嵌套的父级函数的变量对象。当函数执行时，它会先在自己的变量对象中查找变量，如果找不到，就会沿着作用域链一级一级地向上查找，直到找到为止，如果一直到全局作用域都没有找到，就会报错。</p><p>词法作用域的好处是可以避免变量名冲突，因为变量的作用域是在代码书写的时候就确定好的，不会受到运行时的影响。同时，也使得代码的可读性更高，因为变量的作用域是在代码书写的时候就可以看到的，不需要等到运行时才知道。</p><h2 id="环境变量和变量对象是什么？"><a href="#环境变量和变量对象是什么？" class="headerlink" title="环境变量和变量对象是什么？"></a>环境变量和变量对象是什么？</h2><p>环境变量和变量对象都是 JavaScript 中与作用域相关的概念。</p><p>环境变量（Environment Record）是指当前执行上下文中所有变量和函数的声明，以及外部环境的引用。每个执行上下文都有自己的环境变量，它们按照作用域链的顺序组成了一个链式结构，可以通过这个结构访问到所有的变量和函数。</p><p>变量对象（Variable Object）是指当前执行上下文中所有变量和函数的实际存储位置。在全局执行上下文中，变量对象就是全局对象；在函数执行上下文中，变量对象包含了函数的参数、函数声明、变量声明等。变量对象也是按照作用域链的顺序组成了一个链式结构，可以通过这个结构访问到所有的变量和函数。</p><p>在 JavaScript 中，环境变量和变量对象是密切相关的。当一个函数被调用时，会创建一个新的执行上下文，其中包含了一个新的环境变量和变量对象。在函数执行时，会使用环境变量来查找变量和函数的实际存储位置，也就是变量对象。当函数执行完毕后，执行上下文被销毁，其中的环境变量和变量对象也随之被销毁。</p><h2 id="TCP的发送速度是如何得到控制的？"><a href="#TCP的发送速度是如何得到控制的？" class="headerlink" title="TCP的发送速度是如何得到控制的？"></a>TCP的发送速度是如何得到控制的？</h2><ol><li>慢启动算法（Slow Start）：发送方刚开始发送数据时，先发送一小部分数据，然后根据收到的确认消息逐渐增加发送的数据量，以逐渐探测网络的拥塞情况。</li><li>拥塞避免算法（Congestion Avoidance）：当发现网络拥塞时，发送方就会进入拥塞避免阶段，此时发送方会将发送窗口的大小限制在一个较小的值范围内，以避免网络拥塞。</li><li>快重传算法（Fast Retransmit）：当发送方连续发送多个数据包时，如果接收方收到其中一个数据包有丢失或损坏，就会立即发送一个重复确认消息，告诉发送方需要重传该数据包。发送方收到这个重复确认消息后，就会立即重传该数据包，而不是等到超时后再重传，从而加快数据传输速度。</li><li>快恢复算法（Fast Recovery）：当发送方收到重复确认消息时，就会进入快恢复阶段，此时发送方会将发送窗口的大小减半，并重传丢失的数据包，以避免网络拥塞。</li><li>拥塞控制算法（Congestion Control）：TCP中还有一种全局的拥塞控制算法，它通过计算网络的拥塞程度来动态调整发送方的发送速度，以避免网络拥塞。常用的拥塞控制算法有TCP Reno、TCP Vegas、TCP New Reno等。</li></ol><h2 id="什么是CSS样式穿透？有哪些语法？"><a href="#什么是CSS样式穿透？有哪些语法？" class="headerlink" title="什么是CSS样式穿透？有哪些语法？"></a>什么是CSS样式穿透？有哪些语法？</h2><p>CSS样式穿透是指在CSS中，一个选择器可以影响到其他选择器的样式。它允许我们通过一个选择器来改变另一个选择器的样式，从而避免了在HTML中添加额外的类和ID。</p><p><code>&amp;</code>符号：在Less和Sass中，<code>&amp;</code>符号表示当前选择器的父级，可以将当前选择器和父级选择器合并在一起，这样可以影响到父级选择器的样式。例如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>  <span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">color</span>: white;<br>    <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>      <span class="hljs-attribute">background-color</span>: red;<br>      <span class="hljs-selector-class">.sibling</span> <span class="hljs-selector-tag">&amp;</span> &#123;<br>        <span class="hljs-attribute">color</span>: yellow;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="在TCP中有keep-alive，Vue也有keep-alive，Http也有keep-alive，它们都是指什么？"><a href="#在TCP中有keep-alive，Vue也有keep-alive，Http也有keep-alive，它们都是指什么？" class="headerlink" title="在TCP中有keep-alive，Vue也有keep-alive，Http也有keep-alive，它们都是指什么？"></a>在TCP中有keep-alive，Vue也有keep-alive，Http也有keep-alive，它们都是指什么？</h2><ol><li>在TCP协议中，keep-alive是一种保持连接的机制，可以在客户端和服务器之间保持长时间的空闲连接。当客户端和服务器之间没有数据传输时，keep-alive机制会发送一些探测包来检测对方是否还活着，从而确保连接的有效性。这个机制在一些长连接场景下比较常见，例如HTTP长连接、FTP数据传输等。</li><li>在Vue中，keep-alive是一个组件，可以将动态组件进行缓存，以便在切换时可以保留它们的状态或避免重新渲染。这个组件在一些需要频繁切换的场景下比较常见，例如Tab切换、路由切换等。</li><li>在HTTP协议中，keep-alive是一种持久连接机制，可以在客户端和服务器之间保持一个TCP连接，从而避免在每个HTTP请求之间重新建立TCP连接。这个机制可以减少连接建立和关闭的开销，提高HTTP请求的效率，尤其是在一些高并发的Web应用中。</li></ol><h2 id="不同域名指向同一个ip是否是同源的？"><a href="#不同域名指向同一个ip是否是同源的？" class="headerlink" title="不同域名指向同一个ip是否是同源的？"></a>不同域名指向同一个ip是否是同源的？</h2><p>不同域名指向同一个IP地址并不一定是同源的。同源策略是浏览器的一种安全策略，它是指只有当两个页面具有相同的协议、域名和端口号时，才允许这两个页面之间进行交互（例如访问彼此的DOM、Cookie等）。因此，如果两个页面的域名不同，即使它们指向同一个IP地址，也不会被认为是同源的。</p><p>但是，如果在同一个域名下使用不同的子域名（例如a.example.com和b.example.com）指向同一个IP地址，这种情况下它们被认为是同源的，因为它们具有相同的主域名。</p><p>总之，同源策略是根据协议、域名和端口号来判断是否允许跨域访问，而IP地址并不是同源策略的判断依据。</p><h2 id="DFS和BFS的使用场景？"><a href="#DFS和BFS的使用场景？" class="headerlink" title="DFS和BFS的使用场景？"></a>DFS和BFS的使用场景？</h2><p>DFS（深度优先搜索）和BFS（广度优先搜索）都是图遍历算法，它们的使用场景如下：</p><p>DFS使用场景：</p><ul><li>求解连通块问题</li><li>求解迷宫问题</li><li>求解拓扑排序问题</li><li>求解生成树问题</li><li>求解二叉树的遍历问题</li></ul><p>BFS使用场景：</p><ul><li>求解最短路径问题</li><li>求解连通块问题</li><li>求解迷宫问题</li><li>求解拓扑排序问题</li><li>求解生成树问题</li></ul><p>总的来说，DFS更适合解决深度优先的问题，BFS更适合解决广度优先的问题。在实际应用中，需要根据具体问题的特点选择合适的算法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>百度一面</title>
    <link href="/2023/04/12/%E7%99%BE%E5%BA%A6%E4%B8%80%E9%9D%A2/"/>
    <url>/2023/04/12/%E7%99%BE%E5%BA%A6%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="百度一面"><a href="#百度一面" class="headerlink" title="百度一面"></a>百度一面</h1><h2 id="介绍项目"><a href="#介绍项目" class="headerlink" title="介绍项目"></a>介绍项目</h2><h2 id="React如何实现路由缓存的？【项目】"><a href="#React如何实现路由缓存的？【项目】" class="headerlink" title="React如何实现路由缓存的？【项目】"></a><code>React</code>如何实现路由缓存的？【项目】</h2><h2 id="React路由权限控制【项目】"><a href="#React路由权限控制【项目】" class="headerlink" title="React路由权限控制【项目】"></a><code>React</code>路由权限控制【项目】</h2><h2 id="React-Hooks解决了什么问题？有什么优势和限制？"><a href="#React-Hooks解决了什么问题？有什么优势和限制？" class="headerlink" title="React Hooks解决了什么问题？有什么优势和限制？"></a><code>React Hooks</code>解决了什么问题？有什么优势和限制？</h2><p><code>React Hooks</code>解决了在函数组件中管理状态和副作用的问题。以前，函数组件是无状态的，不能使用生命周期方法和<code>state</code>，这意味着无法在函数组件中进行复杂的逻辑和状态管理。使用<code>React Hooks</code>，函数组件可以使用状态和生命周期方法，从而使函数组件具有类组件的能力。</p><p>优势：</p><ol><li>更简洁的代码：使用<code>React Hooks</code>可以减少代码量，使代码更易读。</li><li>更易于测试：使用<code>React Hooks</code>可以减少副作用和状态的耦合，使测试更容易。</li><li>更灵活的逻辑：使用<code>React Hooks</code>可以在函数组件中使用状态和生命周期方法，使逻辑更加灵活。</li><li>更好的性能：使用<code>React Hooks</code>可以减少组件的重新渲染，提高性能。</li></ol><p>限制：</p><ol><li>可能存在性能问题：使用<code>React Hooks</code>可能会导致某些性能问题，需要注意优化。</li><li>可能存在兼容性问题：使用<code>React Hooks</code>可能会存在兼容性问题，需要注意浏览器和React版本的兼容性。</li></ol><h2 id="React-Hooks在使用上有什么限制？"><a href="#React-Hooks在使用上有什么限制？" class="headerlink" title="React Hooks在使用上有什么限制？"></a>React Hooks在使用上有什么限制？</h2><ol><li>只能在函数组件中使用：React Hooks 只能在函数组件中使用，无法在类组件中使用。</li><li>不能在循环、条件语句中使用：React Hooks 必须按照固定的顺序调用，不能在循环、条件语句中使用。</li><li>使用时必须按照约定命名：使用 useState、useEffect 等 React Hooks 时必须按照约定命名，否则会导致无法正常使用。</li><li>不能在普通函数中使用：React Hooks 只能在函数组件中使用，不能在普通函数中使用。</li><li>不能在嵌套组件中使用：React Hooks 只能在最顶层的函数组件中使用，不能在嵌套组件中使用。</li><li>不能在条件渲染的分支中使用：React Hooks 必须在每次渲染时都按照相同的顺序调用，不能在条件渲染的分支中使用。</li><li>不能在 useEffect 中使用 async&#x2F;await：在 useEffect 中使用 async&#x2F;await 会导致一些问题，应该使用 Promise.then()。</li></ol><h2 id="为什么要使用类似React这种MVVM框架？为什么不直接使用原生前端开发？"><a href="#为什么要使用类似React这种MVVM框架？为什么不直接使用原生前端开发？" class="headerlink" title="为什么要使用类似React这种MVVM框架？为什么不直接使用原生前端开发？"></a>为什么要使用类似<code>React</code>这种<code>MVVM</code>框架？为什么不直接使用原生前端开发？</h2><p>使用类似 <code>React</code> 这种 <code>MVVM</code> 框架的主要原因是可以提高前端开发的效率和可维护性。以下是具体的原因：</p><ol><li>组件化开发：<code>React</code> 将页面拆分成多个组件，每个组件负责一部分功能，通过组合和嵌套组件来实现整个页面的功能。这样可以使代码更加模块化和可复用，提高开发效率和代码质量。</li><li>虚拟 DOM：<code>React</code> 使用虚拟 DOM 来代替直接操作 DOM，这样可以避免频繁的 DOM 操作，提高页面性能。</li><li>单向数据流：<code>React</code> 的数据流是单向的，从父组件传递到子组件，这样可以避免数据混乱和难以维护的问题。</li><li>模板语法：<code>React</code> 使用 JSX 语法，可以将组件和数据混合在一起，提高代码可读性和可维护性。</li><li>多平台支持：<code>React</code> 可以用于 Web 开发、移动端开发和桌面端开发，可以实现多平台的代码复用。</li></ol><h2 id="前端直接引入地图SDK会导致页面体积非常大，引起性能问题，如何解决？【项目】"><a href="#前端直接引入地图SDK会导致页面体积非常大，引起性能问题，如何解决？【项目】" class="headerlink" title="前端直接引入地图SDK会导致页面体积非常大，引起性能问题，如何解决？【项目】"></a>前端直接引入地图<code>SDK</code>会导致页面体积非常大，引起性能问题，如何解决？【项目】</h2><ol><li>懒加载：将地图 SDK 的引入延迟到需要使用地图的页面或组件中，这样可以减少页面初始加载时的体积，提高页面加载速度。</li><li>分包加载：将地图 SDK 的引入分离成一个单独的包，只有当用户需要使用地图时才会加载该包，这样可以减小页面的初始加载体积，并且可以使地图相关的代码更容易维护。</li><li>使用第三方库：使用第三方地图库，例如 <code>Mapbox</code>、<code>Leaflet</code> 等，这些库通常提供了更小的文件大小和更高效的加载方式，可以帮助减少页面体积和提高性能。</li><li>服务端渲染：使用服务端渲染技术，将地图相关的代码在服务端生成并输出 HTML，减少客户端的代码量和加载时间。</li><li>CDN 加速：使用 CDN 加速地图 SDK 的加载，可以减少服务器的负担和提高地图 SDK 的加载速度。</li></ol><h2 id="项目开发中遇到过哪些性能问题？如何解决？"><a href="#项目开发中遇到过哪些性能问题？如何解决？" class="headerlink" title="项目开发中遇到过哪些性能问题？如何解决？"></a>项目开发中遇到过哪些性能问题？如何解决？</h2><ol><li><p>首屏加载慢：当用户打开页面时，需要等待很长时间才能看到页面的内容。</p><p>解决方法：使用懒加载技术、减少 HTTP 请求、优化图片大小和格式、合理使用缓存等。</p></li><li><p>页面响应慢：当用户与页面进行交互时，页面响应时间很长，影响用户体验。</p><p>解决方法：使用异步加载技术、优化 JavaScript 代码、减少 DOM 操作、避免频繁的重排和重绘等。</p></li><li><p>大量的 HTTP 请求：当页面需要加载大量的资源时，会产生大量的 HTTP 请求，影响页面的加载速度。</p><p>解决方法：使用合并和压缩技术、使用 CDN 加速、使用 HTTP2 协议等。</p></li><li><p>大量的 JavaScript 和 CSS 文件：当页面需要加载大量的 JavaScript 和 CSS 文件时，也会影响页面的加载速度。</p><p>解决方法：使用合并和压缩技术、使用模块化开发、使用 CSS 预处理器等。</p></li><li><p>内存泄漏：当页面长时间运行时，可能会出现内存泄漏问题，导致页面变得越来越慢。</p><p>解决方法：使用垃圾回收机制、避免循环引用、及时释放不需要的资源等。</p></li></ol><h2 id="项目上线部署流程？"><a href="#项目上线部署流程？" class="headerlink" title="项目上线部署流程？"></a>项目上线部署流程？</h2><ol><li>打包：将前端项目打包成静态资源文件，例如 HTML、CSS、JavaScript、图片等。可以使用 Webpack、Gulp、Grunt 等工具进行打包。</li><li>上传到服务器：将打包好的静态资源文件上传到服务器上，可以使用 FTP、SFTP、SCP、rsync 等工具进行上传。</li><li>配置服务器：根据项目需要，对服务器进行配置，例如安装 Web 服务器、配置域名、SSL 证书、反向代理等。</li><li>启动服务：启动 Web 服务器并将静态资源文件部署到 Web 服务器上，例如使用 Nginx、Apache 等 Web 服务器。</li><li>测试和验证：测试和验证部署的 Web 服务器是否正常工作，例如访问网站、检查日志、排除错误等。</li><li>监控和维护：监控部署的 Web 服务器，确保其稳定运行，并及时处理出现的异常问题。</li></ol><h2 id="是否了解Node-js的EventEmitter事件机制-实现I-x2F-O非阻塞的基础-？"><a href="#是否了解Node-js的EventEmitter事件机制-实现I-x2F-O非阻塞的基础-？" class="headerlink" title="是否了解Node.js的EventEmitter事件机制(实现I&#x2F;O非阻塞的基础)？"></a>是否了解<code>Node.js</code>的<code>EventEmitter</code>事件机制(实现I&#x2F;O非阻塞的基础)？</h2><p><code>EventEmitter</code>是Node.js中一个重要的模块，它提供了一种事件机制，用于实现基于观察者模式的事件处理。它的主要作用是在对象之间建立一种松耦合的联系，使得一个对象在发生某个动作时，可以通知多个对象进行相应的处理。</p><p>在Node.js中，<code>EventEmitter</code>模块是一个核心模块，可以直接使用。使用<code>EventEmitter</code>模块，需要先创建一个事件对象，然后在需要的时候触发事件，并绑定相应的事件处理函数。</p><p>下面是一个简单的例子：</p><p>Copy</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyEmitter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">EventEmitter</span> &#123;&#125;<br><br><span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEmitter</span>();<br>myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;event&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;触发了事件&#x27;</span>);<br>&#125;);<br>myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;event&#x27;</span>);<br></code></pre></td></tr></table></figure><p>上述代码中，我们首先引入<code>events</code>模块，然后创建了一个自定义的事件类<code>MyEmitter</code>，并实例化它为<code>myEmitter</code>。接着，我们在<code>myEmitter</code>上绑定了一个<code>event</code>事件的处理函数，当事件被触发时，会输出<strong>触发了事件</strong>这个字符串。</p><p>在实际使用中，我们可以利用<code>EventEmitter</code>实现很多功能，例如实现自定义事件、异步处理、流处理等。在Node.js中，很多核心模块都是基于事件机制实现的，例如<code>http</code>模块、<code>fs</code>模块等。因此，熟练掌握<code>EventEmitter</code>机制对于Node.js开发非常重要。</p><h2 id="富文本编辑器的选取？"><a href="#富文本编辑器的选取？" class="headerlink" title="富文本编辑器的选取？"></a>富文本编辑器的选取？</h2><h2 id="浏览器输入url到页面渲染出来的整个详细流程？"><a href="#浏览器输入url到页面渲染出来的整个详细流程？" class="headerlink" title="浏览器输入url到页面渲染出来的整个详细流程？"></a>浏览器输入<code>url</code>到页面渲染出来的整个详细流程？</h2><ol><li>首先判断输入的内容是否为合法的域名，如果不是则作为关键字交给搜索引擎进行处理；如果域名中有非法字符则进行转义。</li><li>首先判断浏览器中是否有所需资源的缓存，如果有则直接使用，否则进行DNS查询获取域名对应的IP地址。</li><li>DNS查询<ol><li>判断本地的DNS缓存中是否有该IP地址，如果命中则返回</li><li>如果还是没有命中，则将域名发送到本地域名服务器，本地域名服务器采用递归查询自己的DNS服务器，查找成功则返回。</li><li>如果本地域名服务器的DNS缓存没有命中，则向上级域名服务器进行迭代查询<ul><li>首先本地域名服务器向根域名服务器进行请求，获取顶级域名服务器的地址给本地服务器。</li><li>本地域名服务器拿到这个顶级域名服务器后就想起发送请求，获取权威域名服务器的地址。</li><li>本地域名服务器向权威域名服务器发送请求，获取域名对应的IP地址。</li></ul></li><li>本地域名服务器将得到的IP地址发送给操作系统，同时自己将IP地址缓存起来。</li><li>操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来。</li><li>至此，浏览器得到了域名对应的IP地址，并将IP地址缓存起来。</li></ol></li><li>通过IP地址与本地的子网掩码相与，判断是否与请求主机在一个子网中，如果在一个子网中，则使用ARP协议获取目标主机的MAC地址，如果不在一个子网中，那么请求应该转发给网关，由它代为转发，此时同样可以通过ARP协议获取网关MAC地址，此时目的主机的MAC地址应该为网关地址。</li><li>进行TCP的三次握手</li><li>进行HTTPS握手</li><li><strong>返回数据</strong>：将网页请求发送至服务器端，服务器端返回一个html文件作为响应。浏览器接受响应后，开始对html文件进行解析并开始页面的渲染过程。</li><li><strong>页面渲染</strong>：根据html文件构建DOM树，根据解析到的css构建CSSOM树，如果遇到script标签，则判断有无async和defer属性，否则script的加载和执行会造成页面渲染的阻塞。当DOM树和CSSOM树建立好后，根据他们构建渲染树。渲染树构建好后，根据渲染树进行布局，然后使用浏览器的UI接口对页面进行绘制。此时整个页面就显示出来了。</li><li>TCP四次挥手</li></ol><h2 id="https加密的详细过程？在协商过程中使用的是什么加密？"><a href="#https加密的详细过程？在协商过程中使用的是什么加密？" class="headerlink" title="https加密的详细过程？在协商过程中使用的是什么加密？"></a><code>https</code>加密的详细过程？在协商过程中使用的是什么加密？</h2><ol><li>客户端发送请求：客户端向服务器发送一个HTTPS请求，请求中包含了协议版本、加密算法、随机数等信息。</li><li>服务器证书：服务器向客户端发送自己的证书，证书中包含了服务器公钥、证书颁发机构、证书有效期等信息。</li><li>客户端验证证书：客户端验证服务器证书的合法性，包括验证证书是否过期、证书颁发机构是否受信任、证书中的域名是否与服务器匹配等。</li><li>生成共享密钥：如果服务器证书验证通过，客户端会生成一个随机数作为共享密钥，并使用服务器的公钥加密该密钥，然后发送给服务器。</li><li>服务器解密共享密钥：服务器使用自己的私钥对客户端发送的共享密钥进行解密，得到共享密钥。</li><li>加密通信：客户端和服务器使用共享密钥进行加密通信，通信过程中的数据全部使用共享密钥进行加密和解密。</li></ol><h2 id="数据-HTML、CSS和JS等资源-返回到浏览器后的详细渲染过程？"><a href="#数据-HTML、CSS和JS等资源-返回到浏览器后的详细渲染过程？" class="headerlink" title="数据(HTML、CSS和JS等资源)返回到浏览器后的详细渲染过程？"></a>数据(<code>HTML</code>、<code>CSS</code>和<code>JS</code>等资源)返回到浏览器后的详细渲染过程？</h2><p>当浏览器收到HTML、CSS和JS等资源后，会进行以下渲染过程：</p><ol><li>解析HTML：浏览器会根据HTML文档的结构解析出文档树（DOM树），同时也会解析出CSS文档的样式规则（CSSOM树）。</li><li>构建渲染树：浏览器会将DOM树和CSSOM树结合起来构建渲染树（Render Tree），渲染树只包含需要显示的节点和样式信息。</li><li>布局：浏览器会根据渲染树中每个节点的布局信息（包括位置、大小等）计算出每个节点在屏幕上的位置。</li><li>绘制：浏览器会将渲染树中的每个节点绘制到屏幕上，形成最终的页面展示效果。</li><li>JS执行：如果HTML中包含了JS代码，浏览器会执行这些代码，可能会修改DOM树、CSSOM树以及渲染树等。</li></ol><h2 id="CSS中可以将元素建立单独渲染层，这是什么机制？-CSS中可以为一个元素提供GPU加速，是什么机制？"><a href="#CSS中可以将元素建立单独渲染层，这是什么机制？-CSS中可以为一个元素提供GPU加速，是什么机制？" class="headerlink" title="CSS中可以将元素建立单独渲染层，这是什么机制？(CSS中可以为一个元素提供GPU加速，是什么机制？)"></a><code>CSS</code>中可以将元素建立单独渲染层，这是什么机制？(<code>CSS</code>中可以为一个元素提供<code>GPU</code>加速，是什么机制？)</h2><p>在<code>CSS</code>中，可以通过设置某些属性，将元素建立单独的渲染层，这个机制被称为<strong>GPU加速</strong>或<strong>硬件加速</strong>。</p><p>GPU加速的原理是利用了现代计算机的硬件加速能力，将一些常规的<code>CPU</code>计算任务转移到<code>GPU</code>上进行处理。因为<code>GPU</code>的并行计算能力比<code>CPU</code>强大，所以可以加速页面的渲染速度，提高用户体验。</p><p>在<code>CSS</code>中，可以通过以下属性将元素建立单独的渲染层：</p><ol><li><code>transform</code>属性：通过<code>transform</code>属性对元素进行2D或3D变换，可以触发硬件加速。</li><li><code>opacity</code>属性：通过<code>opacity</code>属性设置元素的透明度，也可以触发硬件加速。</li><li><code>filter</code>属性：通过<code>filter</code>属性对元素进行滤镜效果，也可以触发硬件加速。</li><li><code>will-change</code>属性：通过<code>will-change</code>属性预先告知浏览器哪些属性将会被修改，可以让浏览器提前将元素建立单独的渲染层，从而加速页面渲染。</li></ol><p>需要注意的是，过度使用GPU加速可能会导致性能问题，因为GPU的资源也是有限的。在使用GPU加速时，需要根据实际情况进行优化，避免过度使用。</p><h2 id="有没有了解过TailWindCSS？"><a href="#有没有了解过TailWindCSS？" class="headerlink" title="有没有了解过TailWindCSS？"></a>有没有了解过<code>TailWindCSS</code>？</h2><p>Tailwind CSS是一个“实用优先”的CSS框架，它提供了一系列的样式类，可以用来快速地构建现代化的网站和应用程序。Tailwind CSS的设计理念是遵循“高度可定制”的原则，它提供了一组基础样式类，可以通过组合这些样式类来创建任意复杂度的布局和设计。</p><p>Tailwind CSS的核心思想是使用短小的、可重复使用的样式类来构建UI组件，而不是使用自定义样式表或者内联样式。这种方式可以大大减少代码的重复，并使得样式更易于维护和重构。</p><p>Tailwind CSS提供了一系列的样式类，覆盖了常见的UI组件和布局需求，例如：排版、背景、边框、文本、表格、按钮、表单、响应式布局等。此外，它还提供了一些实用的工具类，例如：间距、宽度、高度、颜色、字体等，可以帮助开发者快速地实现常用的样式效果。</p><p>使用Tailwind CSS可以大大提高开发效率，减少代码量，并且可以快速地构建出具有现代化风格的网站和应用程序。</p><h2 id="ES6有哪些新特性？"><a href="#ES6有哪些新特性？" class="headerlink" title="ES6有哪些新特性？"></a><code>ES6</code>有哪些新特性？</h2><h2 id="Map和WeakMap是基础数据类型吗？"><a href="#Map和WeakMap是基础数据类型吗？" class="headerlink" title="Map和WeakMap是基础数据类型吗？"></a><code>Map</code>和<code>WeakMap</code>是基础数据类型吗？</h2><p>不是，是引用数据类型。</p><h2 id="Map和WeakMap的区别？"><a href="#Map和WeakMap的区别？" class="headerlink" title="Map和WeakMap的区别？"></a><code>Map</code>和<code>WeakMap</code>的区别？</h2><p><code>Map</code>和<code>WeakMap</code>的主要区别在于键的引用类型和引用方式、键值对的垃圾回收机制、以及性能特点方面。</p><ol><li><p>键的引用类型和引用方式</p><p><code>Map</code>的键可以是任意类型的数据，包括基础数据类型和对象。而<code>WeakMap</code>的键必须是对象类型。由于<code>Map</code>的键是强引用的，所以即使键所对应的对象被删除，键值对依然存在。而<code>WeakMap</code>的键是弱引用的，当键所对应的对象被垃圾回收时，键值对也会自动被删除。</p></li><li><p>键值对的垃圾回收机制</p><p><code>Map</code>中的键值对不会被自动删除，只有在手动删除或<code>Map</code>对象被销毁时才会被清空。而<code>WeakMap</code>中的键值对会在键所对应的对象被垃圾回收时自动删除。</p></li><li><p>性能特点</p><p>由于<code>Map</code>的键是强引用的，所以<code>Map</code>的性能相对较高，但是在大量数据存储时，可能会占用较多的内存。而<code>WeakMap</code>的键是弱引用的，所以<code>WeakMap</code>的性能相对较低，但是可以更有效地管理内存，避免内存泄漏。</p></li></ol><p>综上所述，<code>Map</code>适用于需要长期存储大量数据的场景，而<code>WeakMap</code>适用于临时存储数据或需要更有效地管理内存的场景。</p><h2 id="weakMap使用场景？"><a href="#weakMap使用场景？" class="headerlink" title="weakMap使用场景？"></a>weakMap使用场景？</h2><ol><li><p>保护私有属性</p><p>在JavaScript中，对象的属性都是公开的，可以被其他代码访问和修改。但有时我们需要保护一些属性，使其不被外界访问和修改。使用WeakMap可以实现这个目的，因为WeakMap中的数据只能通过键访问，而且键是弱引用，不能被外界访问。</p></li><li><p>避免内存泄漏</p><p>使用WeakMap可以避免内存泄漏，因为WeakMap中的键是弱引用，当键所引用的对象被垃圾回收时，键也会被自动删除，从而避免内存泄漏。</p></li></ol><h2 id="弱引用的好处？使用场景？"><a href="#弱引用的好处？使用场景？" class="headerlink" title="弱引用的好处？使用场景？"></a>弱引用的好处？使用场景？</h2><h3 id="弱引用的优点"><a href="#弱引用的优点" class="headerlink" title="弱引用的优点"></a>弱引用的优点</h3><ol><li><p>避免内存泄漏</p><p>使用弱引用可以避免因为对象之间的循环引用而导致的内存泄漏。当一个对象不再被其他对象引用时，它会被垃圾回收器回收。如果一个对象被其他对象循环引用，即使它们都不再被程序使用，也不会被垃圾回收器回收，从而导致内存泄漏。使用弱引用可以避免这种情况。</p></li><li><p>优化性能</p><p>使用弱引用可以避免过度缓存，优化程序的性能。如果一个对象被缓存起来，但是在程序执行过程中很少被使用，却一直占用内存，会影响程序的性能。使用弱引用可以让缓存的对象在不使用时被垃圾回收器回收，避免浪费内存。</p></li><li><p>简化代码</p><p>使用弱引用可以简化代码，避免手动管理对象的生命周期。弱引用可以让程序自动管理对象的生命周期，减少代码的复杂度和出错的可能性。</p></li></ol><p>总之，弱引用是一种优化程序性能和避免内存泄漏的有效手段，它可以让程序更加健壮、高效和易于维护。</p><h3 id="弱引用使用场景"><a href="#弱引用使用场景" class="headerlink" title="弱引用使用场景"></a>弱引用使用场景</h3><ol><li><p>缓存</p><p>使用弱引用可以避免过度缓存，优化程序的性能。如果一个对象被缓存起来，但是在程序执行过程中很少被使用，却一直占用内存，会影响程序的性能。使用弱引用可以让缓存的对象在不使用时被垃圾回收器回收，避免浪费内存。</p></li><li><p>监听事件</p><p>使用弱引用可以避免因为监听事件而导致的内存泄漏。例如，当一个对象监听了另一个对象的事件，如果不及时取消监听，会导致对象之间的循环引用，从而导致内存泄漏。使用弱引用可以避免这种情况。</p></li><li><p>缓存DOM元素</p><p>在Web开发中，经常需要缓存DOM元素，以避免重复查询。但是，如果缓存的DOM元素不及时释放，会导致内存泄漏。使用弱引用可以避免这种情况，当DOM元素不再被使用时，会被自动释放。</p></li></ol><h2 id="对垃圾回收机制的理解？"><a href="#对垃圾回收机制的理解？" class="headerlink" title="对垃圾回收机制的理解？"></a>对垃圾回收机制的理解？</h2><p>JavaScript的垃圾回收机制是自动的，程序员不需要手动释放内存。垃圾回收机制的主要任务是识别不再使用的内存，然后释放它们，以便让系统可以重复使用这些内存。</p><p>JavaScript中的垃圾回收机制主要有两种方式：标记清除和引用计数。</p><ol><li><p>标记清除</p><p>标记清除是JavaScript中最常用的垃圾回收算法。它的原理是通过标记对象是否可达来判断对象是否还在使用中。当一个对象不再被使用时，垃圾回收器会将其标记为可回收对象，然后在下一次垃圾回收时将其回收。</p><p>标记清除算法的缺点是，当存在循环引用时，垃圾回收器无法判断哪些对象是可达的，哪些对象是不可达的，从而导致内存泄漏。</p></li><li><p>引用计数</p><p>引用计数是一种不常用的垃圾回收算法。它的原理是为每个对象维护一个引用计数器，当对象被引用时，计数器加1；当对象不再被引用时，计数器减1。当计数器为0时，垃圾回收器会将其回收。</p><p>引用计数算法的缺点是，它无法处理循环引用的情况，从而导致内存泄漏。</p></li></ol><p>JavaScript中的垃圾回收机制是自动的，程序员不需要手动释放内存。垃圾回收机制的主要任务是识别不再使用的内存，然后释放它们，以便让系统可以重复使用这些内存。在实际开发中，我们应该尽量避免循环引用的情况，以便让垃圾回收器更好地工作。</p><h2 id="写项目的时候有没有用到哪些设计模式使得代码更加利于修改？"><a href="#写项目的时候有没有用到哪些设计模式使得代码更加利于修改？" class="headerlink" title="写项目的时候有没有用到哪些设计模式使得代码更加利于修改？"></a>写项目的时候有没有用到哪些设计模式使得代码更加利于修改？</h2><ol><li><p>MVC（Model-View-Controller）模式</p><p>MVC模式是一种将应用程序分成三个核心部分的设计模式：模型（Model）、视图（View）和控制器（Controller）。这种模式可以使得代码更加清晰、易于维护和修改，也可以提高代码的重用性和可扩展性。</p></li><li><p>MVVM（Model-View-ViewModel）模式</p><p>MVVM模式是一种MVC模式的变体，它将控制器（Controller）替换为视图模型（ViewModel）。视图模型负责将模型数据转换为视图可以使用的数据，并且可以通过双向绑定来实现数据的自动更新，从而减少了手动操作DOM的代码量。</p></li><li><p>单例模式</p><p>单例模式是一种保证一个类只有一个实例的设计模式。在前端开发中，常用于管理全局状态或资源，例如全局配置、全局事件管理等。</p></li><li><p>装饰者模式</p><p>装饰者模式是一种在不改变原有对象的基础上，动态地给对象增加新的功能的设计模式。在前端开发中，常用于对原有组件进行功能扩展或增强。</p></li><li><p>观察者模式</p><p>观察者模式是一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖它的对象都会得到通知并自动更新。在前端开发中，常用于实现事件监听和发布-订阅模式。</p></li></ol><p>使用这些设计模式可以使前端项目的代码更加易于维护和修改，提高代码的重用性和可扩展性。但是，过度使用设计模式也会增加代码的复杂度，所以需要根据实际情况选择合适的设计模式。</p><h2 id="git合并commit有哪几种方式？"><a href="#git合并commit有哪几种方式？" class="headerlink" title="git合并commit有哪几种方式？"></a><code>git</code>合并<code>commit</code>有哪几种方式？</h2><p>git merge</p><p>git merge 会新建一个新的 commit 对象，然后两个分支以前的 commit 记录都指向这个新 commit 记录。这种方法会保留之前每个分支的 commit 历史。</p><p>git rebase</p><p>git rebase 会先找到两个分支的第一个共同的 commit 祖先记录，然后将提取当前分支这之后的所有 commit 记录，然后将这个 commit 记录添加到目标分支的最新提交后面。经过这个合并后，两个分支合并后的 commit 记录就变为了线性的记录了。</p><h2 id="有没有使用过单元测试工具或代码检查？"><a href="#有没有使用过单元测试工具或代码检查？" class="headerlink" title="有没有使用过单元测试工具或代码检查？"></a>有没有使用过单元测试工具或代码检查？</h2><ol><li>Jest：Facebook 开源的 JavaScript 测试框架，支持单元测试、集成测试和快照测试等。</li><li>Mocha：一个功能丰富的 JavaScript 测试框架，支持异步测试、前端和后端测试，以及 BDD 和 TDD 等测试风格。</li><li>Jasmine：一个行为驱动开发（BDD）框架，支持浏览器和 Node.js 等环境，可以进行单元测试、集成测试和端到端测试。</li><li>Karma：一个测试运行器，可以在多个浏览器和平台上运行测试，并支持与其他测试框架集成。</li><li>Enzyme：一个 React 组件测试工具，可以方便地进行组件渲染、事件模拟和快照测试等。</li><li>Ava：一个快速、轻量级的测试框架，支持并行测试和异步测试，可以在浏览器和 Node.js 等环境下运行。</li><li>Puppeteer：一个由 Google 开发的自动化测试工具，可以模拟用户操作和浏览器环境，用于进行端到端测试。</li><li>Cypress：一个端到端测试工具，具有自动重试、实时重载和可视化测试等功能，可以在浏览器中运行测试。</li></ol><h2 id="ESLint代码检查原理？"><a href="#ESLint代码检查原理？" class="headerlink" title="ESLint代码检查原理？"></a>ESLint代码检查原理？</h2><p>ESLint是一个开源的JavaScript代码检查工具，它可以检查代码的语法错误、代码风格、潜在的错误等。ESLint的核心原理是基于抽象语法树（AST）来检查代码。</p><p>ESLint会将代码解析成AST，然后通过遍历AST节点来检查代码，检查的规则由配置文件中的规则集合定义。ESLint的规则集合包括官方规则和第三方规则，可以根据需要自定义规则。</p><p>在检查代码时，ESLint会根据规则集合中的规则来判断代码是否符合规范，如果不符合则输出错误或警告信息。ESLint还支持自动修复代码中的一些问题，可以通过–fix选项来修复代码中的问题。</p><p>ESLint的检查原理可以总结为以下几个步骤：</p><ol><li>将代码解析成AST。</li><li>遍历AST节点，根据规则集合中的规则判断代码是否符合规范。</li><li>如果代码不符合规范，则输出错误或警告信息。</li><li>如果需要，可以通过–fix选项来自动修复代码中的问题。</li></ol><p>总之，ESLint的检查原理基于抽象语法树（AST）来检查代码，可以根据规则集合中的规则来判断代码是否符合规范。</p><h2 id="bebel将ES6转换为ES5的流程？"><a href="#bebel将ES6转换为ES5的流程？" class="headerlink" title="bebel将ES6转换为ES5的流程？"></a><code>bebel</code>将<code>ES6</code>转换为<code>ES5</code>的流程？</h2><ol><li>Babel首先读取ES6代码并将其转换为一个字符串。</li><li>然后，Babel使用解析器将字符串转换为AST。</li><li>Babel会遍历AST并应用配置的插件和预设来转换代码。每个插件都会检查AST节点并决定是否需要修改它。如果需要修改，插件会返回新的AST节点以替换原来的节点。</li><li>转换后，Babel会将AST转换回代码字符串。</li><li>最后，Babel会将ES5代码写入文件或输出到控制台。</li></ol><h2 id="设计一个Button组件，要求点击按钮发起一个POST请求，当请求结束后通知给父组件。"><a href="#设计一个Button组件，要求点击按钮发起一个POST请求，当请求结束后通知给父组件。" class="headerlink" title="设计一个Button组件，要求点击按钮发起一个POST请求，当请求结束后通知给父组件。"></a>设计一个<code>Button</code>组件，要求点击按钮发起一个<code>POST</code>请求，当请求结束后通知给父组件。</h2><ul><li>该请求耗时很长</li><li><code>POST</code>请求非幂等</li></ul><p>以下是一个简单的React <code>Button</code>组件的实现，满足上述要求：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> [loading, setLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(props.<span class="hljs-property">url</span>, &#123;<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>        <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(props.<span class="hljs-property">data</span>),<br>        <span class="hljs-attr">headers</span>: &#123;<br>          <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>        &#125;<br>      &#125;);<br>      <span class="hljs-keyword">if</span> (response.<span class="hljs-property">ok</span>) &#123;<br>        props.<span class="hljs-title function_">onSuccess</span>();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        props.<span class="hljs-title function_">onError</span>();<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      props.<span class="hljs-title function_">onError</span>();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>);<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span> <span class="hljs-attr">disabled</span>=<span class="hljs-string">&#123;loading&#125;</span>&gt;</span></span><br><span class="language-xml">      &#123;loading ? &#x27;Loading...&#x27; : props.label&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Button</span>;<br></code></pre></td></tr></table></figure><p>该组件接受以下属性：</p><ul><li><code>url</code>：<code>POST</code>请求的URL。</li><li><code>data</code>：要发送的数据。</li><li><code>label</code>：按钮上显示的文本。</li><li><code>onSuccess</code>：请求成功后的回调函数。</li><li><code>onError</code>：请求失败后的回调函数。</li></ul><p>该组件使用了React的状态钩子来管理按钮的加载状态，当按钮被点击时，它会设置<code>loading</code>状态为<code>true</code>并发起<code>POST</code>请求。如果请求成功，它会调用<code>props.onSuccess</code>回调函数，否则调用<code>props.onError</code>回调函数。无论请求成功与否，它都会将<code>loading</code>状态设置为<code>false</code>，以使按钮再次可用。</p><p>该组件可以在父组件中使用，如下所示：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Button&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSuccess</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Request succeeded!&#x27;</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleError</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Request failed!&#x27;</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;https://example.com/api&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">name:</span> &#x27;<span class="hljs-attr">John</span>&#x27; &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;Submit&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onSuccess</span>=<span class="hljs-string">&#123;handleSuccess&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onError</span>=<span class="hljs-string">&#123;handleError&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p>在这个例子中，当<code>Button</code>被点击时，它会向<code>https://example.com/api</code>发送一个<code>POST</code>请求，并将<code>&#123; name: &#39;John&#39; &#125;</code>作为请求体。如果请求成功，它会弹出一个消息框显示<code>Request succeeded!</code>，否则显示<code>Request failed!</code>。注意，这个例子并没有考虑请求的幂等性和请求耗时较长的情况，这些问题需要根据具体情况进行处理。</p><h2 id="了解过哪些前端新知识？"><a href="#了解过哪些前端新知识？" class="headerlink" title="了解过哪些前端新知识？"></a>了解过哪些前端新知识？</h2>]]></content>
    
    
    
    <tags>
      
      <tag>前端|面经</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识点整理(6)</title>
    <link href="/2023/04/12/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-6/"/>
    <url>/2023/04/12/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-6/</url>
    
    <content type="html"><![CDATA[<h1 id="知识点整理-6"><a href="#知识点整理-6" class="headerlink" title="知识点整理(6)"></a>知识点整理(6)</h1><h2 id="callback、Promise和async-x2F-await三者间的区别？"><a href="#callback、Promise和async-x2F-await三者间的区别？" class="headerlink" title="callback、Promise和async&#x2F;await三者间的区别？"></a>callback、Promise和async&#x2F;await三者间的区别？</h2><ol><li>callback是一种传统的处理异步操作的方式，通过将一个函数作为参数传递给另一个函数，在异步操作完成后调用该函数来处理异步操作的结果。callback的缺点是，<strong>如果嵌套过多，会形成回调地狱，代码难以维护</strong>。</li><li>Promise是ES6中提出的一种处理异步操作的方式，它可以更好地处理异步操作的结果。Promise可以链式调用，避免了回调地狱的问题，同时还可以更好地处理错误。Promise有三种状态：pending、fulfilled和rejected，可以通过then()和catch()方法来处理异步操作的结果。</li><li>async&#x2F;await是ES8中提出的一种基于Promise的异步编程方式。async函数返回一个Promise对象，可以使用await关键字来等待异步操作的结果，使得异步代码看起来更像同步代码。async&#x2F;await通过将异步操作转换为同步操作来实现异步编程的效果。</li></ol><h2 id="如何避免样式干扰？"><a href="#如何避免样式干扰？" class="headerlink" title="如何避免样式干扰？"></a>如何避免样式干扰？</h2><p>样式干扰通常是由于CSS选择器不当或者CSS权重过高导致的。</p><p>以下是几种防止样式干扰的方法：</p><ol><li>使用更具体的CSS选择器：使用更具体的CSS选择器可以减少样式冲突的风险。例如，使用类选择器 <code>.my-component .my-button</code> 而不是 <code>.my-button</code> 。</li><li>使用CSS模块化：CSS模块化可以将CSS代码封装在组件内，避免全局样式的污染。例如，使用CSS Modules或CSS-in-JS等技术。</li><li>使用CSS预处理器：CSS预处理器可以帮助我们编写更清晰、更易维护的CSS代码，并且可以避免CSS选择器的冲突。例如，使用Less、Sass等预处理器。</li><li>使用CSS命名规范：使用一致的CSS命名规范可以避免命名冲突。例如，使用BEM命名规范。</li><li>使用!important规则：使用!important规则可以提高CSS样式的权重，但是应该尽量避免使用它。如果必须使用!important规则，应该将其用在极少数情况下，并确保它不会影响其他组件的样式。</li></ol><h2 id="使用CSS的动画属性-animation和translate-会引起回流和重绘吗？"><a href="#使用CSS的动画属性-animation和translate-会引起回流和重绘吗？" class="headerlink" title="使用CSS的动画属性(animation和translate)会引起回流和重绘吗？"></a>使用CSS的动画属性(animation和translate)会引起回流和重绘吗？</h2><p><code>animation</code>属性可以通过改变元素的位置、大小、颜色等属性来实现动画效果，这些改变会导致元素的布局（位置和大小）和绘制（颜色和背景）属性发生变化，因此可能会引起回流和重绘。</p><p><code>translate</code>属性可以通过改变元素的位置来实现动画效果，这些改变也会导致元素的布局属性发生变化，因此可能会引起回流。</p><p>然而，相对于其他属性（如改变元素的宽高），使用<code>translate</code>属性进行动画效果的性能更高，因为它只会引起元素的复合（Compositing）和绘制（Painting），而不会引起布局（Layout）的改变，从而减少了回流的可能性。因此，建议在实现动画效果时尽可能使用<code>translate</code>属性。</p><h2 id="JS如何阻止冒泡？"><a href="#JS如何阻止冒泡？" class="headerlink" title="JS如何阻止冒泡？"></a>JS如何阻止冒泡？</h2><p>在JS中，可以使用<code>event.stopPropagation()</code>方法来阻止事件冒泡。</p><p>事件冒泡是指当一个元素上的事件被触发时，该事件会向上冒泡到父元素，直到冒泡到文档根节点为止。如果希望阻止事件冒泡，可以在事件处理函数中使用<code>event.stopPropagation()</code>方法来阻止事件继续向上冒泡。</p><p>例如，以下代码可以阻止按钮点击事件冒泡到父元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.parent&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Parent element clicked.&#x27;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.child&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Child element clicked.&#x27;</span>);<br>  event.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// 阻止事件冒泡</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>在上面的代码中，当点击子元素时，<code>event.stopPropagation()</code>方法会阻止事件继续向上冒泡到父元素，因此只会触发子元素的点击事件处理函数，而不会触发父元素的点击事件处理函数。</p><h2 id="怎么设置padding、border不会撑开盒子？"><a href="#怎么设置padding、border不会撑开盒子？" class="headerlink" title="怎么设置padding、border不会撑开盒子？"></a>怎么设置padding、border不会撑开盒子？</h2><p>如果要设置<code>padding</code>和<code>border</code>不会撑开盒子，可以使用<code>box-sizing</code>属性来改变盒模型的计算方式。默认情况下，盒模型的计算方式是<code>content-box</code>(标准盒模型)，即宽度只包括内容区域，不包括内边距和边框。而如果将<code>box-sizing</code>属性设置为<code>border-box</code>(怪异盒模型)，则宽度包括内容区域、内边距和边框的宽度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: border-box; <span class="hljs-comment">/* 将盒模型设置为border-box */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样设置之后，元素的实际宽度就是200px，包括内边距和边框的宽度。而不会因为内边距和边框的宽度而撑开盒子。</p><h2 id="常用的Webpack-plugin有哪些？"><a href="#常用的Webpack-plugin有哪些？" class="headerlink" title="常用的Webpack plugin有哪些？"></a>常用的Webpack plugin有哪些？</h2><ol><li>HtmlWebpackPlugin：自动生成HTML文件，包括引入打包后的JS、CSS文件等。</li><li>MiniCssExtractPlugin：将CSS从打包后的JS中分离出来，生成单独的CSS文件。</li><li>CleanWebpackPlugin：在每次打包时清除之前生成的文件。</li><li>CopyWebpackPlugin：将文件从源目录复制到目标目录。</li><li>DefinePlugin：定义全局变量，可以在代码中直接使用。</li><li>UglifyJsPlugin：压缩JS代码，减小文件体积。</li><li>HotModuleReplacementPlugin：实现热更新，修改代码后无需刷新页面即可看到效果。</li><li>ExtractTextWebpackPlugin：将CSS从打包后的JS中分离出来，生成单独的CSS文件。</li><li>ProvidePlugin：自动加载模块，无需import或require。</li><li>BundleAnalyzerPlugin：分析打包后的文件大小，找出体积较大的模块。</li></ol><h2 id="CSS如何隐藏元素？"><a href="#CSS如何隐藏元素？" class="headerlink" title="CSS如何隐藏元素？"></a>CSS如何隐藏元素？</h2><ul><li><code>diaplay: none</code>：元素从页面移除，不占用空间，但是会破坏文档流，影响其他元素布局。</li><li><code>visibility: hidden</code>：元素隐藏，但是不会从文档流移除，仍然占用空间。</li><li><code>opacity: 0</code>：元素透明度设置为0，但是仍然占用空间，也会被屏幕阅读器识别。</li><li><code>position: absolute</code>，将元素移动到屏幕外面，不会影响布局，但是仍然占用空间，也会被屏幕阅读器识别。</li></ul><h2 id="前端性能优化的过程和具体方法？"><a href="#前端性能优化的过程和具体方法？" class="headerlink" title="前端性能优化的过程和具体方法？"></a>前端性能优化的过程和具体方法？</h2><p>前端性能优化的过程可以分为以下几个步骤：</p><ol><li>分析性能瓶颈：使用浏览器的开发者工具或第三方工具来分析页面性能，例如 Chrome DevTools、Lighthouse、PageSpeed Insights 等。</li><li>识别优化机会：根据分析结果，识别出需要优化的关键资源，例如 JavaScript、CSS、图片等。</li><li>制定优化策略：根据优化机会，制定相应的优化策略，例如缩小文件大小、减少 HTTP 请求、使用缓存等。</li><li>实施优化方案：根据制定的优化策略，实施具体的优化方案。</li><li>测试和监控：对优化后的页面进行测试和监控，确保优化效果。</li></ol><p>具体的优化方法包括：</p><ol><li>压缩代码：使用压缩工具压缩 JavaScript、CSS、HTML 代码，减小文件大小，加快加载速度。</li><li>减少 HTTP 请求：将多个小文件合并为一个大文件，减少 HTTP 请求次数。</li><li>使用缓存：使用浏览器缓存或服务器缓存来减少文件加载时间。</li><li>延迟加载：将不必要的资源延迟加载，例如图片、视频等。</li><li>使用图片压缩：使用图片压缩工具将图片压缩，减小文件大小，加快加载速度。</li><li>使用 CDN：使用 CDN（内容分发网络）来加速文件加载速度。</li><li>使用 Web Workers：使用 Web Workers 来在后台运行 JavaScript 代码，提高页面响应速度。</li><li>避免重排和重绘：避免频繁的 DOM 操作和样式修改，减少浏览器的重排和重绘次数。</li><li>使用异步加载：使用异步加载技术，例如 async 和 defer 属性来加快页面加载速度。</li><li>优化图片大小：使用合适的图片格式和尺寸，减小图片大小，加快加载速度。</li></ol><h2 id="如何监控性能指标？"><a href="#如何监控性能指标？" class="headerlink" title="如何监控性能指标？"></a>如何监控性能指标？</h2><p>前端监控性能指标可以通过以下几种方式实现：</p><ol><li>使用浏览器自带的开发者工具，如Chrome DevTools、Firefox Developer Tools等，通过Performance面板可以监控页面的加载、解析、渲染等过程的性能指标，如网络请求时间、DOMContentLoaded时间、首次渲染时间等。</li><li>使用第三方性能监控工具，如Google Analytics、New Relic、AppDynamics等，这些工具可以在网站代码中嵌入一段JavaScript代码，通过前端代码监控页面的性能指标，并将数据发送到后台进行分析和展示。</li><li>使用性能指标监控库，如Performance.js、Metrics.js等，这些库可以通过JavaScript代码监控页面的性能指标，并提供API接口让开发者可以自定义监控指标和展示方式。</li><li>使用前端性能监控服务，如SpeedCurve、Pingdom等，这些服务可以在多个地点模拟用户访问网站，并监控页面的性能指标，同时提供报告和分析工具，帮助开发者优化页面性能。</li></ol><h2 id="Webpack5有哪些新特性？"><a href="#Webpack5有哪些新特性？" class="headerlink" title="Webpack5有哪些新特性？"></a>Webpack5有哪些新特性？</h2><ol><li>支持Module Federation：Module Federation是Webpack5中的一个新特性，它允许多个独立的Webpack构建共享模块，从而实现跨域共享模块的能力。</li><li>支持持久化缓存：Webpack5引入了持久化缓存，可以将编译过程中的中间结果缓存到本地磁盘上，从而提高二次构建的速度。</li><li>支持WebAssembly：Webpack5对WebAssembly提供了原生支持，可以将WebAssembly模块打包为单独的chunk，从而提高应用程序的性能。</li><li>支持Tree Shaking优化：Webpack5对Tree Shaking优化进行了改进，可以更精确地识别和移除无用代码。</li><li>支持Top-level await：Webpack5支持Top-level await，可以在模块顶层使用await关键字，从而简化异步代码的写法。</li></ol><h2 id="Webpack4相比3有哪些新特性？"><a href="#Webpack4相比3有哪些新特性？" class="headerlink" title="Webpack4相比3有哪些新特性？"></a>Webpack4相比3有哪些新特性？</h2><ol><li>Webpack4引入了Mode选项，可以通过设置Mode为development或production来自动启用不同的优化策略。</li><li>Webpack4<strong>对代码分割进行了优化，可以更好地支持动态导入和异步加载</strong>。</li><li>Webpack4<strong>对性能优化进行了改进，可以更快地进行编译和构建</strong>。</li><li>Webpack4支持多种文件格式的导入和导出，如JSON、WebAssembly等。</li><li>Webpack4对API进行了改进，提供了更好的插件和Loader接口。</li></ol><h2 id="Webpack3更新了哪些？"><a href="#Webpack3更新了哪些？" class="headerlink" title="Webpack3更新了哪些？"></a>Webpack3更新了哪些？</h2><ol><li><strong>Scope Hoisting</strong>：Webpack3引入了Scope Hoisting功能，可以将模块的作用域提升，从而减少代码量，提高性能。</li><li>Magic Comments：Webpack3支持Magic Comments，可以通过在代码中添加特殊注释来控制chunk的生成和命名。</li><li><strong>动态import</strong>：Webpack3支持动态import，可以在运行时动态加载模块，从而提高应用程序的性能和灵活性。</li><li>CommonChunkPlugin：Webpack3对CommonChunkPlugin进行了优化，可以更灵活地配置和使用。</li><li>Loader Options：Webpack3引入了Loader Options功能，可以在配置文件中为Loader设置选项，从而更方便地进行定制化配置。</li><li>NamedModulesPlugin：Webpack3引入了NamedModulesPlugin插件，可以为模块和chunk生成可读性更好的名称。</li><li><strong>配置文件优化</strong>：Webpack3对配置文件进行了优化，可以更方便地进行模块解析、路径映射、文件处理等操作。</li></ol><h2 id="Webpack3、4、5版本有哪些差异？"><a href="#Webpack3、4、5版本有哪些差异？" class="headerlink" title="Webpack3、4、5版本有哪些差异？"></a>Webpack3、4、5版本有哪些差异？</h2><ol><li>性能：Webpack4和Webpack5相比于Webpack3，在构建速度和性能优化方面有了很大的提升，尤其是Webpack5更加注重性能优化，引入了持久化缓存和Module Federation等功能。</li><li>模块热替换：Webpack4和Webpack5相比于Webpack3，在模块热替换方面有所改进，提供了更好的开发体验。</li><li>Tree Shaking：Webpack4和Webpack5相比于Webpack3，在Tree Shaking方面有了更好的支持，可以更精确地识别和移除无用代码。</li><li>Mode选项：Webpack4引入了Mode选项，可以通过设置Mode为development或production来自动启用不同的优化策略。</li><li>WebAssembly：Webpack5对WebAssembly提供了原生支持，可以将WebAssembly模块打包为单独的chunk，从而提高应用程序的性能。</li><li>Top-level await：Webpack5支持Top-level await，可以在模块顶层使用await关键字，从而简化异步代码的写法。</li><li>插件和Loader：Webpack4和Webpack5相比于Webpack3，在插件和Loader方面提供了更好的接口和扩展性。</li></ol><h2 id="JS常用的压缩工具？"><a href="#JS常用的压缩工具？" class="headerlink" title="JS常用的压缩工具？"></a>JS常用的压缩工具？</h2><ol><li>UglifyJS：UglifyJS是一个广泛使用的JavaScript压缩工具，它可以将JavaScript代码压缩成更小、更高效的形式，从而提高网页的性能。它支持ES6语法，并且可以在命令行或者作为Gulp、Grunt等构建工具的插件使用。</li><li>Closure Compiler：Closure Compiler是Google开发的JavaScript压缩工具，可以将JavaScript代码压缩成更小的形式，并且可以进行代码优化和错误检查。它支持ES6语法和模块化，并且可以在命令行或者作为Gulp、Grunt等构建工具的插件使用。</li><li>Babel-minify：Babel-minify是一个基于Babel的JavaScript压缩工具，可以将JavaScript代码压缩成更小、更高效的形式。它支持ES6语法和模块化，并且可以在命令行或者作为Gulp、Grunt等构建工具的插件使用。</li><li>Terser：Terser是一个JavaScript压缩工具，可以将JavaScript代码压缩成更小、更高效的形式。它支持ES6语法和模块化，并且可以在命令行或者作为Gulp、Grunt等构建工具的插件使用。</li></ol><h2 id="JS进行压缩的原理是什么？"><a href="#JS进行压缩的原理是什么？" class="headerlink" title="JS进行压缩的原理是什么？"></a>JS进行压缩的原理是什么？</h2><p>JS压缩的原理是通过<strong>删除JavaScript代码中的空格、注释、不必要的分号和换行符等无用字符</strong>，以及<strong>将变量名、函数名等重复的内容替换成更短的名称</strong>来减小文件大小。这样可以<strong>减少文件的加载时间和网络传输的流量，提高网页的性能</strong>。</p><p>JS压缩工具一般分为两种压缩方式：</p><ol><li>基于词法分析的压缩方式：这种方式通过对JavaScript代码进行词法分析，找出其中的关键字、变量名、函数名等，然后将其替换成更短的名称，同时删除无用的字符和注释，从而减小文件大小。常用的JS压缩工具如UglifyJS和Closure Compiler都是基于词法分析的压缩方式。</li><li>基于语法分析的压缩方式：这种方式通过对JavaScript代码进行语法分析，找出其中的无用代码、重复代码等，然后将其删除或合并，同时进行变量名、函数名等的替换和删除无用的字符和注释，从而减小文件大小。常用的JS压缩工具如Babel-minify和Terser都是基于语法分析的压缩方式。</li></ol><h2 id="UglifyJS和Terser的区别？"><a href="#UglifyJS和Terser的区别？" class="headerlink" title="UglifyJS和Terser的区别？"></a>UglifyJS和Terser的区别？</h2><ol><li>压缩效率：Terser相对于UglifyJS来说，能够更好地压缩JavaScript代码，生成的压缩文件体积更小。</li><li>ES6+支持：Terser支持ES6+语法，包括箭头函数、模板字符串、解构赋值等，而UglifyJS只支持ES5语法。</li><li>代码质量：Terser生成的代码质量更高，更容易维护和调试，而UglifyJS在某些情况下可能会生成一些难以阅读的代码。</li><li>插件支持：Terser支持插件机制，可以使用插件对JavaScript代码进行更细致的优化和压缩，而UglifyJS没有插件机制。</li><li>平台支持：Terser支持多种平台，包括Node.js、浏览器、Webpack等，而UglifyJS主要是针对浏览器环境进行优化。</li></ol><h2 id="为什么Terser压缩的代码更小？"><a href="#为什么Terser压缩的代码更小？" class="headerlink" title="为什么Terser压缩的代码更小？"></a>为什么Terser压缩的代码更小？</h2><ol><li>更好的算法：Terser采用了更先进的压缩算法，例如更好的代码分析和优化，更多的死代码消除等，能够更好地识别和删除不必要的代码，从而生成更小的压缩文件。</li><li>ES6+支持：Terser能够支持ES6+语法，包括箭头函数、模板字符串、解构赋值等，能够更好地处理新的语法特性，从而生成更小的压缩文件。</li><li>代码优化：Terser能够对代码进行更深入的优化，例如内联函数、变量重命名、常量替换等，从而进一步减小代码体积。</li></ol><h2 id="什么是SSR？"><a href="#什么是SSR？" class="headerlink" title="什么是SSR？"></a>什么是SSR？</h2><p>SSR，全称为Server Side Rendering，即服务器端渲染。它是指在<strong>服务器端生成HTML代码，然后将其发送到浏览器端进行展示</strong>的一种技术。</p><p>在传统的前端开发中，所有的HTML、CSS和JavaScript代码都是在浏览器端进行渲染的，这种方式被称作客户端渲染（CSR）。但是，随着Web应用程序的复杂性不断增加，客户端渲染会带来一些问题，例如：</p><ol><li>首屏加载慢：因为需要等待所有的JavaScript代码加载完成后才能进行页面渲染，用户需要等待较长时间才能看到页面内容。</li><li>SEO不友好：由于搜索引擎爬虫无法执行JavaScript代码，因此客户端渲染的页面对SEO不友好。</li><li>用户体验差：由于需要等待JavaScript代码加载完成后才能进行页面渲染，因此会出现白屏或者Loading页面，用户体验较差。</li></ol><p>SSR技术就是为了解决这些问题而提出的。通过在服务器端生成HTML代码，可以<strong>大大缩短首屏加载时间，提高SEO友好性，改善用户体验</strong>。同时，由于服务器端生成的HTML代码已经包含了页面内容，因此<strong>不需要等待JavaScript代码加载完成，可以直接展示给用户</strong>。</p><h2 id="执行npm-install后发生了什么？"><a href="#执行npm-install后发生了什么？" class="headerlink" title="执行npm install后发生了什么？"></a>执行npm install后发生了什么？</h2><ol><li>检查package.json文件，确定需要安装的模块和版本号。</li><li>从npm仓库中下载指定版本的模块，并将其存储在本地的node_modules目录中。</li><li>如果package.json文件中定义了依赖关系，npm会递归地安装这些依赖模块，直到所有的依赖关系都被满足。</li><li>如果package.json文件中定义了开发环境依赖关系，npm会将这些模块安装在node_modules&#x2F;.dev目录中，而不是node_modules目录中。</li><li>如果npm在安装过程中发现了与当前包管理器版本不兼容的模块，它会尝试自动修复这些模块。</li><li>安装完成后，npm会在本地生成一个package-lock.json文件，用于记录所有安装的模块及其版本号，以便在以后重新安装时保证一致性。</li></ol><h2 id="执行npm-run-start后发生了什么？"><a href="#执行npm-run-start后发生了什么？" class="headerlink" title="执行npm run start后发生了什么？"></a>执行npm run start后发生了什么？</h2><ol><li>npm会查找package.json文件中scripts对象中名为”start”的脚本，并执行该脚本命令。</li><li>根据scripts对象中的”start”命令，npm会执行相应的命令，如”node server.js”或”webpack-dev-server”等。</li><li>如果”start”命令中包含了其他命令，如”prestart”或”poststart”，npm会先执行这些命令，再执行”start”命令。</li><li>如果”start”命令中包含了环境变量，npm会将这些变量传递给执行的命令。</li><li>如果在执行过程中出现错误，npm会显示相应的错误信息，并停止执行。</li></ol><h2 id="前端如何适配手机端？怎么知道当前设备是手机端？"><a href="#前端如何适配手机端？怎么知道当前设备是手机端？" class="headerlink" title="前端如何适配手机端？怎么知道当前设备是手机端？"></a>前端如何适配手机端？怎么知道当前设备是手机端？</h2><p>前端适配手机端主要有以下几种方式：</p><ol><li>使用响应式设计：通过CSS3的媒体查询，根据不同的屏幕尺寸和设备类型，动态调整网页布局和样式。</li><li>使用移动端框架：如Bootstrap、Foundation、Ant Design Mobile等，这些框架提供了一些常用的组件和布局，可以快速构建移动端应用。</li><li>使用Viewport：设置Viewport的meta标签，可以让网页自适应不同的设备屏幕尺寸。</li><li>使用Flexbox布局：使用Flexbox布局可以更方便地实现自适应布局。</li><li>通过JavaScript判断设备类型：可以通过navigator.userAgent判断当前设备的类型和浏览器信息，从而根据不同的设备类型，选择不同的布局和样式。</li></ol><p>判断当前设备是手机端，可以通过以下几种方式：</p><ol><li>使用CSS3的媒体查询，根据不同的屏幕尺寸和设备类型，判断当前设备是手机端还是PC端。</li><li>使用JavaScript判断设备类型，通过navigator.userAgent判断当前设备的类型和浏览器信息，从而判断当前设备是手机端还是PC端。</li><li>使用第三方库或工具，如Device.js、Detector.js等，这些库可以根据设备类型、分辨率、屏幕尺寸等信息，判断当前设备是手机端还是PC端。</li></ol><h2 id="什么是SEO？"><a href="#什么是SEO？" class="headerlink" title="什么是SEO？"></a>什么是SEO？</h2><p>SEO（Search Engine Optimization）是指通过各种技术手段，优化网站结构、内容、外部链接等因素，提高网站在搜索引擎中的排名，从而获得更多的有机流量和用户。SEO主要分为以下几个方面：</p><ol><li>网站结构优化：包括网站的URL结构、页面标题、Meta标签、HTML标签等的优化，以便搜索引擎更好地理解和抓取网站内容。</li><li>内容优化：包括网站内容的质量、关键词密度、标题、描述、图片等的优化，以提高网站的相关性和权威性。</li><li>外部链接优化：包括外部链接的质量、数量、来源、锚文本等的优化，以提高网站的权重和流量。</li><li>移动端优化：包括网站的响应式设计、页面加载速度、移动端友好性等的优化，以适应移动互联网时代的需求。</li><li>社交媒体优化：包括网站在社交媒体上的活跃度、分享度、关注度等的优化，以提高网站的曝光度和口碑效应。</li></ol><p>SEO的优化需要综合考虑多个因素，包括用户体验、搜索引擎算法、竞争对手等，需要长期持续地进行优化和调整。</p><h2 id="SEO的优化有哪些方法？"><a href="#SEO的优化有哪些方法？" class="headerlink" title="SEO的优化有哪些方法？"></a>SEO的优化有哪些方法？</h2><ol><li>关键词优化：通过研究用户搜索行为和竞争对手情况，确定关键词，并将其合理地分布在网站的标题、内容、Meta标签等位置，以提高网站的相关性和排名。</li><li>内容优化：通过提高网站内容的质量和原创性，增加关键词密度和标题、描述等元素的优化，以提高网站的权威性和吸引力。</li><li>网站结构优化：通过优化网站的URL、HTML标签、网站结构等，使搜索引擎更好地识别和抓取网站内容，提高网站的可访问性和相关性。</li><li>外部链接优化：通过获取高质量的外部链接，提高网站的权重和流量，并避免使用无效或违规的链接方式。</li><li>移动端优化：通过响应式设计、页面加载速度、移动端友好性等方式，提高移动端用户的体验和访问量。</li><li>社交媒体优化：通过在社交媒体上活跃、分享、关注等方式，提高网站的曝光度和口碑效应。</li></ol><h2 id="如何正则匹配一个手机号？"><a href="#如何正则匹配一个手机号？" class="headerlink" title="如何正则匹配一个手机号？"></a>如何正则匹配一个手机号？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">^<span class="hljs-number">1</span>[<span class="hljs-number">3</span>-<span class="hljs-number">9</span>]\d&#123;<span class="hljs-number">9</span>&#125;$<br></code></pre></td></tr></table></figure><ul><li><code>^</code> 表示字符串开始位置</li><li><code>1</code> 表示手机号码的第一位必须为1</li><li><code>[3-9]</code> 表示手机号码的第二位可以是3-9中的任意一个数字</li><li><code>\d&#123;9&#125;</code> 表示手机号码的后9位必须是数字</li><li><code>$</code> 表示字符串结束位置</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识点整理(5)</title>
    <link href="/2023/04/11/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-5/"/>
    <url>/2023/04/11/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-5/</url>
    
    <content type="html"><![CDATA[<h1 id="知识点整理-5"><a href="#知识点整理-5" class="headerlink" title="知识点整理(5)"></a>知识点整理(5)</h1><h2 id="在多线程的情况下如何保证线程安全？"><a href="#在多线程的情况下如何保证线程安全？" class="headerlink" title="在多线程的情况下如何保证线程安全？"></a>在多线程的情况下如何保证线程安全？</h2><ol><li>加锁：使用锁机制来保护共享资源，确保同一时间只有一个线程可以访问共享资源，其他线程需要等待锁释放后才能访问。</li><li>使用原子操作：原子操作是不可被中断的操作，可以保证多线程访问共享资源时的原子性，避免数据不一致的问题。</li><li>使用线程安全的数据结构：如ConcurrentHashMap、CopyOnWriteArrayList等，这些数据结构是线程安全的，多个线程可以同时访问并修改其中的元素，不需要加锁。</li><li>使用volatile关键字：volatile关键字可以保证变量在多线程中的可见性，即一个线程修改了变量的值，其他线程可以立即看到修改后的值。</li><li>避免共享资源：尽量避免多个线程访问共享资源，可以采用线程本地存储（ThreadLocal）等方式来避免共享资源的访问冲突。</li></ol><h2 id="线程有哪几种状态？"><a href="#线程有哪几种状态？" class="headerlink" title="线程有哪几种状态？"></a>线程有哪几种状态？</h2><ol><li>新建状态（New）：当线程对象被创建时，它就处于新建状态，此时它还没有被启动。</li><li>就绪状态（Runnable）：当线程被调用start()方法后，它进入就绪状态，表示它已经准备好运行，等待系统分配资源。</li><li>运行状态（Running）：当系统分配到资源后，线程就进入运行状态，开始执行run()方法中的代码。</li><li>阻塞状态（Blocked）：当线程等待某个操作完成或等待某个资源时，它进入阻塞状态，暂时停止执行。</li><li>等待状态（Waiting）：当线程执行某个操作后，需要等待另一个线程或操作完成时，它进入等待状态，调用wait()或join()方法时，线程就会进入等待状态。</li><li>超时等待状态（Timed Waiting）：当线程执行某个操作后，需要等待一段时间后再继续执行时，它进入超时等待状态，调用sleep()、wait(long)或join(long)等方法时，线程就会进入超时等待状态。</li><li>终止状态（Terminated）：当线程执行完run()方法后，它就进入终止状态，线程执行结束，不再继续执行。</li></ol><h2 id="超时重传机制的原理？"><a href="#超时重传机制的原理？" class="headerlink" title="超时重传机制的原理？"></a>超时重传机制的原理？</h2><blockquote><p>超时重传机制是指在网络通信中，当发送方发送数据后，如果没有收到确认应答或者收到了错误的应答，就会触发超时重传机制，重新发送数据。</p></blockquote><ol><li>发送数据：发送方将数据发送给接收方，并启动计时器，等待接收方的应答。</li><li>接收应答：接收方接收到数据后，向发送方发送应答信息，表示已经收到数据。</li><li>超时计时器：发送方启动一个计时器，等待接收方的应答。如果在规定的时间内没有收到应答，就认为数据丢失或超时，触发超时重传机制。</li><li>重传数据：发送方重新发送数据，等待接收方的应答。</li><li>停止计时器：当发送方收到接收方的应答后，停止计时器，表示数据已经成功发送。如果在规定的时间内没有收到应答，就会重新触发超时重传机制。</li></ol><h2 id="TLS是如何保证可靠传输的？"><a href="#TLS是如何保证可靠传输的？" class="headerlink" title="TLS是如何保证可靠传输的？"></a>TLS是如何保证可靠传输的？</h2><blockquote><p>TLS（Transport Layer Security）是一种加密协议，用于保护网络通信中的数据安全性和完整性。它是SSL（Secure Sockets Layer）协议的继任者。</p></blockquote><p>TLS使用公钥加密技术和数字证书来确保通信的安全性。它采用了对称加密和非对称加密的组合方式来保护通信的内容和身份验证。通信双方首先通过握手协议交换密钥，然后使用这些密钥对数据进行加密和解密。</p><ol><li>加密通信：TLS使用对称加密算法来加密通信内容，保护数据的机密性。</li><li>数据完整性：TLS使用消息认证码（MAC）来保证数据的完整性，防止数据被篡改或损坏。</li><li>身份验证：TLS使用数字证书来进行身份验证，确保通信双方的身份是合法的。</li><li>防止重放攻击：TLS使用时间戳和随机数来防止重放攻击，确保通信的实时性。</li></ol><h2 id="React为什么要使用虚拟DOM？"><a href="#React为什么要使用虚拟DOM？" class="headerlink" title="React为什么要使用虚拟DOM？"></a>React为什么要使用虚拟DOM？</h2><p>提高性能和开发效率。</p><p>传统的DOM操作是非常耗费性能的，因为每次更新DOM都需要重新计算布局、绘制等操作，而且频繁的DOM操作会导致页面卡顿和性能下降。而虚拟DOM是在内存中维护一个虚拟的DOM树，通过对比新旧虚拟DOM树的差异，最终只更新需要更新的部分，从而减少DOM操作次数，提高性能。</p><p>此外，使用虚拟DOM还可以提高开发效率。开发者可以通过JSX语法编写组件，将组件的状态和属性传递给虚拟DOM，React会根据虚拟DOM自动更新组件的状态，从而减少了手动操作DOM的代码量，提高了开发效率。</p><h2 id="什么是React-Fiber？"><a href="#什么是React-Fiber？" class="headerlink" title="什么是React Fiber？"></a>什么是React Fiber？</h2><p>React Fiber是React v16中引入的一种新的协调引擎，用于重新设计和实现React的核心算法。它的目标是提高React的性能、灵活性和可扩展性。</p><p>React v15在渲染时,会递归比对 VirtualDOM树，找出需要变动的节点步更新它过程期间， React会占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，导致用户感觉到卡顿。</p><p>为了给用户制造一种应用很快的”假象”，不能让一个任务长期霸占着资源。可以将浏览器的渲染、布局、绘制、资源载、事件响应、脚本执行视作操作系统的”进程”，需要通过某些调策略合理地分配CPU资源，从而提高浏览器的用户响应速率，同时兼顾任务执行效率。</p><p>React通过Fiber架构，让这个执行过程变得可中断。适时的让出CPU执行权，除了可以让浏览器及时的响应用户的交互，还有一些好处：</p><ul><li>分批延时的对DOM进行操作，避免一次性操作大量DOM节点，可以获得更好的用户体验。</li><li>给浏览器一些喘息的机会，它会对代码进行编译优化 ( JIT ) 及热代码优化，或对 reflow 进行修正。</li></ul><p>React Fiber的主要特点包括：</p><ol><li>可中断的渲染：React Fiber可以在渲染过程中暂停、中断和恢复渲染，以支持更高优先级的任务，如动画和用户输入。</li><li>渐进式渲染：React Fiber可以将渲染过程分为多个阶段，并在每个阶段中执行一部分工作，以避免长时间的阻塞，提高用户体验。</li><li>异步渲染：React Fiber可以在不同的时间段内执行渲染，以支持异步渲染和服务器端渲染等场景。</li><li>更好的错误处理：React Fiber可以更好地捕获和处理错误，以提高应用程序的健壮性和可靠性。</li></ol><h2 id="React为什么要引入Hooks？Hooks的优势和劣势？"><a href="#React为什么要引入Hooks？Hooks的优势和劣势？" class="headerlink" title="React为什么要引入Hooks？Hooks的优势和劣势？"></a>React为什么要引入Hooks？Hooks的优势和劣势？</h2><p>React引入Hooks的主要原因是为了解决<strong>组件之间复用状态逻辑</strong>的问题。</p><p>在React之前，组件之间复用状态逻辑通常需要使用高阶组件、render props等技术，这些技术增加了组件的复杂性和理解难度，同时也不够直观和自然。而Hooks可以让组件之间复用状态逻辑变得更加简单和直观，同时可以提高代码的重用性和可读性。</p><p>优势：</p><ol><li>更少的代码量：使用Hooks可以<strong>减少组件之间的重复代码，提高代码的重用性</strong>，同时也可以提高代码的可读性和可维护性。</li><li>更好的逻辑复用：使用Hooks可以将状态逻辑从组件中抽离出来，使得逻辑复用更加自然和简单。</li><li>更好的测试性：使用Hooks可以更容易地编写和执行单元测试，以保证代码的质量和稳定性。</li></ol><p>劣势：</p><ol><li>学习曲线：使用Hooks需要掌握一些新的概念和用法，对于初学者来说可能需要一定的学习曲线。</li><li>兼容性问题：Hooks是在React v16.8中引入的，需要React 16.8或更高版本才能使用，如果项目中使用的是旧版本的React，需要升级React版本才能使用Hooks。</li></ol><h2 id="操作DOM的时候，如何给节点添加兄弟节点？"><a href="#操作DOM的时候，如何给节点添加兄弟节点？" class="headerlink" title="操作DOM的时候，如何给节点添加兄弟节点？"></a>操作DOM的时候，如何给节点添加兄弟节点？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取当前元素</span><br><span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;box&quot;</span>);<br><span class="hljs-comment">// 创建新元素</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;a&quot;</span>);<br><span class="hljs-comment">// 设置元素内容</span><br>a.<span class="hljs-property">href</span> = <span class="hljs-string">&quot;www.abc.com&quot;</span>;<br>a.<span class="hljs-property">innerText</span> = <span class="hljs-string">&quot;ABC&quot;</span>;<br><span class="hljs-comment">// 添加元素到box中</span><br>box.<span class="hljs-title function_">appendChildren</span>(a); <span class="hljs-comment">// 给父元素添加子元素</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;p&quot;</span>);<br>box.<span class="hljs-title function_">insertBefore</span>(p, a); <span class="hljs-comment">// 假设box中存在p元素，在p元素前面插入a元素</span><br><span class="hljs-comment">// 获取克隆元素</span><br><span class="hljs-keyword">const</span> cloneP = p.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 默认参数为false,是狗采用深度克隆</span><br>box.<span class="hljs-title function_">appendChild</span>(cloneP);<br></code></pre></td></tr></table></figure><h2 id="appendChild的实现原理？"><a href="#appendChild的实现原理？" class="headerlink" title="appendChild的实现原理？"></a>appendChild的实现原理？</h2><ol><li>首先，检查要添加的子节点是否是一个DOM节点，如果不是则抛出一个错误。</li><li>然后，检查要添加的子节点是否已经是一个父节点的子节点，如果是则将子节点从原来的父节点中移除。</li><li>最后，将子节点添加到指定的父节点的子节点列表的末尾。</li></ol><p>在添加子节点的过程中，<strong>appendChild()方法会自动更新父节点、子节点和兄弟节点的引用关系。同时，appendChild()方法也会自动更新文档的布局和渲染</strong>，因此需要谨慎使用，以避免频繁的DOM操作导致性能下降。</p><p>appendChild()方法只能将一个节点添加到一个父节点中，如果要添加多个节点，需要多次调用appendChild()方法。</p><p>在插入子节点的过程中，insertBefore()方法会自动更新父节点、子节点和兄弟节点的引用关系。同时，insertBefore()方法也会自动更新文档的布局和渲染，因此需要谨慎使用，以避免频繁的DOM操作导致性能下降。</p><p>需要注意的是，如果要将一个节点插入到一个父节点的子节点列表的末尾，可以使用appendChild()方法。如果要将一个节点插入到指定位置，可以使用insertBefore()方法。</p><ol><li>首先，检查要插入的子节点是否是一个DOM节点，如果不是则抛出一个错误。</li><li>然后，检查要插入的参考节点是否是一个子节点，如果不是则抛出一个错误。</li><li>接着，检查要插入的子节点是否已经是一个父节点的子节点，如果是则将子节点从原来的父节点中移除。</li><li>最后，将子节点插入到指定的位置，即参考节点的前面。</li></ol><p>在插入子节点的过程中，insertBefore()方法会自动更新父节点、子节点和兄弟节点的引用关系。同时，insertBefore()方法也会自动更新文档的布局和渲染，因此需要谨慎使用，以避免频繁的DOM操作导致性能下降。</p><p>如果要将一个节点插入到一个父节点的子节点列表的末尾，可以使用appendChild()方法。如果要将一个节点插入到指定位置，可以使用insertBefore()方法。</p><h2 id="代码懒加载的实现原理？"><a href="#代码懒加载的实现原理？" class="headerlink" title="代码懒加载的实现原理？"></a>代码懒加载的实现原理？</h2><blockquote><p>代码懒加载（Code Splitting）是一种优化网页性能的技术，它的原理是将网页的代码分割成多个小块，只在需要时才加载这些小块，从而提高网页的加载速度和性能。</p></blockquote><p>代码懒加载的实现原理如下：</p><ol><li>将网页的代码分割成多个小块，每个小块对应一个模块或页面组件。</li><li>在网页加载时，只加载必要的代码块，其他代码块暂时不加载。</li><li>当用户访问到需要使用某个模块或组件时，再动态加载对应的代码块。</li><li>加载完成后，将新的模块或组件插入到网页中，从而实现懒加载效果。</li></ol><p>代码懒加载可以使用Webpack等工具来实现。Webpack可以将网页的代码分割成多个小块，并使用动态import()语法来实现懒加载。当Webpack打包代码时，会将代码分割成多个小块，并生成多个独立的文件。在网页加载时，只加载必要的代码块，其他代码块暂时不加载。当用户需要访问某个模块或组件时，再动态加载对应的代码块，并将它插入到网页中。</p><p>代码懒加载可以大大提高网页的性能和用户体验，特别是在移动设备等网络环境不佳的情况下。</p><h2 id="git-amend命令的作用？"><a href="#git-amend命令的作用？" class="headerlink" title="git amend命令的作用？"></a>git amend命令的作用？</h2><p>git amend命令是Git版本控制系统中的一个命令，用于修改最后一次提交的信息或者将缺失的文件添加到最后一次提交中。</p><p>具体来说，git amend命令可以用于以下两种情况：</p><ol><li><p>修改最后一次提交的信息：如果最后一次提交的信息存在错误或者需要进行修改，可以使用git amend命令来修改。具体操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit --amend<br></code></pre></td></tr></table></figure><p>在执行上述命令之后，Git会打开默认编辑器，让你修改最后一次提交的信息。修改完成后，保存并关闭编辑器即可。</p></li><li><p>将缺失的文件添加到最后一次提交中：如果最后一次提交中漏掉了某个文件，可以使用git amend命令将该文件添加到最后一次提交中。具体操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add missed_file<br>$ git commit --amend<br></code></pre></td></tr></table></figure><p>在执行上述命令之后，Git会将missed_file文件添加到最后一次提交中。</p></li></ol><p>需要注意的是，使用git amend命令修改最后一次提交的信息或者添加缺失的文件，会改变Git仓库的历史记录，因此需要谨慎使用。</p><h2 id="instanceof有什么缺点？"><a href="#instanceof有什么缺点？" class="headerlink" title="instanceof有什么缺点？"></a>instanceof有什么缺点？</h2><ol><li>instanceof无法检测基本数据类型：instanceof只能检测对象类型，对于基本数据类型（如number、string、boolean等）无法进行检测。</li><li>instanceof无法检测null和undefined：当使用instanceof检测null或undefined时，会抛出TypeError错误。</li><li>instanceof无法检测继承自同一父类的对象：如果两个不同的对象继承自同一个父类，那么使用instanceof检测时会返回true，这可能会导致一些问题。</li><li>instanceof无法检测跨iframe的对象：当对象跨越不同的iframe时，使用instanceof检测时会返回false，这是因为不同的iframe拥有不同的全局环境。</li><li>instanceof无法检测自定义对象：如果没有正确地实现对象的原型链，那么使用instanceof检测时可能会出现错误的结果。</li></ol><h2 id="如何根据元素的class提取元素？"><a href="#如何根据元素的class提取元素？" class="headerlink" title="如何根据元素的class提取元素？"></a>如何根据元素的class提取元素？</h2><ol><li><p>getElementByClassName方法：这个方法可以通过class名称获取一组元素，返回的是一个类数组对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;class-name&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>querySelectorAll方法：这个方法可以通过CSS选择器获取一组元素，返回的是一个NodeList对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.class-name&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>getElementsByTagname方法结合class属性：这个方法可以通过标签名获取一组元素，然后结合class属性进行筛选。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-keyword">var</span> result = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; elements.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-keyword">if</span> (elements[i].<span class="hljs-property">className</span> === <span class="hljs-string">&#x27;class-name&#x27;</span>) &#123;<br>    result.<span class="hljs-title function_">push</span>(elements[i]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="递归有什么缺陷？"><a href="#递归有什么缺陷？" class="headerlink" title="递归有什么缺陷？"></a>递归有什么缺陷？</h2><ol><li>内存消耗大：递归需要在执行过程中不断地压入和弹出栈帧，这会消耗大量的内存空间。如果递归层数过多，可能会导致栈溢出。</li><li>性能低下：递归需要不断地进行函数调用和返回，这会消耗大量的CPU时间。如果递归次数过多，可能会导致程序运行缓慢。</li><li>可读性差：递归算法通常比较难理解和调试，代码可读性较差。</li><li>可能导致死循环：如果递归函数没有正确地终止条件，可能会导致死循环，使程序无法正常运行。</li></ol><h2 id="如何解决递归的缺陷？"><a href="#如何解决递归的缺陷？" class="headerlink" title="如何解决递归的缺陷？"></a>如何解决递归的缺陷？</h2><ol><li>限制递归深度：通过限制递归深度，可以避免栈溢出的问题。可以在递归函数中加入一个计数器或者设置一个最大深度，当达到指定深度时，停止递归。</li><li>尾递归优化：尾递归是一种特殊的递归形式，在尾递归中，递归调用是函数体中的最后一条语句。尾递归可以通过将当前状态作为参数传递给递归函数，从而避免不必要的栈帧压入和弹出操作，从而提高了效率。</li><li>使用迭代代替递归：在某些情况下，可以使用循环等其他算法代替递归，从而提高效率和可读性。</li><li>优化递归算法：对递归算法进行优化，如使用记忆化搜索等技术，可以大幅提高递归算法的效率。</li></ol><h2 id="事件循环中的宏任务和微任务分别有哪些？"><a href="#事件循环中的宏任务和微任务分别有哪些？" class="headerlink" title="事件循环中的宏任务和微任务分别有哪些？"></a>事件循环中的宏任务和微任务分别有哪些？</h2><p>宏任务（macro task）：</p><ol><li>script（整体代码）</li><li>setTimeout</li><li>setInterval</li><li>setImmediate（仅在IE和Edge浏览器中支持）</li><li>I&#x2F;O操作</li><li>UI交互事件（如click、keyup等）</li><li>requestAnimationFrame（动画效果）</li></ol><p>微任务（micro task）：</p><ol><li>Promise.then&#x2F;catch&#x2F;finally</li><li>MutationObserver</li><li>process.nextTick（仅在Node.js环境中支持）</li></ol><p>在事件循环中，每次执行完一个宏任务后，会先执行所有的微任务，然后再执行下一个宏任务。因此，微任务的执行优先级高于宏任务。</p><p>需要注意的是，虽然Promise.then&#x2F;catch&#x2F;finally属于微任务，但是Promise的构造函数是属于宏任务的。当创建一个Promise对象时，Promise的构造函数会立即执行，而then&#x2F;catch&#x2F;finally中的回调函数则是微任务。</p><h2 id="什么是混入？"><a href="#什么是混入？" class="headerlink" title="什么是混入？"></a>什么是混入？</h2><p>混入（Mixin）是一种在面向对象编程中，通过将多个类的属性和方法“混合”到一个类中来扩展该类功能的方式。</p><p>混入可以在不修改原有类的情况下，为该类添加新的功能。在JavaScript中，混入可以通过对象的复制、原型继承、类继承等方式来实现。</p><p>具体来说，混入可以通过以下几个步骤来实现：</p><ol><li>定义一个混入对象，该对象包含要混入的属性和方法。</li><li>在需要混入的类中，通过复制、继承等方式将混入对象的属性和方法“混合”到该类中。</li><li>使用混入后的类，即可享受到混入对象中扩展的功能。</li></ol><p>混入可以使代码更加模块化、灵活，可以避免代码冗余和重复。但是，在使用混入时，需要注意命名冲突和属性覆盖等问题，避免出现不必要的错误和bug。</p><h2 id="为什么typeof-NaN返回的是Number"><a href="#为什么typeof-NaN返回的是Number" class="headerlink" title="为什么typeof NaN返回的是Number?"></a>为什么typeof NaN返回的是Number?</h2><p>因为NaN是一种特殊的数值，它表示一个非数值的数值（Not-a-Number）。虽然NaN不是一个有效的数值，但它仍然属于数值类型，因此typeof NaN返回的是Number。</p><p>需要注意的是，虽然NaN属于数值类型，但它与任何值都不相等，包括它本身。这是因为NaN与任何值都不相等的特殊规定。因此，在比较值是否相等时，需要特别注意NaN的情况。可以使用isNaN函数来判断一个值是否为NaN。</p><h2 id="JS中Number的最大值返回的是什么？"><a href="#JS中Number的最大值返回的是什么？" class="headerlink" title="JS中Number的最大值返回的是什么？"></a>JS中Number的最大值返回的是什么？</h2><p>Number类型的最大值可以通过Number.MAX_VALUE常量获取，该常量的值接近于1.79e+308。超过这个值的数值将被表示为Infinity（正无穷）。</p><p>例如，可以使用以下代码来检查Number类型的最大值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span>); <span class="hljs-comment">// 输出1.7976931348623157e+308</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 输出Infinity</span><br></code></pre></td></tr></table></figure><p>需要注意的是，JavaScript中的Number类型是一种双精度浮点数，它的表示范围和精度是有限的，不能精确表示所有的数值。在进行数值计算时，需要特别注意数值的精度和范围，避免出现不必要的错误。</p><h2 id="对JS中继承的理解？"><a href="#对JS中继承的理解？" class="headerlink" title="对JS中继承的理解？"></a>对JS中继承的理解？</h2><p>一个对象（子类）可以从另一个对象（父类）继承属性和方法。子类可以使用父类的方法和属性，也可以添加自己的方法和属性。JS中的继承可以通过原型链实现，子类的原型指向父类的实例，这样子类就可以继承父类的属性和方法。另外，ES6中也提供了class关键字来实现继承。子类通过extends关键字继承父类，并可以使用super关键字来调用父类的方法和属性。继承在JS中是非常常见的概念，它可以提高代码的复用性和可维护性。</p><h2 id="实现继承有哪些方式？"><a href="#实现继承有哪些方式？" class="headerlink" title="实现继承有哪些方式？"></a>实现继承有哪些方式？</h2><ol><li><p>原型链继承</p><p>原型链继承是通过将父类的实例作为子类的原型来实现继承。这种方法的缺点是子类实例共享父类实例的属性和方法，无法实现多继承。</p></li><li><p>借用构造函数继承</p><p>借用构造函数继承是通过在子类构造函数中调用父类构造函数来实现继承。这种方法的缺点是无法继承父类原型上的属性和方法。</p></li><li><p>组合继承</p><p>组合继承是通过将原型链继承和借用构造函数继承结合起来实现继承。这种方法的缺点是在创建子类实例时会调用两次父类构造函数，造成一定的性能浪费。</p></li><li><p>原型式继承</p><p>原型式继承是通过创建一个临时的构造函数，将父类实例作为该构造函数的原型，然后返回该构造函数的实例来实现继承。这种方法的缺点是无法传递参数，无法实现多继承。</p></li><li><p>寄生式继承</p><p>寄生式继承是通过在原型式继承的基础上，对实例进行扩展来实现继承。这种方法的缺点也是无法传递参数，无法实现多继承。</p></li><li><p>寄生组合式继承</p><p>寄生组合式继承是通过在组合继承的基础上，优化父类构造函数的调用，来实现继承。这种方法的优点是既能够继承父类原型上的属性和方法，又能够避免调用两次父类构造函数，性能更优。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识点整理(4)</title>
    <link href="/2023/04/10/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-4/"/>
    <url>/2023/04/10/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-4/</url>
    
    <content type="html"><![CDATA[<h1 id="知识点整理-4"><a href="#知识点整理-4" class="headerlink" title="知识点整理(4)"></a>知识点整理(4)</h1><h2 id="颜色转换-十六进制转换RGB格式"><a href="#颜色转换-十六进制转换RGB格式" class="headerlink" title="颜色转换: 十六进制转换RGB格式"></a>颜色转换: 十六进制转换RGB格式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">hexToRgb</span> = (<span class="hljs-params">hex</span>) =&gt; &#123;<br>    hex = hex.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^#/</span>, <span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 去除前面的#</span><br>    <span class="hljs-keyword">const</span> r = <span class="hljs-built_in">parseInt</span>(hex.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>), <span class="hljs-number">16</span>); <br>    <span class="hljs-keyword">const</span> g = <span class="hljs-built_in">parseInt</span>(hex.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>), <span class="hljs-number">16</span>);<br>    <span class="hljs-keyword">const</span> b = <span class="hljs-built_in">parseInt</span>(hex.<span class="hljs-title function_">substring</span>(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>), <span class="hljs-number">16</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`rgb(<span class="hljs-subst">$&#123;r&#125;</span>, <span class="hljs-subst">$&#123;g&#125;</span>, <span class="hljs-subst">$&#123;b&#125;</span>)`</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="替换字符串内容"><a href="#替换字符串内容" class="headerlink" title="替换字符串内容"></a>替换字符串内容</h2><p>给你一个字符串<code>Hello #1#, Is&#39;s a #2# day</code>和一个数组<code>[&quot;Jack&quot;, &quot;sunny&quot;]</code>，将字符串中井号之间的索引换成在字符串中的对应元素。</p><blockquote><p>substr是从起始索引号开始提取指定长度的字符串</p><p>substring是提取字符串中两个指定索引号之间的</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">matchKeywords</span> = (<span class="hljs-params">str, arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> matchs = str.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/#(\d+)#/g</span>); <span class="hljs-comment">// 获取所有#index#占位符</span><br>    <span class="hljs-keyword">let</span> result = str;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; matchs.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-comment">// 获取matchs[i]对应的数组元素</span><br>        <span class="hljs-keyword">const</span> index = <span class="hljs-built_in">parseInt</span>(matchs[i].<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>, matchs[i].<span class="hljs-property">length</span> - <span class="hljs-number">2</span>)) - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 进行替换</span><br>        result = result.<span class="hljs-title function_">replace</span>(matchs[i], arr[index]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="useRef的返回值是什么？"><a href="#useRef的返回值是什么？" class="headerlink" title="useRef的返回值是什么？"></a>useRef的返回值是什么？</h2><p><code>useRef</code>的返回值是一个可变的<code>ref</code>对象，且只有一个current属性，其中 <code>current</code> 属性指向一个可变的值。可以通过修改 <code>current</code> 属性来更新这个值，而不会触发组件的重新渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>Focus<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="用useState可以实现useRef的效果吗？"><a href="#用useState可以实现useRef的效果吗？" class="headerlink" title="用useState可以实现useRef的效果吗？"></a>用useState可以实现useRef的效果吗？</h2><p>不能。</p><p>虽然 <code>useState</code> 和 <code>useRef</code> 都可以用来存储组件中的数据，但是它们的实现方式不同，因此不能完全替代彼此。</p><p><code>useState</code> 用于存储组件的状态，每次更新状态都会触发组件的重新渲染。而 <code>useRef</code> 用于存储组件中的数据，不会触发组件的重新渲染。</p><p>虽然 <code>useState</code> 可以用来存储组件中的数据，但是每次更新状态都会触发组件的重新渲染，这可能会导致性能问题。而 <code>useRef</code> 可以在不触发组件重新渲染的情况下存储数据，因此更适合用来存储不需要触发重新渲染的数据。</p><p>例如，<code>useRef</code> 可以用来存储 DOM 元素的引用，而 <code>useState</code> 则不适合用来存储 DOM 元素的引用，因为每次更新状态都会触发组件的重新渲染，从而导致 DOM 元素的重新创建和销毁。</p><h2 id="useMemo返回的是什么？"><a href="#useMemo返回的是什么？" class="headerlink" title="useMemo返回的是什么？"></a>useMemo返回的是什么？</h2><p>在 React 中，<code>useMemo</code> 是一个 Hook 函数，用于优化组件的性能。它的作用是在组件渲染过程中缓存计算结果，以避免重复计算，从而提高组件的渲染速度。<code>useMemo</code> 的返回值是缓存的计算结果。</p><p>当组件重新渲染时，<code>useMemo</code> 会检查依赖项列表中的值是否发生了变化。<strong>如果依赖项的值没有发生变化，则 <code>useMemo</code> 直接返回缓存的计算结果，而不会重新计算；如果依赖项的值发生了变化，则 <code>useMemo</code> 会重新计算并返回新的计算结果。</strong></p><h2 id="React如何减少渲染次数？"><a href="#React如何减少渲染次数？" class="headerlink" title="React如何减少渲染次数？"></a>React如何减少渲染次数？</h2><ol><li>使用 <code>React.memo</code> 或 <code>PureComponent</code>：这些方法可以帮助组件实现浅比较，当组件的 props 没有发生变化时，避免不必要的重新渲染。</li><li>使用 <code>useCallback</code>：当需要将函数作为 props 传递给子组件时，可以使用 <code>useCallback</code> 缓存函数，避免在每次重新渲染时都创建新的函数。</li><li>尽可能地将组件拆分成更小的组件：这样可以避免不必要的重新渲染，提高组件的复用性。</li><li>避免在 <code>render</code> 方法中执行复杂的计算或操作：将复杂的计算或操作移到组件外部，或者使用 <code>useMemo</code> 或 <code>useEffect</code> 缓存计算结果。</li><li>避免在 <code>render</code> 方法中使用匿名函数：使用匿名函数会导致组件的重新渲染，因此尽可能地避免在 <code>render</code> 方法中使用匿名函数。</li></ol><h2 id="有哪些Hooks可以减少渲染次数？"><a href="#有哪些Hooks可以减少渲染次数？" class="headerlink" title="有哪些Hooks可以减少渲染次数？"></a>有哪些Hooks可以减少渲染次数？</h2><ol><li><code>React.memo</code>：这个 Hook 可以帮助函数组件进行浅比较，避免不必要的重新渲染。它接受一个组件作为参数，并返回一个新的组件，新组件会对原组件的 props 进行浅比较，当 props 没有发生变化时，避免不必要的重新渲染。</li><li><code>useCallback</code>：这个 Hook 可以缓存函数，避免在每次重新渲染时都创建新的函数。它接受一个函数和依赖项列表作为参数，并返回一个新的函数。当依赖项的值没有发生变化时，返回缓存的函数，否则返回新的函数。</li><li><code>useMemo</code>：这个 Hook 可以缓存计算结果，避免在每次重新渲染时都重新计算。它接受一个计算函数和依赖项列表作为参数，并返回计算结果。当依赖项的值没有发生变化时，返回缓存的计算结果，否则重新计算并返回新的结果。</li><li><code>useReducer</code>：这个 Hook 可以帮助管理组件的状态，并避免不必要的重新渲染。它接受一个 reducer 函数、初始状态和一个初始化函数作为参数，并返回一个包含状态和 dispatch 函数的数组。当状态发生变化时，只会重新渲染与状态相关的部分。</li><li><code>useMemoOne</code>：这个 Hook 可以缓存计算结果，避免在每次重新渲染时都重新计算。它类似于 <code>useMemo</code>，但是可以在渲染期间多次调用计算函数，并缓存计算结果。它接受一个计算函数和依赖项列表作为参数，并返回计算结果。</li></ol><h2 id="React单向数据流？"><a href="#React单向数据流？" class="headerlink" title="React单向数据流？"></a>React单向数据流？</h2><p>React的单向数据流是指数据的流动方向是单向的，从父组件流向子组件。父组件通过props将数据传递给子组件，子组件不能直接修改父组件传递过来的数据，只能通过触发事件或调用父组件传递过来的回调函数来修改数据。这样做的好处是保证了数据的一致性，<strong>避免了组件之间的相互影响，提高了应用的可维护性</strong>。</p><p>React的单向数据流也是React的核心思想之一，它使得组件之间的数据传递变得简单明了，也方便了组件的重用和组合。在React应用中，每个组件都是一个独立的单元，它只关心自己的数据和UI展示，而不需要考虑其他组件的状态和行为。这种组件化的思想也是React的另一个重要特点。</p><h2 id="hash路由和history路由的区别？"><a href="#hash路由和history路由的区别？" class="headerlink" title="hash路由和history路由的区别？"></a>hash路由和history路由的区别？</h2><ul><li><p>hash路由是通过触发并监听hashChange事件来实现前端路由的，改变hash可以直接通过location.hash &#x3D; xxx来改变；而history路由是通过history的各种API (history.pushState、history.replaceState) 等实现url的改变的，监听url的变化可以通过自定义事件触发实现。</p></li><li><p>hash路由兼容性好，支持所有的浏览器，而且可以实现前端路由的核心功能 (IE8以上)，但是ur不够美观；history路由url美观，可以利用浏览器的前进、后退等基本功能，但是兼容性不好(IE10以上)，需要浏览器支持HTML5的history API，同时需要服务器端支持，否则刷新页面会出现404错误。</p></li><li><p>history pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中。</p></li><li><p>history 进行刷新页面时，无法找到url对应的页面，会出现 404 问题。因为域名后面的路由是由前端控制的，后端只能保留域名部分，所以就会造成页面丢失的问题。</p></li></ul><h2 id="React中什么时候用history路由，什么时候用hash路由？"><a href="#React中什么时候用history路由，什么时候用hash路由？" class="headerlink" title="React中什么时候用history路由，什么时候用hash路由？"></a>React中什么时候用history路由，什么时候用hash路由？</h2><ul><li>如果需要兼容更老的路由，建议使用hash路由，history的兼容性较差。</li><li>如果希望url看起来更美观，建议使用history路由，不会在url中添加#字符。</li><li>如果需要更好的SEO(搜索引擎优化)，建议使用history路由，因为搜索引擎对hash路由中的#字符处理不太友好。</li><li>服务端渲染：如果需要在服务端渲染应用程序，建议使用history路由，因为服务端渲染需要在服务器上匹配URL。</li><li>前进&#x2F;后退：如果需要利用浏览器的前进&#x2F;后退等基本功能，建议使用history路由，因为hash路由中的#字符不会被浏览器记录到历史记录中。</li></ul><h2 id="React中hash路由与history路由的实现原理？"><a href="#React中hash路由与history路由的实现原理？" class="headerlink" title="React中hash路由与history路由的实现原理？"></a>React中hash路由与history路由的实现原理？</h2><p>Hash路由：通过监听<code>hashChange</code>事件，感知hash的变化，改变hash可以直接通过<code>location.hash = xxx</code>进行改变。</p><p>History路由：改变url需要通过<code>history.pushState</code>和<code>history.replaceState</code>等，会将url压入堆栈，同时能够适应<code>history.go()</code>等API，监听url的改变可以通过自定义事件触发实现。</p><h2 id="React的diffing算法-比如从ABCD变为BADC，具体是移动还是销毁？"><a href="#React的diffing算法-比如从ABCD变为BADC，具体是移动还是销毁？" class="headerlink" title="React的diffing算法 比如从ABCD变为BADC，具体是移动还是销毁？"></a>React的diffing算法 比如从ABCD变为BADC，具体是移动还是销毁？</h2><p>如果节点没有发生变化，只是位置发生了变化，会对它们进行移动而不是销毁。</p><p><strong>React允许开发者对同一层级的同组子节点，添加唯一 key 进行区分。</strong></p><p>当同一层级的某个节点添加了对于其他同级节点唯一的key属性，当它在<strong>当前层级</strong>的位置发生了变化后。react diff算法通过新旧节点比较后，<strong>如果发现了key值相同的新旧节点，就会执行移动操作（然后依然按原策略深入节点内部的差异对比更新），而不会执行原策略的删除旧节点，创建新节点的操作。</strong>这无疑大大提高了React性能和渲染效率。</p><p>在具体的执行过程中，首先会对新集合中的节点进行遍历循环，通过唯一的key判断新旧节点中是否存在相同的节点，如果存在则进行移动操作，但是在移动操作之前需要将当前节点在旧几个中的位置与lastIndex进行比较 <code>if(child._mountIndex &lt; lastIndex)</code>，否则不执行该操作。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe044edaaf28439c9d4afba753690eb9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="同一层级中所有节点只发生了位置变化"></p><p>按新集合中顺序开始遍历</p><ol><li>B在新集合中 lastIndex(类似浮标) &#x3D; 0, 在旧集合中 index &#x3D; 1，index &gt; lastIndex 就认为 B 对于集合中其他元素位置无影响，不进行移动，之后lastIndex &#x3D; max(index, lastIndex) &#x3D; 1</li><li>A在旧集合中 index &#x3D; 0， 此时 lastIndex &#x3D; 1, 满足 index &lt; lastIndex, 则对A进行移动操作，此时lastIndex &#x3D; max(Index, lastIndex) &#x3D; 1</li><li>D和B操作相同，同(1)，不进行移动，此时lastIndex&#x3D;max(index, lastIndex) &#x3D; 3</li><li>C和A操作相同，同(2)，进行移动，此时lastIndex &#x3D; max(index, lastIndex) &#x3D; 3</li></ol><p>如果同一层级中的节点不仅发生了位置变化，还发生了节点增删：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83a71d590dce4999a0320e7d7ba7bacd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="不仅发生了位置变化，还发生了节点增删"></p><ol><li>同上面那种情形，B不进行移动，lastIndex&#x3D;1</li><li>新集合中取得E,发现旧中不存在E，在 lastIndex处<strong>创建</strong>E，lastIndex++</li><li>在旧集合中取到C，C不移动，lastIndex&#x3D;2</li><li>在旧集合中取到A，A移动到新集合中的位置，lastIndex&#x3D;2</li><li>完成新集合中所有节点diff后，对旧集合进行循环遍历，寻找新集合中不存在但就集合中的节点(此例中为D)，删除D节点。</li></ol><p><strong>是否推荐使用遍历时的index作为key属性值？</strong></p><p>React官方建议不要用遍历的index作为这种场景下的节点的key属性值。比如当前遍历的所有节点类型都相同，其内部文本不同，在用index作key的情况下，当我们对原始的数据list进行了某些元素的顺序改变操作，导致了新旧集合中在进行diff比较时，相同index所对应的新旧的节点其文本不一致了，就会出现一些节点需要更新渲染文本，而如果用了其他稳定的唯一标识符作为key，则只会发生位置顺序变化，无需更新渲染文本，提升了性能。</p><p><strong>key机制的缺陷：</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce6eb05a24674c51943127fcde856d34~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="只有D节点位置变化"></p><p>如图 所示，若新集合的节点更新为 D、A、 B、C，与旧集合相比只有 D 节点移动，而 A、B、C 仍然保持原有的顺序，理论上 diff 应该只需对 D 执行移动操作，然而由于 D 在旧集合中的位置是最大的，导致其他节点的 _mountIndex &lt;lastIndex，造成 D 没有执行移动操作，而是 A、B、C 全部移动到 D 节点后面的现象。</p><p><strong>在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作。当节点数量过大或更新操作过于频繁时，这在一定程度上会影响 React 的渲染性能。</strong></p><p><strong>key使用注意事项：</strong></p><ol><li>如果遍历的列表子节是作为纯展示，而不涉及到列表元素顺序的动态变更，那使用index作为key还是没有问题的。</li><li>key只是针对同一层级的节点进行了diff比较优化，而跨层级的节点互相之间的key值没有影响</li><li>大部分情况下，通过遍历的同一层级的使用了key属性的元素节点其节点类型是相同的（比如都是span元素或者同一个组件）。如果存在新旧集合中，相同的key值所对应的节点类型不同（比如从span变成div），这相当于完全替换了旧节点，删除了旧节点，创建了新节点。</li><li>如果新集合中，出现了旧集合没有存在过的key值。例如某个节点的key之前为1，现在为100，但旧集合中其他节点也没有使用100这个key值。说明没发生过移动操作，此时diff算法会对对应的节点进行销毁并重新创建。这在一些场景中会比较有用（比如重置某个组件的状态）</li><li>key值在比较之前都会被执行toString()操作，所以尽量不要使用object类型的值作为key，会导致同一层级出现key值相同的节点。key值重复的同一类型的节点或组件很可能出现拷贝重复内部子元素的问题。</li></ol><p>参考：<a href="https://juejin.cn/post/6967626390380216334#comment">React虚拟DOM、Diff算法与Key机制</a></p><h2 id="CSS中padding和margin的百分比写法是相对于谁的？"><a href="#CSS中padding和margin的百分比写法是相对于谁的？" class="headerlink" title="CSS中padding和margin的百分比写法是相对于谁的？"></a>CSS中padding和margin的百分比写法是相对于谁的？</h2><p>相对于父元素的宽度来进行计算。</p><p>例如，如果一个元素的父元素宽度为100px，将padding-left设置为20%，则左边padding宽度为20px。</p><h2 id="绝对定位是相对于谁进行定位的？"><a href="#绝对定位是相对于谁进行定位的？" class="headerlink" title="绝对定位是相对于谁进行定位的？"></a>绝对定位是相对于谁进行定位的？</h2><p>相对于其最近的已定位 (position属性值不为static) 的父元素进行定位的。如果没有已定位的父元素，则相对于最初的包含块(根元素)进行定位。</p><p>当一个元素被设置为绝对定位时，它会被从文档流中移除，因此它不占据文档中的空间。它的位置由top、bottom、left和right属性来指定，这些属性定义了元素相对于其父元素的偏移量。如果没有给这些属性指定值，元素将会被放置在其父元素的左上角。</p><h2 id="flex布局？"><a href="#flex布局？" class="headerlink" title="flex布局？"></a>flex布局？</h2><p>flex弹性布局，为盒模型提供了最大的灵活性，设置为flex布局后，子元素的float、clear和vertical-align属性将失效。它的所有子元素自动成为容器成员，称为flex项目。容器默认两条轴：水平主轴(main axis)和垂直的交叉轴(cross axis)，项目默认沿水平主轴排列。</p><p>常见属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-direction</span> <span class="hljs-comment">/* 决定主轴方向 */</span><br><span class="hljs-attribute">flex-wrap</span> <span class="hljs-comment">/* 如果一条轴线排不下，如何换行 */</span><br><span class="hljs-attribute">flex-flow</span> <span class="hljs-comment">/* flex-direction和flex-wrap属性简写，默认为row nowrap */</span><br><span class="hljs-attribute">justify-content</span> <span class="hljs-comment">/* 项目在主轴上的对齐方式 */</span><br><span class="hljs-attribute">align-items</span> <span class="hljs-comment">/* 项目在交叉轴上的对其方式 */</span><br><span class="hljs-attribute">align-content</span> <span class="hljs-comment">/* 多根轴线时的对齐方式，如果只有一条轴线则不起作用 */</span><br><span class="hljs-attribute">align-self</span>  <span class="hljs-comment">/* 允许单个项目与其他项目不一样的对齐方式，可以覆盖align-items属性，默认为auto，表示继承父元素align-items属性，如果没有父元素则等同于stretch */</span> <br></code></pre></td></tr></table></figure><p><code>flex: 1</code>代表什么含义？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;<br><span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">1</span>;<br><span class="hljs-attribute">flex-basis</span>: <span class="hljs-number">0%</span>;<br></code></pre></td></tr></table></figure><p><code>flex: auto</code>代表什么含义？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;<br><span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">1</span>;<br><span class="hljs-attribute">flex-basis</span>: auto;  <span class="hljs-comment">/*元素根据剩余空间自动调整自身大小*/</span><br></code></pre></td></tr></table></figure><h2 id="node-js框架Express常用API？"><a href="#node-js框架Express常用API？" class="headerlink" title="node.js框架Express常用API？"></a>node.js框架Express常用API？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title function_">express</span>(); <span class="hljs-comment">// 创建一个express应用程序实例</span><br>app.<span class="hljs-title function_">use</span>(); <span class="hljs-comment">// 使用中间件函数，可以用来处理HTTP请求、响应和错误</span><br>app.<span class="hljs-title function_">set</span>(); <span class="hljs-comment">// 设置应用程序级别变量</span><br>app.<span class="hljs-title function_">get</span>(); <span class="hljs-comment">// 获取应用级别的变量</span><br>app.<span class="hljs-title function_">listen</span>(); <span class="hljs-comment">// 启动express应用程序并指定监听端口</span><br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>();<br>router.<span class="hljs-title function_">get</span>(); <span class="hljs-comment">// 创建HTTP GET路由</span><br>router.<span class="hljs-title function_">post</span>(); <span class="hljs-comment">// 创建HTTP POST路由</span><br>res.<span class="hljs-title function_">send</span>(); <span class="hljs-comment">// 将HTTP响应发送给客户端</span><br>res.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// 将JSON格式的HTTP响应发送给客户端</span><br>res.<span class="hljs-title function_">render</span>(); <span class="hljs-comment">// 将模板渲染成HTML，并将其发送给客户端</span><br>req.<span class="hljs-property">params</span>; <span class="hljs-comment">// 获取路由参数</span><br>req.<span class="hljs-property">query</span>; <span class="hljs-comment">// 获取查询参数</span><br>req.<span class="hljs-property">body</span>; <span class="hljs-comment">// 获取请求体的内容</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识点整理(3)</title>
    <link href="/2023/04/09/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-3/"/>
    <url>/2023/04/09/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-3/</url>
    
    <content type="html"><![CDATA[<h1 id="知识点整理-3"><a href="#知识点整理-3" class="headerlink" title="知识点整理(3)"></a>知识点整理(3)</h1><h2 id="原生JS实现图片拖拽"><a href="#原生JS实现图片拖拽" class="headerlink" title="原生JS实现图片拖拽"></a>原生JS实现图片拖拽</h2><p><img src="https://pic.imgdb.cn/item/6432ac210d2dde5777840625.png" alt="图片拖拽"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-id">#box</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position: relative;overflow: hidden;&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 将要被拖拽的元素, 设置为绝对定位 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;img src=&quot;https://pic.imgdb.cn/item/64326d120d2dde57772c4eab.png&quot; alt=&quot;&quot; id=&quot;box&quot; /&gt; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;box&quot;</span>); <span class="hljs-comment">// 获取目标元素</span></span><br><span class="language-javascript">            <span class="hljs-comment">// 鼠标按下事件</span></span><br><span class="language-javascript">            box.<span class="hljs-property">onmousedown</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">let</span> e = ev || event;</span><br><span class="language-javascript">                <span class="hljs-comment">// 鼠标到元素左边缘距离 = 鼠标到屏幕左边缘距离 - 元素到屏幕左边缘距离</span></span><br><span class="language-javascript">                <span class="hljs-keyword">let</span> x = e.<span class="hljs-property">clientX</span> - box.<span class="hljs-property">offsetLeft</span>;</span><br><span class="language-javascript">                <span class="hljs-comment">// 鼠标到元素上边缘距离 = 鼠标到屏幕上边缘距离 - 元素到屏幕上边缘距离</span></span><br><span class="language-javascript">                <span class="hljs-keyword">let</span> y = e.<span class="hljs-property">clientY</span> - box.<span class="hljs-property">offsetTop</span>;</span><br><span class="language-javascript">                <span class="hljs-comment">// 鼠标移动事件</span></span><br><span class="language-javascript">                <span class="hljs-variable language_">document</span>.<span class="hljs-property">onmousemove</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>) &#123;</span><br><span class="language-javascript">                    <span class="hljs-keyword">let</span> e = ev || event;</span><br><span class="language-javascript">                    box.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = ev.<span class="hljs-property">clientX</span> - x + <span class="hljs-string">&quot;px&quot;</span>;</span><br><span class="language-javascript">                    box.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = ev.<span class="hljs-property">clientY</span> - y + <span class="hljs-string">&quot;px&quot;</span>;</span><br><span class="language-javascript">                    <span class="hljs-comment">// 鼠标距离浏览器窗口左边缘和上边缘的距离</span></span><br><span class="language-javascript">                    <span class="hljs-keyword">let</span> bodyScreenX = ev.<span class="hljs-property">screenX</span>, bodyScreenY = ev.<span class="hljs-property">screenY</span>;</span><br><span class="language-javascript">                    <span class="hljs-comment">// 屏幕的宽度和高度</span></span><br><span class="language-javascript">                    <span class="hljs-keyword">let</span> bodyClientWidth = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientWidth</span>,</span><br><span class="language-javascript">                        bodyClientHeight = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientHeight</span>;</span><br><span class="language-javascript">                    <span class="hljs-comment">// 鼠标松开事件</span></span><br><span class="language-javascript">                    <span class="hljs-variable language_">document</span>.<span class="hljs-property">onmouseup</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>) &#123;</span><br><span class="language-javascript">                        <span class="hljs-comment">// 判断松开的时候元素是否在屏幕中</span></span><br><span class="language-javascript">                        <span class="hljs-keyword">if</span>(ev.<span class="hljs-property">clientX</span> - x &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="language-javascript">                            <span class="hljs-comment">// 如果超出屏幕左边缘, 将元素放回屏幕最左边</span></span><br><span class="language-javascript">                            box.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = <span class="hljs-number">0</span>;</span><br><span class="language-javascript">                        &#125;</span><br><span class="language-javascript">                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bodyScreenX &gt; bodyClientWidth) &#123;</span><br><span class="language-javascript">                            <span class="hljs-comment">// 如果超出屏幕右边缘, 将元素放回屏幕最右边</span></span><br><span class="language-javascript">                            box.<span class="hljs-property">style</span>.<span class="hljs-property">right</span> = <span class="hljs-number">0</span>;</span><br><span class="language-javascript">                            box.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = bodyClientWidth - <span class="hljs-number">100</span> + <span class="hljs-string">&quot;px&quot;</span>;</span><br><span class="language-javascript">                        &#125;</span><br><span class="language-javascript">                        <span class="hljs-variable language_">document</span>.<span class="hljs-property">onmousemove</span> = <span class="hljs-literal">null</span>;</span><br><span class="language-javascript">                        <span class="hljs-variable language_">document</span>.<span class="hljs-property">onmouseup</span> = <span class="hljs-literal">null</span>;</span><br><span class="language-javascript">                    &#125;</span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="z-index在什么情况下会失效？"><a href="#z-index在什么情况下会失效？" class="headerlink" title="z-index在什么情况下会失效？"></a>z-index在什么情况下会失效？</h2><ul><li><p>元素设置了浮动</p></li><li><p><del>父元素的<code>position</code>为<code>relative</code>时，子元素的<code>z-index</code>会失效。</del></p></li><li><p>元素的<code>position</code>不是<code>relative</code>、<code>absolute</code>或者<code>fixed</code>时。</p></li></ul><h2 id="npm包会自己发送请求吗？"><a href="#npm包会自己发送请求吗？" class="headerlink" title="npm包会自己发送请求吗？"></a>npm包会自己发送请求吗？</h2><p>一般而言，npm包本身并不会发送请求。npm包只是一些代码和资源的打包，用于在项目中引用和使用。然而，<u>一些npm包可能会包含与第三方服务进行交互的代码，这些代码可能会发送请求</u>。</p><p>例如，一些npm包可能会包含用于访问API的代码，或包含用于从CDN加载资源的代码。</p><h2 id="如何使用原生JS发送HTTP请求？"><a href="#如何使用原生JS发送HTTP请求？" class="headerlink" title="如何使用原生JS发送HTTP请求？"></a>如何使用原生JS发送HTTP请求？</h2><p>使用JS内置的<code>XMLHttpRequest</code>发送请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建一个xhr对象</span><br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">// 使用open方法设置请求方法、url和是否异步</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;http://test.com&quot;</span>, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 设置请求头(可选)</span><br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>);<br><span class="hljs-comment">// 状态监听函数</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 请求成功</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-title function_">handle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 请求失败时的监听函数</span><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>&#125;<br><span class="hljs-comment">// 发送请求</span><br>xhr.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><h2 id="JS的引用数据类型有哪些？"><a href="#JS的引用数据类型有哪些？" class="headerlink" title="JS的引用数据类型有哪些？"></a>JS的引用数据类型有哪些？</h2><p>对象(Object)、数组(Array)和函数(Function)</p><h2 id="在给DOM元素做事件委托的时候，如何判断要对哪个子元素进行操作处理？"><a href="#在给DOM元素做事件委托的时候，如何判断要对哪个子元素进行操作处理？" class="headerlink" title="在给DOM元素做事件委托的时候，如何判断要对哪个子元素进行操作处理？"></a>在给DOM元素做事件委托的时候，如何判断要对哪个子元素进行操作处理？</h2><p>通过event.target实时获取到用户点击的子元素，并对该子元素进行操作处理。</p><h2 id="如何实现进入页面同时发送两个请求？"><a href="#如何实现进入页面同时发送两个请求？" class="headerlink" title="如何实现进入页面同时发送两个请求？"></a>如何实现进入页面同时发送两个请求？</h2><p><code>Promise.all()</code>方法</p><h2 id="使用Promise-all时，当一个请求失败时，如何获取剩余请求的结果？"><a href="#使用Promise-all时，当一个请求失败时，如何获取剩余请求的结果？" class="headerlink" title="使用Promise.all时，当一个请求失败时，如何获取剩余请求的结果？"></a>使用Promise.all时，当一个请求失败时，如何获取剩余请求的结果？</h2><p><code>Promise.all()</code>进行实现，对传入的数组进行<code>map</code>处理。</p><p>核心内容是<code>map</code>方法，<code>map</code>的每一项都是<code>promise</code>，**<code>catch</code>方法返回值会被<code>promise.resolve()</code>包裹**，这样传进<code>promise.all</code>的数据都是<code>resolved</code>状态的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">let</span> p4 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">4</span>);<br><span class="hljs-keyword">let</span> p5 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;error&quot;</span>);<br><br><span class="hljs-keyword">let</span> arr = [p1, p2, p3, p4, p5];<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e))) <span class="hljs-comment">// rejected的Promise会被处理并用resolve包裹成一个新的Promise</span><br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求成功: &quot;</span>, res);<br>&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求失败: &quot;</span>, err);<br>&#125;)<br><br><span class="hljs-comment">// 请求成功:  [ 1, 2, 3, 4, &#x27;error&#x27; ]</span><br></code></pre></td></tr></table></figure><h2 id="Promise内部是如何实现的？"><a href="#Promise内部是如何实现的？" class="headerlink" title="Promise内部是如何实现的？"></a>Promise内部是如何实现的？</h2><p><code>Promise</code> 是基于 <strong>观察者的设计模式</strong> 实现的，<code>then</code> 函数要执行的函数会被塞入观察者数组中，当 <code>Promise</code> 状态变化的时候，就去执行观察组数组中的所有函数。</p><blockquote><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。</p></blockquote><p><code>Promise</code> 有三个状态：</p><ul><li><code>pending</code>：等待中</li><li><code>resolved</code>：已成功</li><li><code>rejected</code>：已失败</li></ul><p>在 <code>Promise</code> 的状态改变只有两种可能：从 <code>pending</code> 变为 <code>resolved</code> 或者从 <code>pending</code> 变为 <code>rejected</code>。</p><p><img src="https://pic.imgdb.cn/item/6432ac3c0d2dde57778423f8.png" alt="promise-states"></p><p>每一个 <code>promise</code> 都一个 <code>then</code> 方法，这个是当 <code>promise</code> 返回结果之后，需要执行的回调函数，他有两个可选参数：</p><ul><li><code>onFulfilled</code>：成功的回调；</li><li><code>onRejected</code>：失败的回调；</li></ul><p><img src="https://pic.imgdb.cn/item/6434061e0d2dde5777204f05.png" alt="Then Catch flow"></p><h2 id="Async如何进行错误捕获？原理是什么？"><a href="#Async如何进行错误捕获？原理是什么？" class="headerlink" title="Async如何进行错误捕获？原理是什么？"></a>Async如何进行错误捕获？原理是什么？</h2><p>在<code>async</code>函数中可以使用<code>try...catch</code>捕获错误，如果在<code>async</code>函数中发生了错误，它将会被抛出并将被<code>catch</code>捕获。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">doSomething</span>();<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>    &#125;<br>    <span class="hljs-keyword">catch</span>(error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>async/await</code>是基于Promise的语法糖，它背后的原理与Promise类似。在<code>async</code>函数中，如果发生错误，它将返回一个被拒绝的Promise对象，其错误原因就是抛出的错误。我们可以使用<code>try...catch</code>来捕获这个错误，就像捕获普通的Promise一样。在<code>catch</code>块中，我们可以处理这个错误，或者将它重新抛出，以便于在async函数的代码中继续处理它。</p><h2 id="try…catch是如何捕获异常的？"><a href="#try…catch是如何捕获异常的？" class="headerlink" title="try…catch是如何捕获异常的？"></a>try…catch是如何捕获异常的？</h2><p>首先执行<code>try</code>代码块中的代码。</p><p>如果<code>try</code>代码块中的代码没有发生任何异常，那么<code>catch</code>块中的代码不会被执行，程序将继续执行<code>try...catch</code>块后面的代码。</p><p>如果<code>try</code>块中发生了异常，那么程序将立即跳转到<code>catch</code>块中，并执行其中的代码。<code>catch</code>块中的代码将处理异常，并且可以使用异常对象来获取异常的详细信息。</p><p>如果<code>catch</code>中的代码成功处理了异常，那么程序将继续执行<code>try...catch</code>后面的代码。</p><p>如果<code>catch</code>中的代码没有成功处理异常，或抛出了新的异常，那么程序将被终止，并将新的异常抛出到调用栈中，直到被捕获或导致程序崩溃。</p><h2 id="异常是如何被抛出的？"><a href="#异常是如何被抛出的？" class="headerlink" title="异常是如何被抛出的？"></a>异常是如何被抛出的？</h2><p>当程序发生错误或意外情况的时候，将创建一个异常对象。</p><p>异常对象将被抛出到当前函数的调用栈中，直到被捕获或导致程序崩溃。</p><p>当异常现象被抛出的时候，当前函数的执行将立即停止，并且将控制权传递给调用栈中的上一级函数。</p><p>如果异常对象没有被捕获，将继续向上传递，直到到达程序的顶层，或者导致程序崩溃。</p><p>如果异常对象被捕获了，那么它将被传递给相应的catch块，直到catch块中的代码被执行。</p><h2 id="如何定义错误对象？"><a href="#如何定义错误对象？" class="headerlink" title="如何定义错误对象？"></a>如何定义错误对象？</h2><p>使用Error对象来定义错误对象。Error是JS内置对象，它包含一些属性和方法，用于描述和处理错误。我们可以通过创建一个新的Error对象来定义一个错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">consr error = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;This is a error message.&quot;</span>);<br></code></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个新的Error对象，并传递了一个错误消息作为参数。这个错误消息将被包含在Error对象中，并且可以在抛出错误时被输出到控制台或日志中。</p><p>除了Error对象之外，JavaScript还提供了其他一些内置的错误类型，例如SyntaxError、TypeError和ReferenceError等，它们都继承自Error对象，并且具有不同的属性和方法，用于描述和处理特定类型的错误。</p><p>我们还可以自定义对象类型，继承自Error对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Error</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">message</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(message);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;MyError&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个名为MyError的错误类型，它继承自Error对象。我们重写了构造函数，以便在创建MyError对象时设置错误消息和错误名称。我们可以像使用内置的Error对象一样使用MyError对象来抛出和处理错误。</p><h2 id="JS的Error对象有哪些内置的属性和方法？"><a href="#JS的Error对象有哪些内置的属性和方法？" class="headerlink" title="JS的Error对象有哪些内置的属性和方法？"></a>JS的Error对象有哪些内置的属性和方法？</h2><ul><li><strong>name</strong>: 错误类型的名称，如”Error”、”SyntaxError”等。</li><li><strong>message</strong>: 错误信息的描述。</li><li><strong>stack</strong>: 错误堆栈的跟踪信息。</li><li><strong>toString()</strong>: 返回错误类型和错误信息的字符串表示形式。</li></ul><p>参考：[MDN Error](<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error">Error - JavaScript | MDN (mozilla.org)</a>)</p><h2 id="HTTPS的加密过程？"><a href="#HTTPS的加密过程？" class="headerlink" title="HTTPS的加密过程？"></a>HTTPS的加密过程？</h2><ol><li>客户端向服务器发送HTTPS请求。请求中包含了客户端支持的加密算法列表和随机数（ClientHello）。</li><li>服务器从客户端发送的加密算法列表中选择一种加密算法，并向客户端发送服务器的证书，证书中包含了服务器的公钥和证书的签名（ServerHello）。</li><li>客户端验证服务器的证书是否有效，包括证书是否过期、证书是否被吊销、证书中的域名是否和服务器的域名匹配等。如果验证通过，客户端生成一个随机数，并使用服务器的公钥加密这个随机数（ClientKeyExchange）。</li><li>服务器使用自己的私钥解密客户端发送的随机数，并使用这个随机数生成对称密钥（ServerKeyExchange）。</li><li>客户端和服务器使用这个对称密钥进行通信，将通信内容加密后发送给对方。</li></ol><p>在这个过程中，客户端和服务器使用非对称加密算法（如RSA）来完成证书的验证和随机数的加密，使用对称加密算法（如AES）来加密通信内容。这样可以保证通信过程中传输的数据是加密的，同时也保证了通信双方的身份和数据的完整性，防止数据被篡改或窃取。</p><h2 id="CSS常用的垂直对齐方式属性？"><a href="#CSS常用的垂直对齐方式属性？" class="headerlink" title="CSS常用的垂直对齐方式属性？"></a>CSS常用的垂直对齐方式属性？</h2><ol><li><code>vertical-align</code>：用于控制元素的垂直对齐方式。该属性可以应用于行内元素和表格单元格元素。取值可以是基线（baseline）、顶部（top）、底部（bottom）、中间（middle）等。</li><li><code>line-height</code>：用于设置行高。行高决定了行内元素在垂直方向上的位置和间距。可以使用具体的像素值或百分比值来设置行高。</li></ol><h2 id="如何设置rem单位等于窗口高度？"><a href="#如何设置rem单位等于窗口高度？" class="headerlink" title="如何设置rem单位等于窗口高度？"></a>如何设置rem单位等于窗口高度？</h2><p>要将<code>rem</code>单位设置为等于窗口高度，可以使用JavaScript计算窗口高度，并将其值设置为<code>html</code>元素的<code>font-size</code>属性值。这样，<code>rem</code>单位的大小就会随着窗口高度的变化而变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取窗口高区 </span><br><span class="hljs-comment">// const windowHeight = window.innerHeight; 包含滚动条高度</span><br><span class="hljs-keyword">const</span> windowHeight = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span>;<br><span class="hljs-comment">// 将窗口高度设置为html元素的fonr-size属性值</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = windowHeight + <span class="hljs-string">&quot;px&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="如何将ES6转为ES5？"><a href="#如何将ES6转为ES5？" class="headerlink" title="如何将ES6转为ES5？"></a>如何将ES6转为ES5？</h2><p>babel-loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">module</span>: &#123;<br>  <span class="hljs-attr">rules</span>: [<br>    &#123;<br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.m?js$/</span>,<br>      <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/(node_modules|bower_components)/</span>,<br>      <span class="hljs-attr">use</span>: &#123;<br>        <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>        <span class="hljs-attr">options</span>: &#123;<br>          <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>]<br>        &#125;<br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="手写数组扁平化"><a href="#手写数组扁平化" class="headerlink" title="手写数组扁平化"></a>手写数组扁平化</h2><p>递归实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">flat</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> newArr = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> arr) &#123;<br>        <span class="hljs-keyword">if</span>(item <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) &#123;<br>            newArr = newArr.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">flat</span>(item));<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            newArr.<span class="hljs-title function_">push</span>(item);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newArr;<br>&#125;<br></code></pre></td></tr></table></figure><p>reduce迭代实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">flat</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, item</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> prev.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item) ? <span class="hljs-title function_">flat</span>(item) : item);<br>    &#125;, [])<br>&#125;<br></code></pre></td></tr></table></figure><p>split和toString</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">flat</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;,&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>JSON.stringify和JSON.parse</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">flat</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> str = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(arr);<br>    str = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(\[|\])/g</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    str = <span class="hljs-string">&quot;[&quot;</span> + str + <span class="hljs-string">&quot;]&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="AJAX中的readyState从0到4分别代表什么含义？"><a href="#AJAX中的readyState从0到4分别代表什么含义？" class="headerlink" title="AJAX中的readyState从0到4分别代表什么含义？"></a>AJAX中的readyState从0到4分别代表什么含义？</h2><ul><li>0：请求未初始化。XMLHttpRequest对象已创建，但是尚未调用open方法。</li><li>1：服务器连接已建立。open方法已经调用，但是send方法未调用。请求已经建立，但是还未发送。</li><li>2：请求已接收。send方法已经调用，并且服务器已经返回了响应头。</li><li>3：请求处理中。响应体部分已经被接收，但是仍然没有完全接收。</li><li>4：请求已完成，且响应已就绪。响应体已经被完全接收，可以通过responseText或responseXML获取完整的响应数据。</li></ul><p>readyState属性只表示请求&#x2F;响应的状态，不能代表请求&#x2F;响应的结果。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈的应用</title>
    <link href="/2023/04/08/%E5%8D%95%E8%B0%83%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2023/04/08/%E5%8D%95%E8%B0%83%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>单调栈是始终保持单调递增或递减的栈，一般用于寻找数组中某个元素的下一个更大元素</p></blockquote><p>进栈过程：</p><ul><li>对于单调递增栈，如果当前进栈元素为<code>e</code>，从栈顶开始遍历元素，把小于<code>e</code>或者等于<code>e</code>的元素弹出栈，直到遇到一个大于<code>e</code>的元素或者栈空位置，然后再把<code>e</code>压入栈中。</li><li>对于单调递减栈，则每次弹出的是大于<code>e</code>或者等于<code>e</code>的元素。</li></ul><h2 id="例题1：下一个更大元素I"><a href="#例题1：下一个更大元素I" class="headerlink" title="例题1：下一个更大元素I"></a>例题1：下一个更大元素I</h2><p>题目地址: <a href="https://leetcode.cn/problems/next-greater-element-i/">下一个更大元素 I</a></p><p><code>nums1</code> 中数字 x 的 下一个更大元素 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 右侧 的 第一个 比 <code>x</code> 大的元素。</p><p>给你两个 没有重复元素 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <code>0</code> 开始计数，其中<code>nums1</code> 是 <code>nums2</code>的子集。</p><p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足<code>nums1[i] == nums2[j]</code>的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p><p>返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 下一个更大元素 。</p><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @单调栈</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums1</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums2</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> nextGreaterElement = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums1, nums2</span>) &#123;<br>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(); <br>    <span class="hljs-keyword">const</span> stack = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = nums2.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">const</span> num = nums2[i]; <span class="hljs-comment">// 取出当前数字</span><br>        <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span> &amp;&amp; num &gt;= stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]) &#123;<br>            stack.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 当栈顶元素小于num的时候,将其出栈(保证栈中元素递减)</span><br>        &#125;<br>        <span class="hljs-comment">// 找到下一个更大元素(如果栈为空,说明没有下一个更大元素,查询答案是-1)</span><br>        map.<span class="hljs-title function_">set</span>(num, stack.<span class="hljs-property">length</span> ? stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] : -<span class="hljs-number">1</span>);<br>        stack.<span class="hljs-title function_">push</span>(num); <span class="hljs-comment">// 将当前元素存入栈中</span><br>    &#125;<br>    <span class="hljs-comment">// 取出哈希表中nums1中每个元素对应的下一个更大元素</span><br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(nums1.<span class="hljs-property">length</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">_, index</span>) =&gt;</span> map.<span class="hljs-title function_">get</span>(nums1[index]));<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="例题2：商品折扣后的最终价格"><a href="#例题2：商品折扣后的最终价格" class="headerlink" title="例题2：商品折扣后的最终价格"></a>例题2：商品折扣后的最终价格</h2><p>题目地址:<a href="https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/">商品折扣后的最终价格</a></p><p>给你一个数组 <code>prices</code>，其中 <code>prices[i]</code> 是商店里第 <code>i</code> 件商品的价格。</p><p>商店里正在进行促销活动，如果你要买第 <code>i</code> 件商品，那么你可以得到与 <code>prices[j]</code> 相等的折扣，其中 <code>j</code> 是满足 <code>j &gt; i</code> 且 <code>prices[j] &lt;= prices[i]</code> 的 最小下标 ，如果没有满足条件的 <code>j</code> ，你将没有任何折扣。</p><p>请你返回一个数组，数组中第 <code>i</code> 个元素是折扣后你购买商品 <code>i</code> 最终需要支付的价格。</p><p>代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">prices</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> finalPrices = <span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) &#123;<br>    <span class="hljs-keyword">const</span> stack = []; <span class="hljs-comment">// 单调递增栈</span><br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(prices.<span class="hljs-property">length</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 存储最终价格的数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = prices.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">while</span>(stack.<span class="hljs-property">length</span> &amp;&amp; stack[stack.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>] &gt; prices[i])&#123;<br>            stack.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 如果后面元素大于当前元素,出栈</span><br>        &#125;<br>        <span class="hljs-comment">// 如果没有找到满足条件的j,则折扣为0</span><br>        res[i] = stack.<span class="hljs-property">length</span> ? prices[i] - stack[stack.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>] : prices[i];<br>        stack.<span class="hljs-title function_">push</span>(prices[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="例题3：下一个更大元素II"><a href="#例题3：下一个更大元素II" class="headerlink" title="例题3：下一个更大元素II"></a>例题3：下一个更大元素II</h2><p>题目地址:<a href="https://leetcode.cn/problems/next-greater-element-ii/">下一个更大元素 II</a></p><p>给定一个循环数组 <code>nums</code> （ <code>nums[nums.length - 1]</code> 的下一个元素是<code>nums[0]</code> ），返回 <code>nums</code> 中每个元素的 下一个更大元素 。</p><p>数字 <code>x</code> 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出<code>-1</code> 。</p><p>代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> nextGreaterElements = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">const</span> n = nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(-<span class="hljs-number">1</span>); <span class="hljs-comment">// 存储结果的数组</span><br>    <span class="hljs-keyword">const</span> stack = []; <span class="hljs-comment">// 单调栈(存储元素下标)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">2</span>*n-<span class="hljs-number">1</span>; i++)&#123; <span class="hljs-comment">// 相当于在数组之后再次进行了拼接</span><br>        <span class="hljs-keyword">const</span> num = nums[i % n]; <span class="hljs-comment">// 取出当前元素</span><br>        <span class="hljs-comment">// 当栈中有元素并且当前元素大于前面的元素,则前面元素的下一个更大数就是当前元素</span><br>        <span class="hljs-keyword">while</span>(stack.<span class="hljs-property">length</span> &amp;&amp; nums[stack[stack.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>]] &lt; num)&#123;<br>            res[stack[stack.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>]] = num; <span class="hljs-comment">// 存储下一个更大数</span><br>            stack.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 将小于等于num的数字弹出栈</span><br>        &#125;<br>        stack.<span class="hljs-title function_">push</span>(i % n); <span class="hljs-comment">// 存储元素下标</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker运行项目报错</title>
    <link href="/2023/04/08/Docker%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99/"/>
    <url>/2023/04/08/Docker%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<p>打开页面发现报错如下：</p><p><img src="http://dawning.fun/wp-content/uploads/2022/09/3160a97269cb1e4c9553081ad2b053b.png" alt="img"></p><p>进入服务器运行<code>docker ps -a</code>发现8080端口的服务处于停止状态</p><p><img src="http://dawning.fun/wp-content/uploads/2022/09/image-20220903145254986.png" alt="img"></p><p>尝试通过<code>docker start xld-front</code>启动服务失败,根据报错信息得知,8080端口被占用,无法启动服务</p><p><img src="http://dawning.fun/wp-content/uploads/2022/09/image-20220903145404282.png" alt="img"></p><p>运行<code>netstat -tanlp</code>查看端口被哪个程序占用</p><p><img src="http://dawning.fun/wp-content/uploads/2022/09/image-20220903145504171.png" alt="img"></p><p>执行指令<code>kill 659</code>(kill PID)关掉指令后重新启动</p><p><img src="http://dawning.fun/wp-content/uploads/2022/09/image-20220903145559017.png" alt="img"></p><p>启动成功！</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Docker上通过Nginx上传项目</title>
    <link href="/2023/04/08/%E5%9C%A8Docker%E4%B8%8A%E9%80%9A%E8%BF%87Nginx%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/"/>
    <url>/2023/04/08/%E5%9C%A8Docker%E4%B8%8A%E9%80%9A%E8%BF%87Nginx%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p>查看Docker中有没有Nginx镜像</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker image<br></code></pre></td></tr></table></figure><p>如果存在Nginx镜像,如图,则不需要再下载</p><p><img src="https://dawning.fun/wp-content/uploads/2022/08/image-20220816151239658.png" alt="img"></p><p>否则通过docker pull nginx指令下载Nginx镜像</p><p>创建用于存储Nginx容器相关的文件夹</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir -p <span class="hljs-regexp">/home/</span>dockers<span class="hljs-regexp">/nginx/</span>&#123;log,conf,html&#125;<br><span class="hljs-comment"># log用于存储日志</span><br><span class="hljs-comment"># conf用于存储配置文件</span><br><span class="hljs-comment"># html用于存储需要展示的文件</span><br></code></pre></td></tr></table></figure><p>创建Nginx镜像</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> <span class="hljs-comment">--name my-nginx -d nginx</span><br></code></pre></td></tr></table></figure><p>拷贝Nginx配置文件</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">docker cp my-nginx:<span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/nginx.conf /</span>home<span class="hljs-regexp">/dockers/</span>nginx<span class="hljs-regexp">/conf/</span><br>docker cp my-nginx:<span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/conf.d/</span><span class="hljs-keyword">default</span>.conf <span class="hljs-regexp">/home/</span>dockers<span class="hljs-regexp">/nginx/</span>conf<br></code></pre></td></tr></table></figure><p>进行配置文件的备份</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cp</span> default.<span class="hljs-keyword">conf</span> default.bak.<span class="hljs-keyword">conf</span><br><span class="hljs-keyword">cp</span> nginx.<span class="hljs-keyword">conf</span> nginx.bak.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><p>停掉并删除之前创建的Nginx容器</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">docker stop my-nginx<br>docker rm my-nginx<br></code></pre></td></tr></table></figure><p>用挂载的方式重新创建并运行容器</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run --privileged --name my-nginx -it -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> -v <span class="hljs-regexp">/home/</span>dockers<span class="hljs-regexp">/nginx/</span>conf<span class="hljs-regexp">/nginx.conf:/</span>etc<span class="hljs-regexp">/nginx/</span>nginx.conf:ro -v <span class="hljs-regexp">/home/</span>dockers<span class="hljs-regexp">/nginx/</span>conf<span class="hljs-regexp">/default.conf:/</span>etc<span class="hljs-regexp">/nginx/</span>conf.d<span class="hljs-regexp">/default.conf:ro -v /</span>home<span class="hljs-regexp">/dockers/</span>nginx<span class="hljs-regexp">/html:/u</span>sr<span class="hljs-regexp">/share/</span>nginx<span class="hljs-regexp">/html:rw -v /</span>home<span class="hljs-regexp">/dockers/</span>nginx<span class="hljs-regexp">/log:/</span>var<span class="hljs-regexp">/log/</span>nginx -d nginx<br></code></pre></td></tr></table></figure><p>命令解释:</p><p><strong>–privileged</strong></p><p> 使用该参数，[container]内的root拥有真正的root权限。<br>​ 否则，container内的root只是外部的一个普通用户权限。<br>​ privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。<br>​ 甚至允许你在docker容器中启动docker容器。</p><p><strong>–name</strong></p><p> 设置nginx容器的名称</p><p><strong>-p 80:80</strong></p><p> 设置访问端口和Nginx容器的监听端口的映射关系</p><p> 第一个80是访问的端口</p><p> 第二个80是Docker的Nginx配置文件监听端口</p><p><strong>-d</strong> </p><p>后台挂载运行nginx</p><p><strong>-v &#x2F;home&#x2F;dockers&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf:ro<br>-v &#x2F;home&#x2F;dockers&#x2F;nginx&#x2F;conf&#x2F;default.conf:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf:ro<br>-v &#x2F;home&#x2F;dockers&#x2F;nginx&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html:rw<br>-v &#x2F;home&#x2F;dockers&#x2F;nginx&#x2F;log:&#x2F;var&#x2F;log&#x2F;nginx</strong></p><p> 将docker容器nginx的配置文件目录、日志目录、服务访问目录和挂载到容器外</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识点整理(2)</title>
    <link href="/2023/04/08/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-2/"/>
    <url>/2023/04/08/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-2/</url>
    
    <content type="html"><![CDATA[<h1 id="整理总结-2"><a href="#整理总结-2" class="headerlink" title="整理总结(2)"></a>整理总结(2)</h1><h2 id="常见的Web安全问题有哪些？"><a href="#常见的Web安全问题有哪些？" class="headerlink" title="常见的Web安全问题有哪些？"></a>常见的Web安全问题有哪些？</h2><ul><li><p>注入漏洞</p><p>注入漏洞会让攻击者方便将恶意代码植入到目标应用系统(如解析器中)。如果你的Web应用允许用户将其输入的信息插入到后端数据库，或使用shell命令对操作系统进行调用，那么您的应用就可能会受到注入漏洞的影响。</p><p>当然，您可以通过检查应用的源代码，或对应用进行彻底的渗透测试，来发现此类漏洞。注入漏洞最常见的类型是SQL注入。攻击者会在SQL查询中，插入恶意代码，并将其转发到后端数据库服务器上，实施远程盗窃或攻击。</p><p>除常见的SQL注入之外，目前还有LDAP注入、XML注入、XPATH注入、OS命令注入、以及HTML注入。我们通常可以通过适当、及时地检查与清理用户的输入，来防范此类威胁。</p></li><li><p>身份认证失败</p><p>身份验证失败是由身份验证和会话管理控件的实施不当而引起的。如果攻击者能够成功的识别和利用那些与身份验证相关的漏洞，那么他们就能直接访问各种敏感数据和功能。</p><p>为了利用身份验证漏洞，攻击者需要通过采用诸如：凭证填充、会话劫持、密码暴力破解、以及会话ID URL重写等方法，来模拟应用程序的合法用户。</p><p>我们可以通过实施健全的会话管理控制、多因素身份验证、限制和监视失败的登录尝试，来防范此类攻击。</p></li><li><p>敏感数据泄露</p><p>当Web应用不能充分保护诸如：会话ID、密码、财务信息以及客户信息等敏感信息时，数据泄露就会发生。</p><p>此类泄漏的内部原因主要包括：未对敏感数据实施加密，仅采用了弱加密方式，软件应用的本身漏洞，以及操作员将数据上传至错误的数据库等方面。而外部攻击因素则包括：SQL注入、身份验证与访问控制的破坏、网络钓鱼攻击、以及针对明文协议HTTP、FTP和SMTP传输数据等网络级别的攻击。</p><p>为了应对此类泄漏，我们可以采取的主要措施包括：彻底检查应用程序的源代码与IT环境，尤其是正在使用安全密码算法等方面。</p></li><li><p>XML外部实体</p><p>XML外部实体注入(通常被称为XML External Entity，XXE)可以让攻击者通过Web应用的漏洞，干扰应用对于XML数据的处理。此类攻击往往会导致诸如拒绝服务、数据泄露、服务器端请求伪造等问题。</p><p>我们可以通过实施服务器端的输入验证，修补和升级所有XML处理器，以及使用SAST工具来分析源代码等方法，来有效地防止XML外部实体注入。</p></li><li><p>受损的访问控制</p><p>从概念上说，访问控制机制就是要确定用户是否可以执行，与之身份和权限相符的操作。而当用户可以在其预期权限之外执行某项操作时，那么就出现了访问控制的破坏。</p><p>受损的访问控制通常会导致：未经授权的信息泄露、数据被直接修改或破坏、以及业务功能偏离预期用途等情况。我们可以通过在受信任的服务器端代码中、或无服务器的API中，强制使用完备的访问控制机制，来防止攻击者修改元数据(metadata)，或绕过正常的访问控制检查。</p></li></ul><h2 id="如何保护Web应用程序的安全？"><a href="#如何保护Web应用程序的安全？" class="headerlink" title="如何保护Web应用程序的安全？"></a>如何保护Web应用程序的安全？</h2><ul><li>定义并采用合适的网络安全框架</li><li>跟踪资产并进行安全评估</li><li>遵循安全编码标准</li><li>部署企业级安全解决方案</li><li>尽可能自动化</li><li>对数据进行加密</li><li>渗透测试</li></ul><p>Web安全相关：<a href="https://zhuanlan.zhihu.com/p/363791438#:~:text=5%E5%A4%A7Web%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81%E4%B8%8E7%E5%A4%A7%E9%98%B2%E6%8A%A4%E6%8E%AA%E6%96%BD%201%201.%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%202%202.%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E5%A4%B1%E8%B4%A5%203%203.%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E6%B3%84%E6%BC%8F%204,5.%E5%8F%97%E6%8D%9F%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%206%201.%E5%AE%9A%E4%B9%89%E5%B9%B6%E9%87%87%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%207%202.%E8%B7%9F%E8%B8%AA%E6%82%A8%E7%9A%84%E8%B5%84%E4%BA%A7%E5%B9%B6%E8%BF%9B%E8%A1%8C%E5%A8%81%E8%83%81%E8%AF%84%E4%BC%B0%208%203.%E9%81%B5%E5%AE%88%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%20%E6%9B%B4%E5%A4%9A%E9%A1%B9%E7%9B%AE">5大Web应用安全威胁与7大防护措施</a></p><h2 id="什么是前端工程化？"><a href="#什么是前端工程化？" class="headerlink" title="什么是前端工程化？"></a>什么是前端工程化？</h2><p>对前端进行一些流程的标准化，让开发变得更有效率，且更好的做产品交付。前端工程化是使用软件工程的技术和方法来进行前端的开发流程、技术、工具、经验等规范化、标准化，其主要目的是为了提高效率和降低成本，即提高开发过程中的开发效率，减少不必要的重复工作时间。</p><p><a href="https://zhuanlan.zhihu.com/p/588483704">前端工程化指的是什么？</a></p><h2 id="如何实现模块懒加载？"><a href="#如何实现模块懒加载？" class="headerlink" title="如何实现模块懒加载？"></a>如何实现模块懒加载？</h2><p>模块懒加载是指在需要模块的时候才进行加载，而不是在应用启动时就加载所有的模块，这样可以提高应用的启动速度与性能。实现模块懒加载的方法由很多，比如：</p><ul><li>Webpack实现</li><li>ES6 import()</li></ul><h2 id="Http3-0更新了什么？"><a href="#Http3-0更新了什么？" class="headerlink" title="Http3.0更新了什么？"></a>Http3.0更新了什么？</h2><ul><li><p><strong>使用UDP代替TCP，不需要复杂的创建连接和关闭连接的成本</strong></p></li><li><p><strong>基于传输层的多路复用，避免队头阻塞</strong></p></li><li><p><strong>向前纠错</strong> (每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传)</p><p>向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间（包括确认数据包丢失、请求重传、等待新数据包等步骤的时间消耗）。</p></li><li><p><strong>加密认证的报文</strong></p><p>TCP协议头部没有经过任何加密和认证，所以在传输的过程中很容易被中间网络设备篡改、注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也可能是主动攻击。</p><p>但是QUIC的packet除了个别报文比如说PUBLIC_RESET和CHLO，所有的报文头部都是经过认证的，报文体都是经过加密的。</p><p>这样只要对QUIC报文进行任何修改，接收端都能够及时发现，有效地降低了安全风险。</p></li></ul><p>参考：<a href="https://limeii.github.io/2019/06/http2-http3/">Http3.0更新了什么</a></p><h2 id="前端常见的安全问题？"><a href="#前端常见的安全问题？" class="headerlink" title="前端常见的安全问题？"></a>前端常见的安全问题？</h2><ul><li>跨站脚本攻击(XSS)</li><li>跨站请求伪造(CSRF)</li><li>点击劫持(Click Jacking)</li><li>HTTP严格传输安全(HSTS)</li><li>CDN劫持</li><li>SQL注入攻击</li></ul><h2 id="如何进行防范？"><a href="#如何进行防范？" class="headerlink" title="如何进行防范？"></a>如何进行防范？</h2><ul><li>输入检查：对用户输入的数据进行检查和过滤，防止XSS和SQL注入等攻击。</li><li>输出攻击：对输出到页面上的数据进行检查和过滤，防止XSS攻击。</li><li>防范CSRF攻击：在请求中添加随机数或者验证码。</li><li>防止点击劫持：使用X-FRAME-OPTIONS头部或者JS脚本防止点击劫持</li><li>防止HTTP劫持：使用HTTPS协议或HTTP严格传输安全(HSTS)协议防范HTTP劫持</li><li>防止CDN劫持：使用SRI，为了防止校验资源完整性来判断是否被篡改。它通过验证文件的哈希值是否与你提供的哈希值一样来判断资源是否被篡改。</li></ul><h2 id="XSS与CSRF的攻击场景？"><a href="#XSS与CSRF的攻击场景？" class="headerlink" title="XSS与CSRF的攻击场景？"></a>XSS与CSRF的攻击场景？</h2><p>XSS：跨站脚本攻击，攻击者将恶意脚本嵌入到被攻击网站中，当用户访问该网站时，恶意脚本会被执行，从而达到获取用户信息、窃取Cookie等目的。</p><p>攻击场景：评论区、搜索框、留言板、聊天室。</p><p>CSRF：跨站请求伪造。攻击者通过某种方法诱导用户访问被攻击网站，从而在用户不知情的情况下发起恶意请求，如转账、修改密码等。</p><p>攻击场景：点击链接、打开图片、访问网页等。</p><h2 id="如果通过-html-标签内的-src-属性攻击-只能攻击到-GET-请求-如何攻击到-POST-请求？"><a href="#如果通过-html-标签内的-src-属性攻击-只能攻击到-GET-请求-如何攻击到-POST-请求？" class="headerlink" title="如果通过 html 标签内的 src 属性攻击, 只能攻击到 GET 请求, 如何攻击到 POST 请求？"></a>如果通过 html 标签内的 src 属性攻击, 只能攻击到 GET 请求, 如何攻击到 POST 请求？</h2><p>如果攻击者想要攻击POST请求，可以使用类似XSS攻击的方式，即通过在HTML标签内嵌入恶意代码，从而实现攻击。例如，攻击者在一个表单中插入一个隐藏的iframe，然后将表单的提交地址修改为攻击者的服务器地址，当用户提交表单的时候，iframe自动向被攻击网站发起POST请求，从而实现CSRF攻击。</p><h2 id="多进程编程的难点和解决方案？"><a href="#多进程编程的难点和解决方案？" class="headerlink" title="多进程编程的难点和解决方案？"></a>多进程编程的难点和解决方案？</h2><p>多线程编程的难点主要有以下几个方面：线程安全、死锁、资源竞争、线程间通信等。</p><p>其中，线程安全是多线程编程中最重要的问题之一，它涉及到<strong>多个线程同时访问同一个共享资源时的数据一致性问题</strong>。</p><p>死锁是指两个或多个进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法继续执行下去。</p><p>资源竞争是指多个线程同时访问同一个共享资源时，由于访<strong>问顺序不当而导致程序出现错误</strong>。</p><p>线程间通信是指多个线程之间相互协作完成任务的过程，包括等待通知机制、管道机制、信号量机制等。</p><h2 id="script的引入方式有哪些？"><a href="#script的引入方式有哪些？" class="headerlink" title="script的引入方式有哪些？"></a>script的引入方式有哪些？</h2><p>script的引入方式有三种：行内式、嵌入式和外链式。</p><ul><li><p>行内式是将JavaScript代码作为HTML标签的属性值使用。</p></li><li><p>嵌入式使用<code>&lt;script&gt;</code>标签包裹JavaScript代码，直接编写到HTML文件中，通常将其放到<code>&lt;head&gt;</code>标签或<code>&lt;body&gt;</code>标签中。</p></li><li><p>外链式是将JavaScript代码写在一个单独的文件中，一般使用<code>.js</code>作为文件的扩展名，在HTML页面中使用<code>&lt;script&gt;</code>标签的<code>src</code>属性引入<code>.js</code>文件。外链式适合<code>JS</code>代码量较多的情况。</p></li></ul><h2 id="localStorage和Cookie存储如果不注意的话，会有什么安全问题？"><a href="#localStorage和Cookie存储如果不注意的话，会有什么安全问题？" class="headerlink" title="localStorage和Cookie存储如果不注意的话，会有什么安全问题？"></a>localStorage和Cookie存储如果不注意的话，会有什么安全问题？</h2><p>Cookie容易受到跨站脚本攻击(XSS)和跨站请求伪造(CSRF)的攻击；而localStorage容易受到跨站脚本攻击(XSS)的攻击。</p><ul><li><p>对于Cookie，可以使用HttpOnly标志来防止XSS攻击，使其无法通过JS进行访问；使用SameSite标志来防止CSRF攻击。</p></li><li><p>对于localStorage，尽量不要存储敏感信息，或者使用sessionStorage进行替代。</p></li></ul><h2 id="首屏加载、白屏时间长可能是哪些原因导致的？"><a href="#首屏加载、白屏时间长可能是哪些原因导致的？" class="headerlink" title="首屏加载、白屏时间长可能是哪些原因导致的？"></a>首屏加载、白屏时间长可能是哪些原因导致的？</h2><ul><li>打包后的js和css文件过大，浏览器初始访问网站时，会先加载该项目的js和css文件，加载完成后才会进行页面渲染。如果打包的文件过大，加载时间就会变长，出现视觉上的页面白屏，可以使用webpack进行代码分割、懒加载等优化，减小入口文件体积。</li><li>网络延迟：网络延迟是影响首屏加载速度的主要因素之一。可以通过使用CDN、DNS预解析等方式来减少网络延迟时间。</li><li>资源重复请求加载：可以使用Webpack的splitChunks进行公共代码抽离，避免重复请求。</li><li>加载脚本的过程中，渲染堵塞：可以使用defer、async等属性来异步加载脚本，避免渲染堵塞。</li></ul><h2 id="页面响应式布局方式？"><a href="#页面响应式布局方式？" class="headerlink" title="页面响应式布局方式？"></a>页面响应式布局方式？</h2><p>媒体查询、弹性布局、rem布局、自适应布局、百分比布局、grid布局</p><h2 id="如何实现CSS的渐变？"><a href="#如何实现CSS的渐变？" class="headerlink" title="如何实现CSS的渐变？"></a>如何实现CSS的渐变？</h2><p>CSS渐变可以让你在两个或多个指定的颜色之间显示平稳的过渡。CSS定义了两种渐变类型：线性渐变和径向渐变。线性渐变是从一个方向到另一个方向的颜色过渡，而径向渐变是从一个中心点到另一个中心点的颜色过渡。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(red, yellow); <span class="hljs-comment">/* 从上到下(默认)渐变 */</span><br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(to right, red , yellow); <span class="hljs-comment">/* 从左到右渐变 */</span><br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(to bottom right, red, yellow); <span class="hljs-comment">/* 从坐上到右下线性渐变 */</span><br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(angle, color-stop1, color-stop2); <span class="hljs-comment">/* angle指定水平线与渐变线之间的角度 */</span><br></code></pre></td></tr></table></figure><h2 id="forEach和map的区别？"><a href="#forEach和map的区别？" class="headerlink" title="forEach和map的区别？"></a>forEach和map的区别？</h2><p>forEach会针对每个元素执行提供的操作，该方法没有返回值。</p><p>如果对数据进行操作，如果是基础数据类型，不会有效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    item *= <span class="hljs-number">2</span>;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1,2,3,4,5]</span><br></code></pre></td></tr></table></figure><p>但如果是引用数据类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<br>    &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;001&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;LiHua&quot;</span><br>    &#125;, <br>    &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;002&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;XiaoMei&quot;</span><br>    &#125;<br>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(item.<span class="hljs-property">id</span> === <span class="hljs-string">&quot;001&quot;</span>) &#123;<br>        item.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;LiQiang&quot;</span>;<br>    &#125;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [ &#123; id: &#x27;001&#x27;, name: &#x27;LiQiang&#x27; &#125;, &#123; id: &#x27;002&#x27;, name: &#x27;XiaoMei&#x27; &#125; ]</span><br></code></pre></td></tr></table></figure><p>这是因为forEach中的item并不是真正的数组中的项，而是对数组中项的复制，因此如果是原始数据类型，修改它的复制元素并不会影响到它本身，而对于引用数据类型，复制的是对数据的引用，<strong>因此修改item的属性，对应的原始值的属性也会变化</strong>，但是直接修改item，将其指向另一个数据的话也不行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<br>    &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;001&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;LiHua&quot;</span><br>    &#125;, <br>    &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;002&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;XiaoMei&quot;</span><br>    &#125;<br>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(item.<span class="hljs-property">id</span> === <span class="hljs-string">&quot;001&quot;</span>) &#123;<br>        item = &#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&quot;003&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;XiaoMei&quot;</span>&#125;;<br>    &#125;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [ &#123; id: &#x27;001&#x27;, name: &#x27;LiHua&#x27; &#125;, &#123; id: &#x27;002&#x27;, name: &#x27;XiaoMei&#x27; &#125; ]</span><br></code></pre></td></tr></table></figure><p>而如果是下面的方法，原始数据类型和引用数据类型都能被修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>    arr[index] = item * <span class="hljs-number">2</span>;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [2,4,6,8,10]</span><br></code></pre></td></tr></table></figure><p>forEach使用return方法只能跳出本次循环，要想跳出整个循环需要抛出错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(item === <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-comment">// return;</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;你好&quot;</span>)<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>&#125;)<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * forEach跳出循环：抛出错误</span><br><span class="hljs-comment"> * 跳出本次循环：return</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>map方法会改变原数组的值，返回一个新的数组，新数组中的值为原数组调用函数处理后的值。</p><h2 id="for…in和for…of的区别？"><a href="#for…in和for…of的区别？" class="headerlink" title="for…in和for…of的区别？"></a>for…in和for…of的区别？</h2><p>for…of是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构(对象、数组等)并返回各项的值，二者区别如下：</p><ul><li>for…of遍历获取的是对象的键值，而for…in获取的是对象的键名</li><li>for…in会遍历对象的整个原型链，性能非常差不推荐使用，而for…of只会遍历当前对象不会遍历原型链</li><li>对数组的遍历，for…in会返回数组中所有可枚举对象(包括原型链上的可枚举对象)，for…of只返回数组下标对应的属性值。</li></ul><h2 id="如何使用for…of遍历对象？"><a href="#如何使用for…of遍历对象？" class="headerlink" title="如何使用for…of遍历对象？"></a>如何使用for…of遍历对象？</h2><ul><li>如果是类数组对象，使用Array.from进行转换</li><li>如果不是，添加[Symbol.iterator]属性，并指向一个迭代器即可 (yield进行添加) 。</li></ul><h2 id="Webpack中热更新-HMR-的原理是什么？"><a href="#Webpack中热更新-HMR-的原理是什么？" class="headerlink" title="Webpack中热更新(HMR)的原理是什么？"></a>Webpack中热更新(HMR)的原理是什么？</h2><p><code>HMR</code>全称 <code>Hot Module Replacement</code>，可以理解为模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用。</p><p>开启热更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>)<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-comment">// 开启 HMR 特性</span><br>    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span><br>    <span class="hljs-comment">// hotOnly: true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/1725635059c3e804~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ul><li>Webpack Compile：将 JS 源代码编译成 bundle.js</li><li>HMR Server：用来将热更新的文件输出给 HMR Runtime</li><li>Bundle Server：静态资源文件服务器，提供文件访问路径</li><li>HMR Runtime：socket服务器，会被注入到浏览器，更新文件的变化</li><li>bundle.js：构建输出的文件</li><li>在HMR Runtime 和 HMR Server之间建立 websocket，即图上4号线，用于实时更新文件变化</li></ul><p>热更新的两个过程</p><ul><li><p>启动阶段 1 - 2 - A - B</p><p>首先我们在文件系统便写完代码之后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server，Bundle Server 是一个服务器，这样在浏览器里就可以以服务的方式访问文件。</p></li><li><p>更新阶段 1 - 2 - 3 - 4</p><p>当我们在文件系统更新文件之后，还是会经过 Webpack Compile 的编译，Webpack Compile 会将编译后的结果传递给 HMR Server，HMR Server 会比较哪些文件发生了变化，因为服务端的 HMR Server 会和客户端的 HMR Runtime 建立起一条 websocket 链接，所以 HMR Server 会以 json 的形式通知给 HMR Runtime 文件做出了哪些变化。</p></li></ul><p><strong>总结：</strong></p><ul><li>通过<code>webpack-dev-server</code>创建两个服务器：提供静态资源的服务（express）和Socket服务</li><li>express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）</li><li>socket server 是一个 websocket 的长连接，双方可以通信</li><li>当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）</li><li>通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）</li><li>浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新</li></ul><p>参考：<a href="https://juejin.cn/post/6844904134697549832">https://juejin.cn/post/6844904134697549832</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识点整理(1)</title>
    <link href="/2023/04/08/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-1/"/>
    <url>/2023/04/08/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-1/</url>
    
    <content type="html"><![CDATA[<h1 id="整理总结-1"><a href="#整理总结-1" class="headerlink" title="整理总结(1)"></a>整理总结(1)</h1><h2 id="Vite比Webpack快的原因？"><a href="#Vite比Webpack快的原因？" class="headerlink" title="Vite比Webpack快的原因？"></a>Vite比Webpack快的原因？</h2><p>Vite比Webpack快的原因的因为Vite在开发阶段使用了浏览器原生ES模块导入，而不是想Wepkack一样使用打包后的文件。这使得Vite在开发阶段的热更新速度更快，因为它不需要重新打包整个应用程序，而只需要更新更改的部分。</p><h2 id="前端如何判断内存泄漏？如何处理？"><a href="#前端如何判断内存泄漏？如何处理？" class="headerlink" title="前端如何判断内存泄漏？如何处理？"></a>前端如何判断内存泄漏？如何处理？</h2><p>检测方法：</p><ul><li><p>使用Chrome的开发者工具profiles来进行快照对比。</p><ul><li>打开Chrome浏览器，进入开发者工具。</li><li>点击Profiles选项卡，选择Take Heap Snapshot或Take Allocation Profile。</li><li>进行操作后，再次点击Profiles选项卡，选择Compare Snapshots或Compare Allocation Profiles。</li><li>选择两个快照进行比较，即可看到两个快照之间的差异。</li></ul></li><li><p>在Node环境下，可以使用Node提供的<code>process.memoryUsage()</code>方法来检查内存泄漏。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">process.<span class="hljs-title function_">memoryUsage</span>();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">res: 2366456,</span><br><span class="hljs-comment">heapTotal: 9232384,</span><br><span class="hljs-comment">heapUsed: 5019712,</span><br><span class="hljs-comment">external: 8776</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li><p>res: (Resident Set Size)操作系统分配给进程的总的内存大小。</p></li><li><p>heapTotal：堆的总大小，包括3个部分，</p><ul><li>已分配的内存，用于对象的创建和存储，对应于heapUsed</li><li>未分配的但可用于分配的内存</li><li>未分配的但不能分配的内存，例如在垃圾收集（GC）之前对象之间的内存碎片</li></ul></li><li><p>heapUsed: 已分配的内存，即堆中所有对象的总大小，是heapTotal的子集</p></li><li><p>external: 进程使用到的系统链接库所占用的内存</p></li></ul><p>判断内存泄漏以heapUsed为准</p></li><li><p>利用Performance录制页面性能变化，若内存下限不断升高，则可能发生了内存泄漏</p></li></ul><p>如何处理内存泄漏？</p><p>变量导致的内存泄漏，将变量清除为null即可</p><p>事件导致的内存泄漏，监听后移除即可。</p><h2 id="为什么Redux要设计action等工具，而不是允许用户直接进行修改？"><a href="#为什么Redux要设计action等工具，而不是允许用户直接进行修改？" class="headerlink" title="为什么Redux要设计action等工具，而不是允许用户直接进行修改？"></a>为什么Redux要设计action等工具，而不是允许用户直接进行修改？</h2><p>设计action等工具是为了更好的管理状态。通过使用action，可以确保状态的变化是可预测的，因为它们只能通过dispatch函数进行更改，这样可以避免在应用程序中出现意外的状态变化，从而使代码更具有可维护性和可测试性。此外，使用action还可以使我们更好的跟踪应用程序中发生的事情，因为每个action都有唯一的标识符，可以轻松跟踪它们。</p><h2 id="组件库是如何实现让用户按需加载的？"><a href="#组件库是如何实现让用户按需加载的？" class="headerlink" title="组件库是如何实现让用户按需加载的？"></a>组件库是如何实现让用户按需加载的？</h2><p>通过支持基于ES模块的tree shaking来实现按需加载。只需要直接引入需要的组件，就可以实现按需加载的效果。</p><h2 id="axios的二次封装一般封装了什么？"><a href="#axios的二次封装一般封装了什么？" class="headerlink" title="axios的二次封装一般封装了什么？"></a>axios的二次封装一般封装了什么？</h2><p>设置超时事件、请求头、请求方法、错误处理，请求拦截器和响应拦截器等操作，如果重复进行劳动会浪费时间并使得代码变得冗余难以维护。</p><p>在请求拦截器中可以统一添加超时处理或取消请求等需要在请求前执行的事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 每次发送请求之前判断是否存在token</span><br>    <span class="hljs-comment">// 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况，此处token一般是用户完成登录后储存到localstorage里的</span><br>    token &amp;&amp; (config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = token)<br>    <span class="hljs-keyword">return</span> config<br>  &#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>&#125;)<br></code></pre></td></tr></table></figure><p>响应拦截器可以在接收到响应后先做一层操作，如根据状态码判断登陆状态、授权等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 响应拦截器</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据</span><br>  <span class="hljs-comment">// 否则的话抛出错误</span><br>  <span class="hljs-keyword">if</span> (response.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-keyword">if</span> (response.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> === <span class="hljs-number">511</span>) &#123;<br>      <span class="hljs-comment">// 未授权调取授权接口</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (response.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> === <span class="hljs-number">510</span>) &#123;<br>      <span class="hljs-comment">// 未登录跳转登录页</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(response)<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(response)<br>  &#125;<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 我们可以在这里对异常状态作统一处理</span><br>  <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span>) &#123;<br>    <span class="hljs-comment">// 处理请求失败的情况</span><br>    <span class="hljs-comment">// 对不同返回码对相应处理</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error.<span class="hljs-property">response</span>)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="Tree-Shaking的实现原理？"><a href="#Tree-Shaking的实现原理？" class="headerlink" title="Tree-Shaking的实现原理？"></a>Tree-Shaking的实现原理？</h2><p>Tree-Shaking是一种基于ES Module规范的Dead Code Elimination技术，它会在运行过程中静态分析模块之间的导入导出，确定ESM模块中的哪些导出值未曾被其他模块使用，并将其删除，以此实现打包产物的优化。</p><ul><li>Make阶段，收集模块导出变量并记录到模块依赖关系图ModuleGraph变量中</li><li>Seal阶段，遍历ModuleGraph标记模块导出变量有没有被使用</li><li>生成产物时，若变量没有被其他模块使用则删除对应的导出语言</li></ul><blockquote><p>标记功能需要配置 <code>optimization.usedExports = true</code> 开启</p></blockquote><h2 id="手写图片懒加载"><a href="#手写图片懒加载" class="headerlink" title="手写图片懒加载"></a>手写图片懒加载</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">lazyload</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> imgs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;img&#x27;</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> len = imgs.<span class="hljs-property">length</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> viewHeight = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span>;</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> scrollHeight = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span>;</span><br><span class="language-javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> offsetHeight = imgs[i].<span class="hljs-property">offsetTop</span>;</span><br><span class="language-javascript">            <span class="hljs-keyword">if</span> (offsetHeight &lt; viewHeight + scrollHeight) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">const</span> src = imgs[i].<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>;</span><br><span class="language-javascript">                imgs[i].<span class="hljs-property">src</span> = src;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, lazyload);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="针对弱网环境如何从Http的角度去做前端优化？"><a href="#针对弱网环境如何从Http的角度去做前端优化？" class="headerlink" title="针对弱网环境如何从Http的角度去做前端优化？"></a>针对弱网环境如何从Http的角度去做前端优化？</h2><ul><li>使用CDN加速，避免弱网环境下资源加载过慢</li><li>使用HTTP Cache、Service Worker和Cache Storage API等技术进行缓存资源，避免重复请求</li><li>对于移动端，可以使用SSR、CSR、预渲染等技术，提升网页首帧优化，从而优化白屏问题，提升用户体验</li></ul><h2 id="Webpack打包原理"><a href="#Webpack打包原理" class="headerlink" title="Webpack打包原理"></a>Webpack打包原理</h2><p>Webpack处理应用程序时，它会递归的构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle。Webpack的打包原理就是将所有的模块霸道成一个或多个Bundle，以便于在浏览器中加载和使用。</p><p>Webpack就像是一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有当完成当前处理后才能交给下一个流程去处理。而插件就像是插入到生产线中的一个功能，在特定的时机对生产线上的资源进行处理。</p><p>Webpack打包原理：<a href="https://zhuanlan.zhihu.com/p/101541041">https://zhuanlan.zhihu.com/p/101541041</a></p><h2 id="Webpack打包流程？"><a href="#Webpack打包流程？" class="headerlink" title="Webpack打包流程？"></a>Webpack打包流程？</h2><ol><li>解析配置文件：Webpack会读取并解析配置文件(通常为webpack.config.js文件)。并根据配置生成一个Compiler对象。</li><li>读取入口文件：Webpack会根据配置中的入口文件，读取这些文件及其依赖的模块，并将它们组成一个依赖图。</li><li>解析模块依赖：Webpack会根据模块之间的依赖关系，递归的解析它们的依赖。直到所有的依赖都被解析完毕。</li><li>加载模块：Webpack会根据模块的路径，使用相应的Loader加载模块的源代码，并将其转换成Webpack可以处理的形式。</li><li>转换代码：Webpack会根据配置中的插件，对加载的模块进行一系列的转换操作，比如压缩，优化等。</li><li>生成代码：Webpack会将所有模块转换后的代码都合并到一个或多个文件中并输出到指定目录中。</li></ol><p>Webpack打包流程：<a href="https://juejin.cn/post/7210756376309203005">简析Webpack打包流程 - 掘金 (juejin.cn)</a></p><h2 id="useRef有哪些作用？"><a href="#useRef有哪些作用？" class="headerlink" title="useRef有哪些作用？"></a>useRef有哪些作用？</h2><p>React中的useRef是一个Hook，它返回一个可变的ref对象，它的<code>.current</code>属性被初始化为传入的参数(initialValue)。useRef可以用来存储任何可变值，就像在类数组中使用实例属性一样。</p><p>useRef返回的对象在组件的整个生命周期中保持不变，因此可以用来存储哪些 不需要触发重新渲染的值，例如定时器或其他引用类型的值。另外，useRef还可以用来获取DOM元素或者其他组件的实例。</p><p>作用：</p><ul><li>存储状态</li><li>获取DOM元素或其他组件实例</li></ul><h2 id="如何在父组件中执行子组件内部的方法-不知道这个子组件内部方法的名称-？"><a href="#如何在父组件中执行子组件内部的方法-不知道这个子组件内部方法的名称-？" class="headerlink" title="如何在父组件中执行子组件内部的方法(不知道这个子组件内部方法的名称)？"></a>如何在父组件中执行子组件内部的方法(不知道这个子组件内部方法的名称)？</h2><p>使用useRef进行解决</p><h2 id="React中父组件如何向子孙组件传值？"><a href="#React中父组件如何向子孙组件传值？" class="headerlink" title="React中父组件如何向子孙组件传值？"></a>React中父组件如何向子孙组件传值？</h2><ul><li>props</li><li>useContext</li></ul><h2 id="子孙组件如何修改通过useContext获取到的值？"><a href="#子孙组件如何修改通过useContext获取到的值？" class="headerlink" title="子孙组件如何修改通过useContext获取到的值？"></a>子孙组件如何修改通过useContext获取到的值？</h2><p>在父组件中定义一个state，然后将state和其更新方法一起传递给context对象，然后再需要的时候调用该函数修改state。</p><p>例如：在App.jsx中定义count，并将其传递给Context</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; createContext, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Father</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Father&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> C = <span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">C.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;count,</span> <span class="hljs-attr">setCount</span>&#125;&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Father</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">C.Provider</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在Father组件中引用Son组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../Son&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Son</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Son</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>最终在子组件中展示count以及修改count</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; C &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../App&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;count, setCount&#125; = <span class="hljs-title function_">useContext</span>(C);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>count的值为&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count+1)&#125;&gt;点我+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="context封装的值改变了，会触发组件的重新渲染吗？"><a href="#context封装的值改变了，会触发组件的重新渲染吗？" class="headerlink" title="context封装的值改变了，会触发组件的重新渲染吗？"></a>context封装的值改变了，会触发组件的重新渲染吗？</h2><p>在 React 中，当一个组件被包裹在一个 Context Provider 中时，只有当该组件<strong>直接依赖于该 Context 数据</strong>时，才会在 Context 数据发生变化时重新渲染。</p><p>如果一个组件被包裹在一个 Context Provider 中，但是它并没有使用该 Context 数据，那么该组件不会在 Context 数据发生变化时重新渲染。</p><p>这是因为 React 使用了优化算法来避免不必要的重新渲染，也就是说，只有当组件的 props 或者 state 发生变化时，才会触发重新渲染。而对于 Context 数据的变化，只有当该 Context 数据被使用的组件才会重新渲染。</p><p><del>当<code>Context</code>中某一个值改变，所有<strong>使用了该<code>Context</code>的组件</strong>一定都会更新。</del></p><p><del>如果想要避免组件重新渲染，可以使用React.memo。</del></p><p><del>如果组件没有使用Context，但是被Context包裹，当Context封装的值改变时，React不会重新渲染该组件。</del></p><p><del>如果一个组件没有使用Context，但是被Context包裹，当Context封装的值改变时，React会重新渲染该组件。这是因为React会检查组件的所有祖先节点是否有更新，如果有更新，React会重新渲染这些组件。因此，即使一个组件没有使用Context，但是它被Context包裹，当Context封装的值改变时，React也会重新渲染该组件。</del></p><h2 id="假如在某个子孙组件中-使用了-useEffect-其依赖项中记录了某个-context-当-context-值变了-会触发-useEffect-内包裹的函数执行吗-会触发该组件的重新渲染吗"><a href="#假如在某个子孙组件中-使用了-useEffect-其依赖项中记录了某个-context-当-context-值变了-会触发-useEffect-内包裹的函数执行吗-会触发该组件的重新渲染吗" class="headerlink" title="假如在某个子孙组件中, 使用了 useEffect, 其依赖项中记录了某个 context, 当 context 值变了, 会触发 useEffect 内包裹的函数执行吗? 会触发该组件的重新渲染吗?"></a>假如在某个子孙组件中, 使用了 useEffect, 其依赖项中记录了某个 context, 当 context 值变了, 会触发 useEffect 内包裹的函数执行吗? 会触发该组件的重新渲染吗?</h2><p>使用useEffect包裹context的值，当context的值发生变化会触发useEffect包裹的函数执行，即使props和state没有发生变化，也会导致该组件的重新渲染，但是如果使用React.memo包裹就不会导致组件重新渲染了。<del>但是不会触发该组件的重新渲染。</del></p><h2 id="Http-301和302状态码的区别？"><a href="#Http-301和302状态码的区别？" class="headerlink" title="Http 301和302状态码的区别？"></a>Http 301和302状态码的区别？</h2><p>二者都是重定向状态码，都代表着某个URL发生了转移。不同支持在于，301表示永久性转移，表示请求的资源分配了新的URL，以后应使用新的URL；而302表示暂时性转移，请求的资源临时分配了新的URL，本次请求暂且使用新URL，重定向的URL可能还会改变。</p><h2 id="在触发301状态码的时候，浏览器会把更新的url存放在何处？"><a href="#在触发301状态码的时候，浏览器会把更新的url存放在何处？" class="headerlink" title="在触发301状态码的时候，浏览器会把更新的url存放在何处？"></a>在触发301状态码的时候，浏览器会把更新的url存放在何处？</h2><p>当浏览器收到301状态码时，会把更新的URL存放在响应头的Location字段中，浏览器会自动重定向到该URL，301状态码表示永久性转移，所以浏览器会记住这个URL，下次访问该URL，浏览器会直接访问新的URL，不再请求旧的URL。</p><h2 id="Promise的优点和缺点？"><a href="#Promise的优点和缺点？" class="headerlink" title="Promise的优点和缺点？"></a>Promise的优点和缺点？</h2><p>优点：</p><p>将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数，提供了统一的接口，使得控制异步操作更加容易。</p><p>缺点：</p><p>无法取消Promise，一旦新建后它就会立即执行，无法中途取消；如果不设置回调函数，Promise内部抛出错误不会反应到外部；当处于Pending状态时，无法得知现在处于哪个阶段(刚刚开始还是即将完成)。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算及其应用</title>
    <link href="/2023/04/08/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <url>/2023/04/08/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="判断一个整数n是否为负数"><a href="#判断一个整数n是否为负数" class="headerlink" title="判断一个整数n是否为负数"></a>判断一个整数n是否为负数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 判断n是负数还是非负数</span><br><span class="hljs-comment"> * if n是非负数,返回1</span><br><span class="hljs-comment"> * if n是负数,返回0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">sign</span> = (<span class="hljs-params">n</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>-((n &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="比较两个数的大小"><a href="#比较两个数的大小" class="headerlink" title="比较两个数的大小"></a>比较两个数的大小</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 位运算获取较的大值</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getMax1</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> c = a-b; <span class="hljs-comment">// a&gt;=b时,c&gt;=0;否则c&lt;0</span><br>    <span class="hljs-keyword">let</span> scA = <span class="hljs-title function_">sign</span>(c); <span class="hljs-comment">// a-b为非负,scA为1,a-b为负,scA为0(当scA为1的时候,a比较大)</span><br>    <span class="hljs-keyword">let</span> scB = <span class="hljs-number">1</span>-scA; <span class="hljs-comment">// 当scB为1的时候,b比较大</span><br>    <span class="hljs-comment">// 当scA为0的时候,scB一定为1,当scA为1的时候,scB一定为0</span><br>    <span class="hljs-comment">// (若scA为1,返回a,若scB为1,返回b)</span><br>    <span class="hljs-keyword">return</span> a*scA + b*scB;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码有一个缺点,即当a,b异号且相差较大的时候,c可能溢出</p><p>改善后的代码为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 优化后</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getMax2</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> c = a-b; <span class="hljs-comment">// a&gt;=b时,c&gt;=0;否则c&lt;0</span><br>    <span class="hljs-keyword">let</span> sa = <span class="hljs-title function_">sign</span>(a); <span class="hljs-comment">// a&gt;=0时sa=1,否则sa=0</span><br>    <span class="hljs-keyword">let</span> sb = <span class="hljs-title function_">sign</span>(b); <span class="hljs-comment">// b&gt;=0时sb=1,否则sb=0</span><br>    <span class="hljs-keyword">let</span> sc = <span class="hljs-title function_">sign</span>(c); <span class="hljs-comment">// c&gt;=0时sc=1,否则sc=0</span><br>    <span class="hljs-comment">// 异或运算,判断a,b是否同号</span><br>    <span class="hljs-keyword">let</span> difSab = sa ^ sb; <span class="hljs-comment">// a和b的符號不同为1,相同为0</span><br>    <span class="hljs-keyword">let</span> sameSab = <span class="hljs-number">1</span> - difSab; <span class="hljs-comment">// a和b的符号一样为1,不一样为0</span><br>    <span class="hljs-comment">// 当二者不同号且a&gt;=0时,returnA=1,当二者同号且a&gt;=b(c&gt;=0)时,returnA为1,否则为0</span><br>    <span class="hljs-keyword">let</span> returnA = difSab * sa + sameSab * sc;<br>    <span class="hljs-keyword">let</span> returnB = <span class="hljs-number">1</span> - returnA;<br>    <span class="hljs-comment">// 返回较大的数</span><br>    <span class="hljs-keyword">return</span> a*returnA + b*returnB;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="判断一个32位正数是不是2的幂-4的幂"><a href="#判断一个32位正数是不是2的幂-4的幂" class="headerlink" title="判断一个32位正数是不是2的幂,4的幂"></a>判断一个32位正数是不是2的幂,4的幂</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 判断一个32位正数是不是2的幂</span><br><span class="hljs-comment"> * 思路:</span><br><span class="hljs-comment"> * 如果一个正数是2的幂,则它的二进制上只有一个1</span><br><span class="hljs-comment"> * 00001 -&gt; 2^0</span><br><span class="hljs-comment"> * 00010 -&gt; 2^1</span><br><span class="hljs-comment"> * 00100 -&gt; 2^2</span><br><span class="hljs-comment"> * 01000 -&gt; 2^3</span><br><span class="hljs-comment"> * 10000 -&gt; 2^4</span><br><span class="hljs-comment"> * .....</span><br><span class="hljs-comment"> * 当最后一位为1时,num-1 = 0</span><br><span class="hljs-comment"> * 其他情况下,1会被打散 </span><br><span class="hljs-comment"> * 2^1-1 -&gt; 00001</span><br><span class="hljs-comment"> * 2^2-1 = 000011</span><br><span class="hljs-comment"> * ......</span><br><span class="hljs-comment"> * 因此,num &amp; (num-1)=0时.就是2的幂</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 判断一个32位正数是不是4的幂</span><br><span class="hljs-comment"> * 同理,二进制只能有一个1,且必须在0,2,4,6...位上</span><br><span class="hljs-comment"> * 1. num &amp; (num-1) = 0 (只有一个1)</span><br><span class="hljs-comment"> * 2. num &amp; 01010101...01 !== 0(1在偶数位上)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 判断一个数是不是2的幂</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">is2Power</span> = (<span class="hljs-params">n</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> n &amp; (n-<span class="hljs-number">1</span>) === <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 判断一个数是不是4的幂</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">is4Power</span> = (<span class="hljs-params">n</span>) =&gt; &#123;<br>    <span class="hljs-comment">//                               ...1010101</span><br>    <span class="hljs-keyword">return</span> (n &amp; (n-<span class="hljs-number">1</span>)) === <span class="hljs-number">0</span> &amp;&amp; (n &amp; <span class="hljs-number">0x55555555</span>) != <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="位运算实现加减乘除"><a href="#位运算实现加减乘除" class="headerlink" title="位运算实现加减乘除"></a>位运算实现加减乘除</h2><p>给定两个有符号32位整数a和b,不能使用算术运算符,分别实现a和b的加,减,乘,除运算</p><p><strong>[要求]</strong></p><p>如果给定a,b执行加减乘除的运算结果就会导致数据溢出,那你实现的函数不必对此负责,除此之外请保证计算过程不发生溢出</p><h3 id="两个数的二进制进行相加"><a href="#两个数的二进制进行相加" class="headerlink" title="两个数的二进制进行相加"></a>两个数的二进制进行相加</h3><p>进行异或运算,得到的结果就是<strong>二者相加后无进位的值</strong></p><p>通过与运算能获取要进位的数</p><p>与运算向左移一位,得到的就是<strong>进位结果</strong></p><p>然后将异或运算得到的结果和与运算得到的结果再进行如上运算</p><p>直到与运算的结果为0(没有进位了)</p><p><img src="http://dawning.fun/wp-content/uploads/2022/06/image-20220513203808367.png" alt="img"> 进行异或运算和与运算得到结果</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//@ 加法</span><br><span class="hljs-comment">// 如果用户传入的参数,a+b就是溢出的,那结果就可能出错</span><br>const add = <span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> &#123;<br>    let <span class="hljs-built_in">sum</span> = a;<br>    <span class="hljs-keyword">while</span>(b ^= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 当与运算的值不为0,一直进行循环</span><br>        <span class="hljs-built_in">sum</span> = a ^ b; <span class="hljs-comment">// 无进位相加的结果</span><br>        b = (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 进位信息</span><br>        a = <span class="hljs-built_in">sum</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两个数的二进制进行相减"><a href="#两个数的二进制进行相减" class="headerlink" title="两个数的二进制进行相减"></a>两个数的二进制进行相减</h3><p>a-b即为a加上b的相反数(a-(-b))</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">negNum</span> = (<span class="hljs-params">n</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 计算n取反后与1相加的结果(即为n的相反数-n)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">add</span>(~n,<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">minus</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 计算a与-b相加的结果</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">add</span>(a,<span class="hljs-title function_">negNum</span>(b));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两个数的二进制进行相乘"><a href="#两个数的二进制进行相乘" class="headerlink" title="两个数的二进制进行相乘"></a>两个数的二进制进行相乘</h3><p>两个二进制相乘的时候,直接使用二进制的每一位互相乘(和十进制乘法相同),最后将结果相加即可</p><p><img src="http://dawning.fun/wp-content/uploads/2022/06/16524503131.png" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//@ 二进制计算两个数相乘</span><br><span class="hljs-comment">// 如果用户传入的参数中,a*b就是溢出的,那结果肯定会出错</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">mulit</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(b !== <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>((b &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// b的最后一位不为0</span><br>            res = <span class="hljs-title function_">add</span>(res,a);<br>        &#125; <br>        a &lt;&lt;= <span class="hljs-number">1</span>;<br>        b &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两个数的二进制进行相除"><a href="#两个数的二进制进行相除" class="headerlink" title="两个数的二进制进行相除"></a>两个数的二进制进行相除</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isNeg</span> = (<span class="hljs-params">n</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> n &lt; <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//@ 二进制计算两个数相除</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">div</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">isNeg</span>(a) ? <span class="hljs-title function_">negNum</span>(a) : a;<br>    <span class="hljs-keyword">let</span> y = <span class="hljs-title function_">isNeg</span>(b) ? <span class="hljs-title function_">negNum</span>(b) : b;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">31</span>;i &gt; -<span class="hljs-number">1</span>;i = <span class="hljs-title function_">minus</span>(i,<span class="hljs-number">1</span>))&#123;<br>        <span class="hljs-keyword">if</span>((x &gt;&gt; i) &gt;= y)&#123;<br>            res |= (<span class="hljs-number">1</span> &lt;&lt; i);<br>            x = <span class="hljs-title function_">minus</span>(x,y &lt;&lt; i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">isNeg</span>(a) ^ <span class="hljs-title function_">isNeg</span>(b) ? <span class="hljs-title function_">negNum</span>(res) : res;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">divide</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span>(b === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 分母不能为0</span><br>    <span class="hljs-keyword">if</span>(a === <span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_VALUE</span> &amp;&amp; b === <span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_VALUE</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b === <span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_VALUE</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a === <span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_VALUE</span>)&#123;<br>        <span class="hljs-keyword">let</span> res = <span class="hljs-title function_">div</span>(<span class="hljs-title function_">add</span>(a,<span class="hljs-number">1</span>),b);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">add</span>(req,<span class="hljs-title function_">div</span>(<span class="hljs-title function_">minus</span>(a,<span class="hljs-title function_">mulit</span>(res,b)),b));<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">div</span>(a,b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结(4.1)</title>
    <link href="/2023/04/08/%E6%80%BB%E7%BB%93-4-1/"/>
    <url>/2023/04/08/%E6%80%BB%E7%BB%93-4-1/</url>
    
    <content type="html"><![CDATA[<h1 id="携程一面"><a href="#携程一面" class="headerlink" title="携程一面"></a>携程一面</h1><h2 id="介绍项目"><a href="#介绍项目" class="headerlink" title="介绍项目"></a>介绍项目</h2><h2 id="Redux的实现原理？"><a href="#Redux的实现原理？" class="headerlink" title="Redux的实现原理？"></a>Redux的实现原理？</h2><p><code>Redux</code> 的实现原理可以概括为：单一数据源、状态不可变、纯函数更新状态。</p><p>具体来说，<code>Redux</code> 将应用程序的状态存储在一个单一的对象中，称为<code>store</code>。这个<code>store</code>对象是只读的，应用程序的状态只能通过派发“action”来改变。每个“action”描述了应用程序中发生的某个事件，它包含一个类型和一些数据。当派发一个<code>action</code>时，<code>Redux</code> 会将当前的状态和“action”一起传递给一个“reducer”函数，这个函数根据“action”的类型来更新状态，并返回一个新的状态对象。<code>Redux</code> 的状态更新是纯函数式的，它不会直接修改原来的状态，而是返回一个新的状态对象，从而保证了状态的不可变性。</p><p><code>Redux</code> 还提供了一些辅助函数，如<code>connect</code>和<code>mapStateToProps</code>，用于将<code>store</code>中的状态映射到组件的属性中，并在状态变化时自动更新组件。这些函数也是基于纯函数的原理实现的。</p><h2 id="React-Hooks是什么？"><a href="#React-Hooks是什么？" class="headerlink" title="React Hooks是什么？"></a>React Hooks是什么？</h2><p>React Hooks 是 React 16.8 引入的新特性，它可以让函数组件拥有类组件的一些特性，如状态管理、副作用处理等。</p><p>在 React 16.7 之前，函数组件只能通过 props 传递数据和方法，无法保存状态，也无法使用类组件的生命周期方法和其他特性。但是，函数组件具有代码简洁、易于测试和重构的优势，因此在实际开发中使用较多。React Hooks 的出现，使得函数组件也能够方便地管理状态、访问上下文和处理副作用。</p><h2 id="React官方为什么推荐使用Hooks？"><a href="#React官方为什么推荐使用Hooks？" class="headerlink" title="React官方为什么推荐使用Hooks？"></a>React官方为什么推荐使用Hooks？</h2><p>React 官方推荐使用 Hooks 的原因主要有以下几点：</p><ol><li>更好的代码复用：使用 Hooks 可以将组件之间的状态和逻辑进行复用，避免了 HOC 和 render props 带来的嵌套和重复。</li><li>更好的组件结构：使用 Hooks 可以将组件的状态和逻辑进行拆分，使组件的结构更加清晰和简洁。</li><li>更好的性能优化：使用 Hooks 可以避免不必要的渲染，从而提高组件的性能。</li><li>更好的测试性：使用 Hooks 可以更方便地进行单元测试，避免了类组件中需要使用 Enzyme 等工具进行测试的情况。</li><li>更好的开发体验：使用 Hooks 可以减少代码量，提高开发效率，使代码更加易读、易懂。</li></ol><h2 id="为什么React-Hooks对代码的可维护性更强？"><a href="#为什么React-Hooks对代码的可维护性更强？" class="headerlink" title="为什么React Hooks对代码的可维护性更强？"></a>为什么React Hooks对代码的可维护性更强？</h2><p>React Hooks 可以提高代码的可读性、可维护性、可测试性和性能优化，从而使得项目的可维护性更强。</p><h2 id="常见的React-Hooks"><a href="#常见的React-Hooks" class="headerlink" title="常见的React Hooks?"></a>常见的React Hooks?</h2><ul><li>useState</li><li>useEffect</li><li>useRef</li><li>useContext</li><li>useReducer</li><li>useCallback</li><li>useMemo</li></ul><h2 id="为什么要在项目中使用useMemo？"><a href="#为什么要在项目中使用useMemo？" class="headerlink" title="为什么要在项目中使用useMemo？"></a>为什么要在项目中使用useMemo？</h2><p>在项目中使用 useMemo 的主要原因是优化组件的性能，避免不必要的计算和渲染，从而提高项目性能和用户体验。</p><p>useMemo 是一个 Hooks API，它可以缓存计算结果，只有在依赖项发生变化时才重新计算。这样可以避免在每次渲染时都进行昂贵的计算，从而提高组件的性能。</p><p>在项目中，使用 useMemo 可以优化以下情况：</p><ol><li>计算昂贵的函数结果：如果一个函数的计算结果很昂贵，但是这个结果只在某些依赖项发生变化时才需要重新计算，这时就可以使用 useMemo 缓存计算结果，避免不必要的计算。</li><li>避免不必要的渲染：如果一个组件的某个属性是通过复杂计算得到的，但是这个属性并不是组件状态的一部分，这时可以使用 useMemo 缓存属性值，避免不必要的渲染。</li><li>优化子组件的渲染：如果一个组件的某个属性是一个函数，这个函数返回一个组件，但是这个函数并不是组件状态的一部分，这时可以使用 useMemo 缓存函数结果，避免不必要的子组件渲染。</li></ol><h2 id="useMemo相当于是对状态进行了一次缓存吗？"><a href="#useMemo相当于是对状态进行了一次缓存吗？" class="headerlink" title="useMemo相当于是对状态进行了一次缓存吗？"></a>useMemo相当于是对状态进行了一次缓存吗？</h2><p>是的，useMemo 可以看作是对计算结果进行缓存，仅在依赖项发生变化时才会重新计算。</p><p>useMemo 接收两个参数：一个是计算函数，另一个是依赖项数组。当依赖项数组中的任意一个依赖项发生变化时，useMemo 会重新计算计算函数的结果。如果依赖项数组中的依赖项没有发生变化，则 useMemo 返回上一次缓存的结果。</p><p>通过使用 useMemo，可以避免在每次渲染时都进行昂贵的计算，提高组件的性能。在某些情况下，如果没有使用 useMemo，组件可能会进行大量的重复计算，导致性能下降。</p><p>此外，虽然 useMemo 可以优化组件的性能，但是过度使用 useMemo 也会带来一些问题，如增加内存占用和代码复杂度等。因此，在使用 useMemo 时需要根据实际情况进行权衡和调整。</p><h2 id="useEffect和useLayoutEffect的区别？"><a href="#useEffect和useLayoutEffect的区别？" class="headerlink" title="useEffect和useLayoutEffect的区别？"></a>useEffect和useLayoutEffect的区别？</h2><p>useEffect 和 useLayoutEffect 都是 React 的 Hooks API，它们的主要区别在于执行的时机和是否会阻塞浏览器渲染。</p><ol><li>执行时机：useEffect 是在组件渲染完成后、在浏览器完成布局和绘制之后异步执行的，而 useLayoutEffect 是在组件渲染完成后、页面绘制和布局前同步执行的。因此，useLayoutEffect 的执行优先级更高。</li><li>是否阻塞浏览器渲染：useEffect 不会阻塞浏览器渲染，而 useLayoutEffect 会阻塞浏览器渲染。因此，在使用 useLayoutEffect 时要注意避免长时间的计算和操作，以免影响用户体验。</li><li>使用场景：useEffect 适合处理副作用，如数据获取、订阅事件等。而 useLayoutEffect 适合处理需要同步更新 DOM 的操作，如计算 DOM 元素的大小和位置等。</li></ol><p>综上所述，useEffect 和 useLayoutEffect 在执行时机和是否阻塞浏览器渲染方面有所不同，需要根据实际情况选择使用。一般来说，如果需要同步更新 DOM，可以使用 useLayoutEffect，否则可以使用 useEffect。</p><h2 id="Node-js在搭建服务器的时候起了哪些作用？"><a href="#Node-js在搭建服务器的时候起了哪些作用？" class="headerlink" title="Node.js在搭建服务器的时候起了哪些作用？"></a>Node.js在搭建服务器的时候起了哪些作用？</h2><p>在搭建服务端时，Node.js 起到了以下几个作用：</p><ol><li>提供 Web 服务器：Node.js 提供了内置的 HTTP 模块，可以用来创建 Web 服务器。开发者可以使用该模块创建 HTTP 服务器，接收和处理客户端请求，并返回响应。</li><li>处理请求和响应：Node.js 可以用来处理客户端请求，解析请求头和请求体，提取参数和数据等。同时，Node.js 也可以用来构建响应，设置响应头和响应体，返回数据给客户端。</li><li>实现业务逻辑：Node.js 可以用来实现业务逻辑，如处理数据、验证用户信息、调用其他服务等。同时，Node.js 也可以用来调用第三方库和 API，实现更丰富的业务功能。</li><li>数据库交互：Node.js 可以用来与数据库进行交互，执行查询、插入、更新和删除操作等。Node.js 支持多种数据库，如 MongoDB、MySQL、PostgreSQL 等，可以根据实际需求选择合适的数据库。</li><li>处理并发请求：Node.js 的事件驱动和非阻塞 I&#x2F;O 特性，可以处理大量并发请求，提高服务器的性能和吞吐量。</li></ol><h2 id="JS的基本数据类型有哪些？"><a href="#JS的基本数据类型有哪些？" class="headerlink" title="JS的基本数据类型有哪些？"></a>JS的基本数据类型有哪些？</h2><p>Null、Undefined、Number、String、Boolean、Symbol、BigInt、Object。</p><h2 id="判断数据类型的方式有哪些？"><a href="#判断数据类型的方式有哪些？" class="headerlink" title="判断数据类型的方式有哪些？"></a>判断数据类型的方式有哪些？</h2><ul><li>typeof</li><li>constructor</li><li>instanceof</li><li>Object.prototype.toString.call</li></ul><h2 id="什么是原型？"><a href="#什么是原型？" class="headerlink" title="什么是原型？"></a>什么是原型？</h2><p>在JavaScript中，每个对象都有一个原型。原型是一个对象，它包含着对象的属性和方法。当我们访问一个对象的属性或方法时，如果该对象本身没有该属性或方法，JavaScript引擎会沿着对象的原型链查找，直到找到该属性或方法为止。原型是JavaScript实现继承的基础，可以通过原型链实现属性和方法的继承。</p><h2 id="new一个对象发生了什么？"><a href="#new一个对象发生了什么？" class="headerlink" title="new一个对象发生了什么？"></a>new一个对象发生了什么？</h2><ol><li>首先创建一个空的对象</li><li>将该对象的原型指向构造函数的prototype属性</li><li>将构造函数的this指向该对象并执行构造函数</li><li>如果构造函数返回一个基本数据类型，则返回这个对象，否则返回构造函数返回的引用数据类型对象。</li></ol><h2 id="引入模块的两种方式？"><a href="#引入模块的两种方式？" class="headerlink" title="引入模块的两种方式？"></a>引入模块的两种方式？</h2><ul><li><p>ES6导入导出模块方式：<code>import</code>和<code>export</code>。</p><ul><li><p><code>import</code>：在一个模块中引入另一个模块的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> defaultExport <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> name <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; export1 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; export1 <span class="hljs-keyword">as</span> alias1 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; export1 , export2 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; export1 , export2 <span class="hljs-keyword">as</span> alias2 , [...] &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> defaultExport, &#123; export1 [ , [...] ] &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br><span class="hljs-keyword">import</span> defaultExport, * <span class="hljs-keyword">as</span> name <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li><code>defaultExport</code>表示模块的默认输出</li><li><code>name</code>表示模块的命名输出</li><li><code>export1</code>表示模块的具名输出</li></ul></li><li><p><code>export</code>：用于在一个模块中导出内容，让其他模块可以引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> expression;<br><span class="hljs-keyword">export</span> &#123; name1, name2, …, nameN &#125;;<br><span class="hljs-keyword">export</span> &#123; variable1 <span class="hljs-keyword">as</span> name1, variable2 <span class="hljs-keyword">as</span> name2, …, nameN &#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> name1, name2, …, nameN; <span class="hljs-comment">// also var</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> name1 = value1, name2 = value2, …, nameN = valueN;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span> &#123;...&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">FunctionName</span>(<span class="hljs-params"></span>)&#123;...&#125;<br></code></pre></td></tr></table></figure><ul><li><code>defalut</code>表示模块的默认输出</li><li><code>name</code>等表示模块的具名输出</li></ul></li></ul></li><li><p>CommonJS主要用于服务端的JS编程，<code>require()</code>导入模块，<code>module.exports</code>或<code>exports</code>导出模块。</p><ul><li><p><code>require()</code>导入模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;module-name&quot;</span>);<br></code></pre></td></tr></table></figure><p><code>module-name</code>为要导出的模块名</p></li><li><p><code>module.exports</code>或<code>exports</code>导出模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = value;<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">name</span> = values;<br></code></pre></td></tr></table></figure><p>其中<code>value</code>为要导出的值，可以是任意类型的值，包括对象、函数、字符串、数字等。</p></li></ul><p>需要注意的是，<code>module.exports</code>是直接将一个对象赋值给<code>exports</code>，而<code>exports</code>只是对<code>module.exports</code>的一个引用，因此可以使用<code>exports</code>导出多个属性，但不能使用<code>exports</code>直接覆盖<code>module.exports</code>。</p></li></ul><h2 id="ES6和CommonJS引入模块的区别？"><a href="#ES6和CommonJS引入模块的区别？" class="headerlink" title="ES6和CommonJS引入模块的区别？"></a>ES6和CommonJS引入模块的区别？</h2><ol><li><p>语法不同：</p><p>ES6使用<code>import</code>和<code>export</code>来导入和导出模块，而CommonJS使用<code>require()</code>和<code>module.exports</code>或<code>exports</code>来导入和导出模块。</p></li><li><p>加载方式不同：</p><p>ES6采用静态编译方式，在编译时就确定模块的依赖关系，然后再进行模块的加载。而CommonJS采用动态加载方式，在运行时根据代码需要动态加载模块。</p></li><li><p>可以导出的内容不同：</p><p>ES6中可以导出的内容包括变量、函数、类等，而CommonJS中只能导出对象。</p></li><li><p>作用域不同：</p><p>ES6中的模块是静态的，每个模块都有自己的作用域，不会污染全局作用域，而CommonJS中的模块是动态的，导出的对象是引用类型，会污染全局作用域。</p></li></ol><h2 id="ES6有哪些新特性？"><a href="#ES6有哪些新特性？" class="headerlink" title="ES6有哪些新特性？"></a>ES6有哪些新特性？</h2><ul><li><p>块级作用域：let和const</p></li><li><p>箭头函数</p></li><li><p>模板字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;XiaoMing&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`My name is <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br></code></pre></td></tr></table></figure></li><li><p>拓展运算符</p></li><li><p>类和继承 (<code>class</code>)</p></li><li><p>模块化：<code>import</code>和<code>export</code></p></li><li><p>Promise和async&#x2F;await</p></li><li><p>Symbol、BigInt</p></li><li><p>数组新增方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>() <span class="hljs-comment">// 将类数组对象or可迭代对象转换为数组</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>() <span class="hljs-comment">// 根据传入的参数创建一个数组</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">find</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">findIndex</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">fill</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">keys</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">values</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">includes</span>()<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">copyWithin</span>() <span class="hljs-comment">// 将数组的一部分复制到另一部分</span><br></code></pre></td></tr></table></figure></li><li><p>对象新增方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>()<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>()<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>()<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entires</span>() <span class="hljs-comment">// 返回一个数组，包含自身所有可枚举属性的键值对</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>() <span class="hljs-comment">// 返回一个对象，包含指定对象所有属性的描述符</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>() <span class="hljs-comment">// 冻结对象，使其属性不可修改、添加或删除</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">seal</span>() <span class="hljs-comment">// 封闭对象，使其属性不可添加或删除，但是可以修改</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>() <span class="hljs-comment">// 用于比较两个值是否完全相同</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="移动端epx-移动端适配-问题如何解决？"><a href="#移动端epx-移动端适配-问题如何解决？" class="headerlink" title="移动端epx(移动端适配)问题如何解决？"></a>移动端epx(移动端适配)问题如何解决？</h2><ul><li>使用em&#x2F;rem等单位设置元素尺寸</li><li>使用vw和vh单位</li><li>第三方库(lib-flexible、amfe-fiexible等)进行解决，这些库会根据屏幕像素密度和屏幕尺寸等信息自动计算出合适的rem值，从而解决移动端epx问题。</li></ul><h2 id="HTTP和HTTPS的区别？"><a href="#HTTP和HTTPS的区别？" class="headerlink" title="HTTP和HTTPS的区别？"></a>HTTP和HTTPS的区别？</h2><ul><li>HTTP是超文本传输协议，采用明文传输，而HTTPS采用SSL进行了数据加密，保证了数据的安全性</li><li>HTTP使用的是80端口，HTTPS是443端口</li><li>HTTPS需要数字证书，用于验证服务器身份和保证通信安全性</li><li>HTTPS加密和解密过程需要消耗更多计算资源，更加消耗性能</li><li>HTTPS的数据不容易被存储，因为每个请求和响应都需要加密和解密，而HTTP的数据易于被存储，可以提高访问速度。</li></ul><h2 id="302状态码是什么意思？和301有什么区别？"><a href="#302状态码是什么意思？和301有什么区别？" class="headerlink" title="302状态码是什么意思？和301有什么区别？"></a>302状态码是什么意思？和301有什么区别？</h2><p>302表示临时重定向，表示所请求的资源临时转移到了另一个URL上面。</p><p>301状态码表示永久重定向，告诉客户端所请求的资源已经被永久移动到了新的位置，以后应该使用新的URL访问，它会在响应头的Location字段中存储新的URL，浏览器收到后会对新的URL进行缓存，在以后的请求中会自动使用新的URL而不是旧的URL。</p><p>302状态码表示临时重定向，告诉客户端所请求的资源已经被临时移动到了新的位置，但以后还是应该使用原来的URL访问，浏览器在以后的请求中仍然会使用原来的URL，需要再次请求服务器获取新的URL。</p><h2 id="什么是防抖和节流？"><a href="#什么是防抖和节流？" class="headerlink" title="什么是防抖和节流？"></a>什么是防抖和节流？</h2><p>防抖：一个事件在触发n秒之后再进行执行，如果重复进行请求则重新进行计时。</p><p>节流：一个事件在一段时间内只能执行一次，如果多次触发也只会执行一次。</p><h2 id="手写防抖"><a href="#手写防抖" class="headerlink" title="手写防抖"></a>手写防抖</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> args = [...<span class="hljs-variable language_">arguments</span>], context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">if</span>(timer) &#123;<br>            <span class="hljs-built_in">clearTimeout</span>(timer);<br>            timer = <span class="hljs-literal">null</span>;<br>        &#125;<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            fn.<span class="hljs-title function_">apply</span>(context, args);<br>        &#125;, wait);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueArr</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">const</span> newArr = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(arr.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item1</span> =&gt;</span> item1 === item) === index) &#123;<br>            <span class="hljs-keyword">return</span> item;<br>        &#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> newArr;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端|面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法总结</title>
    <link href="/2023/04/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="常见的排序算法"><a href="#常见的排序算法" class="headerlink" title="常见的排序算法"></a>常见的排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><blockquote><p>冒泡排序(Bubble Sort)是一种最基础的排序方式，它的每个元素都可以像小气泡一样，根据自身大小一点点向数组的一侧移动</p></blockquote><p>冒泡排序<strong>每次比较相邻的两个节点</strong>，如果两个节点排序错误，将两个节点的位置调换，重复此步骤直到所有的元素归位。</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 冒泡排序</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">bubbleSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> len = arr.<span class="hljs-property">length</span>;<br>  <span class="hljs-comment">// 将元素按照从小到大的顺序排序</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; len;i++)&#123; <br>    <span class="hljs-comment">// 每次排序能确定一个元素的位置</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>;j &lt; len-i;j++)&#123;<br>      <span class="hljs-comment">// 当前面节点大于后面节点的时候</span><br>      <span class="hljs-comment">// 当一轮交换结束的时候，最大的元素一定在最后一位</span><br>      <span class="hljs-keyword">if</span>(arr[j-<span class="hljs-number">1</span>] &gt; arr[j])&#123;<br>          <span class="hljs-keyword">const</span> tmp = arr[j-<span class="hljs-number">1</span>];<br>          arr[j-<span class="hljs-number">1</span>] = arr[j];<br>          arr[j] = tmp;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。</p></blockquote><p>每次都从待排序的数据元素中选择出最小(或最大)的一个元素作为首元素，直到所有元素都排列完毕。</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">selectionSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> minIndex, temp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len-<span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-comment">// 在每次遍历中,将第一个元素设置为最小的元素</span><br>        minIndex = i;<br>        <span class="hljs-comment">// 遍历后面的元素,如果有比当前元素更小的元素,将其下标赋值给minIndex</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i+<span class="hljs-number">1</span>; j &lt; len; j++) &#123;<br>            <span class="hljs-keyword">if</span>(arr[j] &lt; arr[minIndex]) &#123;<br>                minIndex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果头一个元素不是最小元素,将其与后面最小元素交换位置</span><br>        <span class="hljs-keyword">if</span>(minIndex !== i) &#123;<br>            temp = arr[i];<br>            arr[i] = arr[minIndex];<br>            arr[minIndex] = temp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 返回排好序的arr</span><br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>插入排序，一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。</p></blockquote><p>每一步都将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素位置。</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">insertSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">// 每次进行排序的时候,0~i-1位置上一定是有序的</span><br>    <span class="hljs-comment">// 将当前元素进行比较并插入合适的位置</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">let</span> preIndex = i-<span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">let</span> current = arr[i]; <span class="hljs-comment">// 记录当前元素的值</span><br>        <span class="hljs-comment">// 将大于current的元素依次往后移,找到插入current的合适位置的时候停止</span><br>        <span class="hljs-keyword">while</span>(preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;<br>            arr[preIndex+<span class="hljs-number">1</span>] = arr[preIndex];<br>            preIndex--;<br>        &#125;<br>        <span class="hljs-comment">// 将current插入到合适的位置</span><br>        arr[preIndex+<span class="hljs-number">1</span>] = current;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p></blockquote><p>核心思想：分治，采用自上而下的递归方法</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">mergeSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> len = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">// 如果长度&lt;2, 无需进行排序</span><br>    <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr; <br>    <span class="hljs-comment">// 将数组从中间进行切割</span><br>    <span class="hljs-keyword">const</span> middle = len &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">const</span> left = arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, middle), right = arr.<span class="hljs-title function_">slice</span>(middle);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(<span class="hljs-title function_">mergeSort</span>(left), <span class="hljs-title function_">mergeSort</span>(right));<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">merge</span> = (<span class="hljs-params">left, right</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 存储最终结果的数组</span><br>    <span class="hljs-keyword">const</span> result = [];<br>    <span class="hljs-comment">// 比较left和right中的元素并将较小的先存入result中</span><br>    <span class="hljs-keyword">while</span>(left.<span class="hljs-property">length</span> &amp;&amp; right.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">if</span>(left[<span class="hljs-number">0</span>] &lt;= right[<span class="hljs-number">0</span>]) &#123;<br>            result.<span class="hljs-title function_">push</span>(left.<span class="hljs-title function_">shift</span>());<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            result.<span class="hljs-title function_">push</span>(right.<span class="hljs-title function_">shift</span>());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(left.<span class="hljs-property">length</span>) &#123;<br>        result.<span class="hljs-title function_">push</span>(left.<span class="hljs-title function_">shift</span>());<br>    &#125;<br>    <span class="hljs-keyword">while</span>(right.<span class="hljs-property">length</span>) &#123;<br>        result.<span class="hljs-title function_">push</span>(right.<span class="hljs-title function_">shift</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><blockquote><p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O(nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p></blockquote><p>根据键值的每位数字来分配桶</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">radixSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> []);<br>    <span class="hljs-keyword">let</span> maxDigit = (<span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...arr))).<span class="hljs-title function_">toString</span>().<span class="hljs-property">length</span> <span class="hljs-comment">// 取最大位数</span><br>    <span class="hljs-keyword">let</span> m = <span class="hljs-number">10</span>,n = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 取最大的数字的位数长度</span><br>    <span class="hljs-keyword">while</span>(maxDigit--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; arr.<span class="hljs-property">length</span>;i++)&#123;<br>            <span class="hljs-keyword">let</span> bucket = <span class="hljs-built_in">parseInt</span>((arr[i] % m) / n); <span class="hljs-comment">// 获取需要的位数</span><br>            ans[bucket].<span class="hljs-title function_">push</span>(arr[i]);<br>        &#125;<br>        <span class="hljs-keyword">let</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 将数组中的数字排序后重新放入arr数组中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; ans.<span class="hljs-property">length</span>;i++)&#123;<br>            <span class="hljs-keyword">let</span> value = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span>(ans[i].<span class="hljs-property">length</span> !== <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">while</span>((value = ans[i].<span class="hljs-title function_">shift</span>()) != <span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-comment">// 当ans[i]中还有值</span><br>                    arr[pos++] = value;<br>                &#125;<br>            &#125;<br>        &#125;<br>        m *= <span class="hljs-number">10</span>;<br>        n *= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><blockquote><p>桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后依次把各个桶中的记录列出来记得到有序序列。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ(n)）。但桶排序并不是比较排序，他不受到O(n log n)下限的影响。</p></blockquote><p>将元素分布在桶中：</p><p><img src="http://dawning.fun/wp-content/uploads/2022/11/Bucket_sort_1.svg_.png" alt="img"></p><p>然后，将每个桶中的元素进行排序：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_2.svg_.png" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">bucketSort</span> = (<span class="hljs-params">arr, bucketSize</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-keyword">let</span> minValue = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> maxValue = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 获取数据的最大值和最小值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span>(arr[i] &lt; minValue) &#123;<br>            minValue = arr[i];<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[i] &gt; maxValue) &#123;<br>            maxValue = arr[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 进行桶的初始化</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DEFAULT_BUCKET_SIZE</span> = <span class="hljs-number">5</span>; <span class="hljs-comment">// 设置桶的默认数量为5</span><br>    bucketSize = bucketSize || <span class="hljs-variable constant_">DEFAULT_BUCKET_SIZE</span>; <span class="hljs-comment">// 如果函数没有传值就将桶的默认数量设置为5</span><br>    <span class="hljs-keyword">const</span> bucketCount = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((maxValue - minValue) / bucketSize) + <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">const</span> buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(bucketCount).<span class="hljs-title function_">fill</span>([]);<br>    <span class="hljs-comment">// 利用映射函数将数据分配到各个桶中</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>        buckets[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((arr[i] - minValue) / bucketSize)].<span class="hljs-title function_">push</span>(arr[i]);<br>    &#125;<br>    arr.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; buckets.<span class="hljs-property">length</span>; i++)&#123;<br>        <span class="hljs-title function_">insertSort</span>(buckets[i]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; bucketCount[i].<span class="hljs-property">length</span>; i++) &#123;<br>            arr.<span class="hljs-title function_">push</span>(buckets[i][j]);;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序由于排序效率在同为<code>O(N*logN)</code>的几种排序方法中效率较高，因此经常被采用。快速排序的思想为——分治法。在快速排序中，一般选中第一个元素作为基准点<code>pivot</code>，定义<code>l</code>和<code>r</code>两个指针分别从数组的两边遍历，当从右边找到比<code>pivot</code>大的数字时，停止移动，再从左边找到比<code>pivot</code>小的元素，将两者进行交换，然后继续移动指针。</p><p>当移动到同一位置的时候，将该位置与基准点元素<code>pivot</code>进行交换，然后对<code>pivot</code>两边的元素进行如上遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @每次找一个基准点pivot，小于pivot的放在左边，大于pivot的放在右边，然后对左右进行同样的操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number[]</span>&#125; arr </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">quickSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-title function_">quick</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">quick</span> = (<span class="hljs-params">arr, start, end</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span>(start &gt; end) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">const</span> pivot = arr[start];<br>    <span class="hljs-keyword">let</span> l = start, r = end;<br>    <span class="hljs-keyword">while</span>(l !== r) &#123;<br>        <span class="hljs-keyword">while</span>(arr[r] &gt;= pivot &amp;&amp; l !== r) r--;<br>        <span class="hljs-keyword">while</span>(arr[l] &lt;= pivot &amp;&amp; l !== r) l++;<br>        <span class="hljs-keyword">if</span>(l !== r) &#123;<br>            <span class="hljs-keyword">const</span> temp = arr[l];<br>            arr[l] = arr[r];<br>            arr[r] = temp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(arr[l] &gt; pivot) l--;<br>    arr[start] = arr[l];<br>    arr[l] = pivot;<br>    <span class="hljs-title function_">quick</span>(arr, start, l-<span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">quick</span>(arr, l+<span class="hljs-number">1</span>, end);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单边快速排序"><a href="#单边快速排序" class="headerlink" title="单边快速排序"></a>单边快速排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; start </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; end </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">quickSort</span> = (<span class="hljs-params">arr, start, end</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span>(start &gt;= end) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 排序并得到基准元素</span><br>    <span class="hljs-keyword">let</span> pivotIndex = <span class="hljs-title function_">partition</span>(arr, start, end);<br>    <span class="hljs-comment">// 根据基准元素分成两部分并进行递归排序</span><br>    <span class="hljs-title function_">quickSort</span>(arr, start, pivotIndex-<span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">quickSort</span>(arr, pivotIndex+<span class="hljs-number">1</span>, end);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; start </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; end </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">partition</span> = (<span class="hljs-params">arr, start, end</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 取第一个位置的元素作为基准点</span><br>    <span class="hljs-keyword">let</span> pivot = arr[start];<br>    <span class="hljs-keyword">let</span> mark = start; <span class="hljs-comment">// 标记元素,用于交换</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = start+<span class="hljs-number">1</span>; i &lt;= end; i++) &#123;<br>        <span class="hljs-keyword">if</span>(arr[i] &lt; pivot) &#123; <span class="hljs-comment">// 当遍历到比基准元素小的元素,mark+1,将当前元素和基准元素交换位置</span><br>            mark++;<br>            <span class="hljs-keyword">let</span> tmp = arr[mark];<br>            arr[mark] = arr[i];<br>            arr[i] = tmp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 遍历完毕的时候,mark及其左边元素都小于基准点,mark右边都大于基准点</span><br>    arr[start] = arr[mark];<br>    arr[mark] = pivot;<br>    <span class="hljs-keyword">return</span> mark;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">main</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-title function_">quickSort</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h2><p>鸡尾酒排序又称双向冒泡排序、鸡尾酒搅拌排序、搅拌排序、涟漪排序、来回排序或快乐小时排序, 是冒泡排序的一种变形。该算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。</p><p><img src="https://pic4.zhimg.com/v2-f9716c786a05cb28547440f12e337a0b_b.webp" alt="动图"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @鸡尾酒排序与冒泡排序类似，不同的是冒泡排序是按照一种顺序进行是，而鸡尾酒是从两边轮流进行交换</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">cocktailSort</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(arr.<span class="hljs-property">length</span>/<span class="hljs-number">2</span>); i++) &#123;<br>        <span class="hljs-comment">// 使用isSorted标记是否进行交换顺序，如果没有进行交换，说明顺序已经符合要求，直接跳出循环</span><br>        <span class="hljs-keyword">let</span> isSorted = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 奇数轮的遍历，从左往右进行比较</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j &lt; arr.<span class="hljs-property">length</span>-i-<span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;<br>                tmp = arr[j];<br>                arr[j] = arr[j+<span class="hljs-number">1</span>];<br>                arr[j+<span class="hljs-number">1</span>] = tmp;<br>                isSorted = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        isSorted = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 重置isSorted</span><br>        <span class="hljs-comment">// 偶数轮的遍历，从右往左进行比较</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = arr.<span class="hljs-property">length</span>-i-<span class="hljs-number">1</span>; j &gt;= i; j--) &#123;<br>            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j-<span class="hljs-number">1</span>]) &#123;<br>                tmp = arr[j];<br>                arr[j] = arr[j-<span class="hljs-number">1</span>];<br>                arr[j-<span class="hljs-number">1</span>] = tmp;<br>                isSorted = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isSorted) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序（HeapSort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p><img src="https://pic3.zhimg.com/v2-b7907d351809293c60658b0b87053c66_b.webp" alt="动图"></p><p>传入一个数组，将其从最下面的非叶子结点进行排序，依次向上调整为最大堆，每次将顶上最大的数取出来放在数组res中，然后重新调整为最大堆，再取出最大的数放在res中…重复以上过程直到arr为空。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @堆排序</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr 要进行排序的数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">main</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> res = []; <span class="hljs-comment">// 存储排序后的结果</span><br>    <span class="hljs-title function_">buildHeap</span>(arr); <span class="hljs-comment">// 构建大根堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = n-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-title function_">swap</span>(arr, <span class="hljs-number">0</span>, i); <span class="hljs-comment">// 将最大值(顶点)交换到最后一个位置</span><br>        res.<span class="hljs-title function_">unshift</span>(arr.<span class="hljs-title function_">pop</span>()); <span class="hljs-comment">// 将最大值取出</span><br>        <span class="hljs-title function_">heapify</span>(arr, <span class="hljs-number">0</span>); <span class="hljs-comment">// 对大根堆进行自上而下重新调整(下一个最大值一定是根节点的两个孩子之一，因此从顶点进行调整即可)</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @构建大根堆</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr 要构建大根堆的数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">buildHeap</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">// 自下而上进行调整</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(n/<span class="hljs-number">2</span>)-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-title function_">heapify</span>(arr, i);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @调整大根堆</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr 进行大根堆调整的数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; index 要调整的节点下标</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">heapify</span> = (<span class="hljs-params">arr, index</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前节点的左子节点</span><br>    <span class="hljs-keyword">while</span>(left &lt; n) &#123;<br>        <span class="hljs-keyword">let</span> largest = index; <span class="hljs-comment">// 记录最大值下标,初始设置为当前节点</span><br>        <span class="hljs-comment">// 比较左右节点找出较大的节点</span><br>        largest = (left+<span class="hljs-number">1</span> &lt; n &amp;&amp; arr[left+<span class="hljs-number">1</span>] &gt; arr[left]) ? left+<span class="hljs-number">1</span> : left;<br>        <span class="hljs-comment">// 比较左右节点中较大的一个和当前节点</span><br>        largest = arr[largest] &gt; arr[index] ? largest : index;<br>        <span class="hljs-keyword">if</span>(largest === index) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 当前堆为大根堆，不需要继续调整 </span><br>        <span class="hljs-comment">// 子节点中存在比index节点大的值,继续向下调整</span><br>        <span class="hljs-title function_">swap</span>(arr, index, largest);<br>        index = largest;<br>        left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @对数组两个位置的值进行交换</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; i </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; j </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">swap</span> = (<span class="hljs-params">arr, i, j</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> tmp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>小根堆进行排序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">main</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-title function_">buildHeap</span>(arr);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = n-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-title function_">swap</span>(arr, <span class="hljs-number">0</span>, i);<br>        res.<span class="hljs-title function_">unshift</span>(arr.<span class="hljs-title function_">pop</span>());<br>        <span class="hljs-title function_">heapify</span>(arr, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">buildHeap</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(n/<span class="hljs-number">2</span>)-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-title function_">heapify</span>(arr, i);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; index </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">heapify</span> = (<span class="hljs-params">arr, index</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt; n) &#123;<br>        <span class="hljs-keyword">let</span> least = index;<br>        least = (left+<span class="hljs-number">1</span> &lt; n &amp;&amp; arr[left+<span class="hljs-number">1</span>] &lt; arr[left]) ? left+<span class="hljs-number">1</span> : left;<br>        least = (arr[least] &lt; arr[index]) ? least : index;<br>        <span class="hljs-keyword">if</span>(least === index) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-title function_">swap</span>(arr, index, least);<br>        index = least;<br>        left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @对数组两个位置的值进行交换</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; arr </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; i </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Number</span>&#125; j </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">swap</span> = (<span class="hljs-params">arr, i, j</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> tmp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结(3.1)</title>
    <link href="/2023/04/08/%E6%80%BB%E7%BB%93-3-1/"/>
    <url>/2023/04/08/%E6%80%BB%E7%BB%93-3-1/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS常见的行内元素和块级元素？它们有什么区别？"><a href="#CSS常见的行内元素和块级元素？它们有什么区别？" class="headerlink" title="CSS常见的行内元素和块级元素？它们有什么区别？"></a>CSS常见的行内元素和块级元素？它们有什么区别？</h2><p><strong>行内元素：</strong>行内元素与其他行内元素并排，不能设置宽高，宽度默认为文字的宽度。</p><p><strong>块级元素：</strong>块级元素霸占一行，不能与其他任何元素并列，能接受宽高，如果不设置宽度，那么宽度将默认变为父级的100%。</p><p>常见的行内元素有：button、input、label、select、textarea、a、img、span、script等。</p><p>常见的块级元素有：div、section、p、table、form、header、footer、h1~h6、aside、canvas、ol、ul等。</p><p>CSS中，块级元素和行内元素的区别在于：</p><ul><li>块级元素独占一行，不能与其他任何元素并列；行内元素可以与其他行内元素并排。</li><li>块级元素可以设置宽高，而行内元素不能设置宽高，宽度由内容撑开。</li></ul><h2 id="什么是回流和重绘？"><a href="#什么是回流和重绘？" class="headerlink" title="什么是回流和重绘？"></a>什么是回流和重绘？</h2><p>回流：当DOM节点中的部分或全部元素的尺寸、结构、布局等发生变化的时候，浏览器就会重新渲染部分或全部文档，这个过程称为回流。</p><p>重绘：页面中元素的样式发生变化，但是不影响其在文档流中的位置，浏览器就会对该元素进行重绘。</p><p>发生回流一定会引起重绘，但是重绘不一定会引起回流。</p><h2 id="在什么情况下会触发回流？"><a href="#在什么情况下会触发回流？" class="headerlink" title="在什么情况下会触发回流？"></a>在什么情况下会触发回流？</h2><ul><li>添加或删除可见的DOM元素</li><li>元素位置、尺寸(包括外边距、内边距、边框大小、高度和宽度等)发生变化</li><li>内容发生变化(例如文本变化或图片被另一个不同尺寸的图片取代)</li><li>页面一开始渲染</li><li>浏览器窗口尺寸变化(因为回流是根据视口的大小来计算元素的位置和大小的)</li></ul><h2 id="获取元素的offsetHeight等会触发回流吗？"><a href="#获取元素的offsetHeight等会触发回流吗？" class="headerlink" title="获取元素的offsetHeight等会触发回流吗？"></a>获取元素的offsetHeight等会触发回流吗？</h2><p>会。</p><p><code>offsetHeight</code> 是一个元素的实时高度，必须重排重绘以后才能得到，如果不提前进行重排重绘，<code>offsetHeight</code> 有可能拿到的是浏览器缓存队列没执行完的时候的值。</p><h2 id="什么是flex布局？"><a href="#什么是flex布局？" class="headerlink" title="什么是flex布局？"></a>什么是flex布局？</h2><p>flex为”弹性布局”，可以简便、完整、响应式的实现各种页面布局。它的所有子元素自动成为容器成员，称为flex项目的item。</p><p>容器中默认存在两条轴，主轴和交叉轴，呈90°的关系。项目默认沿主轴排列，通过<code>flelx-direction</code>来决定主轴方向。</p><h2 id="flex-1具体指的是什么？"><a href="#flex-1具体指的是什么？" class="headerlink" title="flex: 1具体指的是什么？"></a>flex: 1具体指的是什么？</h2><ul><li><code>flex-grow: 1</code> (默认为0) ：表示元素的放大比例</li><li><code>flex-shrink: 1</code> (默认为1) ：表示元素的缩小比例</li><li><code>flex-basis: 0%</code> (默认为auto) ：元素本身的大小，这个属性定义了在分配多余空间之前，元素占据的主轴空间。浏览器根据这个属性计算是否有多余空间。</li></ul><h2 id="如何进行移动端适配？"><a href="#如何进行移动端适配？" class="headerlink" title="如何进行移动端适配？"></a>如何进行移动端适配？</h2><ul><li>rem布局</li><li>vw&#x2F;vh布局</li><li>百分比布局</li><li>响应式布局</li></ul><h2 id="em和rem的区别？"><a href="#em和rem的区别？" class="headerlink" title="em和rem的区别？"></a>em和rem的区别？</h2><p>em和rem都是相对单位长度</p><p>em是相对于父元素的字体大小来计算元素的大小</p><p>rem是相对于根元素的字体大小来计算元素的大小</p><h2 id="什么是vw和vh"><a href="#什么是vw和vh" class="headerlink" title="什么是vw和vh?"></a>什么是vw和vh?</h2><p>vw和vh是CSS3引入的视口单位，是相对于视口的宽度和高度来计算元素的大小。</p><p>1vw等于视口宽度的1%，1vh等于视口高度的1%。除了vw和vh，还有vmin和vmax两个单位，vmin是vw和vh中较小的那个，vmax是vw和vh中较大的那个。</p><h2 id="什么是JS的事件机制？"><a href="#什么是JS的事件机制？" class="headerlink" title="什么是JS的事件机制？"></a>什么是JS的事件机制？</h2><p>JavaScript 事件机制描述的是事件在 DOM 里面的传递顺序，以及我们可以对这些事件做出如何的响应。</p><p>DOM事件流（event flow ）存在三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。</p><p>事件捕获（event capturing）： 通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始<strong>由外到内</strong>进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。</p><p>事件冒泡（dubbed bubbling）： 与事件捕获恰恰相反，事件冒泡顺序是<strong>由内到外</strong>进行事件传播，直到根节点。无论是事件捕获还是事件冒泡，它们都有一个共同的行为，就是事件传播，它就像一跟引线，只有通过引线才能将绑在引线上的鞭炮（事件监听器）引爆。</p><p>DOM标准事件流的触发的先后顺序为 ：<strong>先捕获再冒泡，即当触发dom事件时，会先进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡</strong>。</p><h2 id="代码输出"><a href="#代码输出" class="headerlink" title="代码输出"></a>代码输出</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">fun2</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br><br><span class="hljs-title function_">fun1</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);<br>&#125;, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>);<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">7</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="Promise常用的API？"><a href="#Promise常用的API？" class="headerlink" title="Promise常用的API？"></a>Promise常用的API？</h2><p>Promise.then、Promise.catch、Promise.finally、Promise.all、Promise.race</p><h2 id="Promise-all和Promise-race的区别？"><a href="#Promise-all和Promise-race的区别？" class="headerlink" title="Promise.all和Promise.race的区别？"></a>Promise.all和Promise.race的区别？</h2><p>Promise.all()和Promise.race()都是Promise的静态方法，用于处理多个Promise对象。它们的区别在于：</p><ul><li>Promise.all()会在多个promise全部resolve之后执行.then，而Promise.race()会在任何一个promise resolve后就会执行.then。</li><li>Promise.all()会等待所有的promise对象都resolve或有一个reject后才会执行.then，而Promise.race()只要有一个promise对象resolve或reject就会执行.then。</li><li>Promise.all()会返回所有Promise resolved后的结果数组或第一个rejected的Promise对象的报错信息。</li></ul><h2 id="Promise的错误在哪里进行捕捉"><a href="#Promise的错误在哪里进行捕捉" class="headerlink" title="Promise的错误在哪里进行捕捉?"></a>Promise的错误在哪里进行捕捉?</h2><p>Promise发生的错误可以在try…catch中捕获，也可以在.catch()中捕获。如果在try…catch中捕获，需要在Promise对象前加await关键字，否则无法捕获异步错误。如果在.catch()中捕获，需要在Promise对象后加.catch()方法。</p><h2 id="假设一个function中有多个Promise任务，然后有某个Promise发生了异常，如何准确判断是哪个Promise发生了异常？"><a href="#假设一个function中有多个Promise任务，然后有某个Promise发生了异常，如何准确判断是哪个Promise发生了异常？" class="headerlink" title="假设一个function中有多个Promise任务，然后有某个Promise发生了异常，如何准确判断是哪个Promise发生了异常？"></a>假设一个function中有多个Promise任务，然后有某个Promise发生了异常，如何准确判断是哪个Promise发生了异常？</h2><p>在reject()中进行处理</p><h2 id="bind、call和apply的区别？"><a href="#bind、call和apply的区别？" class="headerlink" title="bind、call和apply的区别？"></a>bind、call和apply的区别？</h2><ul><li><code>apply</code>接受两个参数，第一个参数是<code>this</code>的指向，第二个参数是函数接受的参数，以数组的形式传入，改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次。</li><li><code>call</code>方法的第一个参数也是<code>this</code>的指向，后面传入的是一个参数列表，跟<code>apply</code>一样，改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次。</li><li>bind方法和call很相似，第一参数也是<code>this</code>的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)，改变<code>this</code>指向后不会立即执行，而是返回一个永久改变<code>this</code>指向的函数。</li></ul><h2 id="箭头函数和普通函数的区别？"><a href="#箭头函数和普通函数的区别？" class="headerlink" title="箭头函数和普通函数的区别？"></a>箭头函数和普通函数的区别？</h2><ul><li>箭头函数不绑定this，会捕获其所在上下文的this作为自己的this。</li><li>箭头函数没有arguments对象，只能通过rest参数获取参数。</li><li>箭头函数不能使用yield命令，不能用作Generator函数。</li><li>箭头函数是匿名函数，不能用作构造函数，不可以使用new命令。</li></ul><h2 id="React函数组件和类组件的区别？"><a href="#React函数组件和类组件的区别？" class="headerlink" title="React函数组件和类组件的区别？"></a>React函数组件和类组件的区别？</h2><ul><li>类组件有生命周期，函数组件无生命周期</li><li>类组件调用setStatet管理state状态，函数组件使用useState</li><li>函数组件调用即是执行函数，类组件需要先将组件实例化，再调用实例对象的render方法</li><li>函数组件更加简洁易懂，容易被开发、理解和测试。</li></ul><h2 id="函数式组件用哪个hook模拟声明周期"><a href="#函数式组件用哪个hook模拟声明周期" class="headerlink" title="函数式组件用哪个hook模拟声明周期"></a>函数式组件用哪个hook模拟声明周期</h2><p>useEffect</p><h2 id="React-state更新机制"><a href="#React-state更新机制" class="headerlink" title="React state更新机制"></a>React state更新机制</h2><p>React中类组件的state是通过setState()方法来更新的。当执行setState()时，会将需要更新的state合并后放入状态队列，不会立即更新。React也正是通过状态队列实现了setState的异步更新，避免频繁的重复更新state。当React需要更新组件时，会将状态队列中的state合并后一次性更新组件，这样可以提高性能。</p><p>React函数组件中的state是通过useState()方法来更新的。useState()方法返回一个数组，第一个元素是当前state的值，第二个元素是更新state的函数。当执行更新state的函数时，会将需要更新的state合并后放入状态队列，不会立即更新。React也正是通过状态队列实现了useState的异步更新，避免频繁的重复更新state。当React需要更新组件时，会将状态队列中的state合并后一次性更新组件，这样可以提高性能。</p><p>在React18优化了批处理之后，state的更新都表现为异步的。</p><h2 id="React虚拟DOM的Diff算法？"><a href="#React虚拟DOM的Diff算法？" class="headerlink" title="React虚拟DOM的Diff算法？"></a>React虚拟DOM的Diff算法？</h2><p>React中的虚拟DOM和diff算法是为了提高渲染效率而设计的。虚拟DOM是一种编程概念，UI以一种理想化的、或者说“虚拟的”表现形式存在于内存中，而不是真实的DOM树。当状态发生变化时，React会通过diff算法比较新旧虚拟DOM树的差异，然后只更新需要更新的部分，从而避免了全量渲染，提高了渲染效率。</p><p>React中的diff算法是通过比较新旧虚拟DOM树的差异来确定需要更新的节点。diff算法会遍历新旧虚拟DOM树，对比它们的节点，然后根据节点的变化情况来更新真实DOM。React中的diff算法是基于两个假设：同一层级的两个节点可以通过唯一的id进行区分；同一层级的节点可以通过位置进行区分。React中的diff算法是一个递归算法，它会递归遍历新旧虚拟DOM树，对比它们的节点，然后根据节点的变化情况来更新真实DOM。如果两个节点不同，则会直接替换掉旧节点，如果两个节点相同，则会更新该节点。</p><p><strong>查找需要更新的节点是从尾节点找还是头节点找还是中间二分择半？</strong></p><p>React的Diff算法进行虚拟节点比较是从头部开始，然后依次向后比较，直到找到不同的节点位置。如果新旧虚拟节点的数量不同，则从尾部开始比较，直到找到不同的节点为止。</p><h2 id="useMemo和useCallback的区别？"><a href="#useMemo和useCallback的区别？" class="headerlink" title="useMemo和useCallback的区别？"></a>useMemo和useCallback的区别？</h2><p>二者都是用于缓存数据，优化性能的，它们接受到的参数是一样的，第一个参数表示回调函数，第二个参数表示依赖的数据。</p><p>共同作用：在依赖数据发生变化的时候，才会调用传进去的回调函数去重新计算结果，起到缓冲的作用。</p><p>区别：</p><ul><li><code>useMemo</code>缓存的结果是回调函数中return回来的值，主要用于缓存计算结果的值，应用场景如需要计算的状态。</li><li><code>useCallback</code>缓存的结果是函数，主要用于缓存函数，应用场景如需要缓存的函数，因为函数式组件每次任何一个state发生变化都会触发整个组件更新，一些函数是没有必要更新的，此时就应该缓存起来，提高性能，减少对资源的浪费。<code>useCallback</code>应该和<code>React.memo</code>配套使用，缺少一个可能会导致性能不升反降。</li></ul><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useState, useMemo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Info</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">const</span> [info, setInfo] = <span class="hljs-title function_">useState</span>(&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;LiHua&quot;</span>,<br>        <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;male&quot;</span><br>    &#125;);<br>    <span class="hljs-comment">// 翻译性别的函数</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">formatGender</span> = (<span class="hljs-params">gender</span>) =&gt; &#123;<br>        <span class="hljs-keyword">return</span> gender === <span class="hljs-string">&quot;male&quot;</span> ? <span class="hljs-string">&quot;男&quot;</span> : <span class="hljs-string">&quot;女&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果不使用useMemo,修改其他属性，也会导致formatGender方法的调用，浪费计算资源</span><br>    <span class="hljs-comment">// const gender = formatGender(info.gender);</span><br>    <span class="hljs-comment">// 仅当info.gender发生变化的时候才调用formatGender</span><br>    <span class="hljs-keyword">const</span> gender = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">formatGender</span>(info.<span class="hljs-property">gender</span>);<br>    &#125;, [info.<span class="hljs-property">gender</span>]);<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        姓名：&#123;info.name&#125; - 性别：&#123;gender&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onClick</span> = <span class="hljs-string">&#123;()</span> =&gt;</span> setInfo(...info, name: &quot;XiaoMing&quot;)&#125;</span><br><span class="language-xml">        &gt;点击修改姓名<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>useCallback是设计初衷是为了<strong>减少子组件的不必要重读渲染</strong>，优化思路主要有以下两种：</p><ul><li>减少render的次数</li><li>减少计算量</li></ul><p>在如下场景中</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-comment">// 不使用useCallback和memo的时候</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Comp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [dataA, setDataA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> [dataB, setDataB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickA</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataA</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickB</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataB</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Cheap</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickA&#125;</span>&gt;</span>组件Cheap: &#123;dataA&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Cheap</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Expensive</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickB&#125;</span>&gt;</span>组件Expensive: &#123;dataB&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Expensive</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述组件中，每当点击Cheap组件的时候，Expensive组件也会重新渲染，即使dataB没有发生变化，原因就是onClickB被重新定义，导致React在diff新旧组件的时候判定了组件发生了变化。</p><p>此时，useCallback和memo就发挥作用了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useCallback, useState, memo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Expensive</span>(<span class="hljs-params">&#123;onClick, name&#125;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Expensive渲染&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><span class="hljs-keyword">const</span> memoExpensive = <span class="hljs-title function_">memo</span>(<span class="hljs-title class_">Expensive</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cheap</span>(<span class="hljs-params">&#123;onClick, name&#125;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Cheap渲染&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Comp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [dataA, setDataA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> [dataB, setDataB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickA</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataA</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> onClickB = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">setDataB</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;, [])<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Cheap</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickA&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">组件Cheap:</span> $&#123;<span class="hljs-attr">dataA</span>&#125;`&#125; /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Expensive</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickB&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">组件Expensive:</span> $&#123;<span class="hljs-attr">data</span>&#125;`&#125; /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>memo与PureComponent类似，对传入组件的新旧数据进行浅比较，如果相同则不会触发渲染。</p><p>useCallback保证onClickB不会发生变化，此时点击Cheap组件不会触发Expensive组件的刷新，只有点击Expensive组件才会触发。在实现减少不必要渲染的优化过程中，useCallback和memo是一对利器。</p><h2 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h2><p>要求：使用React的hook实现一个useRequest</p><ul><li>展示loading效果后告诉用户后台正在处理请求</li><li>接口异常时要进行错误处理</li><li>缓存同一请求(非结果)</li></ul><h2 id="Redux使用流程及场景？"><a href="#Redux使用流程及场景？" class="headerlink" title="Redux使用流程及场景？"></a>Redux使用流程及场景？</h2><ol><li>安装Redux。</li><li>创建一个store，store是一个对象，它有四个方法：dispatch、subscribe、getState和replaceReducer。</li><li>定义action，action是一个普通的JavaScript对象，用来描述发生了什么。</li><li>定义reducer，reducer是一个纯函数，接收旧的state和action，返回新的state。</li><li>使用combineReducers将多个reducer合并成一个根reducer。</li><li>使用Provider组件将store传递给子组件。</li><li>在组件中使用connect函数连接store和组件。</li></ol><h2 id="有没有了解Mobx"><a href="#有没有了解Mobx" class="headerlink" title="有没有了解Mobx?"></a>有没有了解Mobx?</h2><h2 id="Webpack如何进行配置？"><a href="#Webpack如何进行配置？" class="headerlink" title="Webpack如何进行配置？"></a>Webpack如何进行配置？</h2><p>主要配置过相关loader</p><h2 id="Webpack中loader和plugin的区别？"><a href="#Webpack中loader和plugin的区别？" class="headerlink" title="Webpack中loader和plugin的区别？"></a>Webpack中loader和plugin的区别？</h2><ul><li>loader是一种打包方案，对于某一种类型文件它知道如何打包，帮助Webpack完成打包工作。loader就是一个单纯的文件转化过程。</li><li>plugin是一个扩展器，丰富Webpack本身，增强功能，针对的是在loader结束之后，Webpack打包的整个过程。plugin并不直接操作文件，而是基于事件机制工作，会监听Webpack打包过程中的某些事件钩子，执行任务。</li></ul><h2 id="浏览器缓存机制？"><a href="#浏览器缓存机制？" class="headerlink" title="浏览器缓存机制？"></a>浏览器缓存机制？</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>Cache-Control &#x2F; Expires</p><p> expires <code>http1.0</code>控制网页缓存的字段，其值为服务器返回该请求结果的到期时间，即再次发送请求，如果客户端的时间小于expires的值时，直接使用缓存结果</p><p> cache-control(优先级更大) http1.1中控制网页缓存，是最重要的规则</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>Etag If-None-Match &#x2F; Last-Midified If-Midified-Since</p><p> <code>Last-Modified / If-Modified-Since</code> 和 <code>Etag / If-None-Match</code> (后者优先级更高)</p><p> Last-Modified 服务器响应请求时，返回该文件资源在服务器内最后被修改的时间</p><p> If-Modified-Since 客户端再次发起请求时，携带上次请求返回的Last-Modified值，通过此字段告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据此字段值与该资源在服务器的最后被修改的时间做对比，若服务器的资源最后被修改的时间大于If-Modified-Since字段值，则重新返回资源，状态码为200；否则返回304，代表资源无更新，可继续使用缓存文件</p><p> Etag 是服务区响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)</p><p> If-None-Match 服务器再次发起请求时，携带上次请求返回的唯一标识Etag，通过此字段告诉服务器该资源上次请求返回的唯一标识，服务器收到该请求后，发现请求头中含有If-None-Match的字段与该资源在服务器的Etag值进行比对，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码200</p><h2 id="前端常见的优化手段？"><a href="#前端常见的优化手段？" class="headerlink" title="前端常见的优化手段？"></a>前端常见的优化手段？</h2><p>常见的前端性能优化手段包括：减少请求数量、减小资源大小、优化网络连接、优化资源加载、减少重绘回流、使用性能更好的API和构建优化等。</p><p>其中，减少请求数量可以通过合并CSS和JS文件、使用CSS Sprites技术、使用字体图标等方式来实现；减小资源大小可以通过压缩CSS、JS和图片等方式来实现；优化网络连接可以通过使用CDN、开启Gzip压缩等方式来实现；优化资源加载可以通过使用预加载、懒加载等方式来实现；减少重绘回流可以通过避免频繁操作DOM、使用CSS3动画等方式来实现；使用性能更好的API可以通过使用requestAnimationFrame代替setTimeout、使用Web Workers等方式来实现；构建优化可以通过使用Webpack等打包工具进行代码分割、按需加载等方式来实现。</p><p>七大优化手段：<a href="https://juejin.cn/post/7016868803069886471">https://juejin.cn/post/7016868803069886471</a></p><h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>闭包是指一个函数能够访问其他函数内部变量的函数。在JavaScript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数”。</p><p>闭包的优点是可以保护变量不被污染，同时也可以实现数据私有化。缺点是会占用更多的内存空间，同时也会增加代码的复杂度。</p><h2 id="React过期闭包了解过吗？"><a href="#React过期闭包了解过吗？" class="headerlink" title="React过期闭包了解过吗？"></a>React过期闭包了解过吗？</h2><p>React过期闭包是指在使用React Hook时，由于函数组件多次render之间，函数的闭包可能会包住过期的上下文，也就是之前render时的上下文。这个问题在应用Hooks更突出。</p><p>React解决过期闭包问题的方法是依赖数组。针对过期state，可以使用函数的方法更新值。React确保通过更新函数可以得到最新的state值。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端|面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结(2.1)</title>
    <link href="/2023/04/08/%E6%80%BB%E7%BB%93-2-1/"/>
    <url>/2023/04/08/%E6%80%BB%E7%BB%93-2-1/</url>
    
    <content type="html"><![CDATA[<h2 id="进程和线程的概念及区别"><a href="#进程和线程的概念及区别" class="headerlink" title="进程和线程的概念及区别"></a>进程和线程的概念及区别</h2><p>进程是对正在运行中的程序的一个抽象，是系统进行资源分配和调度的基本单位。</p><p>线程是CPU任务调度和执行的基本单位。</p><p>区别：</p><ul><li>进程可以看作是一个独立应用，而线程不能。</li><li>进行是CPU进行资源分配的最小单位，而线程是CPU调度的最小单位。</li><li>线程间可以直接共享同一进程中的资源，而进程通信需要借助<strong>进程间通信</strong>。</li><li>进行切换的开销比线程切换的开销要大。线程的切换不会引起进程的切换，但某个进程中的线程切换到另一个进程中的线程会引起进程的切换。</li><li>撤销或创建进程的时候，系统要为之分配或回收资源，开销远大于创建或撤销线程时的开销。同样，进程切换的时候涉及到<strong>当前进程的CPU环境还有各种各样状态的保存及新调度进程状态的设置</strong>，而线程切换只需要保存和设置少量的寄存器内容，开销较小。</li></ul><h2 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h2><ul><li><p>管道通信</p><p>操作系统在内核中开辟一段缓冲区，进程A可以将需要交互的数据拷贝到这段缓冲区中，进程B就可以读取了。(只能单向通信，并只能在有血缘关系的进程间通信)</p></li><li><p>消息队列队列通信</p><p>消息队列就是一个消息的列表，用户可以在消息队列中添加消息、读取消息等。它提供了一种从一个进程向另一个进程发送数据块的方法。每个数据块都被认为含有一个类型，接收进程可以独立的接受含有不同类型的数据结构。但消息队列与命名管道一样，每个数据块都有一个<strong>最大长度的限制</strong>。</p></li><li><p>共享内存通信</p><p>共享内存就是映射了一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问(使多个进程可以访问同一块内存空间)。</p></li><li><p>信号量通信</p><p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。</p></li><li><p>信号通信</p><p>Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件(一组事件中的一个)，它也是用户进程间通信和同步的一种原始机制。</p></li><li><p>套接字通信</p><p>是计算机之间进行通信的一种约定或一种方式。</p></li></ul><h2 id="进程的状态有哪些？"><a href="#进程的状态有哪些？" class="headerlink" title="进程的状态有哪些？"></a>进程的状态有哪些？</h2><p>进程的状态通常分为五种基本状态：创建态、就绪态、运行态、阻塞态和终止态。</p><ul><li>创建态：进程刚被创建，但是还没有被操作系统调度执行。</li><li>就绪态：进程已经准备好运行，但是还没有被操作系统调度执行。</li><li>运行态：进程正在被操作系统调度执行。</li><li>阻塞态：进程因为某些原因而暂停执行，等待外部事件的发生。</li><li>终止态：进程已经完成了它的任务，或者因为某些原因被操作系统强制终止。</li></ul><h2 id="操作系统进程调度有哪几种？"><a href="#操作系统进程调度有哪几种？" class="headerlink" title="操作系统进程调度有哪几种？"></a>操作系统进程调度有哪几种？</h2><p>操作系统的进程调度的常见策略：</p><ul><li>先来先服务调度算法(FCFS)：按照进程到达的先后顺序进行调度，先到达的进程限制性，后到达的进程后执行。</li><li>短作业优先调度算法(SJF)：按照进程需要的CPU时间长短进行调度，即需要CPU时间最短的进程先执行。</li><li>优先级调度算法：按照进程的优先级进行调度，即优先级高的进程先执行。</li><li>时间片轮转调度算法：按照时间片轮流分配CPU时间进行调度，即每个进程分配一个时间片，当时间片用完后，该进程被挂起，等到下一次轮到它的时候再继续执行。</li><li>多级反馈队列算法：将就绪队列分成多个队列，每个队列有不同的优先级，每个队列采用不同的调度算法。新到达的进程首先放在第一级队列，如果该队列中没有可执行的进程，则将该队列放入第二级队列中等待执行。如果第一级队列中有可执行的进程，则按照时间片轮转调度算法去进行调度。如果一个进程再第一级队列中运行了一段时间仍然没有完成，则将其移动到第二级队列中等待执行，以此类推，直到该进程完成或被强制终止。</li></ul><h2 id="操作系统的堆区和栈区"><a href="#操作系统的堆区和栈区" class="headerlink" title="操作系统的堆区和栈区"></a>操作系统的堆区和栈区</h2><p>操作系统中的堆和栈都是指内存空间，不同的是堆为按需申请、动态分配，例如 C 中的 malloc 函数和 C++ 中的 new 操作。而栈是由编译器自动分配释放，存放函数的参数值，局部变量的值等。<br>堆和栈之间的区别主要有以下几点：</p><ul><li><p>分配方式：堆是动态分配的，而栈是静态分配的。</p></li><li><p>空间大小：堆的空间大小不确定，而栈的空间大小固定。</p></li><li><p>空间分配方式：堆是由程序员手动申请和释放，而栈是由编译器自动分配和释放。</p></li><li><p>空间使用方式：堆的空间可以随时申请和释放，而栈的空间只能在函数调用时申请，在函数返回时释放。</p></li></ul><h2 id="常见的数据结构有哪些？"><a href="#常见的数据结构有哪些？" class="headerlink" title="常见的数据结构有哪些？"></a>常见的数据结构有哪些？</h2><ul><li>数组 (Array)</li><li>队列 (Queue)</li><li>链表 (Linked List)</li><li>栈 (Stack)</li><li>树 (Tree)</li><li>散列表(Hash)</li><li>堆(Heap)</li><li>图 (Graph)</li></ul><h2 id="在JS中如何实现图结构？"><a href="#在JS中如何实现图结构？" class="headerlink" title="在JS中如何实现图结构？"></a>在JS中如何实现图结构？</h2><p>在JavaScript中，可以使用邻接表或邻接矩阵来实现图结构。其中，邻接表是一种链式存储方式，它将每个顶点的所有邻居顶点都存储在一个链表中。而邻接矩阵则是一个二维数组，其中每个元素表示两个顶点之间是否有边。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span> = []；<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()；<br>  &#125;<br><br>  <span class="hljs-title function_">addVertex</span>(<span class="hljs-params">v</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-title function_">push</span>(v)；<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">set</span>(v, [])；<br>  &#125;<br><br>  <span class="hljs-title function_">addEdge</span>(<span class="hljs-params">v, w</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(v).<span class="hljs-title function_">push</span>(w)；<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(w).<span class="hljs-title function_">push</span>(v)；<br>  &#125;<br><br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;&#x27;</span>；<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>； i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-property">length</span>； i++) &#123;<br>      s += <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.vertices[i]&#125;</span> -&gt; `</span>；<br>      <span class="hljs-keyword">const</span> neighbors = <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>[i])；<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>； j &lt; neighbors.<span class="hljs-property">length</span>； j++) &#123;<br>        s += <span class="hljs-string">`<span class="hljs-subst">$&#123;neighbors[j]&#125;</span> `</span>；<br>      &#125;<br>      s += <span class="hljs-string">&#x27;\n&#x27;</span>；<br>    &#125;<br>    <span class="hljs-keyword">return</span> s；<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Graph</span>()；<br><span class="hljs-keyword">const</span> vertices = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>]；<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>； i &lt; vertices.<span class="hljs-property">length</span>； i++) &#123;<br>  graph.<span class="hljs-title function_">addVertex</span>(vertices[i])；<br>&#125;<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;H&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>)；<br>graph.<span class="hljs-title function_">addEdge</span>(<span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>)；<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(graph.<span class="hljs-title function_">toString</span>())；<br></code></pre></td></tr></table></figure><h2 id="JS-DOM树用什么数据结构进行存储？"><a href="#JS-DOM树用什么数据结构进行存储？" class="headerlink" title="JS DOM树用什么数据结构进行存储？"></a>JS DOM树用什么数据结构进行存储？</h2><p>JavaScript的DOM树是以多叉树的形式存储的。DOM模型用一个逻辑树来表示一个文档，树的每个分支的终点都是一个节点(node)，每人节点都包含着对象(Obiects)。</p><h2 id="什么是哈希冲突？"><a href="#什么是哈希冲突？" class="headerlink" title="什么是哈希冲突？"></a>什么是哈希冲突？</h2><p>哈希冲突是指，当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象。在哈希表中，每个关键字都对应一个位置，但是不同的关键字可能会对应到相同的位置，这就是哈希冲突。哈希冲突的解决方法有很多种，其中比较常见的有链地址法和开放地址法。链地址法是将相同hash值的对象组织成一个链表放在hash值对应的槽位；开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。</p><h2 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h2><p>数组和链表是两种常见的数据结构。数组是一种线性数据结构，它在内存中占用一段连续的空间，每个元素都可以通过下标来访问。而链表则是一种非线性数据结构，它的元素在内存中不一定是连续的，每个元素都包含了指向下一个元素的指针。</p><p>因此，数组和链表有以下区别：</p><ul><li>数组在内存中占用一段连续的空间，而链表的元素在内存中不一定是连续的。</li><li>数组的元素可以通过下标来访问，而链表的元素只能通过指针来访问。</li><li>数组的大小是固定的，而链表的大小可以动态改变。</li><li>数组的插入和删除操作需要移动其他元素，时间复杂度为O(n)，而链表只需要改变指针指向，时间复杂度为0(1)。</li></ul><h2 id="数组和链表在内存分配上的区别？"><a href="#数组和链表在内存分配上的区别？" class="headerlink" title="数组和链表在内存分配上的区别？"></a>数组和链表在内存分配上的区别？</h2><p>数组和链表在内存分配上的区别是：</p><p>数组静态分配内存，链表动态分配内存；数组在内存中连续，链表不连续；数组元素在栈区，链表元素在堆区。此外，数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)； 数组插入或删除元素的时间复杂度0(n)，链表的时间复杂度0(1)。</p><h2 id="在使用JS进行开发的时候，什么情况下用数组存储数据-什么情况下用链表存储数据"><a href="#在使用JS进行开发的时候，什么情况下用数组存储数据-什么情况下用链表存储数据" class="headerlink" title="在使用JS进行开发的时候，什么情况下用数组存储数据? 什么情况下用链表存储数据?"></a>在使用JS进行开发的时候，什么情况下用数组存储数据? 什么情况下用链表存储数据?</h2><p>在使用JS进行开发时</p><p>使用数组存储数据的情况包括：需要快速访问元素，需要按照顺序存储元素，需要对元素进行排序或者操作，需要在数组中存储不同类型的数据等。</p><p>使用链表存储据的情况包括：需要动态添加或删除元素，不需要按照顺序存储元素，不需要快速访问元素等。</p><h2 id="JS中二叉树通过什么数据结构进行实现？"><a href="#JS中二叉树通过什么数据结构进行实现？" class="headerlink" title="JS中二叉树通过什么数据结构进行实现？"></a>JS中二叉树通过什么数据结构进行实现？</h2><p>在实现二叉树时，采用的存储结构为链式存储结构，链式结构的意思是采用一个链表来存储一颗二叉树，二叉树中每一个节点用链表的一个节点来存储，在二叉树中，节点结构至少有三个域：数据域data，左指针域left，右指针域right。</p><h2 id="栈和队列的特点及区别"><a href="#栈和队列的特点及区别" class="headerlink" title="栈和队列的特点及区别?"></a>栈和队列的特点及区别?</h2><p>栈和队列都是线性结构，但它们的特点和应用场景不同。栈是一种后进先出(LIFO)的数据结构，而队列是一种先进先出 (FIFO) 的数据结构。</p><p>栈和队列的区别在于它们的出入方式不同。栈是后进先出，队列是先进先出。在具体实现的时候操作的位置也不同:因为栈是后进先出，它在一端进行操作；而队列是先进先出，实现的时候在两端进行操作。</p><h2 id="OSI七层网络协议"><a href="#OSI七层网络协议" class="headerlink" title="OSI七层网络协议"></a>OSI七层网络协议</h2><p>OSI七层网络协议是一种通信协议的标准，它将计算机网络体系结构分为七个层次，每个层次都有自己的功能和任务。这些层次分别是：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p><p>物理层：负责传输比特流，即由1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换。<br>数据链路层：在计算机网络中由于各种干扰的存在，物理链路是不可靠的。该层的主要功能就是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。<br>网络层：负责数据包从源到宿的传递和网际互连。<br>传输层：负责向两台主机进程之间提供端到端的可靠数据传输服务。<br>会话层：负责建立、管理和终止会话。<br>表示层：负责数据格式转换、加密解密等。<br>应用层：为用户提供各种应用服务。</p><h3 id="HTTP属于哪层协议？"><a href="#HTTP属于哪层协议？" class="headerlink" title="HTTP属于哪层协议？"></a>HTTP属于哪层协议？</h3><p>应用层</p><h3 id="TCP和UDP属于哪层协议？"><a href="#TCP和UDP属于哪层协议？" class="headerlink" title="TCP和UDP属于哪层协议？"></a>TCP和UDP属于哪层协议？</h3><p>传输层</p><h2 id="TCP和UDP的区别？"><a href="#TCP和UDP的区别？" class="headerlink" title="TCP和UDP的区别？"></a>TCP和UDP的区别？</h2><p>TCP和UDP的区别如下:</p><ul><li>TCP是面向连接的，UDP是无连接的</li><li>TCP提供可靠的服务，UDP则不保证可靠交付数据 </li><li>TCP是一对一的两点服务，即一条连接只有两个端点。UDP支持一对一、一对多、多对多的交互通信</li><li>TCP有拥塞控制和流量控制机制，保证数据传输的安全性。UDP则没有，即使网络非常拥堵了，也不会影响UDP的发送速率</li><li>TCP首部长度较长，会有一定的开销，首部在没有使用[选项，字段时是20个字节，如果使用了[选项]字段则会变长。UDP首部只有8个字节，并且是固定不变的，开销较小。</li></ul><h2 id="TCP和UDP的应用场景？"><a href="#TCP和UDP的应用场景？" class="headerlink" title="TCP和UDP的应用场景？"></a>TCP和UDP的应用场景？</h2><p>TCP和UDP是两种不同的传输协议。TCP是面向连接的协议，而UDP是无连接的协议。TCP提供交付保证，这意味着一个使用TCP协议发送的消息是保证交付给客户端的，如果消息在传输过程中丢失，那么它将重发。而UDP不提供这种保证。因此，TCP适用于对准确性要求相对高的场景，如文件传输、发送或接收邮件、远程登录等，而UDP适用于对准确性要求相对低但速度要求相对高的场景，如即时通信、在线视频、网络语音电话等。</p><h2 id="TCP的三次挥手"><a href="#TCP的三次挥手" class="headerlink" title="TCP的三次挥手"></a>TCP的三次挥手</h2><p>TCP三次握手是TCP协议中用于在客户端和服务器之间建立连接的过程。三次握手的过程如下：</p><ol><li><p>客户端向服务器发送一个SYN包，其中标志位为SYN，表示请求建立连接，序号为Seq&#x3D;x(一般取随机数)。</p></li><li><p>服务器接收到客户端发来的SYN包后，对该包进行确认后结束LISTEN阶段，并返回一段TCP报文，其中标志位为SYN和ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接，序号为Seq&#x3D;y。</p></li><li><p>客户端接收到服务器发来的TCP报文后，对该报文进行确认，其中标志位为ACK，表示确认服务器的报文Seq序号有效，客户端能正常接收服务器发送的数据，并向服务器发送一段TCP报文，其中标志位为ACK，表示确认服务器的报文Seq序号有效。</p></li></ol><h2 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h2><p>TCP四次挥手是TCP协议中用于在客户端和服务器之间断开连接的过程。四次挥手的过程如下：</p><ol><li><p>客户端向服务器发送一个FIN包，其中标志位为FIN，表示请求断开连接，序号为Seq&#x3D;u。</p></li><li><p>服务器接收到客户端发来的FIN包后，对该包进行确认后结束ESTABLISHED阶段，并返回一段TCP抵文，其中标志位为ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并告诉客户端：我知道你想断开连接的请求了。</p></li><li><p>服务器向客户端发送一个FIN包，其中标志位为FIN，表示请求断开连接，序号为Seq&#x3D;V。</p></li><li><p>客户端接收到服务器发来的TCP报文后，对该报文进行确认，其中标志位为ACK，表示确认服务器的报文Seq序号有效，客户端能正常接收服务器发送的数据，并向服务器发送一段TCP报文，其中标志位为ACK，表示确认服务器的报文Seq序号有效。</p></li></ol><h2 id="TCP的三次握手为什么不能改成两次？"><a href="#TCP的三次握手为什么不能改成两次？" class="headerlink" title="TCP的三次握手为什么不能改成两次？"></a>TCP的三次握手为什么不能改成两次？</h2><p>TCP三次握手是TCP协议中用于在客户端和服务器之间建立连接的过程。其中，第一次握手是客户端向服务器发送一个SYN包，其中标志位为SYN，表示请求建立连接，序号为Seq&#x3D;x；</p><p>第二次握手是服务器接收到客户端发来的SYN包后，对该包进行确认后结束SYN_RECEIVED阶段，并返回一段TCP报文，其中标志位为SYN&#x2F;ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并告诉客户端:我知道你想建立连接的请求了，我的序号是Seq&#x3D;y；</p><p>第三次握手是客户端接收到服务器发来的TCP报文后，对该报文进行确认，其中标志位为ACK，表示确认服务器的报文Seq序号有效，客户端能正常接收服务器发送的数据，并告诉服务器:我知道你想建立连接的请求了，我的序号是Seq&#x3D;x+1。这样就完成了TCP三次握手过程。</p><p>如果采用两次握手，则<strong>只能确定从客户端到服务端的网络是可达的，但无法保证从服务端到客户端的网络是可达的</strong>。</p><p>此外，在采用两次握手时，如果已失效的连接请求报文段突然又传到了服务端，则会导致双方不一致，造成资源浪费。</p><h2 id="浏览器中输入网址并发起网络请求后都经历了什么？"><a href="#浏览器中输入网址并发起网络请求后都经历了什么？" class="headerlink" title="浏览器中输入网址并发起网络请求后都经历了什么？"></a>浏览器中输入网址并发起网络请求后都经历了什么？</h2><ol><li><p>首先判断输入的内容是否为合法的域名，如果不是则作为关键字交给搜索引擎进行处理；如果域名中有非法字符则进行转义。</p></li><li><p>首先判断浏览器中是否有所需资源的缓存，如果有则直接使用，否则进行DNS查询获取域名对应的IP地址。</p></li><li><p>DNS查询</p><ol><li><p>判断本地的DNS缓存中是否有该IP地址，如果命中则返回</p></li><li><p>如果还是没有命中，则将域名发送到本地域名服务器，本地域名服务器采用递归查询自己的DNS服务器，查找成功则返回。</p></li><li><p>如果本地域名服务器的DNS缓存没有命中，则向上级域名服务器进行迭代查询</p><ul><li><p>首先本地域名服务器向根域名服务器进行请求，获取顶级域名服务器的地址给本地服务器。</p></li><li><p>本地域名服务器拿到这个顶级域名服务器后就想起发送请求，获取权威域名服务器的地址。</p></li><li><p>本地域名服务器向权威域名服务器发送请求，获取域名对应的IP地址。</p></li></ul></li><li><p>本地域名服务器将得到的IP地址发送给操作系统，同时自己将IP地址缓存起来。</p></li><li><p>操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来。</p></li><li><p>至此，浏览器得到了域名对应的IP地址，并将IP地址缓存起来。</p></li></ol></li><li><p>通过IP地址与本地的子网掩码相与，判断是否与请求主机在一个子网中，如果在一个子网中，则使用ARP协议获取目标主机的MAC地址，如果不在一个子网中，那么请求应该转发给网关，由它代为转发，此时同样可以通过ARP协议获取网关MAC地址，此时目的主机的MAC地址应该为网关地址。</p></li><li><p>进行TCP的三次握手</p></li><li><p>进行HTTPS握手</p></li><li><p><strong>返回数据</strong>：将网页请求发送至服务器端，服务器端返回一个html文件作为响应。浏览器接受响应后，开始对html文件进行解析并开始页面的渲染过程。</p></li><li><p><strong>页面渲染</strong>：根据html文件构建DOM树，根据解析到的css构建CSSOM树，如果遇到script标签，则判断有无async和defer属性，否则script的加载和执行会造成页面渲染的阻塞。当DOM树和CSSOM树建立好后，根据他们构建渲染树。渲染树构建好后，根据渲染树进行布局，然后使用浏览器的UI接口对页面进行绘制。此时整个页面就显示出来了。</p></li><li><p>TCP四次挥手</p></li></ol><h2 id="什么是数据库的索引？"><a href="#什么是数据库的索引？" class="headerlink" title="什么是数据库的索引？"></a>什么是数据库的索引？</h2><p>数据库索引是一种数据结构，用于提高数据库表中数据的查询效率。索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。</p><p>在数据库中，索引类似于书籍的目录。如果您想查找书籍中的某个主题，您可以查找目录以找到该主题的页码，而不必翻阅整本书。同样，如果您想查找数据库表中的某个值，则可以使用索引来快速查找该值所在的行，而不必扫描整个表。</p><p>索引可以大大提高查询效率，但也会增加写入操作的时间和空间开销。因此，在设计数据库时，需要权衡查询效率和写入效率之间的平衡。</p><h2 id="数据库的索引有哪几种类型？"><a href="#数据库的索引有哪几种类型？" class="headerlink" title="数据库的索引有哪几种类型？"></a>数据库的索引有哪几种类型？</h2><p>数据库索引有多种类型，包括: 普通索引、唯一索引、主键索引、组合索引和全文索引等。</p><ul><li>普通索引：基本的索引类型，没有唯一性的限制，允许为NULL值。</li><li>唯一索引：数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</li><li>主键索引：主键是一种特殊的唯一索引，不允许为NULL值，一个表只能有一个主键</li><li>组合索引：将多个列作为一个索引建立，可以提高查询效率。</li><li>全文索引：用于全文搜索的特殊类型的索引。</li></ul><h2 id="什么是MySQL关联查询？"><a href="#什么是MySQL关联查询？" class="headerlink" title="什么是MySQL关联查询？"></a>什么是MySQL关联查询？</h2><p>MySQL关联查询是指在查询时，需要同时操作多张表来查询数据，即关联查询。MySQL关联查询的语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column name(s)<br>FROM tablel<br>JOIN table2<br>ON table1.column_name = table2.column_name;<br></code></pre></td></tr></table></figure><p>其中，<code>table1</code> 和 <code>table2</code> 是要连接的表的名称，column_name 是要检索的列的名称。JOIN关键字用于指定要连接的表，而关键字用于指定连接条件。</p><p>MySQL支持多种类型的关联查询，包括：内连接、左连接、右连接和全连接等。</p><h2 id="关系型数据库和非关系型数据库的区别？"><a href="#关系型数据库和非关系型数据库的区别？" class="headerlink" title="关系型数据库和非关系型数据库的区别？"></a>关系型数据库和非关系型数据库的区别？</h2><p>关系型数据库和非关系型数据库的区别在于，关系型数据库一般都是有固定的表结构，并且需要通知DDL语句来修改表结构，不是很容易进行扩展；而非关系型数据库的存储机制就有很多了，比如基于文档的，K-V键值对的，还有基于图的等，对于数据的格式十分灵活没有固定的表结构，方便扩展。因此<u>如果业务的数据结构并不是固定的或者经常变动比较大的，那么非关系型数据库是个好的选择</u>。</p><h2 id="关系型数据库与文档型数据库的区别？"><a href="#关系型数据库与文档型数据库的区别？" class="headerlink" title="关系型数据库与文档型数据库的区别？"></a>关系型数据库与文档型数据库的区别？</h2><p>关系型数据库（Relational Database）是建立在关系模型基础上的数据库，借助于几何代数等数学概念和方法来处理数据库中的数据。所谓关系模型是一对一、一对多或者多对多等关系，常见的关系型数据库有Oracle、SQL Server、DB2、MySQL等。</p><p>而文档型数据库是一种非关系型数据库，非关系型数据库（Not Only SQL，NoSQL）正好与关系型数据库相反，它不是建立在“关系模型”上的数据库。文档型数据库的典型代表是MongoDB。</p><h2 id="MongoDB和MySQL的区别"><a href="#MongoDB和MySQL的区别" class="headerlink" title="MongoDB和MySQL的区别"></a>MongoDB和MySQL的区别</h2><p>MongoDB是一种文档型数据库，而MySQL是一种关系型数据库。</p><p>MongoDB可以处理大量和非结构化数据量，而MySQL则<strong>缺乏处理大数据量的速度</strong>。因此，对于拥有较小数据库并寻求更通用解决方案的公司来说，MySQL可以胜任。</p><p>另外，MongoDB以一种直观文档的方式来完成数据的存储，它很像JavaScript中定义的JSON格式，不过数据在存储的时候MongoDB数据库为文档增加了序列化的操作，最终存进磁盘的其实是一种叫做BSON的格式，即Binary-JSON。</p><p>MySQL在<strong>处理关系数据方面具有更好的优势</strong>，而MongoDB则更能满足现代应用程序的需求。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端|面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结(1.1)</title>
    <link href="/2023/04/08/%E6%80%BB%E7%BB%93-1-1/"/>
    <url>/2023/04/08/%E6%80%BB%E7%BB%93-1-1/</url>
    
    <content type="html"><![CDATA[<h2 id="React函数组件的优势"><a href="#React函数组件的优势" class="headerlink" title="React函数组件的优势"></a>React函数组件的优势</h2><ul><li>函数式组件没有this困扰且代码简洁</li><li>不涉及到复杂的state和生命周期</li><li>类组件过于冗余不宜拆分</li></ul><h2 id="常用的React-Hooks"><a href="#常用的React-Hooks" class="headerlink" title="常用的React Hooks"></a>常用的React Hooks</h2><blockquote><p>Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数</p><p>Hook使用规则：</p><ul><li>只能在<strong>函数最外层</strong>调用Hook。不能在循环、条件判断或子函数中调用。</li><li>只能在React的<strong>函数组件</strong>中调用Hook。不能在其他JavaScript函数中调用。</li></ul></blockquote><ul><li><p>State Hook</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">count</span>, setCount] = useState(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li><p>Effect Hook</p><blockquote><p><code>useEffect</code>就是一个Effect Hook，给函数组件增加了操作副作用的能力。它跟class组件中的<code>componentDidMount</code>、<code>componentDidUpdate</code>和<code>componentWillUnMount</code>具有相同的用途，只不过被合并成了一个<code>API</code>。</p></blockquote><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 模拟componentDidMount</span><br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>   <span class="hljs-comment">// 第一次渲染时调用 </span><br>&#125;, [])<br><br><span class="hljs-comment">// 模拟componentDidUpdate</span><br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 任意属性发生改变该属性就会改变</span><br>&#125;)<br><br><span class="hljs-comment">// 模拟componentWillUnmount useEffect会在状态变化的时候进行解绑</span><br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    const timer = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;, <span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <span class="hljs-comment">// 返回的函数是用于清除副作用的</span><br>        <span class="hljs-comment">// 执行卸载操作</span><br>        clearInterval(timer);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>自定义Hooks</p><p>例如：自定义一个订阅好友在线状态的Hook</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">import React, &#123; useEffect, useState &#125; from <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> use<span class="hljs-constructor">FriendStatus(<span class="hljs-params">friendID</span>)</span> &#123;<br>    const <span class="hljs-literal">[<span class="hljs-identifier">isOnline</span>, <span class="hljs-identifier">setIsOnlone</span>]</span> = use<span class="hljs-constructor">State(<span class="hljs-params">null</span>)</span>;<br>    const handleStatusChange =<span class="hljs-function"> (<span class="hljs-params">status</span>) =&gt;</span> &#123;<br>        set<span class="hljs-constructor">IsOnline(<span class="hljs-params">status</span>)</span>;<br>    &#125;<br>    use<span class="hljs-constructor">Effect(()</span> =&gt; &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChatAPI</span>.</span></span>subscribe<span class="hljs-constructor">ToFriendStatus(<span class="hljs-params">friendId</span>, <span class="hljs-params">handleStatusChange</span>)</span>; <span class="hljs-comment">// 订阅好友在线状态</span><br>        return<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChatAPI</span>.</span></span>unsubscribe<span class="hljs-constructor">ToFriend(<span class="hljs-params">friendId</span>, <span class="hljs-params">handleStatusChange</span>)</span>; <span class="hljs-comment">// 解绑对好友在线状态的订阅</span><br>        &#125;<br>    &#125;)<br>    return isOnline;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们可以在别的组件中使用它</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">FriendStatus(<span class="hljs-params">props</span>)</span> &#123;<br>    const isOnline = use<span class="hljs-constructor">FriendStatus(<span class="hljs-params">props</span>.<span class="hljs-params">friend</span>.<span class="hljs-params">id</span>)</span>;<br>    <span class="hljs-keyword">if</span>(isOnline<span class="hljs-operator"> === </span>null) &#123;<br>        return <span class="hljs-string">&quot;Loading...&quot;</span>;<br>    &#125;<br>    return isOnline ? <span class="hljs-string">&quot;onLine&quot;</span> : <span class="hljs-string">&quot;OffLine&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>useContext</p><p>不使用组件嵌套就可以订阅React的Context</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">function Example() &#123;<br>    const locale <span class="hljs-operator">=</span> useContext(LocaleContext)<span class="hljs-comment">;</span><br>    const theme <span class="hljs-operator">=</span> useContext(ThemeContext)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>useReducer</p><p>通过reducer管理本地复杂的state</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Todos()</span> &#123;<br>    const <span class="hljs-literal">[<span class="hljs-identifier">todos</span>, <span class="hljs-identifier">setTodos</span>]</span> = use<span class="hljs-constructor">Reducer(<span class="hljs-params">todosReducer</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="React为什么推荐用Hook而不是生命周期"><a href="#React为什么推荐用Hook而不是生命周期" class="headerlink" title="React为什么推荐用Hook而不是生命周期"></a>React为什么推荐用Hook而不是生命周期</h2><p>生命周期不利于逻辑相关的状态的管理。</p><p>side effect相关逻辑被分散到不同的函数中可能会导致bug的出现和产生数据不一致的情况；我们也可能会在组件的同一生命周期中放很多不相关的side effect逻辑。</p><p>使用Hook可以将某个side effect相关的逻辑都放在同一个函数中，方便代码的维护，方便组件的复用。</p><h2 id="为什么不能在循环、条件或嵌套函数中调用React-Hook"><a href="#为什么不能在循环、条件或嵌套函数中调用React-Hook" class="headerlink" title="为什么不能在循环、条件或嵌套函数中调用React Hook"></a>为什么不能在循环、条件或嵌套函数中调用React Hook</h2><p>React是使用链表来存储Hook的，每次Hook的调用都对应着一个全局的index索引，通过这个索引运行当前组件上的_hooks数组查找保存的值，也就是Hook返回的<code>[state, useState]</code></p><p>假设如下代码：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">function Example() &#123;<br>    <span class="hljs-keyword">const</span> [state1, <span class="hljs-built_in">set</span>State1] = useState(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> [state2, <span class="hljs-built_in">set</span>State2] = useState(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">const</span> [state3, <span class="hljs-built_in">set</span>State3] = useState(<span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/5/166e20d92aa52108~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="react-hooks"></p><p>在执行函数组件的时候，第一次执行<code>useState</code>是时候，它会对应Fiber对象上的<code>memoizedState</code>，这个属性原来是设计来存储类组件的state的，因为在类组件中state是一整个对象，所以可以和<code>memoizedState</code>一一对应。</p><p>但是在Hooks中，React并不知道我们调用了几次<code>useState</code>，所以在保存state这件事上，React提出了另一种解决方案，即调用<code>useState</code>之后在<code>memoizedState</code>上的对象设计成如下样式：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">&#123;<br><span class="hljs-built_in">    baseState,</span><br><span class="hljs-built_in">    next,</span><br><span class="hljs-built_in">    baseUpdate,</span><br><span class="hljs-built_in">    queue,</span><br>    memoizedState<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将其称为Hook对象。这里最需要关心的是<code>memoizedState</code>和<code>next</code>，<code>memoizedState</code>用来记录该<code>useState</code>应该返回的结果，而<code>next</code>指向下一次<code>useState</code>对应的Hook对象。</p><p>即：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">hook1</span> <span class="hljs-operator">=</span>&gt; Fiber.memoizedState<br><span class="hljs-attribute">state1</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> hook1.memoizedState<br>hook1.next <span class="hljs-operator">=</span>&gt; hook2<br><span class="hljs-attribute">state2</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> hook2.memoizedState<br>hook2.next <span class="hljs-operator">=</span>&gt; hook3<br><span class="hljs-attribute">state3</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> hook3.memoizedState<br></code></pre></td></tr></table></figure><p>React按照执行顺序以类似链表的数据格式存放在<code>Fiber.memoizedState</code>上</p><p>由于按照这种方式存储state，因此<code>useState</code>(包括其他Hooks)都必须在函数组件的根作用域声明，而不能再条件或循环中声明。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if(something) &#123;<br>    const [state1] <span class="hljs-operator">=</span> useState(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>&#125;<br>// or<br>for(something) &#123;<br>    const [state2] <span class="hljs-operator">=</span> useState(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们无法保证条件语句每次执行的次数是一样的，也就是说如果第一次render创建了<code>state1 =&gt; hook1, state2 =&gt; hook2, state3 =&gt; hook3</code>这样的对应关系，再次render的时候因为<code>something</code>未达成，导致<code>useState(1)</code>没有执行的话，那么执行<code>useState(2)</code>的时候，拿到的hook对象是<code>state1</code>的，那么逻辑就会混乱，因此该条件必须遵守。</p><p>更新state的时候，调用<code>useState</code>的返回方法如下：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">var</span> dispatch = <span class="hljs-built_in">queue</span>.dispatch = dispatchAction.bind(<span class="hljs-built_in">null</span>, currentlyRenderingFiber$<span class="hljs-number">1</span>, <span class="hljs-built_in">queue</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-meta">[</span>workInProgressHook.memoizedState, dispatch<span class="hljs-meta">]</span>;<br></code></pre></td></tr></table></figure><p>调用该方法会创建一个update</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">var</span> <span class="hljs-string">update</span> <span class="hljs-string">=</span> &#123;<br>  <span class="hljs-attr">expirationTime:</span> <span class="hljs-string">_expirationTime</span>,<br>  <span class="hljs-attr">action:</span> <span class="hljs-string">action</span>,<br>  <span class="hljs-attr">callback:</span> <span class="hljs-string">callback</span> <span class="hljs-type">!==</span> <span class="hljs-string">undefined</span> <span class="hljs-string">?</span> <span class="hljs-attr">callback :</span> <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">next:</span> <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的action是调用<code>setState(1)</code>传入的值，而这个update会被加入到queue上，因此可能存在一次性调用多次setState1的情况。</p><p>在收集完这所有<code>update</code>之后，会调度一次<code>React</code>的更新，在更新的过程中，肯定会执行到函数组件，那么就会执行到对应的<code>useState</code>，然后就拿到了<code>Hook</code>对象，它保存了<code>queue</code>对象表示有哪些更新存在，然后依次进行更新，拿到最新的<code>state</code>保存在<code>memoizedState</code>上，并且返回，最终达到了<code>setState</code>的效果。</p><p>参考文档：<a href="https://juejin.cn/post/6844903704437456909">https://juejin.cn/post/6844903704437456909</a></p><h2 id="useMemo和useCallback的区别"><a href="#useMemo和useCallback的区别" class="headerlink" title="useMemo和useCallback的区别"></a>useMemo和useCallback的区别</h2><p>二者都是用于缓存数据，优化性能的，它们接受到的参数是一样的，第一个参数表示回调函数，第二个参数表示依赖的数据。</p><p>共同作用：在依赖数据发生变化的时候，才会调用传进去的回调函数去重新计算结果，起到缓冲的作用。</p><p>区别：</p><ul><li><code>useMemo</code>缓存的结果是回调函数中return回来的值，主要用于缓存计算结果的值，应用场景如需要计算的状态。</li><li><code>useCallback</code>缓存的结果是函数，主要用于缓存函数，应用场景如需要缓存的函数，因为函数式组件每次任何一个state发生变化都会触发整个组件更新，一些函数是没有必要更新的，此时就应该缓存起来，提高性能，减少对资源的浪费。<code>useCallback</code>应该和<code>React.memo</code>配套使用，缺少一个可能会导致性能不升反降。</li></ul><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useState, useMemo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Info</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">const</span> [info, setInfo] = <span class="hljs-title function_">useState</span>(&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;LiHua&quot;</span>,<br>        <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;male&quot;</span><br>    &#125;);<br>    <span class="hljs-comment">// 翻译性别的函数</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">formatGender</span> = (<span class="hljs-params">gender</span>) =&gt; &#123;<br>        <span class="hljs-keyword">return</span> gender === <span class="hljs-string">&quot;male&quot;</span> ? <span class="hljs-string">&quot;男&quot;</span> : <span class="hljs-string">&quot;女&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果不使用useMemo,修改其他属性，也会导致formatGender方法的调用，浪费计算资源</span><br>    <span class="hljs-comment">// const gender = formatGender(info.gender);</span><br>    <span class="hljs-comment">// 仅当info.gender发生变化的时候才调用formatGender</span><br>    <span class="hljs-keyword">const</span> gender = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">formatGender</span>(info.<span class="hljs-property">gender</span>);<br>    &#125;, [info.<span class="hljs-property">gender</span>]);<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        姓名：&#123;info.name&#125; - 性别：&#123;gender&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onClick</span> = <span class="hljs-string">&#123;()</span> =&gt;</span> setInfo(...info, name: &quot;XiaoMing&quot;)&#125;</span><br><span class="language-xml">        &gt;点击修改姓名<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>useCallback是设计初衷是为了<strong>减少子组件的不必要重读渲染</strong>，优化思路主要有以下两种：</p><ul><li>减少render的次数</li><li>减少计算量</li></ul><p>在如下场景中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-comment">// 不使用useCallback和memo的时候</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Comp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [dataA, setDataA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> [dataB, setDataB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickA</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataA</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickB</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataB</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Cheap</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickA&#125;</span>&gt;</span>组件Cheap: &#123;dataA&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Cheap</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Expensive</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickB&#125;</span>&gt;</span>组件Expensive: &#123;dataB&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Expensive</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述组件中，每当点击Cheap组件的时候，Expensive组件也会重新渲染，即使dataB没有发生变化，原因就是onClickB被重新定义，导致React在diff新旧组件的时候判定了组件发生了变化。</p><p>此时，useCallback和memo就发挥作用了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useCallback, useState, memo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Expensive</span>(<span class="hljs-params">&#123;onClick, name&#125;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Expensive渲染&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><span class="hljs-keyword">const</span> memoExpensive = <span class="hljs-title function_">memo</span>(<span class="hljs-title class_">Expensive</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cheap</span>(<span class="hljs-params">&#123;onClick, name&#125;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Cheap渲染&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Comp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [dataA, setDataA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> [dataB, setDataB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClickA</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setDataA</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> onClickB = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">setDataB</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o+<span class="hljs-number">1</span>);<br>    &#125;, [])<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Cheap</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickA&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">组件Cheap:</span> $&#123;<span class="hljs-attr">dataA</span>&#125;`&#125; /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Expensive</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClickB&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">组件Expensive:</span> $&#123;<span class="hljs-attr">data</span>&#125;`&#125; /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>memo与PureComponent类似，对传入组件的新旧数据进行浅比较，如果相同则不会触发渲染。</p><p>useCallback保证onClickB不会发生变化，此时点击Cheap组件不会触发Expensive组件的刷新，只有点击Expensive组件才会触发。在实现减少不必要渲染的优化过程中，useCallback和memo是一对利器。</p><h2 id="函数组件模拟componentWillUnmount组件"><a href="#函数组件模拟componentWillUnmount组件" class="headerlink" title="函数组件模拟componentWillUnmount组件"></a>函数组件模拟componentWillUnmount组件</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 执行卸载操作</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="项目：根据用户权限实现路由权限管理"><a href="#项目：根据用户权限实现路由权限管理" class="headerlink" title="项目：根据用户权限实现路由权限管理"></a>项目：根据用户权限实现路由权限管理</h2><p>在编写React路由列表的时候为每一个路由赋一个id值，在用户登录之后将用户的权限列表存储起来，并根据用户权限列表对路由列表进行筛选和展示，根据筛选后的结果部署系统的导航栏。</p><p>当用户想要通过直接输入url的方式访问某个页面的时候，在Route组件的render函数中根据url匹配到路由对应的id值，然后判断用户权限列表中是否存在该id值，如果存在则允许访问，否则警告用户没有权限并返回首页。</p><p>……</p><h2 id="为什么使用Redux进行状态管理"><a href="#为什么使用Redux进行状态管理" class="headerlink" title="为什么使用Redux进行状态管理"></a>为什么使用Redux进行状态管理</h2><ul><li><strong>Redux使状态可预测。</strong>传递相同的状态和动作传递给减速器，总会产生相同的结果，因为减速器是纯函数。</li><li><strong>Redux方便维护。</strong>Redux对代码的组织方式很严格，结构更容易理解，维护更加方便。同时有利于用户将业务逻辑与组件树分离。</li><li><strong>Redux调试简单。</strong>Redux使调试程序变得简单，通过记录操作和状态，很容易理解编码错误、网络错误和生产过程中出现的其他形式的错误。</li><li><strong>Redux有性能优势。</strong>Redux内部实现了很多优化，因此我们自己的连接组件仅在实际需要时才重新渲染。</li><li><strong>数据持久化。</strong></li><li><strong>Redux还能用于服务端渲染。</strong>我们可以通过将应用程序的状态连同它对服务器请求的响应发送到服务器来处理应用程序的初始呈现，然后所需组件以HTML格式呈现并发送到客户端。</li></ul><h2 id="哪些数据需要使用Redux进行存储？"><a href="#哪些数据需要使用Redux进行存储？" class="headerlink" title="哪些数据需要使用Redux进行存储？"></a>哪些数据需要使用Redux进行存储？</h2><p>全局公共数据用Redux进行管理，局部状态用state和props即可。</p><h2 id="浏览器的垃圾回收机制"><a href="#浏览器的垃圾回收机制" class="headerlink" title="浏览器的垃圾回收机制"></a>浏览器的垃圾回收机制</h2><p>JS代码运行时，需要分配内存空间来存储变量和值。当变量不再参与运行时，就需要回收被占用的空间，这就是垃圾回收。</p><p><strong>垃圾回收的方式</strong></p><ul><li><p><strong>标记清除</strong></p><p>当变量进入执行环境时，标记该变量”进入幻境”，此时变量不能回收。当变量离开环境的时候，就会被标记为”离开环境”，会被内存释放</p></li><li><p><strong>引用计数</strong></p><p>跟踪每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量的时候，这个值的引用次数就是1。当包含对该值引用的变量指向另一个值的时候，引用次数减1。当引用次数变为0的时候，说明该值已经没有利用价值，这个变量占用的内存空间就会被释放出来。</p><p>弊端：可能会引起<strong>循环引用</strong>的问题，例如：obj1和obj2通过属性互相进行引用，那么二者的引用次数永远不会归零，函数执行完结束后，两个变量仍然会继续存在，引用次数永远不为0，会引起循环引用。</p></li></ul><p><strong>减少垃圾回收的方式</strong></p><ul><li>对数组进行优化：清空一个数组的时候将其长度设为0</li><li>对对象进行优化：不再使用的时候将其设置为null</li><li>对函数进行优化：在循环中的函数表达式，如果可以复用则尽量放在外面</li></ul><h2 id="实现JS的深拷贝"><a href="#实现JS的深拷贝" class="headerlink" title="实现JS的深拷贝"></a>实现JS的深拷贝</h2><ul><li><p>使用JSON.stringify和JSON.parse实现</p></li><li><p>for…in + Object.assign</p></li><li><p>for…in + 拓展运算符</p></li><li><p><strong>Object.create</strong></p></li><li><p><strong>jQuery.extend(deep, target, obj1, …)</strong></p></li><li><p>函数库lodash</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;lodash&quot;</span>;<br><span class="hljs-keyword">const</span> obj = &#123;a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span>&#125;;<br><span class="hljs-keyword">const</span> deep = _.cloneDeep(obj);<br></code></pre></td></tr></table></figure></li></ul><h2 id="JS作用域是在什么时候创建的"><a href="#JS作用域是在什么时候创建的" class="headerlink" title="JS作用域是在什么时候创建的"></a>JS作用域是在什么时候创建的</h2><p>全局作用域在window对象创建的时候产生。</p><p>局部作用域在函数执行时产生，函数执行完毕后，如果子作用域不需要使用它声明的变量就销毁，如果使用就形成闭包保存下来。</p><h2 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h2><p>有权访问另一个函数作用域内变量的函数</p><h2 id="宏任务和微任务的区别"><a href="#宏任务和微任务的区别" class="headerlink" title="宏任务和微任务的区别"></a>宏任务和微任务的区别</h2><p>宏任务一般是：整体代码script、setTimeout、setInterval、I&#x2F;O、UI render</p><p>微任务主要是：Promise、Object.observe、MutationObserver</p><p>二者都是异步。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端|面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
