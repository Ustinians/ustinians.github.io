

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="想躺在云上">
  <meta name="keywords" content="">
  
    <meta name="description" content="知识点整理(7)git amend的作用？git amend命令用于修改最近一次的提交记录。它允许您添加、删除或修改之前提交的文件、提交消息等。 使用git amend命令，您可以：  修改上一次提交的提交消息。 将一些忘记添加到上一次提交中的文件添加到该提交中。 修改上一次提交中的某些文件。 将上一次提交中的某些文件删除。  使用git amend命令修改最近一次提交记录有以下两种方式： 修改最">
<meta property="og:type" content="article">
<meta property="og:title" content="知识点整理(7)">
<meta property="og:url" content="https://ustinians.github.io/2023/04/13/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-7/index.html">
<meta property="og:site_name" content="想躺在云上 - In doing we learn.">
<meta property="og:description" content="知识点整理(7)git amend的作用？git amend命令用于修改最近一次的提交记录。它允许您添加、删除或修改之前提交的文件、提交消息等。 使用git amend命令，您可以：  修改上一次提交的提交消息。 将一些忘记添加到上一次提交中的文件添加到该提交中。 修改上一次提交中的某些文件。 将上一次提交中的某些文件删除。  使用git amend命令修改最近一次提交记录有以下两种方式： 修改最">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-04-13T04:00:42.000Z">
<meta property="article:modified_time" content="2023-04-20T08:50:27.572Z">
<meta property="article:author" content="想躺在云上">
<meta property="article:tag" content="前端学习">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>知识点整理(7) - 想躺在云上 - In doing we learn.</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"ustinians.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>想躺在云上</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="知识点整理(7)"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-04-13 12:00" pubdate>
          2023年4月13日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          125 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">知识点整理(7)</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="知识点整理-7"><a href="#知识点整理-7" class="headerlink" title="知识点整理(7)"></a>知识点整理(7)</h1><h2 id="git-amend的作用？"><a href="#git-amend的作用？" class="headerlink" title="git amend的作用？"></a>git amend的作用？</h2><p>git amend命令用于修改最近一次的提交记录。它允许您添加、删除或修改之前提交的文件、提交消息等。</p>
<p>使用git amend命令，您可以：</p>
<ol>
<li>修改上一次提交的提交消息。</li>
<li>将一些忘记添加到上一次提交中的文件添加到该提交中。</li>
<li>修改上一次提交中的某些文件。</li>
<li>将上一次提交中的某些文件删除。</li>
</ol>
<p>使用git amend命令修改最近一次提交记录有以下两种方式：</p>
<p><strong>修改最近一次提交记录的提交消息：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git commit --amend -m &quot;New commit message&quot;<br></code></pre></td></tr></table></figure>

<p>这个命令将会修改最近一次提交记录的提交消息。</p>
<p><strong>添加、删除或修改最近一次提交记录中的文件：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs git">git add &lt;file&gt;  # 添加文件到暂存区<br>git rm &lt;file&gt;   # 从暂存区和工作目录中删除文件<br>git reset &lt;file&gt;   # 从暂存区中删除文件，但不删除工作目录中的文件<br>git commit --amend   # 修改最近一次提交记录<br></code></pre></td></tr></table></figure>

<p>注意：使用git amend修改提交记录时，只能修改最近一次提交记录，如果要修改更早的提交记录，需要使用git rebase等其他命令。</p>
<h2 id="Websocket承载的上限，能同时接受多少个客户端连接？"><a href="#Websocket承载的上限，能同时接受多少个客户端连接？" class="headerlink" title="Websocket承载的上限，能同时接受多少个客户端连接？"></a>Websocket承载的上限，能同时接受多少个客户端连接？</h2><p>WebSocket承载的上限取决于多个因素，包括服务器的硬件和软件配置、网络带宽、同时连接的客户端数量、客户端发送和接收数据的频率等。因此，无法给出一个具体的答案来回答能同时接受多少个客户端连接。</p>
<p>一般来说，WebSocket的性能通常比HTTP长连接更好，因为它使用的是基于事件的模型，可以在服务器和客户端之间实现实时的双向通信。但是，在实际应用中，如果同时连接的客户端数量过多，可能会导致服务器的负载过高，从而影响WebSocket的性能和可靠性。</p>
<p>为了提高WebSocket的性能和可靠性，可以采取一些优化措施，例如使用负载均衡、优化服务器端代码、增加服务器硬件配置、限制每个客户端的连接数量等。同时，也需要根据实际情况进行测试和调整，以确保WebSocket在高并发情况下的稳定性和性能。</p>
<h2 id="操作系统的功能有哪些？"><a href="#操作系统的功能有哪些？" class="headerlink" title="操作系统的功能有哪些？"></a>操作系统的功能有哪些？</h2><ol>
<li><p>进程管理：操作系统管理计算机上运行的所有进程，包括进程的创建、调度、终止、通信等。</p>
</li>
<li><p>内存管理：操作系统管理计算机内存的分配和释放，确保程序能够访问到所需的内存空间。</p>
</li>
<li><p>文件系统：操作系统管理计算机上的文件和目录，包括文件的创建、读取、写入、复制、删除等。</p>
</li>
<li><p>设备管理：操作系统管理计算机上的各种设备，包括输入输出设备、存储设备、网络设备等。</p>
</li>
<li><p>用户接口：操作系统提供了用户与计算机交互的接口，包括命令行接口、图形用户界面等。</p>
</li>
<li><p>安全性管理：操作系统确保计算机系统的安全性，包括用户身份验证、访问控制、病毒防护等。</p>
</li>
<li><p>网络管理：操作系统提供了网络通信的支持，包括TCP&#x2F;IP协议栈、网络驱动程序等。</p>
</li>
</ol>
<h2 id="并发和并行的区别？"><a href="#并发和并行的区别？" class="headerlink" title="并发和并行的区别？"></a>并发和并行的区别？</h2><p>并发和并行都是多任务处理的概念，但是它们的含义不同。</p>
<p>并发是指在同一时间段内，有多个任务在交替执行，这些任务可能在同一个处理器上交替执行，也可能在多个处理器上并行执行。在并发执行中，每个任务都会分配一定的时间片，轮流执行，但是在任意时刻只有一个任务在执行。</p>
<p>并行是指在同一时刻，有多个任务在同时执行，这些任务可以在多个处理器上并行执行，也可以在同一处理器上通过多核心并行执行。在并行执行中，多个任务同时执行，每个任务都能够分配到独立的处理器或处理器核心。</p>
<p>简单来说，如果是在同一个处理器上，任务是交替执行的，就是并发；如果是在多个处理器上或者是多核心并行执行，就是并行。</p>
<p>总之，并发和并行都是提高计算机系统效率的重要手段，但是它们的实现方式和效果不同。在实际应用中，需要根据具体情况选择并发或并行的方式来处理任务。</p>
<h2 id="Websocket使用的是TCP还是UDP协议？为什么？"><a href="#Websocket使用的是TCP还是UDP协议？为什么？" class="headerlink" title="Websocket使用的是TCP还是UDP协议？为什么？"></a>Websocket使用的是TCP还是UDP协议？为什么？</h2><p>Websocket使用的是TCP协议，而不是UDP协议。</p>
<p>TCP协议是一种面向连接的、可靠的、有序的协议，它在数据传输过程中提供了数据完整性、可靠性和有序性的保证。Websocket需要<strong>保证数据的可靠性和有序性</strong>，因此选择了TCP协议作为底层传输协议。</p>
<p>相比之下，UDP协议是一种无连接的、不可靠的、无序的协议，它不提供数据的可靠性和有序性保证，适合于一些实时性要求高、数据量小、可丢失的应用，如在线游戏、音视频传输等。但是Websocket需要保证数据的可靠性和有序性，因此不适合使用UDP协议作为底层传输协议。</p>
<p>综上所述，Websocket使用TCP协议作为底层传输协议，可以保证数据的可靠性和有序性，适用于需要保证数据完整性和可靠性的应用。</p>
<h2 id="TCP在连接时会出现拥塞和粘包的问题，要怎么解决粘包的问题？"><a href="#TCP在连接时会出现拥塞和粘包的问题，要怎么解决粘包的问题？" class="headerlink" title="TCP在连接时会出现拥塞和粘包的问题，要怎么解决粘包的问题？"></a>TCP在连接时会出现拥塞和粘包的问题，要怎么解决粘包的问题？</h2><p>TCP协议在传输过程中会出现拥塞和粘包的问题，其中粘包问题是由于<strong>发送端发送的数据大小与接收端接收的数据大小不一致，导致多个数据包被粘在一起，从而造成接收端解析数据时出现错误</strong>。解决粘包问题的方法如下：</p>
<ol>
<li>使用消息定长：在发送端每次发送固定长度的数据，接收端每次接收相同长度的数据，这样就能避免粘包问题。</li>
<li>使用消息分隔符：在发送端每次发送数据时，在每个数据包的末尾添加一个特定的分隔符，接收端根据分隔符将数据包分开处理。</li>
<li>使用消息长度：在发送端每次发送数据时，在数据包的头部添加一个表示数据长度的字段，接收端根据字段的值来判断每个数据包的长度。</li>
<li>应用层协议处理：在应用层协议中定义数据格式和处理方式，例如HTTP协议中使用头部信息和分隔符来处理请求和响应数据。</li>
</ol>
<p>综上所述，通过使用消息定长、消息分隔符、消息长度和应用层协议处理等方法，可以有效解决TCP协议中的粘包问题。</p>
<h2 id="什么是全双工通信？"><a href="#什么是全双工通信？" class="headerlink" title="什么是全双工通信？"></a>什么是全双工通信？</h2><p>全双工通信是指在通信的两端，数据可以同时双向传输，即两端都可以同时发送和接收数据。全双工通信可以实现双向通信，通信效率高，通信质量稳定。与半双工通信和单工通信相比，全双工通信具有更高的带宽利用率和更快的数据传输速度。</p>
<p>在全双工通信中，通信双方可以同时发送和接收数据，而且在发送和接收数据时不需要等待对方的响应。这种通信方式可以在同一信道上实现双向通信，例如电话通信、视频会议、网络通信等都可以采用全双工通信方式。</p>
<p>在全双工通信中，通信双方需要使用专门的设备进行通信，例如全双工电缆、全双工网卡等。这些设备可以同时进行发送和接收数据，并且能够处理来自对方的数据，从而实现双向通信。</p>
<p>因此，全双工通信可以提高通信效率和通信质量，广泛应用于各种通信场景中。</p>
<h2 id="Http的报文格式？"><a href="#Http的报文格式？" class="headerlink" title="Http的报文格式？"></a>Http的报文格式？</h2><p>HTTP（超文本传输协议）的报文格式分为请求报文和响应报文两种类型。</p>
<p><strong>请求报文格式</strong></p>
<p>请求报文由三个部分组成：请求行、请求头和请求体。</p>
<p>请求行格式：METHOD URL HTTP&#x2F;版本号</p>
<p>例如：GET &#x2F;index.html HTTP&#x2F;1.1</p>
<p>请求头格式：键值对，每个键值对用冒号分隔，每个键值对占一行，最后一行用空行表示请求头结束。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Host</span>: www.<span class="hljs-property">example</span>.<span class="hljs-property">com</span> <span class="hljs-title class_">User</span>-<span class="hljs-title class_">Agent</span>: <span class="hljs-title class_">Mozilla</span>/<span class="hljs-number">5.0</span> (<span class="hljs-title class_">Windows</span> <span class="hljs-variable constant_">NT</span> <span class="hljs-number">10.0</span>; <span class="hljs-title class_">Win64</span>; x64) <span class="hljs-title class_">AppleWebKit</span>/<span class="hljs-number">537.36</span> (<span class="hljs-variable constant_">KHTML</span>, like <span class="hljs-title class_">Gecko</span>) <span class="hljs-title class_">Chrome</span>/<span class="hljs-number">58.0</span><span class="hljs-number">.3029</span><span class="hljs-number">.110</span> <span class="hljs-title class_">Safari</span>/<span class="hljs-number">537.36</span> <span class="hljs-title class_">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0.9</span>,image/webp,*<span class="hljs-comment">/*;q=0.8</span><br></code></pre></td></tr></table></figure>

<p>请求体格式：用于传输数据，可以为空。</p>
<p><strong>响应报文格式</strong></p>
<p>响应报文也由三个部分组成：状态行、响应头和响应体。</p>
<p>状态行格式：HTTP&#x2F;版本号 状态码 状态码的原因短语</p>
<p>例如：HTTP&#x2F;1.1 200 OK</p>
<p>响应头格式：键值对，每个键值对用冒号分隔，每个键值对占一行，最后一行用空行表示响应头结束。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Type</span>: text/html; charset=utf-<span class="hljs-number">8</span> <span class="hljs-title class_">Server</span>: <span class="hljs-title class_">Apache</span>/<span class="hljs-number">2.4</span><span class="hljs-number">.18</span> (<span class="hljs-title class_">Ubuntu</span>) <span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Length</span>: <span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure>

<p>响应体格式：用于传输数据，可以为空。</p>
<h2 id="Http状态码1-5代表什么含义"><a href="#Http状态码1-5代表什么含义" class="headerlink" title="Http状态码1-5代表什么含义?"></a>Http状态码1-5代表什么含义?</h2><p>HTTP状态码是服务器响应HTTP请求时返回的3位数字代码。这些代码分为5类，每类都代表了不同的含义。</p>
<p>1xx（信息性状态码）：表示请求已经被接收，继续处理。这个类别的状态码通常是在客户端发送请求时使用，用于提示客户端请求是否被服务器接收。</p>
<p>2xx（成功状态码）：表示请求已经被成功接收、理解、接受和处理。这个类别的状态码意味着服务器已经成功地处理了请求。</p>
<p>3xx（重定向状态码）：表示客户端需要进一步操作才能完成请求。这个类别的状态码通常用于重定向，即让客户端请求另一个URL。</p>
<p>4xx（客户端错误状态码）：表示客户端发送的请求有错误，服务器无法处理该请求。这个类别的状态码通常是由于客户端发送的请求有误、缺少参数或权限等原因引起的。</p>
<p>5xx（服务器错误状态码）：表示服务器在处理请求时发生了错误。这个类别的状态码通常是由于服务器无法处理请求、服务器内部错误或服务器过载等原因引起的。</p>
<p>以下是HTTP状态码的具体含义：</p>
<ul>
<li>1xx：信息性状态码<ul>
<li>100：Continue</li>
<li>101：Switching Protocols</li>
</ul>
</li>
<li>2xx：成功状态码<ul>
<li>200：OK</li>
<li>201：Created</li>
<li>202：Accepted</li>
<li>204：No Content</li>
</ul>
</li>
<li>3xx：重定向状态码<ul>
<li>301：Moved Permanently</li>
<li>302：Found</li>
<li>303：See Other</li>
<li>304：Not Modified</li>
<li>307：Temporary Redirect</li>
</ul>
</li>
<li>4xx：客户端错误状态码<ul>
<li>400：Bad Request</li>
<li>401：Unauthorized</li>
<li>403：Forbidden</li>
<li>404：Not Found</li>
<li>405：Method Not Allowed</li>
<li>408：Request Timeout</li>
<li>409：Conflict</li>
<li>410：Gone</li>
<li>413：Payload Too Large</li>
<li>414：URI Too Long</li>
<li>415：Unsupported Media Type</li>
<li>429：Too Many Requests</li>
</ul>
</li>
<li>5xx：服务器错误状态码<ul>
<li>500：Internal Server Error</li>
<li>501：Not Implemented</li>
<li>502：Bad Gateway</li>
<li>503：Service Unavailable</li>
<li>504：Gateway Timeout</li>
<li>505：HTTP Version Not Supported</li>
</ul>
</li>
</ul>
<h2 id="前端如何解决跨域？"><a href="#前端如何解决跨域？" class="headerlink" title="前端如何解决跨域？"></a>前端如何解决跨域？</h2><ol>
<li><p>JSONP</p>
<p>JSONP是一种跨域解决方案，它利用了script标签的跨域特性来实现。</p>
</li>
<li><p>CORS</p>
<p>CORS是一种新的跨域解决方案，它需要服务器端进行配置。通过在响应头中添加Access-Control-Allow-Origin字段，允许指定的域名跨域访问。</p>
</li>
<li><p>代理</p>
<p>通过在服务器端设置代理，将前端请求发送到后端服务器，然后由后端服务器发送请求到目标服务器，最后将结果返回给前端。</p>
</li>
</ol>
<h2 id="跨域相关的HTTP请求头有哪些？"><a href="#跨域相关的HTTP请求头有哪些？" class="headerlink" title="跨域相关的HTTP请求头有哪些？"></a>跨域相关的HTTP请求头有哪些？</h2><ol>
<li><p>Access-Control-Allow-Origin</p>
<p>该字段用于允许哪些域名可以跨域访问资源。可以设置为*，表示允许所有域名访问。</p>
</li>
<li><p>Access-Control-Allow-Methods</p>
<p>该字段用于允许哪些HTTP方法可以跨域访问资源。例如GET、POST、PUT、DELETE等。</p>
</li>
<li><p>Access-Control-Allow-Headers</p>
<p>该字段用于允许哪些HTTP头可以跨域访问资源。例如Content-Type、Authorization等。</p>
</li>
</ol>
<h2 id="Http缓存，由哪些header控制？"><a href="#Http缓存，由哪些header控制？" class="headerlink" title="Http缓存，由哪些header控制？"></a>Http缓存，由哪些header控制？</h2><p>强缓存：Cache-Control、Expires</p>
<p>协商缓存：Etag&#x2F;If-None-Match、Last-Mpdified&#x2F;If-Modified-Since</p>
<h2 id="Node中的事件循环机制？"><a href="#Node中的事件循环机制？" class="headerlink" title="Node中的事件循环机制？"></a>Node中的事件循环机制？</h2><p>Node.js的事件循环机制是其异步非阻塞I&#x2F;O的核心，它是基于事件驱动的非阻塞I&#x2F;O模型实现的。</p>
<p>在Node.js中，事件循环机制分为6个阶段，分别是：</p>
<ol>
<li>timers阶段：处理setTimeout和setInterval等定时器的回调函数。</li>
<li>I&#x2F;O callbacks阶段：处理一些系统I&#x2F;O操作的回调函数，如网络请求的回调函数。</li>
<li>idle, prepare阶段：只在内部使用，可以忽略。</li>
<li>poll阶段：等待I&#x2F;O事件完成，如网络请求的响应、文件读写完成等。</li>
<li>check阶段：处理setImmediate()的回调函数。</li>
<li>close callbacks阶段：处理一些关闭事件的回调函数，如socket连接关闭的回调函数。</li>
</ol>
<p>事件循环机制的流程如下：</p>
<ol>
<li>进入循环：Node.js会在事件循环开始时，进入timers阶段。</li>
<li>执行timers：Node.js会执行所有定时器的回调函数。</li>
<li>进入I&#x2F;O callbacks阶段：处理所有I&#x2F;O事件的回调函数。</li>
<li>进入poll阶段：等待I&#x2F;O事件完成。</li>
<li>执行check阶段：处理setImmediate()的回调函数。</li>
<li>执行close callbacks阶段：处理所有关闭事件的回调函数。</li>
<li>等待下一个循环：事件循环会等待新的事件被触发，然后再次进入循环。</li>
</ol>
<p>事件循环机制的核心是事件队列，所有的回调函数都会被加入到事件队列中，事件循环机制会不断地从事件队列中取出待执行的回调函数，按照一定的顺序执行。</p>
<p>总之，Node.js的事件循环机制是其异步非阻塞I&#x2F;O的核心，通过不断地循环执行事件队列中的回调函数，实现了高效的异步非阻塞I&#x2F;O模型。</p>
<h2 id="小根堆的概念？作用？"><a href="#小根堆的概念？作用？" class="headerlink" title="小根堆的概念？作用？"></a>小根堆的概念？作用？</h2><p>小根堆（Min Heap）是一种基于树形结构的数据结构，它满足以下两个条件：</p>
<ol>
<li>堆中每个节点的值都小于或等于其子节点的值。</li>
<li>堆是一棵完全二叉树。</li>
</ol>
<p>小根堆的作用：</p>
<ol>
<li>堆排序：小根堆可以用来进行堆排序，堆排序是一种高效的排序算法，时间复杂度为O(nlogn)。</li>
<li>优先队列：小根堆可以用来实现优先队列，优先队列是一种数据结构，它可以按照优先级来处理元素，小根堆可以实现按照元素值的大小来进行优先级排序。</li>
<li>最小值查询：小根堆可以用来查询最小值，由于小根堆的性质，堆顶元素始终是堆中的最小值。</li>
<li>贪心算法：小根堆可以用来实现贪心算法，贪心算法是一种基于贪心思想的算法，它每次选择当前最优的方案，小根堆可以用来找到当前最优的方案。</li>
</ol>
<p>总之，小根堆是一种非常实用的数据结构，它可以用来实现堆排序、优先队列、最小值查询和贪心算法等。</p>
<h2 id="TCP可靠的原因是什么？依靠了哪些机制？"><a href="#TCP可靠的原因是什么？依靠了哪些机制？" class="headerlink" title="TCP可靠的原因是什么？依靠了哪些机制？"></a>TCP可靠的原因是什么？依靠了哪些机制？</h2><ol>
<li>应答机制：TCP在发送数据之后，会等待接收方的应答，以确认数据是否已经到达。如果接收方未能及时应答，TCP会进行重传，直到接收到应答为止。</li>
<li>序列号和确认应答：TCP会为每个数据包分配一个序列号，用于标识数据包的顺序和完整性。接收方在收到数据包后，会发送一个确认应答，其中包含期望接收的下一个序列号，用于告诉发送方哪些数据已经接收到了。</li>
<li>数据包校验和：TCP会对每个数据包进行校验和计算，以检测数据在传输过程中是否发生了损坏或丢失。如果校验和不匹配，TCP会进行重传，以确保数据的完整性。</li>
<li>滑动窗口：TCP使用滑动窗口机制来控制数据流量，以避免网络拥塞。发送方和接收方都有一个窗口大小，用于控制发送和接收的数据量。发送方会根据接收方的窗口大小来控制发送的数据量，以避免数据包的丢失或拥塞。</li>
</ol>
<h2 id="网络层的协议有哪些？"><a href="#网络层的协议有哪些？" class="headerlink" title="网络层的协议有哪些？"></a>网络层的协议有哪些？</h2><ol>
<li>IP协议（Internet Protocol）：IP是互联网中最重要的协议之一，负责将数据包从源地址传输到目的地址，并通过路由选择算法选择最优路径。IPv4和IPv6是最常用的IP协议版本。</li>
<li>ICMP协议（Internet Control Message Protocol）：ICMP是IP协议的附属协议，用于传输网络控制信息和错误报文。常用的功能包括ping命令和traceroute命令。</li>
<li>ARP协议（Address Resolution Protocol）：ARP是用于将IP地址转换为MAC地址的协议，通过查询本地网络中的ARP缓存表或广播ARP请求来查找目标MAC地址。</li>
<li>RARP协议（Reverse Address Resolution Protocol）：RARP是ARP的反向协议，用于将MAC地址转换为IP地址。现在已经很少使用。</li>
<li>OSPF协议（Open Shortest Path First）：OSPF是一种开放的链路状态路由协议，用于在局域网和广域网中选择最短路径，实现路由的自适应和动态变化。</li>
<li>BGP协议（Border Gateway Protocol）：BGP是一种自治系统间的路由协议，用于在不同自治系统之间传输路由信息，实现互联网中的全球路由选择。</li>
<li>RIP协议（Routing Information Protocol）：RIP是一种基于距离向量的内部网关协议，用于在小型网络中选择最短路径，实现路由的自适应和动态变化。</li>
</ol>
<h2 id="如何获取URL中的参数？"><a href="#如何获取URL中的参数？" class="headerlink" title="如何获取URL中的参数？"></a>如何获取URL中的参数？</h2><p>获取URL中的参数可以使用JavaScript中的URLSearchParams对象。以下是一个简单的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取当前URL中的参数</span><br><span class="hljs-keyword">let</span> params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">search</span>);<br><br><span class="hljs-comment">// 获取特定参数的值</span><br><span class="hljs-keyword">let</span> id = params.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-keyword">let</span> name = params.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;name&quot;</span>);<br><br><span class="hljs-comment">// 打印参数值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id); <span class="hljs-comment">// 输出参数id的值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// 输出参数name的值</span><br></code></pre></td></tr></table></figure>

<p>上述代码中，首先使用<code>URLSearchParams</code>对象获取当前URL中的参数。然后使用<code>get</code>方法获取特定参数的值。最后使用<code>console.log</code>方法打印参数值。</p>
<p>字符串分割方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getAllParams</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 获取当前URL</span><br>  <span class="hljs-keyword">let</span> url = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>;<br><br>  <span class="hljs-comment">// 获取参数部分</span><br>  <span class="hljs-keyword">let</span> params = url.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;?&quot;</span>)[<span class="hljs-number">1</span>];<br><br>  <span class="hljs-comment">// 分割参数</span><br>  <span class="hljs-keyword">let</span> paramArr = params.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&amp;&quot;</span>);<br><br>  <span class="hljs-comment">// 创建一个空对象，用于存储参数</span><br>  <span class="hljs-keyword">let</span> paramObj = &#123;&#125;;<br><br>  <span class="hljs-comment">// 遍历参数数组，将参数存储到对象中</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; paramArr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> param = paramArr[i].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;=&quot;</span>);<br><br>    <span class="hljs-comment">// 将参数名和参数值存储到对象中</span><br>    paramObj[param[<span class="hljs-number">0</span>]] = param[<span class="hljs-number">1</span>];<br>  &#125;<br><br>  <span class="hljs-comment">// 返回参数对象</span><br>  <span class="hljs-keyword">return</span> paramObj;<br>&#125;<br><br><span class="hljs-comment">// 获取所有参数</span><br><span class="hljs-keyword">let</span> params = <span class="hljs-title function_">getAllParams</span>();<br><br><span class="hljs-comment">// 打印参数对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params);<br></code></pre></td></tr></table></figure>

<h2 id="手写JS计算m的n次方，要求时间复杂度O-logN-？"><a href="#手写JS计算m的n次方，要求时间复杂度O-logN-？" class="headerlink" title="手写JS计算m的n次方，要求时间复杂度O(logN)？"></a>手写JS计算m的n次方，要求时间复杂度O(logN)？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">power</span>(<span class="hljs-params">m, n</span>) &#123;<br>  <span class="hljs-comment">// 如果n等于0，返回1</span><br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果n是负数，将m变为倒数，n变为相反数</span><br>  <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br>    m = <span class="hljs-number">1</span> / m;<br>    n = -n;<br>  &#125;<br><br>  <span class="hljs-comment">// 用二分法计算m的n次方</span><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 如果n是奇数，将结果乘上m</span><br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) &#123;<br>      result *= m;<br>    &#125;<br>    <span class="hljs-comment">// 将m平方，将n除以2</span><br>    m *= m;<br>    n = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(n / <span class="hljs-number">2</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 返回结果</span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 计算2的10次方</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">power</span>(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>)); <span class="hljs-comment">// 输出1024</span><br></code></pre></td></tr></table></figure>

<h2 id="什么是bem？"><a href="#什么是bem？" class="headerlink" title="什么是bem？"></a>什么是bem？</h2><p>BEM是一种CSS命名规范，全称为Block-Element-Modifier，即块-元素-修饰符。它的核心思想是将页面中的组件或模块抽象成一个个块（Block），块内部可以包含多个元素（Element），而元素可以包含多个修饰符（Modifier），从而实现了对页面组件的精细化管理和命名。</p>
<p>具体来说，BEM的命名规则如下：</p>
<ul>
<li>Block（块）：代表一个独立的组件或模块，使用单个单词或短语命名，使用连字符(-)连接单词，例如：.navbar、.card、.header。</li>
<li>Element（元素）：代表块内部的一个组成部分，使用双下划线(__)连接块名和元素名，例如：.card__title、.navbar__menu。</li>
<li>Modifier（修饰符）：代表块或元素的状态或变体，使用单个单词或短语命名，使用单下划线(_)连接块名或元素名和修饰符名，例如：.card__title_highlighted、.navbar__menu_visible。</li>
</ul>
<p>BEM的优点是可以使CSS代码更加清晰、易于维护和扩展，同时可以避免CSS命名冲突和样式耦合的问题。</p>
<h2 id="什么是shadow-dom？"><a href="#什么是shadow-dom？" class="headerlink" title="什么是shadow dom？"></a>什么是shadow dom？</h2><p>Shadow DOM是一项Web标准技术，用于创建封装的组件和Web应用程序，使得组件的样式和行为不会受到外部CSS样式的干扰。Shadow DOM通过创建一个隔离的DOM树来实现这个目标，这个DOM树被称为“Shadow Tree”，它的内容和结构都不会影响到页面上的其他元素。</p>
<p>Shadow DOM可以被看作是一种Web组件技术，它可以将HTML、CSS和JavaScript封装在一个独立的组件内部，从而使得组件的样式和行为可以完全独立于页面的其他元素。Shadow DOM还提供了一些特殊的API，如：ShadowRoot、Element.attachShadow()和Element.shadowRoot，用于创建和管理Shadow Tree。</p>
<p>Shadow DOM的优点是可以实现组件的封装、复用和可维护性，同时也可以提高Web应用程序的性能和安全性。在Web开发中，Shadow DOM被广泛用于构建Web组件库、单页面应用程序和桌面应用程序等。</p>
<h2 id="TCP客户端和服务端同时发出断开请求后续会怎么样？"><a href="#TCP客户端和服务端同时发出断开请求后续会怎么样？" class="headerlink" title="TCP客户端和服务端同时发出断开请求后续会怎么样？"></a>TCP客户端和服务端同时发出断开请求后续会怎么样？</h2><p>在 TCP 连接中，当客户端和服务端都发出断开请求时，会发生以下情况：</p>
<ol>
<li>服务端先收到断开请求：服务端会发送一个 ACK 确认客户端的断开请求，并关闭连接。此时客户端还没有收到服务端的 ACK，仍然处于等待状态。</li>
<li>客户端先收到断开请求：客户端会发送一个 ACK 确认服务端的断开请求，并关闭连接。此时服务端还没有收到客户端的 ACK，仍然处于等待状态。</li>
<li>客户端和服务端同时收到断开请求：客户端和服务端都会发送一个 ACK 确认对方的断开请求，并关闭连接。此时连接会立即断开，双方都不会处于等待状态。</li>
</ol>
<p>总之，在 TCP 连接中，任何一方发送断开请求后，都需要等待对方的确认，才能真正关闭连接。如果双方同时发出断开请求，则连接会立即断开，否则需要等待对方的确认。</p>
<h2 id="Http1-0时候发起一个http请求会开启一个TCP连接吗？"><a href="#Http1-0时候发起一个http请求会开启一个TCP连接吗？" class="headerlink" title="Http1.0时候发起一个http请求会开启一个TCP连接吗？"></a>Http1.0时候发起一个http请求会开启一个TCP连接吗？</h2><p>在 HTTP&#x2F;1.0 中，每次发起 HTTP 请求都会建立一个新的 TCP 连接。这是因为 HTTP&#x2F;1.0 中每个请求和响应都是独立的，没有复用连接的机制。</p>
<p>在 HTTP&#x2F;1.0 中，每个 TCP 连接只能处理一个请求和响应，因此在处理多个请求和响应时，需要建立多个 TCP 连接。这样会导致建立和关闭连接的开销比较大，影响了 HTTP 请求的性能。</p>
<p>为了解决这个问题，HTTP&#x2F;1.1 引入了持久连接，允许在同一个 TCP 连接上发送多个请求和响应。这样可以减少建立和关闭连接的开销，提高 HTTP 请求的性能。</p>
<h2 id="一般的发Http请求的流程是什么样的？"><a href="#一般的发Http请求的流程是什么样的？" class="headerlink" title="一般的发Http请求的流程是什么样的？"></a>一般的发Http请求的流程是什么样的？</h2><p>一般的发 Http 请求的流程如下：</p>
<ol>
<li>构建请求：构建 HTTP 请求报文，包括请求方法、请求 URL、请求头以及请求体等信息。</li>
<li>建立连接：通过 TCP 协议与服务器建立连接，可以使用 HTTP&#x2F;1.0 中的短连接或者 HTTP&#x2F;1.1 中的长连接。</li>
<li>发送请求：将构建好的 HTTP 请求报文发送给服务器。</li>
<li>接收响应：等待服务器返回响应报文，接收响应数据。</li>
<li>处理响应：对服务器返回的响应数据进行处理，包括状态码、响应头以及响应体等信息。</li>
<li>断开连接：根据 HTTP&#x2F;1.0 或者 HTTP&#x2F;1.1 的规定，关闭 TCP 连接。</li>
</ol>
<p>其中，建立连接和断开连接的过程是比较耗时的，影响了 HTTP 请求的性能。因此，为了提高 HTTP 请求的性能，可以使用 HTTP&#x2F;1.1 中的持久连接或者 HTTP&#x2F;2 中的多路复用等技术。</p>
<h2 id="Http-keep-alive会引起其他的什么问题？"><a href="#Http-keep-alive会引起其他的什么问题？" class="headerlink" title="Http keep-alive会引起其他的什么问题？"></a>Http keep-alive会引起其他的什么问题？</h2><p>HTTP Keep-Alive 是一种 HTTP&#x2F;1.1 中的持久连接技术，可以使客户端和服务器在同一个 TCP 连接上发送多个 HTTP 请求和响应，从而减少连接建立和关闭的开销，提高性能。</p>
<p>然而，HTTP Keep-Alive 也可能引起以下问题：</p>
<ol>
<li>服务器资源占用：当客户端和服务器之间的连接不关闭时，服务器需要一直维护这个连接，占用一定的资源。如果同时有大量客户端连接服务器，会导致服务器资源占用过多，影响服务器的性能。</li>
<li>网络拥塞：当客户端和服务器之间的连接不关闭时，会占用网络带宽，可能导致网络拥塞，影响网络性能。</li>
<li>安全性问题：HTTP Keep-Alive 可能会导致安全性问题，例如，当客户端和服务器之间的连接不关闭时，可能会被黑客利用进行攻击，例如，利用长连接进行 DoS 攻击或者发送恶意请求等。</li>
</ol>
<p>因此，在使用 HTTP Keep-Alive 技术时，需要合理设置连接的超时时间，以及采取一定的安全措施，避免出现以上问题。</p>
<h2 id="层叠上下文是什么？会展现什么效果？它的原理是什么呢？"><a href="#层叠上下文是什么？会展现什么效果？它的原理是什么呢？" class="headerlink" title="层叠上下文是什么？会展现什么效果？它的原理是什么呢？"></a>层叠上下文是什么？会展现什么效果？它的原理是什么呢？</h2><p>层叠上下文（stacking context）是指在 HTML 中，每个元素在页面上都有一个层级，而层叠上下文就是在这个层级中，某些元素在层叠上下文中拥有更高的优先级，能够覆盖在其他元素之上。</p>
<p>层叠上下文的出现会影响元素的显示效果，例如：</p>
<ol>
<li>z-index 属性：如果两个元素重叠在一起，可以通过设置它们的 z-index 值来确定哪个元素在上面显示，z-index 值越高的元素会覆盖在 z-index 值较低的元素之上。</li>
<li>透明度：如果父元素设置了透明度，那么子元素也会继承父元素的透明度，这时就需要用到层叠上下文来控制子元素的透明度。</li>
<li>position 属性：某些情况下，通过设置元素的 position 属性可以创建一个新的层叠上下文，从而影响元素的显示效果。</li>
</ol>
<p>层叠上下文的原理是：在 HTML 中，每个元素都有一个 z-index 属性，它用于控制元素在层级中的位置。当两个元素重叠在一起时，会根据它们的 z-index 值来确定哪个元素在上面显示。但是，有些元素会创建新的层叠上下文，它们的 z-index 值不再是与父元素的 z-index 值相对应，而是相对于整个页面的 z-index 值。这样，就可以通过设置元素的层叠上下文来控制元素在页面上的显示效果。</p>
<h2 id="什么是GPU加速？"><a href="#什么是GPU加速？" class="headerlink" title="什么是GPU加速？"></a>什么是GPU加速？</h2><p>GPU加速是指利用计算机的图形处理器（GPU）来加速图形和多媒体应用程序的运行。GPU加速可以提高应用程序的性能，减少CPU的负载，从而提高整个系统的响应速度。</p>
<p>在GPU加速中，GPU负责处理图形和多媒体数据，而CPU则负责处理其他计算任务。这样可以使系统资源得到更好的利用，提高系统的整体性能。</p>
<p>GPU加速的实现方式有多种，其中最常见的是使用OpenGL或DirectX等图形库来与GPU进行交互。另外，一些Web浏览器也支持GPU加速，可以加速网页的渲染和动画效果。</p>
<p>GPU加速可以应用于许多领域，例如游戏开发、视频编辑、3D建模等。随着计算机硬件和软件的不断发展，GPU加速的应用范围也越来越广泛。</p>
<h2 id="假如有个小球-每一秒往右移动1px，一是直接改margin-left，二是position：absolute-一点点加left，三是transition-translate-横轴一点点加，这三种哪一种性能最好？"><a href="#假如有个小球-每一秒往右移动1px，一是直接改margin-left，二是position：absolute-一点点加left，三是transition-translate-横轴一点点加，这三种哪一种性能最好？" class="headerlink" title="假如有个小球 每一秒往右移动1px，一是直接改margin-left，二是position：absolute 一点点加left，三是transition translate 横轴一点点加，这三种哪一种性能最好？"></a>假如有个小球 每一秒往右移动1px，一是直接改margin-left，二是position：absolute 一点点加left，三是transition translate 横轴一点点加，这三种哪一种性能最好？</h2><p>在这种情况下，使用 <code>transform</code> 和 <code>transition</code> 来移动小球的性能最好。因为这种方式利用了GPU加速，可以避免重排和重绘，从而提高了性能。相比之下，改变 <code>margin-left</code> 和使用 <code>position: absolute</code> 来移动小球，需要进行重排和重绘，性能较差。</p>
<h2 id="什么是变量提升？原理是什么？"><a href="#什么是变量提升？原理是什么？" class="headerlink" title="什么是变量提升？原理是什么？"></a>什么是变量提升？原理是什么？</h2><p>在JavaScript中，变量提升是指变量和函数的声明会被提升到作用域的顶部，无论实际声明的位置在哪里，这也被称为“提升到顶部”。也就是说，在执行代码之前，JavaScript引擎会扫描整个作用域，找出所有的变量和函数声明，并将它们提升到作用域的顶部，这样在代码执行时就可以访问它们了。</p>
<p>变量提升的原理是JavaScript引擎在解析代码时，会先处理变量和函数的声明，将它们存储在内存中，然后再执行代码。这样就可以让变量和函数在声明之前就可以被使用了。但是需要注意的是，只有声明会被提升，而不是赋值。因此，如果一个变量在声明之前被使用，它的值将为undefined。</p>
<h2 id="产生变量提升的原因？"><a href="#产生变量提升的原因？" class="headerlink" title="产生变量提升的原因？"></a>产生变量提升的原因？</h2><p>产生变量提升的原因是JavaScript引擎在解析代码时，会先处理变量和函数的声明，将它们存储在内存中，然后再执行代码。这是由于JavaScript的执行顺序是自上而下的，而变量和函数的声明在代码中可能出现在后面的位置。如果不进行变量提升，那么在使用变量或函数之前必须要先声明，否则会报错。通过变量提升，JavaScript引擎可以在代码执行之前就将变量和函数的声明提前到作用域的顶部，从而让变量和函数在声明之前就可以被使用了。</p>
<h2 id="什么是执行上下文？"><a href="#什么是执行上下文？" class="headerlink" title="什么是执行上下文？"></a>什么是执行上下文？</h2><p>JavaScript执行上下文是指JavaScript代码在执行时所处的环境，包括变量、函数声明、作用域链、this指向等。每当JavaScript代码开始执行时，都会创建一个新的执行上下文，并将其压入执行上下文栈（Execution Context Stack）中。当代码执行完成后，该执行上下文会被弹出栈并销毁。</p>
<p>执行上下文包括三种类型：</p>
<ol>
<li>全局执行上下文：在代码执行之前就会被创建，它是默认的最外层的执行上下文。</li>
<li>函数执行上下文：每当一个函数被调用时，都会创建一个新的函数执行上下文。</li>
<li>Eval执行上下文：eval()函数会在当前作用域中创建一个新的执行上下文。</li>
</ol>
<p>执行上下文中包含了当前代码所处的作用域链、变量对象、this指向等信息，这些信息会在代码执行时被用到，从而影响到代码的执行结果。</p>
<h2 id="词法作用域是什么？"><a href="#词法作用域是什么？" class="headerlink" title="词法作用域是什么？"></a>词法作用域是什么？</h2><p>词法作用域（Lexical Scope），也叫静态作用域，是指<strong>变量的作用域是在代码书写的时候就确定好的，而不是在运行时确定的</strong>。JavaScript就是一种基于词法作用域的语言。</p>
<p>在词法作用域中，变量的作用域是由函数嵌套关系来决定的。当函数被创建时，它的作用域链就被创建了，作用域链中包含了当前函数和所有嵌套的父级函数的变量对象。当函数执行时，它会先在自己的变量对象中查找变量，如果找不到，就会沿着作用域链一级一级地向上查找，直到找到为止，如果一直到全局作用域都没有找到，就会报错。</p>
<p>词法作用域的好处是可以避免变量名冲突，因为变量的作用域是在代码书写的时候就确定好的，不会受到运行时的影响。同时，也使得代码的可读性更高，因为变量的作用域是在代码书写的时候就可以看到的，不需要等到运行时才知道。</p>
<h2 id="环境变量和变量对象是什么？"><a href="#环境变量和变量对象是什么？" class="headerlink" title="环境变量和变量对象是什么？"></a>环境变量和变量对象是什么？</h2><p>环境变量和变量对象都是 JavaScript 中与作用域相关的概念。</p>
<p>环境变量（Environment Record）是指当前执行上下文中所有变量和函数的声明，以及外部环境的引用。每个执行上下文都有自己的环境变量，它们按照作用域链的顺序组成了一个链式结构，可以通过这个结构访问到所有的变量和函数。</p>
<p>变量对象（Variable Object）是指当前执行上下文中所有变量和函数的实际存储位置。在全局执行上下文中，变量对象就是全局对象；在函数执行上下文中，变量对象包含了函数的参数、函数声明、变量声明等。变量对象也是按照作用域链的顺序组成了一个链式结构，可以通过这个结构访问到所有的变量和函数。</p>
<p>在 JavaScript 中，环境变量和变量对象是密切相关的。当一个函数被调用时，会创建一个新的执行上下文，其中包含了一个新的环境变量和变量对象。在函数执行时，会使用环境变量来查找变量和函数的实际存储位置，也就是变量对象。当函数执行完毕后，执行上下文被销毁，其中的环境变量和变量对象也随之被销毁。</p>
<h2 id="TCP的发送速度是如何得到控制的？"><a href="#TCP的发送速度是如何得到控制的？" class="headerlink" title="TCP的发送速度是如何得到控制的？"></a>TCP的发送速度是如何得到控制的？</h2><ol>
<li>慢启动算法（Slow Start）：发送方刚开始发送数据时，先发送一小部分数据，然后根据收到的确认消息逐渐增加发送的数据量，以逐渐探测网络的拥塞情况。</li>
<li>拥塞避免算法（Congestion Avoidance）：当发现网络拥塞时，发送方就会进入拥塞避免阶段，此时发送方会将发送窗口的大小限制在一个较小的值范围内，以避免网络拥塞。</li>
<li>快重传算法（Fast Retransmit）：当发送方连续发送多个数据包时，如果接收方收到其中一个数据包有丢失或损坏，就会立即发送一个重复确认消息，告诉发送方需要重传该数据包。发送方收到这个重复确认消息后，就会立即重传该数据包，而不是等到超时后再重传，从而加快数据传输速度。</li>
<li>快恢复算法（Fast Recovery）：当发送方收到重复确认消息时，就会进入快恢复阶段，此时发送方会将发送窗口的大小减半，并重传丢失的数据包，以避免网络拥塞。</li>
<li>拥塞控制算法（Congestion Control）：TCP中还有一种全局的拥塞控制算法，它通过计算网络的拥塞程度来动态调整发送方的发送速度，以避免网络拥塞。常用的拥塞控制算法有TCP Reno、TCP Vegas、TCP New Reno等。</li>
</ol>
<h2 id="什么是CSS样式穿透？有哪些语法？"><a href="#什么是CSS样式穿透？有哪些语法？" class="headerlink" title="什么是CSS样式穿透？有哪些语法？"></a>什么是CSS样式穿透？有哪些语法？</h2><p>CSS样式穿透是指在CSS中，一个选择器可以影响到其他选择器的样式。它允许我们通过一个选择器来改变另一个选择器的样式，从而避免了在HTML中添加额外的类和ID。</p>
<p><code>&amp;</code>符号：在Less和Sass中，<code>&amp;</code>符号表示当前选择器的父级，可以将当前选择器和父级选择器合并在一起，这样可以影响到父级选择器的样式。例如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>  <span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">color</span>: white;<br>    <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>      <span class="hljs-attribute">background-color</span>: red;<br>      <span class="hljs-selector-class">.sibling</span> <span class="hljs-selector-tag">&amp;</span> &#123;<br>        <span class="hljs-attribute">color</span>: yellow;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="在TCP中有keep-alive，Vue也有keep-alive，Http也有keep-alive，它们都是指什么？"><a href="#在TCP中有keep-alive，Vue也有keep-alive，Http也有keep-alive，它们都是指什么？" class="headerlink" title="在TCP中有keep-alive，Vue也有keep-alive，Http也有keep-alive，它们都是指什么？"></a>在TCP中有keep-alive，Vue也有keep-alive，Http也有keep-alive，它们都是指什么？</h2><ol>
<li>在TCP协议中，keep-alive是一种保持连接的机制，可以在客户端和服务器之间保持长时间的空闲连接。当客户端和服务器之间没有数据传输时，keep-alive机制会发送一些探测包来检测对方是否还活着，从而确保连接的有效性。这个机制在一些长连接场景下比较常见，例如HTTP长连接、FTP数据传输等。</li>
<li>在Vue中，keep-alive是一个组件，可以将动态组件进行缓存，以便在切换时可以保留它们的状态或避免重新渲染。这个组件在一些需要频繁切换的场景下比较常见，例如Tab切换、路由切换等。</li>
<li>在HTTP协议中，keep-alive是一种持久连接机制，可以在客户端和服务器之间保持一个TCP连接，从而避免在每个HTTP请求之间重新建立TCP连接。这个机制可以减少连接建立和关闭的开销，提高HTTP请求的效率，尤其是在一些高并发的Web应用中。</li>
</ol>
<h2 id="不同域名指向同一个ip是否是同源的？"><a href="#不同域名指向同一个ip是否是同源的？" class="headerlink" title="不同域名指向同一个ip是否是同源的？"></a>不同域名指向同一个ip是否是同源的？</h2><p>不同域名指向同一个IP地址并不一定是同源的。同源策略是浏览器的一种安全策略，它是指只有当两个页面具有相同的协议、域名和端口号时，才允许这两个页面之间进行交互（例如访问彼此的DOM、Cookie等）。因此，如果两个页面的域名不同，即使它们指向同一个IP地址，也不会被认为是同源的。</p>
<p>但是，如果在同一个域名下使用不同的子域名（例如a.example.com和b.example.com）指向同一个IP地址，这种情况下它们被认为是同源的，因为它们具有相同的主域名。</p>
<p>总之，同源策略是根据协议、域名和端口号来判断是否允许跨域访问，而IP地址并不是同源策略的判断依据。</p>
<h2 id="DFS和BFS的使用场景？"><a href="#DFS和BFS的使用场景？" class="headerlink" title="DFS和BFS的使用场景？"></a>DFS和BFS的使用场景？</h2><p>DFS（深度优先搜索）和BFS（广度优先搜索）都是图遍历算法，它们的使用场景如下：</p>
<p>DFS使用场景：</p>
<ul>
<li>求解连通块问题</li>
<li>求解迷宫问题</li>
<li>求解拓扑排序问题</li>
<li>求解生成树问题</li>
<li>求解二叉树的遍历问题</li>
</ul>
<p>BFS使用场景：</p>
<ul>
<li>求解最短路径问题</li>
<li>求解连通块问题</li>
<li>求解迷宫问题</li>
<li>求解拓扑排序问题</li>
<li>求解生成树问题</li>
</ul>
<p>总的来说，DFS更适合解决深度优先的问题，BFS更适合解决广度优先的问题。在实际应用中，需要根据具体问题的特点选择合适的算法。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/">#前端学习</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>知识点整理(7)</div>
      <div>https://ustinians.github.io/2023/04/13/知识点整理-7/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>想躺在云上</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年4月13日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/04/13/%E7%BE%8E%E5%9B%A2%E4%B8%80%E9%9D%A2/" title="美团一面">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">美团一面</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/04/12/%E7%99%BE%E5%BA%A6%E4%B8%80%E9%9D%A2/" title="百度一面">
                        <span class="hidden-mobile">百度一面</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
