

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="想躺在云上">
  <meta name="keywords" content="">
  
    <meta name="description" content="浏览器、进程和线程、计算机网络、数据库相关进程和线程的概念及区别？进程是对正在运行中的程序的一个抽象，是系统进行资源分配和调度的基本单位。 线程是CPU任务调度和执行的基本单位。 区别：  进程可以看作是一个独立应用，而线程不能。 进行是CPU进行资源分配的最小单位，而线程是CPU调度的最小单位。 线程间可以直接共享同一进程中的资源，而进程通信需要借助进程间通信。 进行切换的开销比线程切换的开销要">
<meta property="og:type" content="article">
<meta property="og:title" content="浏览器、进程和线程、计算机网络、数据库相关">
<meta property="og:url" content="https://ustinians.github.io/2023/04/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/index.html">
<meta property="og:site_name" content="想躺在云上 - In doing we learn.">
<meta property="og:description" content="浏览器、进程和线程、计算机网络、数据库相关进程和线程的概念及区别？进程是对正在运行中的程序的一个抽象，是系统进行资源分配和调度的基本单位。 线程是CPU任务调度和执行的基本单位。 区别：  进程可以看作是一个独立应用，而线程不能。 进行是CPU进行资源分配的最小单位，而线程是CPU调度的最小单位。 线程间可以直接共享同一进程中的资源，而进程通信需要借助进程间通信。 进行切换的开销比线程切换的开销要">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/9/d8bf92c7906718271fdb8b0d2d5fe5b4~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/9/8c7874fafe233c9278509e40e906055c~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image">
<meta property="article:published_time" content="2023-04-26T03:55:49.000Z">
<meta property="article:modified_time" content="2023-04-26T03:56:43.431Z">
<meta property="article:author" content="想躺在云上">
<meta property="article:tag" content="Spring Recruitment">
<meta property="article:tag" content="进程与线程">
<meta property="article:tag" content="HTTP">
<meta property="article:tag" content="浏览器">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/9/d8bf92c7906718271fdb8b0d2d5fe5b4~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image">
  
  
  
  <title>浏览器、进程和线程、计算机网络、数据库相关 - 想躺在云上 - In doing we learn.</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"ustinians.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>想躺在云上</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="浏览器、进程和线程、计算机网络、数据库相关"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-04-26 11:55" pubdate>
          2023年4月26日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          28k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          231 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">浏览器、进程和线程、计算机网络、数据库相关</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="浏览器、进程和线程、计算机网络、数据库相关"><a href="#浏览器、进程和线程、计算机网络、数据库相关" class="headerlink" title="浏览器、进程和线程、计算机网络、数据库相关"></a>浏览器、进程和线程、计算机网络、数据库相关</h1><h2 id="进程和线程的概念及区别？"><a href="#进程和线程的概念及区别？" class="headerlink" title="进程和线程的概念及区别？"></a>进程和线程的概念及区别？</h2><p>进程是对正在运行中的程序的一个抽象，是系统进行资源分配和调度的基本单位。</p>
<p>线程是CPU任务调度和执行的基本单位。</p>
<p>区别：</p>
<ul>
<li>进程可以看作是一个独立应用，而线程不能。</li>
<li>进行是CPU进行资源分配的最小单位，而线程是CPU调度的最小单位。</li>
<li>线程间可以直接共享同一进程中的资源，而进程通信需要借助<strong>进程间通信</strong>。</li>
<li>进行切换的开销比线程切换的开销要大。线程的切换不会引起进程的切换，但某个进程中的线程切换到另一个进程中的线程会引起进程的切换。</li>
<li>撤销或创建进程的时候，系统要为之分配或回收资源，开销远大于创建或撤销线程时的开销。同样，进程切换的时候涉及到<strong>当前进程的CPU环境还有各种各样状态的保存及新调度进程状态的设置</strong>，而线程切换只需要保存和设置少量的寄存器内容，开销较小。</li>
</ul>
<h2 id="为什么有了进程还要有线程"><a href="#为什么有了进程还要有线程" class="headerlink" title="为什么有了进程还要有线程?"></a>为什么有了进程还要有线程?</h2><p>在计算机操作系统中，进程是程序的基本执行单元，而线程是进程内的一个单独执行流，共享进程的资源和空间。虽然进程可以通过多个线程实现并发，但也有很多情况下需要使用线程，具体原因有以下几点：</p>
<ol>
<li>资源共享：进程间的资源必须通过进程间通信（IPC）进行传递，而线程可以直接共享进程的资源，包括内存空间、打开的文件、信号处理器等，因此线程的通信代价低于进程的通信。</li>
<li>轻量级：线程比进程更轻量级，创建和销毁线程的代价远远小于创建和销毁进程的代价。多个线程可以在同一个进程内并发执行，从而提高整个系统的执行效率。</li>
<li>可以利用多核心：一个进程在单个CPU上只能并发执行一个线程，而一个多线程的进程可以同时在多个CPU内进行并发执行，提高执行效率。</li>
<li>更灵活：线程之间的切换代价要比进程之间的切换少，因此可以更灵活地控制代码的执行流程。线程还可以对代码的并发性进行更精细的控制，比如通过锁、信号量等机制控制对共享资源的访问。</li>
</ol>
<p>综上所述，线程虽然比进程更轻量级，但在实际应用中具有不可替代的优势，可以更高效地实现并发，提高系统的执行效率和灵活性。</p>
<h2 id="进程间通信的方式有哪些？"><a href="#进程间通信的方式有哪些？" class="headerlink" title="进程间通信的方式有哪些？"></a>进程间通信的方式有哪些？</h2><ul>
<li><p>管道通信</p>
<p>操作系统在内核中开辟一段缓冲区，进程A可以将需要交互的数据拷贝到这段缓冲区中，进程B就可以读取了。(只能单向通信，并只能在有血缘关系的进程间通信)</p>
</li>
<li><p>消息队列队列通信</p>
<p>消息队列就是一个消息的列表，用户可以在消息队列中添加消息、读取消息等。它提供了一种从一个进程向另一个进程发送数据块的方法。每个数据块都被认为含有一个类型，接收进程可以独立的接受含有不同类型的数据结构。但消息队列与命名管道一样，每个数据块都有一个<strong>最大长度的限制</strong>。</p>
</li>
<li><p>共享内存通信</p>
<p>共享内存就是映射了一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问(使多个进程可以访问同一块内存空间)。</p>
</li>
<li><p>信号量通信</p>
<p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。</p>
</li>
<li><p>信号通信</p>
<p>Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件(一组事件中的一个)，它也是用户进程间通信和同步的一种原始机制。</p>
</li>
<li><p>套接字通信</p>
<p>是计算机之间进行通信的一种约定或一种方式。</p>
</li>
</ul>
<h2 id="进程共享内存通信具体是怎样实现的？"><a href="#进程共享内存通信具体是怎样实现的？" class="headerlink" title="进程共享内存通信具体是怎样实现的？"></a>进程共享内存通信具体是怎样实现的？</h2><ol>
<li>创建共享内存：需要调用操作系统提供的函数，例如shmget()，创建一个共享内存区域并返回一个共享内存标识符。</li>
<li>将共享内存附加到进程地址空间：使用shmat()函数将共享内存附加到进程的地址空间。该函数会返回一个指向共享内存区域的指针。这一步相当于将共享内存映射到进程的地址空间中。</li>
<li>进程间读写共享内存：多个进程可以直接通过指针操作共享内存区域进行数据的读写。需要注意的是，在读写数据时，需要通过信号量等机制进行进程同步，避免多个进程同时修改同一段内存区域，导致数据冲突。</li>
<li>分离共享内存：当进程不再需要使用共享内存时，需要调用shmdt()函数将它从进程地址空间中分离，这一步相当于解除共享内存和进程地址空间的映射关系。</li>
<li>删除共享内存：当所有使用该共享内存的进程都调用了shmdt()进行分离后，需要调用shmctl()函数删除共享内存。</li>
</ol>
<p>需要注意的是，在使用共享内存进行进程间通信时，需要保证多个进程对数据的读写操作是原子性的，避免出现数据冲突等问题。因此，通常使用信号量等同步机制进行进程间同步。</p>
<h2 id="共享内存通信的好处是什么？"><a href="#共享内存通信的好处是什么？" class="headerlink" title="共享内存通信的好处是什么？"></a>共享内存通信的好处是什么？</h2><ol>
<li>高效性：共享内存通信是一种高效的进程间通信机制。由于多个进程可以直接访问同一块物理内存，因此数据的传递速度很快，可以实现高速的数据交换。</li>
<li>灵活性：共享内存通信可以传递任意类型的数据，包括结构体、数组、指针等多种数据类型。而其他进程间通信机制（如管道、消息队列等）则往往需要数据进行序列化和反序列化，传递数据时需要额外的处理，增加了通信的复杂度。</li>
<li>容量大：共享内存通信可以很容易地传输大量的数据，因为共享内存区域的容量可以在创建时进行指定，从而满足不同应用的实际需求。</li>
<li>维护方便：共享内存通信的使用和管理比较简单，只需创建、附加、使用、分离和删除几个步骤，对于多进程间共享数据的应用场景，可以提供简单有效的通信方案。</li>
</ol>
<h2 id="为什么管道通信和消息队列通信会存在资源大小的限制？"><a href="#为什么管道通信和消息队列通信会存在资源大小的限制？" class="headerlink" title="为什么管道通信和消息队列通信会存在资源大小的限制？"></a>为什么管道通信和消息队列通信会存在资源大小的限制？</h2><p>管道通信和消息队列通信会存在资源大小的限制，主要是由于它们使用的内核缓冲区大小有限，而且这些内核缓冲区是由操作系统分配的。</p>
<p>具体来说，管道通信和消息队列通信使用的内核缓冲区大小是固定的，而且通常比较小（例如Linux中管道的缓冲区大小为4KB，消息队列缓冲区默认大小为16KB）。因此，当需要传输的数据量超过内核缓冲区大小时，就会出现资源大小的限制。这时，要么数据无法传输，要么就需要分多次传输或者使用其他进程间通信方式。</p>
<p>此外，由于管道和消息队列都是一种面向字节流的通信方式，因此在传输结构体、对象、数组等复杂的数据类型时，需要进行序列化和反序列化处理。这种处理会带来额外的开销和复杂性，进一步限制了通信的资源和效率。</p>
<p>综上所述，管道通信和消息队列通信存在资源大小的限制，这是因为它们使用的内核缓冲区大小有限，并且数据类型限制较多，不能很好地支持大数据量和复杂数据类型的通信。</p>
<h2 id="如果没有共享内存通信会导致什么问题？"><a href="#如果没有共享内存通信会导致什么问题？" class="headerlink" title="如果没有共享内存通信会导致什么问题？"></a>如果没有共享内存通信会导致什么问题？</h2><ol>
<li>低效率：使用进程间通信(IPC)方式进行数据交换消耗的时间和资源比较大。常用的IPC方式包括管道、消息队列、信号量等，这些方式都需要用到中间缓冲区、系统调用等，这些操作耗费了很多时间和系统资源。</li>
<li>程序设计复杂：采用IPC方式进行通信，需要对通信方式的技术细节进行了解和掌握，需要考虑数据格式、传输方式、同步方式、异常处理等问题，程序设计复杂度相对高。</li>
<li>难以建立复杂数据结构：使用IPC方式进行通信，不同进程需要采用不同的数据结构进行数据交换，相互之间不太容易建立复杂的数据结构，例如链表或树。</li>
<li>容易出错：使用IPC方式进行通信，需要进行同步操作，否则可能会发生死锁或者忙等等问题，这些问题难以排除。</li>
</ol>
<p>如果进程没有共享内存通信，则会导致进程间通信的效率变得低下，设计难度加大，难以建立复杂的数据结构，而且容易出现错误，降低了程序可维护性和可靠性，也使得应用程序性能不尽如人意。</p>
<h2 id="进程的状态有哪些？"><a href="#进程的状态有哪些？" class="headerlink" title="进程的状态有哪些？"></a>进程的状态有哪些？</h2><p>进程的状态通常分为五种基本状态：创建态、就绪态、运行态、阻塞态和终止态。</p>
<ul>
<li>创建态：进程刚被创建，但是还没有被操作系统调度执行。</li>
<li>就绪态：进程已经准备好运行，但是还没有被操作系统调度执行。</li>
<li>运行态：进程正在被操作系统调度执行。</li>
<li>阻塞态：进程因为某些原因而暂停执行，等待外部事件的发生。</li>
<li>终止态：进程已经完成了它的任务，或者因为某些原因被操作系统强制终止。</li>
</ul>
<h2 id="线程有哪几种状态？"><a href="#线程有哪几种状态？" class="headerlink" title="线程有哪几种状态？"></a>线程有哪几种状态？</h2><ol>
<li>新建状态（New）：当线程对象被创建时，它就处于新建状态，此时它还没有被启动。</li>
<li>就绪状态（Runnable）：当线程被调用start()方法后，它进入就绪状态，表示它已经准备好运行，等待系统分配资源。</li>
<li>运行状态（Running）：当系统分配到资源后，线程就进入运行状态，开始执行run()方法中的代码。</li>
<li>阻塞状态（Blocked）：当线程等待某个操作完成或等待某个资源时，它进入阻塞状态，暂时停止执行。</li>
<li>等待状态（Waiting）：当线程执行某个操作后，需要等待另一个线程或操作完成时，它进入等待状态，调用wait()或join()方法时，线程就会进入等待状态。</li>
<li>超时等待状态（Timed Waiting）：当线程执行某个操作后，需要等待一段时间后再继续执行时，它进入超时等待状态，调用sleep()、wait(long)或join(long)等方法时，线程就会进入超时等待状态。</li>
<li>终止状态（Terminated）：当线程执行完run()方法后，它就进入终止状态，线程执行结束，不再继续执行。</li>
</ol>
<h2 id="匿名通信与命名通信的区别？"><a href="#匿名通信与命名通信的区别？" class="headerlink" title="匿名通信与命名通信的区别？"></a>匿名通信与命名通信的区别？</h2><p>匿名通信和命名通信是通信方式的不同方式。匿名通信是发送者和接收者都是匿名的方式，不会透露身份信息，保护隐私和安全。而命名通信是使用实名或者昵称方式进行通信，对身份信息没有保护作用。</p>
<p>具体区别如下：</p>
<ol>
<li><p>匿名通信只能是据有血缘关系的进程之间进行通信，只能半双工通信；命名通信可以在任意两个进程之间进行通讯，可以全双工通信，命名管道提供了一个路径名与之关联，以FIFO文件的形式存储于文件系统中，能够实现任意两个进程之间通信。</p>
</li>
<li><p>匿名通信只需要发送者和接收者拥有匿名身份，通信过程中不需要透露身份信息，保护隐私和安全。而命名通信需要使用实名或昵称等方式进行通信，会透露身份信息。</p>
</li>
<li><p>匿名通信可以避免被窃听、篡改、攻击等威胁，因为使用匿名身份进行通信。命名通信可能容易被攻击者获取身份信息进行攻击。</p>
</li>
<li><p>匿名通信的验证和监管比较困难，因为发送者和接收者都是匿名的。命名通信可以更容易地监管和验证通信过程。</p>
</li>
<li><p>匿名通信常常被用在各种机密通信、点对点通信和加密通信中。命名通信通常是为了建立信任关系和社交沟通而使用的。</p>
</li>
</ol>
<h2 id="操作系统的进程调度算法有哪几种？"><a href="#操作系统的进程调度算法有哪几种？" class="headerlink" title="操作系统的进程调度算法有哪几种？"></a>操作系统的进程调度算法有哪几种？</h2><p>操作系统的进程调度的常见策略：</p>
<ul>
<li>先来先服务调度算法(FCFS)：按照进程到达的先后顺序进行调度，先到达的进程限制性，后到达的进程后执行。</li>
<li>短作业优先调度算法(SJF)：按照进程需要的CPU时间长短进行调度，即需要CPU时间最短的进程先执行。</li>
<li>优先级调度算法：按照进程的优先级进行调度，即优先级高的进程先执行。</li>
<li>时间片轮转调度算法：按照时间片轮流分配CPU时间进行调度，即每个进程分配一个时间片，当时间片用完后，该进程被挂起，等到下一次轮到它的时候再继续执行。</li>
<li>多级反馈队列算法：将就绪队列分成多个队列，每个队列有不同的优先级，每个队列采用不同的调度算法。新到达的进程首先放在第一级队列，如果该队列中没有可执行的进程，则将该队列放入第二级队列中等待执行。如果第一级队列中有可执行的进程，则按照时间片轮转调度算法去进行调度。如果一个进程再第一级队列中运行了一段时间仍然没有完成，则将其移动到第二级队列中等待执行，以此类推，直到该进程完成或被强制终止。</li>
</ul>
<h2 id="多进程编程的难点和解决方案？"><a href="#多进程编程的难点和解决方案？" class="headerlink" title="多进程编程的难点和解决方案？"></a>多进程编程的难点和解决方案？</h2><p>多线程编程的难点主要有以下几个方面：线程安全、死锁、资源竞争、线程间通信等。</p>
<p>其中，线程安全是多线程编程中最重要的问题之一，它涉及到<strong>多个线程同时访问同一个共享资源时的数据一致性问题</strong>。</p>
<p>死锁是指两个或多个进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法继续执行下去。</p>
<p>资源竞争是指多个线程同时访问同一个共享资源时，由于访<strong>问顺序不当而导致程序出现错误</strong>。</p>
<p>线程间通信是指多个线程之间相互协作完成任务的过程，包括等待通知机制、管道机制、信号量机制等。</p>
<h2 id="在多线程的情况下如何保证线程安全？"><a href="#在多线程的情况下如何保证线程安全？" class="headerlink" title="在多线程的情况下如何保证线程安全？"></a>在多线程的情况下如何保证线程安全？</h2><ol>
<li>加锁：使用锁机制来保护共享资源，确保同一时间只有一个线程可以访问共享资源，其他线程需要等待锁释放后才能访问。</li>
<li>使用原子操作：原子操作是不可被中断的操作，可以保证多线程访问共享资源时的原子性，避免数据不一致的问题。</li>
<li>使用线程安全的数据结构：如ConcurrentHashMap、CopyOnWriteArrayList等，这些数据结构是线程安全的，多个线程可以同时访问并修改其中的元素，不需要加锁。</li>
<li>使用volatile关键字：volatile关键字可以保证变量在多线程中的可见性，即一个线程修改了变量的值，其他线程可以立即看到修改后的值。</li>
<li>避免共享资源：尽量避免多个线程访问共享资源，可以采用线程本地存储（ThreadLocal）等方式来避免共享资源的访问冲突。</li>
</ol>
<h2 id="并发和并行的区别？"><a href="#并发和并行的区别？" class="headerlink" title="并发和并行的区别？"></a>并发和并行的区别？</h2><p>并发和并行都是多任务处理的概念，但是它们的含义不同。</p>
<p>并发是指在同一时间段内，有多个任务在交替执行，这些任务可能在同一个处理器上交替执行，也可能在多个处理器上并行执行。在并发执行中，每个任务都会分配一定的时间片，轮流执行，但是在任意时刻只有一个任务在执行。</p>
<p>并行是指在同一时刻，有多个任务在同时执行，这些任务可以在多个处理器上并行执行，也可以在同一处理器上通过多核心并行执行。在并行执行中，多个任务同时执行，每个任务都能够分配到独立的处理器或处理器核心。</p>
<p>简单来说，如果是在同一个处理器上，任务是交替执行的，就是并发；如果是在多个处理器上或者是多核心并行执行，就是并行。</p>
<p>总之，并发和并行都是提高计算机系统效率的重要手段，但是它们的实现方式和效果不同。在实际应用中，需要根据具体情况选择并发或并行的方式来处理任务。</p>
<h2 id="什么是全双工通信？"><a href="#什么是全双工通信？" class="headerlink" title="什么是全双工通信？"></a>什么是全双工通信？</h2><p>全双工通信是指在通信的两端，数据可以同时双向传输，即两端都可以同时发送和接收数据。全双工通信可以实现双向通信，通信效率高，通信质量稳定。与半双工通信和单工通信相比，全双工通信具有更高的带宽利用率和更快的数据传输速度。</p>
<p>在全双工通信中，通信双方可以同时发送和接收数据，而且在发送和接收数据时不需要等待对方的响应。这种通信方式可以在同一信道上实现双向通信，例如电话通信、视频会议、网络通信等都可以采用全双工通信方式。</p>
<p>在全双工通信中，通信双方需要使用专门的设备进行通信，例如全双工电缆、全双工网卡等。这些设备可以同时进行发送和接收数据，并且能够处理来自对方的数据，从而实现双向通信。</p>
<p>因此，全双工通信可以提高通信效率和通信质量，广泛应用于各种通信场景中。</p>
<h2 id="操作系统的功能有哪些？"><a href="#操作系统的功能有哪些？" class="headerlink" title="操作系统的功能有哪些？"></a>操作系统的功能有哪些？</h2><ol>
<li><p>进程管理：操作系统管理计算机上运行的所有进程，包括进程的创建、调度、终止、通信等。</p>
</li>
<li><p>内存管理：操作系统管理计算机内存的分配和释放，确保程序能够访问到所需的内存空间。</p>
</li>
<li><p>文件系统：操作系统管理计算机上的文件和目录，包括文件的创建、读取、写入、复制、删除等。</p>
</li>
<li><p>设备管理：操作系统管理计算机上的各种设备，包括输入输出设备、存储设备、网络设备等。</p>
</li>
<li><p>用户接口：操作系统提供了用户与计算机交互的接口，包括命令行接口、图形用户界面等。</p>
</li>
<li><p>安全性管理：操作系统确保计算机系统的安全性，包括用户身份验证、访问控制、病毒防护等。</p>
</li>
<li><p>网络管理：操作系统提供了网络通信的支持，包括TCP&#x2F;IP协议栈、网络驱动程序等。</p>
</li>
</ol>
<h2 id="什么是操作系统的堆区和栈区？"><a href="#什么是操作系统的堆区和栈区？" class="headerlink" title="什么是操作系统的堆区和栈区？"></a>什么是操作系统的堆区和栈区？</h2><p>操作系统中的堆和栈都是指内存空间，不同的是堆为按需申请、动态分配，例如 C 中的 malloc 函数和 C++ 中的 new 操作。而栈是由编译器自动分配释放，存放函数的参数值，局部变量的值等。<br>堆和栈之间的区别主要有以下几点：</p>
<ul>
<li>分配方式：堆是动态分配的，而栈是静态分配的。</li>
<li>空间大小：堆的空间大小不确定，而栈的空间大小固定。</li>
<li>空间分配方式：堆是由程序员手动申请和释放，而栈是由编译器自动分配和释放。</li>
<li>空间使用方式：堆的空间可以随时申请和释放，而栈的空间只能在函数调用时申请，在函数返回时释放。</li>
</ul>
<h2 id="堆和栈，哪个操作系统处理起来会更快？"><a href="#堆和栈，哪个操作系统处理起来会更快？" class="headerlink" title="堆和栈，哪个操作系统处理起来会更快？"></a>堆和栈，哪个操作系统处理起来会更快？</h2><p>一般来说，栈的处理速度比堆更快，这是因为<strong>栈的内存分配和释放是由编译器自动完成的，不需要进行复杂的内存管理操作，而且它的数据结构相对简单，访问速度更快</strong>。而堆在内存分配和释放时需要进行一些额外的操作，例如寻找可用内存，管理内存分配器等，因此操作系统在处理堆时需要花费更多的时间。</p>
<p>但是，在实际应用中，我们往往需要使用堆空间来存储动态数据结构，例如动态数组、链表、堆等。这些数据结构使用栈空间无法实现，只能使用堆空间。因此，在程序设计时需要根据实际需求合理使用栈和堆，以取得更好的性能和效率。</p>
<h2 id="OSI七层网络协议"><a href="#OSI七层网络协议" class="headerlink" title="OSI七层网络协议"></a>OSI七层网络协议</h2><p>OSI七层网络协议是一种通信协议的标准，它将计算机网络体系结构分为七个层次，每个层次都有自己的功能和任务。这些层次分别是：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p>
<p>物理层：负责传输比特流，即由1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换。<br>数据链路层：在计算机网络中由于各种干扰的存在，物理链路是不可靠的。该层的主要功能就是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。<br>网络层：负责数据包从源到宿的传递和网际互连。<br>传输层：负责向两台主机进程之间提供端到端的可靠数据传输服务。<br>会话层：负责建立、管理和终止会话。<br>表示层：负责数据格式转换、加密解密等。<br>应用层：为用户提供各种应用服务。</p>
<h2 id="常见的应用层协议有哪些？"><a href="#常见的应用层协议有哪些？" class="headerlink" title="常见的应用层协议有哪些？"></a>常见的应用层协议有哪些？</h2><ol>
<li><strong>HTTP：超文本传输协议，用于浏览器和服务器之间的数据传输。</strong></li>
<li><strong>FTP：文件传输协议，用于在远程计算机之间传输文件。</strong></li>
<li>SMTP：简单邮件传输协议，用于电子邮件传输。</li>
<li>POP3：邮局协议版本3，用于电子邮件客户端从邮件服务器接收邮件。</li>
<li>IMAP：互联网消息访问协议，用于电子邮件客户端从邮件服务器接收邮件。</li>
<li>DNS：域名系统，用于将域名（例如<a target="_blank" rel="noopener" href="http://www.baidu.com)和ip地址进行映射./">www.baidu.com）和IP地址进行映射。</a></li>
<li>Telnet：远程终端协议，用于在计算机之间进行远程控制。</li>
<li>SSH：安全外壳协议，用于在计算机之间进行加密控制。</li>
<li>SNMP：简单网络管理协议，用于在网络中对设备进行管理和监控。</li>
</ol>
<h2 id="常见的传输层协议有哪些？"><a href="#常见的传输层协议有哪些？" class="headerlink" title="常见的传输层协议有哪些？"></a>常见的传输层协议有哪些？</h2><ol>
<li><strong>TCP：传输控制协议，提供可靠的、面向连接的数据传输，在网络不可靠的情况下，TCP可以保证数据的可靠传输。</strong></li>
<li><strong>UDP：用户数据报协议，提供不可靠的、无连接的数据传输。相比TCP，UDP传输速度更快，但不保证数据的可靠传输，适合于实时传输、网络游戏等应用场景。</strong></li>
<li>SCTP：流控制传输协议，提供可靠的、面向连接的数据传输，支持多条独立的数据流，适合于多媒体传输和VoIP（Voice over IP）等应用场景。</li>
</ol>
<p>传输层协议是在网络中负责应用程序之间数据的可靠传输和错误控制的协议，不同的传输层协议有不同的特点和适用场景。TCP是常用的传输层协议，提供可靠的、面向连接的数据传输，适合数据传输要求较高的应用场景；UDP则是提供不可靠的、无连接的数据传输，适合实时传输、网络游戏等应用场景。同时，SCTP相比TCP具备更好的抗攻击能力，因此也得到了广泛应用。</p>
<h2 id="网络层的协议有哪些？"><a href="#网络层的协议有哪些？" class="headerlink" title="网络层的协议有哪些？"></a>网络层的协议有哪些？</h2><ol>
<li>IP协议（Internet Protocol）：IP是互联网中最重要的协议之一，负责将数据包从源地址传输到目的地址，并通过路由选择算法选择最优路径。IPv4和IPv6是最常用的IP协议版本。</li>
<li>ICMP协议（Internet Control Message Protocol）：ICMP是IP协议的附属协议，用于传输网络控制信息和错误报文。常用的功能包括ping命令和traceroute命令。</li>
<li>ARP协议（Address Resolution Protocol）：ARP是用于将IP地址转换为MAC地址的协议，通过查询本地网络中的ARP缓存表或广播ARP请求来查找目标MAC地址。</li>
<li>RARP协议（Reverse Address Resolution Protocol）：RARP是ARP的反向协议，用于将MAC地址转换为IP地址。现在已经很少使用。</li>
<li>OSPF协议（Open Shortest Path First）：OSPF是一种开放的链路状态路由协议，用于在局域网和广域网中选择最短路径，实现路由的自适应和动态变化。</li>
<li>BGP协议（Border Gateway Protocol）：BGP是一种自治系统间的路由协议，用于在不同自治系统之间传输路由信息，实现互联网中的全球路由选择。</li>
<li>RIP协议（Routing Information Protocol）：RIP是一种基于距离向量的内部网关协议，用于在小型网络中选择最短路径，实现路由的自适应和动态变化。</li>
</ol>
<h2 id="TCP和UDP的区别？⭐"><a href="#TCP和UDP的区别？⭐" class="headerlink" title="TCP和UDP的区别？⭐"></a>TCP和UDP的区别？⭐</h2><p>TCP和UDP的区别如下:</p>
<ul>
<li>TCP是面向连接的，UDP是无连接的</li>
<li>TCP提供可靠的服务，UDP则不保证可靠交付数据</li>
<li>TCP是一对一的两点服务，即一条连接只有两个端点。UDP支持一对一、一对多、多对多的交互通信</li>
<li>TCP有拥塞控制和流量控制机制，保证数据传输的安全性。UDP则没有，即使网络非常拥堵了，也不会影响UDP的发送速率</li>
<li>TCP首部长度较长，会有一定的开销，首部在没有使用[选项，字段时是20个字节，如果使用了[选项]字段则会变长。UDP首部只有8个字节，并且是固定不变的，开销较小。</li>
</ul>
<h2 id="TCP和UDP的应用场景？⭐"><a href="#TCP和UDP的应用场景？⭐" class="headerlink" title="TCP和UDP的应用场景？⭐"></a>TCP和UDP的应用场景？⭐</h2><p>TCP和UDP是两种不同的传输协议。TCP是面向连接的协议，而UDP是无连接的协议。TCP提供交付保证，这意味着一个使用TCP协议发送的消息是保证交付给客户端的，如果消息在传输过程中丢失，那么它将重发。而UDP不提供这种保证。因此，<strong>TCP适用于对准确性要求相对高的场景，如文件传输、发送或接收邮件、远程登录等，而UDP适用于对准确性要求相对低但速度要求相对高的场景，如即时通信、在线视频、网络语音电话等。</strong></p>
<h2 id="Websocket使用的是TCP还是UDP协议？为什么？"><a href="#Websocket使用的是TCP还是UDP协议？为什么？" class="headerlink" title="Websocket使用的是TCP还是UDP协议？为什么？"></a>Websocket使用的是TCP还是UDP协议？为什么？</h2><p>Websocket使用的是TCP协议，而不是UDP协议。</p>
<p>TCP协议是一种面向连接的、可靠的、有序的协议，它在数据传输过程中提供了数据完整性、可靠性和有序性的保证。Websocket需要<strong>保证数据的可靠性和有序性</strong>，因此选择了TCP协议作为底层传输协议。</p>
<p>相比之下，UDP协议是一种无连接的、不可靠的、无序的协议，它不提供数据的可靠性和有序性保证，适合于一些实时性要求高、数据量小、可丢失的应用，如在线游戏、音视频传输等。但是Websocket需要保证数据的可靠性和有序性，因此不适合使用UDP协议作为底层传输协议。</p>
<p>综上所述，Websocket使用TCP协议作为底层传输协议，可以保证数据的可靠性和有序性，适用于需要保证数据完整性和可靠性的应用。</p>
<h2 id="TCP的三次挥手"><a href="#TCP的三次挥手" class="headerlink" title="TCP的三次挥手"></a>TCP的三次挥手</h2><p>TCP三次握手是TCP协议中用于在客户端和服务器之间建立连接的过程。三次握手的过程如下：</p>
<ol>
<li>客户端向服务器发送一个SYN包，其中标志位为SYN，表示请求建立连接，序号为Seq&#x3D;x(一般取随机数)。</li>
<li>服务器接收到客户端发来的SYN包后，对该包进行确认后结束LISTEN阶段，并返回一段TCP报文，其中标志位为SYN和ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接，序号为Seq&#x3D;y。</li>
<li>客户端接收到服务器发来的TCP报文后，对该报文进行确认，其中标志位为ACK，表示确认服务器的报文Seq序号有效，客户端能正常接收服务器发送的数据，并向服务器发送一段TCP报文，其中标志位为ACK，表示确认服务器的报文Seq序号有效。</li>
</ol>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/9/d8bf92c7906718271fdb8b0d2d5fe5b4~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h2><p>TCP四次挥手是TCP协议中用于在客户端和服务器之间断开连接的过程。四次挥手的过程如下：</p>
<ol>
<li>客户端向服务器发送一个FIN包，其中标志位为FIN，表示请求断开连接，序号为Seq&#x3D;u。</li>
<li>服务器接收到客户端发来的FIN包后，对该包进行确认后结束ESTABLISHED阶段，并返回一段TCP抵文，其中标志位为ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并告诉客户端：我知道你想断开连接的请求了。</li>
<li>服务器向客户端发送一个FIN包，其中标志位为FIN，表示请求断开连接，序号为Seq&#x3D;V。</li>
<li>客户端接收到服务器发来的TCP报文后，对该报文进行确认，其中标志位为ACK，表示确认服务器的报文Seq序号有效，客户端能正常接收服务器发送的数据，并向服务器发送一段TCP报文，其中标志位为ACK，表示确认服务器的报文Seq序号有效。</li>
</ol>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/9/8c7874fafe233c9278509e40e906055c~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="TCP的三次握手为什么不能改成两次？"><a href="#TCP的三次握手为什么不能改成两次？" class="headerlink" title="TCP的三次握手为什么不能改成两次？"></a>TCP的三次握手为什么不能改成两次？</h2><p>TCP三次握手是TCP协议中用于在客户端和服务器之间建立连接的过程。其中，第一次握手是客户端向服务器发送一个SYN包，其中标志位为SYN，表示请求建立连接，序号为Seq&#x3D;x；</p>
<p>第二次握手是服务器接收到客户端发来的SYN包后，对该包进行确认后结束SYN_RECEIVED阶段，并返回一段TCP报文，其中标志位为SYN&#x2F;ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并告诉客户端:我知道你想建立连接的请求了，我的序号是Seq&#x3D;y；</p>
<p>第三次握手是客户端接收到服务器发来的TCP报文后，对该报文进行确认，其中标志位为ACK，表示确认服务器的报文Seq序号有效，客户端能正常接收服务器发送的数据，并告诉服务器:我知道你想建立连接的请求了，我的序号是Seq&#x3D;x+1。这样就完成了TCP三次握手过程。</p>
<p>如果采用两次握手，则<strong>只能确定从客户端到服务端的网络是可达的，但无法保证从服务端到客户端的网络是可达的</strong>。</p>
<p>此外，在采用两次握手时，如果已失效的连接请求报文段突然又传到了服务端，则会导致双方不一致，造成资源浪费。</p>
<h2 id="TCP客户端和服务端同时发出断开请求后续会怎么样？"><a href="#TCP客户端和服务端同时发出断开请求后续会怎么样？" class="headerlink" title="TCP客户端和服务端同时发出断开请求后续会怎么样？"></a>TCP客户端和服务端同时发出断开请求后续会怎么样？</h2><p>在 TCP 连接中，当客户端和服务端都发出断开请求时，会发生以下情况：</p>
<ol>
<li>服务端先收到断开请求：服务端会发送一个 ACK 确认客户端的断开请求，并关闭连接。此时客户端还没有收到服务端的 ACK，仍然处于等待状态。</li>
<li>客户端先收到断开请求：客户端会发送一个 ACK 确认服务端的断开请求，并关闭连接。此时服务端还没有收到客户端的 ACK，仍然处于等待状态。</li>
<li>客户端和服务端同时收到断开请求：客户端和服务端都会发送一个 ACK 确认对方的断开请求，并关闭连接。此时连接会立即断开，双方都不会处于等待状态。</li>
</ol>
<p>总之，在 TCP 连接中，任何一方发送断开请求后，都需要等待对方的确认，才能真正关闭连接。如果双方同时发出断开请求，则连接会立即断开，否则需要等待对方的确认。</p>
<h2 id="TCP可靠的原因是什么？依靠了哪些机制？"><a href="#TCP可靠的原因是什么？依靠了哪些机制？" class="headerlink" title="TCP可靠的原因是什么？依靠了哪些机制？"></a>TCP可靠的原因是什么？依靠了哪些机制？</h2><ol>
<li>应答机制：TCP在发送数据之后，会等待接收方的应答，以确认数据是否已经到达。如果接收方未能及时应答，TCP会进行重传，直到接收到应答为止。</li>
<li>序列号和确认应答：TCP会为每个数据包分配一个序列号，用于标识数据包的顺序和完整性。接收方在收到数据包后，会发送一个确认应答，其中包含期望接收的下一个序列号，用于告诉发送方哪些数据已经接收到了。</li>
<li>数据包校验和：TCP会对每个数据包进行校验和计算，以检测数据在传输过程中是否发生了损坏或丢失。如果校验和不匹配，TCP会进行重传，以确保数据的完整性。</li>
<li>滑动窗口：TCP使用滑动窗口机制来控制数据流量，以避免网络拥塞。发送方和接收方都有一个窗口大小，用于控制发送和接收的数据量。发送方会根据接收方的窗口大小来控制发送的数据量，以避免数据包的丢失或拥塞。</li>
</ol>
<h2 id="TCP在连接时会出现拥塞和粘包的问题，要怎么解决粘包的问题？"><a href="#TCP在连接时会出现拥塞和粘包的问题，要怎么解决粘包的问题？" class="headerlink" title="TCP在连接时会出现拥塞和粘包的问题，要怎么解决粘包的问题？"></a>TCP在连接时会出现拥塞和粘包的问题，要怎么解决粘包的问题？</h2><p>TCP协议在传输过程中会出现拥塞和粘包的问题，其中粘包问题是由于<strong>发送端发送的数据大小与接收端接收的数据大小不一致，导致多个数据包被粘在一起，从而造成接收端解析数据时出现错误</strong>。解决粘包问题的方法如下：</p>
<ol>
<li>使用消息定长：在发送端每次发送固定长度的数据，接收端每次接收相同长度的数据，这样就能避免粘包问题。</li>
<li>使用消息分隔符：在发送端每次发送数据时，在每个数据包的末尾添加一个特定的分隔符，接收端根据分隔符将数据包分开处理。</li>
<li>使用消息长度：在发送端每次发送数据时，在数据包的头部添加一个表示数据长度的字段，接收端根据字段的值来判断每个数据包的长度。</li>
<li>应用层协议处理：在应用层协议中定义数据格式和处理方式，例如HTTP协议中使用头部信息和分隔符来处理请求和响应数据。</li>
</ol>
<p>综上所述，通过使用消息定长、消息分隔符、消息长度和应用层协议处理等方法，可以有效解决TCP协议中的粘包问题。</p>
<h2 id="TCP的发送速度是如何得到控制的？"><a href="#TCP的发送速度是如何得到控制的？" class="headerlink" title="TCP的发送速度是如何得到控制的？"></a>TCP的发送速度是如何得到控制的？</h2><ol>
<li>慢启动算法（Slow Start）：发送方刚开始发送数据时，先发送一小部分数据，然后根据收到的确认消息逐渐增加发送的数据量，以逐渐探测网络的拥塞情况。</li>
<li>拥塞避免算法（Congestion Avoidance）：当发现网络拥塞时，发送方就会进入拥塞避免阶段，此时发送方会将发送窗口的大小限制在一个较小的值范围内，以避免网络拥塞。</li>
<li>快重传算法（Fast Retransmit）：当发送方连续发送多个数据包时，如果接收方收到其中一个数据包有丢失或损坏，就会立即发送一个重复确认消息，告诉发送方需要重传该数据包。发送方收到这个重复确认消息后，就会立即重传该数据包，而不是等到超时后再重传，从而加快数据传输速度。</li>
<li>快恢复算法（Fast Recovery）：当发送方收到重复确认消息时，就会进入快恢复阶段，此时发送方会将发送窗口的大小减半，并重传丢失的数据包，以避免网络拥塞。</li>
<li>拥塞控制算法（Congestion Control）：TCP中还有一种全局的拥塞控制算法，它通过计算网络的拥塞程度来动态调整发送方的发送速度，以避免网络拥塞。常用的拥塞控制算法有TCP Reno、TCP Vegas、TCP New Reno等。</li>
</ol>
<h2 id="在TCP中有keep-alive，Vue也有keep-alive，Http也有keep-alive，它们都是指什么？"><a href="#在TCP中有keep-alive，Vue也有keep-alive，Http也有keep-alive，它们都是指什么？" class="headerlink" title="在TCP中有keep-alive，Vue也有keep-alive，Http也有keep-alive，它们都是指什么？"></a>在TCP中有keep-alive，Vue也有keep-alive，Http也有keep-alive，它们都是指什么？</h2><ol>
<li>在TCP协议中，keep-alive是一种保持连接的机制，可以在客户端和服务器之间保持长时间的空闲连接。当客户端和服务器之间没有数据传输时，keep-alive机制会发送一些探测包来检测对方是否还活着，从而确保连接的有效性。这个机制在一些长连接场景下比较常见，例如HTTP长连接、FTP数据传输等。</li>
<li>在Vue中，keep-alive是一个组件，可以将动态组件进行缓存，以便在切换时可以保留它们的状态或避免重新渲染。这个组件在一些需要频繁切换的场景下比较常见，例如Tab切换、路由切换等。</li>
<li>在HTTP协议中，keep-alive是一种持久连接机制，可以在客户端和服务器之间保持一个TCP连接，从而避免在每个HTTP请求之间重新建立TCP连接。这个机制可以减少连接建立和关闭的开销，提高HTTP请求的效率，尤其是在一些高并发的Web应用中。</li>
</ol>
<h2 id="Http-keep-alive会引起其他的什么问题？"><a href="#Http-keep-alive会引起其他的什么问题？" class="headerlink" title="Http keep-alive会引起其他的什么问题？"></a>Http keep-alive会引起其他的什么问题？</h2><p>HTTP Keep-Alive 是一种 HTTP&#x2F;1.1 中的持久连接技术，可以使客户端和服务器在同一个 TCP 连接上发送多个 HTTP 请求和响应，从而减少连接建立和关闭的开销，提高性能。</p>
<p>然而，HTTP Keep-Alive 也可能引起以下问题：</p>
<ol>
<li>服务器资源占用：当客户端和服务器之间的连接不关闭时，服务器需要一直维护这个连接，占用一定的资源。如果同时有大量客户端连接服务器，会导致服务器资源占用过多，影响服务器的性能。</li>
<li>网络拥塞：当客户端和服务器之间的连接不关闭时，会占用网络带宽，可能导致网络拥塞，影响网络性能。</li>
<li>安全性问题：HTTP Keep-Alive 可能会导致安全性问题，例如，当客户端和服务器之间的连接不关闭时，可能会被黑客利用进行攻击，例如，利用长连接进行 DoS 攻击或者发送恶意请求等。</li>
</ol>
<p>因此，在使用 HTTP Keep-Alive 技术时，需要合理设置连接的超时时间，以及采取一定的安全措施，避免出现以上问题。</p>
<h2 id="不同域名指向同一个ip是否是同源的？"><a href="#不同域名指向同一个ip是否是同源的？" class="headerlink" title="不同域名指向同一个ip是否是同源的？"></a>不同域名指向同一个ip是否是同源的？</h2><p>不同域名指向同一个IP地址并不一定是同源的。同源策略是浏览器的一种安全策略，它是指只有当两个页面具有相同的协议、域名和端口号时，才允许这两个页面之间进行交互（例如访问彼此的DOM、Cookie等）。因此，如果两个页面的域名不同，即使它们指向同一个IP地址，也不会被认为是同源的。</p>
<p>但是，如果在同一个域名下使用不同的子域名（例如a.example.com和b.example.com）指向同一个IP地址，这种情况下它们被认为是同源的，因为它们具有相同的主域名。</p>
<p>总之，同源策略是根据协议、域名和端口号来判断是否允许跨域访问，而IP地址并不是同源策略的判断依据。</p>
<h2 id="Http1-0时候发起一个http请求会开启一个TCP连接吗？"><a href="#Http1-0时候发起一个http请求会开启一个TCP连接吗？" class="headerlink" title="Http1.0时候发起一个http请求会开启一个TCP连接吗？"></a>Http1.0时候发起一个http请求会开启一个TCP连接吗？</h2><p>在 HTTP&#x2F;1.0 中，每次发起 HTTP 请求都会建立一个新的 TCP 连接。这是因为 HTTP&#x2F;1.0 中每个请求和响应都是独立的，没有复用连接的机制。</p>
<p>在 HTTP&#x2F;1.0 中，每个 TCP 连接只能处理一个请求和响应，因此在处理多个请求和响应时，需要建立多个 TCP 连接。这样会导致建立和关闭连接的开销比较大，影响了 HTTP 请求的性能。</p>
<p>为了解决这个问题，HTTP&#x2F;1.1 引入了持久连接，允许在同一个 TCP 连接上发送多个请求和响应。这样可以减少建立和关闭连接的开销，提高 HTTP 请求的性能。</p>
<h2 id="一般的发Http请求的流程是什么样的？"><a href="#一般的发Http请求的流程是什么样的？" class="headerlink" title="一般的发Http请求的流程是什么样的？"></a>一般的发Http请求的流程是什么样的？</h2><p>一般的发 Http 请求的流程如下：</p>
<ol>
<li>构建请求：构建 HTTP 请求报文，包括请求方法、请求 URL、请求头以及请求体等信息。</li>
<li>建立连接：通过 TCP 协议与服务器建立连接，可以使用 HTTP&#x2F;1.0 中的短连接或者 HTTP&#x2F;1.1 中的长连接。</li>
<li>发送请求：将构建好的 HTTP 请求报文发送给服务器。</li>
<li>接收响应：等待服务器返回响应报文，接收响应数据。</li>
<li>处理响应：对服务器返回的响应数据进行处理，包括状态码、响应头以及响应体等信息。</li>
<li>断开连接：根据 HTTP&#x2F;1.0 或者 HTTP&#x2F;1.1 的规定，关闭 TCP 连接。</li>
</ol>
<p>其中，建立连接和断开连接的过程是比较耗时的，影响了 HTTP 请求的性能。因此，为了提高 HTTP 请求的性能，可以使用 HTTP&#x2F;1.1 中的持久连接或者 HTTP&#x2F;2 中的多路复用等技术。</p>
<h2 id="浏览器中输入网址并发起网络请求后都经历了什么？⭐"><a href="#浏览器中输入网址并发起网络请求后都经历了什么？⭐" class="headerlink" title="浏览器中输入网址并发起网络请求后都经历了什么？⭐"></a>浏览器中输入网址并发起网络请求后都经历了什么？⭐</h2><ol>
<li>首先判断输入的内容是否为合法的域名，如果不是则作为关键字交给搜索引擎进行处理；如果域名中有非法字符则进行转义。</li>
<li>首先判断浏览器中是否有所需资源的缓存，如果有则直接使用，否则进行DNS查询获取域名对应的IP地址。</li>
<li>DNS查询<ol>
<li>判断本地的DNS缓存中是否有该IP地址，如果命中则返回</li>
<li>如果还是没有命中，则将域名发送到本地域名服务器，本地域名服务器采用递归查询自己的DNS服务器，查找成功则返回。</li>
<li>如果本地域名服务器的DNS缓存没有命中，则向上级域名服务器进行迭代查询<ul>
<li>首先本地域名服务器向根域名服务器进行请求，获取顶级域名服务器的地址给本地服务器。</li>
<li>本地域名服务器拿到这个顶级域名服务器后就想起发送请求，获取权威域名服务器的地址。</li>
<li>本地域名服务器向权威域名服务器发送请求，获取域名对应的IP地址。</li>
</ul>
</li>
<li>本地域名服务器将得到的IP地址发送给操作系统，同时自己将IP地址缓存起来。</li>
<li>操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来。</li>
<li>至此，浏览器得到了域名对应的IP地址，并将IP地址缓存起来。</li>
</ol>
</li>
<li>通过IP地址与本地的子网掩码相与，判断是否与请求主机在一个子网中，如果在一个子网中，则使用ARP协议获取目标主机的MAC地址，如果不在一个子网中，那么请求应该转发给网关，由它代为转发，此时同样可以通过ARP协议获取网关MAC地址，此时目的主机的MAC地址应该为网关地址。</li>
<li>进行TCP的三次握手</li>
<li>进行HTTPS握手</li>
<li><strong>返回数据</strong>：将网页请求发送至服务器端，服务器端返回一个html文件作为响应。浏览器接受响应后，开始对html文件进行解析并开始页面的渲染过程。</li>
<li><strong>页面渲染</strong>：根据html文件构建DOM树，根据解析到的css构建CSSOM树，如果遇到script标签，则判断有无async和defer属性，否则script的加载和执行会造成页面渲染的阻塞。当DOM树和CSSOM树建立好后，根据他们构建渲染树。渲染树构建好后，根据渲染树进行布局，然后使用浏览器的UI接口对页面进行绘制。此时整个页面就显示出来了。</li>
<li>TCP四次挥手</li>
</ol>
<h2 id="数据-HTML、CSS和JS等资源-返回到浏览器后的详细渲染过程？"><a href="#数据-HTML、CSS和JS等资源-返回到浏览器后的详细渲染过程？" class="headerlink" title="数据(HTML、CSS和JS等资源)返回到浏览器后的详细渲染过程？"></a>数据(<code>HTML</code>、<code>CSS</code>和<code>JS</code>等资源)返回到浏览器后的详细渲染过程？</h2><p>当浏览器收到HTML、CSS和JS等资源后，会进行以下渲染过程：</p>
<ol>
<li>解析HTML：浏览器会根据HTML文档的结构解析出文档树（DOM树），同时也会解析出CSS文档的样式规则（CSSOM树）。</li>
<li>构建渲染树：浏览器会将DOM树和CSSOM树结合起来构建渲染树（Render Tree），渲染树只包含需要显示的节点和样式信息。</li>
<li>布局：浏览器会根据渲染树中每个节点的布局信息（包括位置、大小等）计算出每个节点在屏幕上的位置。</li>
<li>绘制：浏览器会将渲染树中的每个节点绘制到屏幕上，形成最终的页面展示效果。</li>
<li>JS执行：如果HTML中包含了JS代码，浏览器会执行这些代码，可能会修改DOM树、CSSOM树以及渲染树等。</li>
</ol>
<h2 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>Cache-Control &#x2F; Expires</p>
<p>expires <code>http1.0</code>控制网页缓存的字段，其值为服务器返回该请求结果的到期时间，即再次发送请求，如果客户端的时间小于expires的值时，直接使用缓存结果</p>
<p>cache-control(优先级更大) http1.1中控制网页缓存，是最重要的规则</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>Etag If-None-Match &#x2F; Last-Midified If-Midified-Since</p>
<p><code>Last-Modified / If-Modified-Since</code> 和 <code>Etag / If-None-Match</code> (后者优先级更高)</p>
<p>Last-Modified 服务器响应请求时，返回该文件资源在服务器内最后被修改的时间</p>
<p>If-Modified-Since 客户端再次发起请求时，携带上次请求返回的Last-Modified值，通过此字段告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据此字段值与该资源在服务器的最后被修改的时间做对比，若服务器的资源最后被修改的时间大于If-Modified-Since字段值，则重新返回资源，状态码为200；否则返回304，代表资源无更新，可继续使用缓存文件</p>
<p>Etag 是服务区响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)</p>
<p>If-None-Match 服务器再次发起请求时，携带上次请求返回的唯一标识Etag，通过此字段告诉服务器该资源上次请求返回的唯一标识，服务器收到该请求后，发现请求头中含有If-None-Match的字段与该资源在服务器的Etag值进行比对，<strong>一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码200</strong></p>
<h2 id="HTTP中常见的请求头有哪些？"><a href="#HTTP中常见的请求头有哪些？" class="headerlink" title="HTTP中常见的请求头有哪些？"></a>HTTP中常见的请求头有哪些？</h2><ol>
<li><strong>Accept</strong>：指定客户端接受的MIME类型。如果服务器无法返回指定类型的数据，则返回406错误状态码。</li>
<li>User-Agent：指定请求的客户端代理名称和版本号。这个请求头可以被用于浏览器嗅探，从而让服务器返回针对特定浏览器的响应。</li>
<li><strong>Host</strong>：指定请求的主机名，包括端口号。在多虚拟主机环境下，服务器可以通过该头部来判断客户端所请求的主机名和端口号。</li>
<li>Accept-Language：指定客户端语言环境，告诉服务器可以接受哪些语言的资源。</li>
<li>Accept-Encoding：指定客户端可以支持的内容编码方式，如Gzip、Deflate等，告诉服务器哪种压缩格式可以被客户端处理。</li>
<li><strong>Connection</strong>：控制HTTP连接的行为，如关闭连接、保持连接等。</li>
<li><strong>If-Modified-Since</strong>：告诉服务器如果请求资源自指定日期以来没有被修改过，那么只返回304状态码，不返回资源本身，减少了网络数据传输的开销。</li>
<li>Authorization：用于客户端想要访问需要授权的资源，包含授权类型和凭证信息（通常是用户名密码）。</li>
<li><strong>Cache-Control</strong>：用于控制客户端或缓存是否可以缓存该响应，可以通过设置max-age和no-store等参数来控制缓存行为。</li>
<li><strong>Cookie</strong>：用于在客户端和服务端之间传递状态信息，可以通过设置cookie来实现“记住我”等功能。</li>
<li>Range：指定请求的范围，可以用于断点续传等场景。</li>
<li><strong>Content-Type</strong>：指定请求体的MIME类型，在POST请求中常被用到。</li>
<li><strong>Content-Length</strong>：指定请求体的长度，用于解析请求体。</li>
<li>Transfer-Encoding：指定分块传输编码方式，可以被用于实现长连接。</li>
</ol>
<h2 id="国内网站一般用的是哪个版本的http协议"><a href="#国内网站一般用的是哪个版本的http协议" class="headerlink" title="国内网站一般用的是哪个版本的http协议?"></a>国内网站一般用的是哪个版本的http协议?</h2><p>目前主流还是http1.1</p>
<h2 id="HTTP和HTTPS的区别？⭐"><a href="#HTTP和HTTPS的区别？⭐" class="headerlink" title="HTTP和HTTPS的区别？⭐"></a>HTTP和HTTPS的区别？⭐</h2><ul>
<li>HTTP是超文本传输协议，采用明文传输，而HTTPS采用SSL进行了数据加密，保证了数据的安全性</li>
<li>HTTP使用的是80端口，HTTPS是443端口</li>
<li>HTTPS需要数字证书，用于验证服务器身份和保证通信安全性</li>
<li>HTTPS加密和解密过程需要消耗更多计算资源，更加消耗性能</li>
<li>HTTPS的数据不容易被存储，因为每个请求和响应都需要加密和解密，而HTTP的数据易于被存储，可以提高访问速度。</li>
</ul>
<h2 id="HTTPS的加密过程？⭐"><a href="#HTTPS的加密过程？⭐" class="headerlink" title="HTTPS的加密过程？⭐"></a>HTTPS的加密过程？⭐</h2><ol>
<li>客户端向服务器发送HTTPS请求。请求中包含了客户端支持的加密算法列表和随机数（ClientHello）。</li>
<li>服务器从客户端发送的加密算法列表中选择一种加密算法，并向客户端发送服务器的证书，证书中包含了服务器的公钥和证书的签名（ServerHello）。</li>
<li>客户端验证服务器的证书是否有效，包括证书是否过期、证书是否被吊销、证书中的域名是否和服务器的域名匹配等。如果验证通过，客户端生成一个随机数，并使用服务器的公钥加密这个随机数（ClientKeyExchange）。</li>
<li>服务器使用自己的私钥解密客户端发送的随机数，并使用这个随机数生成对称密钥（ServerKeyExchange）。</li>
<li>客户端和服务器使用这个对称密钥进行通信，将通信内容加密后发送给对方。</li>
</ol>
<p>在这个过程中，客户端和服务器使用非对称加密算法（如RSA）来完成证书的验证和随机数的加密，使用对称加密算法（如AES）来加密通信内容。这样可以保证通信过程中传输的数据是加密的，同时也保证了通信双方的身份和数据的完整性，防止数据被篡改或窃取。</p>
<h2 id="TLS是如何保证可靠传输的？"><a href="#TLS是如何保证可靠传输的？" class="headerlink" title="TLS是如何保证可靠传输的？"></a>TLS是如何保证可靠传输的？</h2><blockquote>
<p>TLS（Transport Layer Security）是一种加密协议，用于保护网络通信中的数据安全性和完整性。它是SSL（Secure Sockets Layer）协议的继任者。</p>
</blockquote>
<p>TLS使用公钥加密技术和数字证书来确保通信的安全性。它采用了对称加密和非对称加密的组合方式来保护通信的内容和身份验证。通信双方首先通过握手协议交换密钥，然后使用这些密钥对数据进行加密和解密。</p>
<ol>
<li>加密通信：TLS使用对称加密算法来加密通信内容，保护数据的机密性。</li>
<li>数据完整性：TLS使用消息认证码（MAC）来保证数据的完整性，防止数据被篡改或损坏。</li>
<li>身份验证：TLS使用数字证书来进行身份验证，确保通信双方的身份是合法的。</li>
<li>防止重放攻击：TLS使用时间戳和随机数来防止重放攻击，确保通信的实时性。</li>
</ol>
<h2 id="HTTPS中的数字证书是哪一方发送的？"><a href="#HTTPS中的数字证书是哪一方发送的？" class="headerlink" title="HTTPS中的数字证书是哪一方发送的？"></a>HTTPS中的数字证书是哪一方发送的？</h2><p>在HTTPS通信中，数字证书是由服务器端发送给客户端的。</p>
<p>当客户端首次访问使用HTTPS协议的网站时，服务器会向客户端发送数字证书。客户端接收到数字证书后，会进行数字证书的验证过程，验证证书是否有效、证书颁发机构是否可信等。如果数字证书验证通过，客户端会生成会话密钥并使用证书中的公钥对该密钥进行加密，然后将加密后的密钥发送给服务器端。服务器端使用自己的私钥对密钥进行解密，然后双方就可以使用该密钥进行加密通信。</p>
<p>因此，在HTTPS协议中，数字证书是由服务器端发送给客户端的，客户端通过验证数字证书的有效性，并使用其公钥加密会话密钥，从而确保双方的通信是加密的、安全的。</p>
<h2 id="Http的报文格式？"><a href="#Http的报文格式？" class="headerlink" title="Http的报文格式？"></a>Http的报文格式？</h2><p>HTTP（超文本传输协议）的报文格式分为请求报文和响应报文两种类型。</p>
<p><strong>请求报文格式</strong></p>
<p>请求报文由三个部分组成：请求行、请求头和请求体。</p>
<p>请求行格式：METHOD URL HTTP&#x2F;版本号</p>
<p>例如：GET &#x2F;index.html HTTP&#x2F;1.1</p>
<p>请求头格式：键值对，每个键值对用冒号分隔，每个键值对占一行，最后一行用空行表示请求头结束。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Host</span>: www.<span class="hljs-property">example</span>.<span class="hljs-property">com</span> <span class="hljs-title class_">User</span>-<span class="hljs-title class_">Agent</span>: <span class="hljs-title class_">Mozilla</span>/<span class="hljs-number">5.0</span> (<span class="hljs-title class_">Windows</span> <span class="hljs-variable constant_">NT</span> <span class="hljs-number">10.0</span>; <span class="hljs-title class_">Win64</span>; x64) <span class="hljs-title class_">AppleWebKit</span>/<span class="hljs-number">537.36</span> (<span class="hljs-variable constant_">KHTML</span>, like <span class="hljs-title class_">Gecko</span>) <span class="hljs-title class_">Chrome</span>/<span class="hljs-number">58.0</span><span class="hljs-number">.3029</span><span class="hljs-number">.110</span> <span class="hljs-title class_">Safari</span>/<span class="hljs-number">537.36</span> <span class="hljs-title class_">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0.9</span>,image/webp,*<span class="hljs-comment">/*;q=0.8</span><br></code></pre></td></tr></table></figure>

<p>请求体格式：用于传输数据，可以为空。</p>
<p><strong>响应报文格式</strong></p>
<p>响应报文也由三个部分组成：状态行、响应头和响应体。</p>
<p>状态行格式：HTTP&#x2F;版本号 状态码 状态码的原因短语</p>
<p>例如：HTTP&#x2F;1.1 200 OK</p>
<p>响应头格式：键值对，每个键值对用冒号分隔，每个键值对占一行，最后一行用空行表示响应头结束。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Type</span>: text/html; charset=utf-<span class="hljs-number">8</span> <span class="hljs-title class_">Server</span>: <span class="hljs-title class_">Apache</span>/<span class="hljs-number">2.4</span><span class="hljs-number">.18</span> (<span class="hljs-title class_">Ubuntu</span>) <span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Length</span>: <span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure>

<p>响应体格式：用于传输数据，可以为空。</p>
<h2 id="HTTP2-0更新了哪些内容？"><a href="#HTTP2-0更新了哪些内容？" class="headerlink" title="HTTP2.0更新了哪些内容？"></a>HTTP2.0更新了哪些内容？</h2><ol>
<li>二进制格式：HTTP&#x2F;2在传输数据时采用二进制格式，而非HTTP&#x2F;1.x的文本格式，这使得解析和传输更加高效。</li>
<li>多路复用：HTTP&#x2F;2允许客户端和服务器之间同时保持多个请求和响应连接，这使得客户端可以发送多个请求，而无需等待每个响应，从而提高了数据传输的效率。</li>
<li>头部压缩：HTTP&#x2F;2使用HPACK算法对头部字段进行压缩，减少了头部发送的数据量，提高了传输速度。</li>
<li>服务器推送：HTTP&#x2F;2允许服务器在客户端请求之前发送额外的响应数据，从而可以提前获取客户端需要的资源并缓存起来，减少了客户端请求的次数和等待时间。</li>
<li>流量控制：HTTP&#x2F;2允许客户端和服务器之间进行流量控制，可以根据实际情况来分配网络带宽，以避免网络拥塞和延迟。</li>
</ol>
<h2 id="HTTP2-0头部压缩的比例是怎样的？"><a href="#HTTP2-0头部压缩的比例是怎样的？" class="headerlink" title="HTTP2.0头部压缩的比例是怎样的？"></a>HTTP2.0头部压缩的比例是怎样的？</h2><p>HTTP&#x2F;2使用HPACK算法进行头部压缩，可以将HTTP头部字段中的冗余数据删除，从而减少传输的数据量，提高传输速度。</p>
<p>具体来说，HTTP&#x2F;2的头部压缩可以做到80%~90%的压缩比率，这对移动网络等带宽有限的环境来说非常有利。因为HTTP头部中的很多字段是重复的，并且头部压缩只需要在建立连接时进行，减少了后续请求的数据量，同时还减少了数据传输过程中的网络阻塞。</p>
<p>此外，虽然HTTP&#x2F;2使用了头部压缩技术，在传输效率上得到了极大提高，但是在实际使用时，掌握合适的压缩策略非常重要，否则就会带来安全问题，比如攻击者通过伪造头部字段来欺骗服务器，破坏数据传输的完整性。</p>
<h2 id="Http3-0更新了什么？"><a href="#Http3-0更新了什么？" class="headerlink" title="Http3.0更新了什么？"></a>Http3.0更新了什么？</h2><ul>
<li><p><strong>使用UDP代替TCP，不需要复杂的创建连接和关闭连接的成本</strong></p>
</li>
<li><p><strong>基于传输层的多路复用，避免队头阻塞</strong></p>
</li>
<li><p><strong>向前纠错</strong> (每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传)</p>
<p>向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间（包括确认数据包丢失、请求重传、等待新数据包等步骤的时间消耗）。</p>
</li>
<li><p><strong>加密认证的报文</strong></p>
<p>TCP协议头部没有经过任何加密和认证，所以在传输的过程中很容易被中间网络设备篡改、注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也可能是主动攻击。</p>
<p>但是QUIC的packet除了个别报文比如说PUBLIC_RESET和CHLO，所有的报文头部都是经过认证的，报文体都是经过加密的。</p>
<p>这样只要对QUIC报文进行任何修改，接收端都能够及时发现，有效地降低了安全风险。</p>
</li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="https://limeii.github.io/2019/06/http2-http3/">Http3.0更新了什么</a></p>
<h2 id="Http3用UDP如何避免队头阻塞"><a href="#Http3用UDP如何避免队头阻塞" class="headerlink" title="Http3用UDP如何避免队头阻塞?"></a>Http3用UDP如何避免队头阻塞?</h2><p>HTTP&#x2F;3使用的是基于UDP协议的QUIC传输协议，相对于传统TCP协议，QUIC可以避免队头阻塞（head-of-line blocking）的问题。</p>
<p>队头阻塞问题指的是当一个数据包在网络传输中出现丢包或延迟时，后续的数据包被迫等待，导致整个数据传输被阻塞。这种情况在TCP协议中比较常见。</p>
<p>而QUIC协议可以通过以下措施来避免队头阻塞问题：</p>
<ol>
<li>使用基于多路复用的流控制（flow control）技术，将数据拆分为多个小型帧，对于每个帧进行单独的传输和确认，从而避免了数据包因为前面的数据包被丢弃而被阻塞的情况。</li>
<li>使用QUIC协议的拥塞控制机制，对网络拥塞做出反应，根据网络负载的情况调整传输速率，避免了TCP协议中因为网络拥塞而导致的队头阻塞。</li>
</ol>
<p>总的来说，HTTP&#x2F;3通过QUIC协议的流控制和拥塞控制机制，有效地避免了队头阻塞问题，提升了网络传输的性能和稳定性。</p>
<h2 id="超时重传机制的原理？"><a href="#超时重传机制的原理？" class="headerlink" title="超时重传机制的原理？"></a>超时重传机制的原理？</h2><blockquote>
<p>超时重传机制是指在网络通信中，当发送方发送数据后，如果没有收到确认应答或者收到了错误的应答，就会触发超时重传机制，重新发送数据。</p>
</blockquote>
<ol>
<li>发送数据：发送方将数据发送给接收方，并启动计时器，等待接收方的应答。</li>
<li>接收应答：接收方接收到数据后，向发送方发送应答信息，表示已经收到数据。</li>
<li>超时计时器：发送方启动一个计时器，等待接收方的应答。如果在规定的时间内没有收到应答，就认为数据丢失或超时，触发超时重传机制。</li>
<li>重传数据：发送方重新发送数据，等待接收方的应答。</li>
<li>停止计时器：当发送方收到接收方的应答后，停止计时器，表示数据已经成功发送。如果在规定的时间内没有收到应答，就会重新触发超时重传机制。</li>
</ol>
<h2 id="针对弱网环境如何从Http的角度去做前端优化？"><a href="#针对弱网环境如何从Http的角度去做前端优化？" class="headerlink" title="针对弱网环境如何从Http的角度去做前端优化？"></a>针对弱网环境如何从Http的角度去做前端优化？</h2><ul>
<li>使用CDN加速，避免弱网环境下资源加载过慢</li>
<li>使用HTTP Cache、Service Worker和Cache Storage API等技术进行缓存资源，避免重复请求</li>
<li>对于移动端，可以使用SSR、CSR、预渲染等技术，提升网页首帧优化，从而优化白屏问题，提升用户体验</li>
</ul>
<h2 id="浏览器的存储方案？"><a href="#浏览器的存储方案？" class="headerlink" title="浏览器的存储方案？"></a>浏览器的存储方案？</h2><p>Cookie</p>
<p>Cookie 是在客户端存储的文本文件，用于存储网站的状态信息，如用户登录状态、购物车内容等。它的大小有一定限制，一般为 4KB 左右，并且会在过期时间之后自动删除。</p>
<p>Web Storage</p>
<p>Web Storage 包括 localStorage 和 sessionStorage。localStorage 存储的数据可以在同一域名下的所有页面共享，且存储容量很大，一般为 5 MB 左右；而 sessionStorage 存储的数据只能在当前会话中共享，关闭浏览器后会自动删除。</p>
<p>IndexedDB</p>
<p>IndexedDB 是一种本地的数据库，用于存储大量结构化数据，支持事务和索引功能，可进行高效的数据查询和操作。</p>
<p>Cache Storage</p>
<p>Cache Storage 用于存储网络请求的响应，能够提高 Web 应用的加载速度和并发性能。它支持缓存的添加、查询、删除、更新等操作。</p>
<p>File API</p>
<p>File API 允许 Web 应用访问本地文件系统，可以在本地文件系统中读取和写入文件，也可以将文件发送到服务器。但是，File API 只能在获得用户授权的情况下使用，且不同浏览器的实现存在差异。</p>
<h2 id="cookie的特点？"><a href="#cookie的特点？" class="headerlink" title="cookie的特点？"></a>cookie的特点？</h2><p>Cookie是一种存储在客户端的小型文本文件，由一个名称、一个值和其他几个用于控制Cookie有效期<br>安全性、使用范围的可选属性组成。Cookie的特点如下：</p>
<ul>
<li>存储位置: Cookie存储在浏览器里面。</li>
<li>存储大小: Cookie的大小在4KB左右，数量在50个左右。</li>
<li>存储时间: Cookie的存储时间非常灵活。</li>
<li>安全性: 通过加密和安全传输技术 (SSL) ，减少Cookie被破解的可能性。</li>
</ul>
<h2 id="cookie有哪些属性？"><a href="#cookie有哪些属性？" class="headerlink" title="cookie有哪些属性？"></a>cookie有哪些属性？</h2><ul>
<li>Name: cookie的名称。</li>
<li>Value: cookie的值。</li>
<li>Domain: cookie所属的域名</li>
<li>Path: cookie所属的路径。</li>
<li>Expires&#x2F;Max-age: cookie的过期时间或存活时间。</li>
<li>Size: cookie的大小。</li>
<li>HttpOnly: 设置为true，表示只能通过HTTP或HTTPS访问，不能通过JavaScript访问。</li>
<li>Secure: 设置为true，表示只能通过HTTPS访问。</li>
<li>SameSite: 设置为Strict，表示浏览器不会在跨站点请求中发送Cookie；设置为Lax，表示浏览器只会在第三方站点的GET请求中发送Cookie；设置为None，表示浏览器会在所有跨站点请求中发送Cookie。</li>
<li>Priority: 设置为High，表示浏览器会优先发送该Cookie。</li>
</ul>
<h2 id="cookie和session的区别？"><a href="#cookie和session的区别？" class="headerlink" title="cookie和session的区别？"></a>cookie和session的区别？</h2><ul>
<li>Cookie数据存放在客户的浏览器上，session数据放在服务器上。</li>
<li>Cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，如果主要考虑到安全应当使用Session。</li>
<li>Session会在一定时间内保存在服务器上。</li>
<li>Cookie会在一定时间内保存在客户端上。</li>
<li>Session可以存储任何类型的对象，而Cookie只能存储字符串类型的数据.</li>
<li>Session依赖于Cookie，即Session ID存储在Cookie中。</li>
</ul>
<h2 id="常见的HTTP状态码及其含义？"><a href="#常见的HTTP状态码及其含义？" class="headerlink" title="常见的HTTP状态码及其含义？"></a>常见的HTTP状态码及其含义？</h2><p>1xx 接收到请求并继续(不常见)</p>
<p>2xx 请求成功</p>
<ul>
<li><p>200 请求成功</p>
</li>
<li><p>204 请求已处理但是没有返回内容</p>
</li>
<li><p>206 客户端进行了范围请求，服务器端执行了这部分GET请求，响应报文中包含由Content-Range指定范围的实体内容</p>
</li>
</ul>
<p>3xx 重定向状态码</p>
<ul>
<li><p>301 永久重定向</p>
</li>
<li><p>302 临时重定向</p>
</li>
<li><p>303 所请求的资源存在另一个URI，应使用GET方法定向获取请求资源</p>
</li>
<li><p>304 缓存中有需要的数据，无须进行请求</p>
</li>
<li><p>307 临时重定向，不会从POST变成GET</p>
</li>
</ul>
<p>4xx 客户端错误</p>
<ul>
<li><p>400 请求报文存在语法错误</p>
</li>
<li><p>401 请求须通过HTTP认证</p>
</li>
<li><p>403 请求资源被服务器拒绝</p>
</li>
<li><p>404 找不到资源</p>
</li>
<li><p>405 方法被识别但禁止使用</p>
</li>
</ul>
<p>5xx 服务器端发生错误</p>
<ul>
<li><p>500 服务器端在执行请求时发生错误</p>
</li>
<li><p>502 服务器接收到的响应无效</p>
</li>
<li><p>503 服务器暂时超负载or停机维护</p>
</li>
<li><p>504 超时</p>
</li>
</ul>
<h2 id="302状态码是什么意思？和301有什么区别？⭐"><a href="#302状态码是什么意思？和301有什么区别？⭐" class="headerlink" title="302状态码是什么意思？和301有什么区别？⭐"></a>302状态码是什么意思？和301有什么区别？⭐</h2><p>302表示临时重定向，表示所请求的资源临时转移到了另一个URL上面。</p>
<p>301状态码表示永久重定向，告诉客户端所请求的资源已经被永久移动到了新的位置，以后应该使用新的URL访问，它会在响应头的Location字段中存储新的URL，浏览器收到后会对新的URL进行缓存，在以后的请求中会自动使用新的URL而不是旧的URL。</p>
<p>302状态码表示临时重定向，告诉客户端所请求的资源已经被临时移动到了新的位置，但以后还是应该使用原来的URL访问，浏览器在以后的请求中仍然会使用原来的URL，需要再次请求服务器获取新的URL。</p>
<h2 id="在触发301状态码的时候，浏览器会把更新的url存放在何处？"><a href="#在触发301状态码的时候，浏览器会把更新的url存放在何处？" class="headerlink" title="在触发301状态码的时候，浏览器会把更新的url存放在何处？"></a>在触发301状态码的时候，浏览器会把更新的url存放在何处？</h2><p>当浏览器收到301状态码时，会把更新的URL存放在响应头的Location字段中，浏览器会自动重定向到该URL，301状态码表示永久性转移，所以浏览器会记住这个URL，下次访问该URL，浏览器会直接访问新的URL，不再请求旧的URL。</p>
<h2 id="返回304状态码的时候响应体里的内容？"><a href="#返回304状态码的时候响应体里的内容？" class="headerlink" title="返回304状态码的时候响应体里的内容？"></a>返回304状态码的时候响应体里的内容？</h2><p>返回304状态码时，响应体是没有内容的，因为浏览器可以直接从本地缓存中获取资源。当请求命中缓存，且服务器判断资源没有更新时，就会返回304响应状态码，告知浏览器可以使用本地缓存，而不需要重新下载资源。此时服务器只需在响应头中包含<code>ETag</code>或<code>Last-Modified</code>等响应头字段，告诉浏览器缓存的版本信息。因此，304响应状态码不会包含响应体，只会包含响应头。</p>
<h2 id="命中本地强缓存的时候状态码是多少？"><a href="#命中本地强缓存的时候状态码是多少？" class="headerlink" title="命中本地强缓存的时候状态码是多少？"></a>命中本地强缓存的时候状态码是多少？</h2><p>当命中本地强缓存时，状态码是<strong>200 OK</strong>。因为浏览器直接从本地缓存中获取了资源，并且确认缓存未过期或者协商缓存未失效，因此服务器不需要再次返回资源，而是直接返回200状态码表示请求成功。此时响应头中会包含相应的缓存控制信息，例如<code>Cache-Control</code>、<code>Expires</code>等字段，用来告诉浏览器如何缓存该资源以及缓存有效期等信息。</p>
<h2 id="强缓存的资源存储在本地的什么位置？"><a href="#强缓存的资源存储在本地的什么位置？" class="headerlink" title="强缓存的资源存储在本地的什么位置？"></a>强缓存的资源存储在本地的什么位置？</h2><p>浏览器会将强缓存的资源存储在浏览器的缓存中，也就是本地磁盘或内存中。具体来说，对于不同类型的资源，浏览器对其的缓存位置可能有所不同：</p>
<ol>
<li>对于HTML文档，通常会被缓存到内存中，因为HTML文档相对较小，频繁的请求也不会导致内存占用过高。</li>
<li>对于CSS、JavaScript、图片等静态资源，则会被缓存到本地磁盘中，因为这些资源相对较大，频繁加载会占用大量内存，并且缓存在本地磁盘中可以加快下一次访问时的加载速度。</li>
</ol>
<p>但无论是缓存到内存还是本地磁盘中，浏览器都会根据缓存策略规则来管理缓存，并在缓存过期或失效时进行更新或重新加载。</p>
<h2 id="Etag里面的文本结构是怎样的？"><a href="#Etag里面的文本结构是怎样的？" class="headerlink" title="Etag里面的文本结构是怎样的？"></a>Etag里面的文本结构是怎样的？</h2><p>Etag（实体标记）是 HTTP 协议头中的一种机制，用于<strong>标识资源是否被修改过</strong>。Etag 的文本结构通常是<strong>一个由双引号包围的字符串</strong>，如下所示：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">ETag:</span> <span class="hljs-string">&quot;686897696a7c876b7e&quot;</span><br></code></pre></td></tr></table></figure>

<p><strong><code>ETag</code>没有指定生成值的方法。通常，使用内容的散列，最后修改时间戳的散列或仅修订版本号。</strong></p>
<p>实体标记通常是<strong>由服务器生成的标识符</strong>，而这个标识符可以根据服务器的算法和资源内容计算出来，只有当资源内容发生改变时，Etag 值才会发生变化。</p>
<p>当客户端请求同一资源时，客户端会向服务器发送 “If-None-Match” 的请求头，这个请求头包含上次请求获得的 Etag 值，如果服务器发现该资源的 Etag 值仍然匹配，则会返回 HTTP 304 Not Modified 状态码，告诉客户端可以直接使用缓存中的资源。如果 Etag 值不匹配，则服务器会返回新的资源给客户端。</p>
<p>因此 Etag 的作用是<strong>减少了无效的带宽消耗，增加了缓存的命中率</strong>。</p>
<h2 id="如果HTTP响应头中ETag值改变了，是否意味着文件内容一定已经更改？"><a href="#如果HTTP响应头中ETag值改变了，是否意味着文件内容一定已经更改？" class="headerlink" title="如果HTTP响应头中ETag值改变了，是否意味着文件内容一定已经更改？"></a>如果HTTP响应头中ETag值改变了，是否意味着文件内容一定已经更改？</h2><p>不一定。虽然 ETag 值是用于标识 HTTP 协议中一个特定的资源的版本号，但它不一定是由文件内容决定的，而是由服务器生成的。服务器可以采用不同的算法生成 ETag 值，例如将文件最后修改时间和文件大小作为参数来计算 ETag 值，而并没有考虑文件内容是否有变化。</p>
<p>因此，如果服务器端修改了 ETag 值，不一定意味着文件内容一定已经更改。在实际应用中，更准确的判断资源是否改变的方法是将 ETag 值与实际文件内容的哈希值比较。只有当 ETag 值与实际哈希值不一致时，才能判断文件内容发生了变更。</p>
<h2 id="GET请求在body设置数据是否会传递？"><a href="#GET请求在body设置数据是否会传递？" class="headerlink" title="GET请求在body设置数据是否会传递？"></a>GET请求在body设置数据是否会传递？</h2><p>按照HTTP协议规范，GET请求的参数应该放在URL的查询参数部分，而不是请求体中。因此，即使在请求体中设置了数据，这些数据也不会被传递，而是会被忽略。</p>
<p>需要注意的是，虽然不建议在GET请求中使用请求体来传递参数，但是HTTP协议规范并未禁止这种行为。某些特定的服务端框架和应用程序可能会对此进行支持，但是这种行为并不常见，因此不推荐使用。</p>
<h2 id="使用第三方富文本编译器可能会遇到哪些安全问题？"><a href="#使用第三方富文本编译器可能会遇到哪些安全问题？" class="headerlink" title="使用第三方富文本编译器可能会遇到哪些安全问题？"></a>使用第三方富文本编译器可能会遇到哪些安全问题？</h2><p>使用第三方富文本编辑器时可能会存在以下安全问题：</p>
<ol>
<li>跨站脚本攻击(XSS)：富文本编辑器中允许用户对文本进行格式化、插入图片或其他媒体，而这些内容很容易被植入恶意脚本，从而造成XSS攻击。</li>
<li>文件上传漏洞：富文本编辑器中可以上传图片或其他媒体文件，如果没有进行严格的文件类型、大小、后缀等限制，攻击者就可以上传恶意文件到服务器上，从而控制整个系统。</li>
<li>恶意插件：一些恶意插件可能会通过富文本编辑器中的API和DOM接口，访问用户的浏览器、cookie等敏感信息。</li>
<li>版权问题：某些富文本编辑器可能没有经过合法授权，使用这些编辑器就可能会涉及到版权问题。</li>
</ol>
<p>为了保障安全，使用第三方富文本编辑器时应该注意以下几点：</p>
<ol>
<li>选择可信赖的编辑器：使用知名厂商或有良好口碑的第三方富文本编辑器，可以降低发生安全问题的概率。</li>
<li>进行数据过滤：在服务端对用户上传的内容进行过滤和验证，处理恶意标签、注入代码等攻击。</li>
<li>对上传文件进行严格限制：在服务端对上传文件的类型、大小、后缀等进行限制，并进行文件内容安全检查。</li>
<li>最小化API权限：在使用富文本编辑器的API和DOM接口时，尽可能限制其权限，减少恶意插件访问浏览器等敏感信息的风险。</li>
<li>授权审查：确保所采用的富文本编辑器源代码是来自授权渠道或已购买授权，以避免版权问题。</li>
</ol>
<h2 id="对XSS攻击的理解？"><a href="#对XSS攻击的理解？" class="headerlink" title="对XSS攻击的理解？"></a>对XSS攻击的理解？</h2><p>XSS（Cross Site Scripting）攻击，即跨站脚本攻击，是一种常见的Web攻击方式之一，其特点就是攻击者通过在目标网站上注入恶意脚本，使得受害者用户在访问该网站时执行攻击者所编写的恶意脚本，从而达到攻击的目的。</p>
<p>XSS攻击的危害有以下几点：</p>
<ol>
<li>盗取用户隐私数据：攻击者可以使用恶意脚本窃取用户密码、会话Cookie等隐私数据，从而进一步攻击用户的账号和个人信息。</li>
<li>篡改页面内容：攻击者可以通过在页面中注入恶意脚本来实现篡改页面内容，包括添加广告、假冒登录页面、弹出广告窗口等。</li>
<li>利用网站漏洞：攻击者可以利用漏洞进行攻击，比如通过XSS攻击利用网站上的漏洞向其他网站发送请求，从而在不知情的情况下进行攻击。</li>
<li>DDos攻击：攻击者可以利用XSS漏洞进行DDos攻击，向目标网站发送大量请求，从而占用网站的带宽以及服务器资源。</li>
</ol>
<p>为了防范XSS攻击，我们可以采取以下措施：</p>
<ol>
<li>对用户输入的数据进行过滤和验证，避免恶意脚本的注入。</li>
<li>对敏感信息进行加密传输和存储，避免信息泄露。</li>
<li>使用HttpOnly和secure标签设置Cookie属性，在一定程度上防止Cookie被窃取和篡改。</li>
<li>对Web应用程序进行漏洞扫描，及时发现漏洞并进行修复。</li>
<li>对网站访问日志进行监控和分析，及时发现异常IP和嫌疑用户。</li>
</ol>
<h2 id="什么是CDN-内容分发网络-？"><a href="#什么是CDN-内容分发网络-？" class="headerlink" title="什么是CDN (内容分发网络) ？"></a>什么是CDN (内容分发网络) ？</h2><p>CDN即内容分发网络（Content Delivery Network），是一种<strong>利用多台服务器分别支持在线业务的网络架构</strong>，也可以理解为一种加速数据传输的技术服务。</p>
<p>CDN的基本原理是，将网站的内容（如文本、图片、视频等）复制到分布在全国乃至全球各地的CDN节点上，当用户需要访问网站的内容时，可以从距离其最近的CDN节点上获取所需内容，降低了网站访问延迟和拥堵，提高了用户访问速度和稳定性。</p>
<p>CDN服务提供商会从中心节点向全球建立多个缓存节点，使得用户的请求可以从离自己最近的节点获取数据，因而避免了传统的以中心节点为中心的单点故障和网络拥堵问题，同时也减轻了源站的压力，提高了数据传输的效率和可靠性。</p>
<p>CDN技术的应用广泛，比如可以用于优化网站速度，提高用户访问体验，降低视频播放卡顿率，减轻服务器负载，提高网站的安全性等等。</p>
<h2 id="CDN会改变IP地址吗？"><a href="#CDN会改变IP地址吗？" class="headerlink" title="CDN会改变IP地址吗？"></a>CDN会改变IP地址吗？</h2><p>CDN（内容分发网络）会改变IP地址。</p>
<p>CDN是一种优化网站性能和提高速度的技术，通过缓存和加速来将网站的内容分发到不同位置的节点，然后根据用户的请求 location 来返回最近节点的缓存内容，从而提高用户访问网站时的响应速度和体验。这些节点就是由 CDN 服务提供商部署在不同地点的服务器，也就是 CDN 边缘节点，它们是用户和网站源服务器之间的中转节点。</p>
<p>当用户请求网站内容时，CDN 会将请求重定向到距离用户最近的边缘节点，并将缓存的内容发送回用户所在的位置。边缘节点会运行一些特性（例如 NAT 网络地址转换），这些特性常常具有重写 IP 地址的功能，从而实现通过动态网络地址转换技术（NAT）进行 IP 地址的变更。</p>
<p>所以，请求经过 CDN 后，用户的请求 IP 地址将会变为节点 IP 地址，而非用户的真实 IP 地址。如果需要获取用户的真实IP地址，可以使用一些特殊的技术来绕过CDN，或者将CDN配置为在HTTP请求头中传递真实IP地址。</p>
<h2 id="硬链接和软链接的区别？"><a href="#硬链接和软链接的区别？" class="headerlink" title="硬链接和软链接的区别？"></a>硬链接和软链接的区别？</h2><ul>
<li>硬链接指向一个inode节点，可以跨目录，但是不能跨文件系统</li>
<li>软链接存放另一个文件的路径的形式存在，可以跨文件，但是不能跨分区。</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="什么是数据库的索引？"><a href="#什么是数据库的索引？" class="headerlink" title="什么是数据库的索引？"></a>什么是数据库的索引？</h3><p>数据库索引是一种数据结构，用于提高数据库表中数据的查询效率。索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。</p>
<p>在数据库中，索引类似于书籍的目录。如果您想查找书籍中的某个主题，您可以查找目录以找到该主题的页码，而不必翻阅整本书。同样，如果您想查找数据库表中的某个值，则可以使用索引来快速查找该值所在的行，而不必扫描整个表。</p>
<p>索引可以大大提高查询效率，但也会增加写入操作的时间和空间开销。因此，在设计数据库时，需要权衡查询效率和写入效率之间的平衡。</p>
<h3 id="数据库的索引有哪几种类型？"><a href="#数据库的索引有哪几种类型？" class="headerlink" title="数据库的索引有哪几种类型？"></a>数据库的索引有哪几种类型？</h3><p>数据库索引有多种类型，包括: 普通索引、唯一索引、主键索引、组合索引和全文索引等。</p>
<ul>
<li>普通索引：基本的索引类型，没有唯一性的限制，允许为NULL值。</li>
<li>唯一索引：数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</li>
<li>主键索引：主键是一种特殊的唯一索引，不允许为NULL值，一个表只能有一个主键</li>
<li>组合索引：将多个列作为一个索引建立，可以提高查询效率。</li>
<li>全文索引：用于全文搜索的特殊类型的索引。</li>
</ul>
<h3 id="什么是MySQL关联查询？"><a href="#什么是MySQL关联查询？" class="headerlink" title="什么是MySQL关联查询？"></a>什么是MySQL关联查询？</h3><p>MySQL关联查询是指在MySQL中，通过<strong>将两个或多个表的行按照指定的条件进行连接，返回一个包含有这些行的关联结果集，以使用户能够以一种更加灵活的方式查询和组装表中的数据</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span> name(s)<br><span class="hljs-keyword">FROM</span> tablel<br><span class="hljs-keyword">JOIN</span> table2<br><span class="hljs-keyword">ON</span> table1.column_name <span class="hljs-operator">=</span> table2.column_name;<br></code></pre></td></tr></table></figure>

<p>在MySQL关联查询中，使用”JOIN”关键字连接两个或多个表，可以根据条件进行对应行的匹配，匹配成功的行会合并到一起，生成关联结果集。其中，JOIN操作基于列之间的关系进行表的连接，包括INNER JOIN（内连接）、LEFT JOIN（左连接）、RIGHT JOIN（右连接）等类型。</p>
<p>MySQL关联查询通常通过联结两个或多个数据表，以便可以检索多个表中的数据，并将这些表的数据连接起来以生成一个更具关联性和完整性的数据集。当然，关联查询可能会涉及到一些复杂的SQL语句和表之间的数据关系，因此需要学习和熟练使用MySQL语言编写进行精确查询。</p>
<h3 id="关系型数据库和非关系型数据库的区别？"><a href="#关系型数据库和非关系型数据库的区别？" class="headerlink" title="关系型数据库和非关系型数据库的区别？"></a>关系型数据库和非关系型数据库的区别？</h3><p>关系型数据库和非关系型数据库的区别在于，关系型数据库一般都是有固定的表结构，并且需要通知DDL语句来修改表结构，不是很容易进行扩展</p>
<p>而非关系型数据库的存储机制就有很多了，比如基于文档的，K-V键值对的，还有基于图的等，对于数据的格式十分灵活没有固定的表结构，方便扩展。</p>
<p>因此<strong>如果业务的数据结构并不是固定的或者经常变动比较大的，那么非关系型数据库是个好的选择</strong>。</p>
<h3 id="关系型数据库与文档型数据库的区别？"><a href="#关系型数据库与文档型数据库的区别？" class="headerlink" title="关系型数据库与文档型数据库的区别？"></a>关系型数据库与文档型数据库的区别？</h3><p>关系型数据库（Relational Database）是建立在关系模型基础上的数据库，借助于几何代数等数学概念和方法来处理数据库中的数据。所谓关系模型是一对一、一对多或者多对多等关系，常见的关系型数据库有Oracle、SQL Server、DB2、MySQL等。</p>
<p>而文档型数据库是一种非关系型数据库，非关系型数据库（Not Only SQL，NoSQL）正好与关系型数据库相反，它不是建立在“关系模型”上的数据库。文档型数据库的典型代表是MongoDB。</p>
<h3 id="MongoDB和MySQL的区别"><a href="#MongoDB和MySQL的区别" class="headerlink" title="MongoDB和MySQL的区别"></a>MongoDB和MySQL的区别</h3><p>MongoDB是一种文档型数据库，而MySQL是一种关系型数据库。</p>
<p>MongoDB可以处理大量和非结构化数据量，而MySQL则<strong>缺乏处理大数据量的速度</strong>。因此，对于拥有较小数据库并寻求更通用解决方案的公司来说，MySQL可以胜任。</p>
<p>另外，MongoDB以一种直观文档的方式来完成数据的存储，它很像JavaScript中定义的JSON格式，不过数据在存储的时候MongoDB数据库为文档增加了序列化的操作，最终存进磁盘的其实是一种叫做BSON的格式，即Binary-JSON。</p>
<p>MySQL在<strong>处理关系数据方面具有更好的优势</strong>，而MongoDB则更能满足现代应用程序的需求。</p>
<h3 id="数据库三大范式是什么？"><a href="#数据库三大范式是什么？" class="headerlink" title="数据库三大范式是什么？"></a>数据库三大范式是什么？</h3><p>数据库三大范式（Normal Forms）指的是在关系数据库中，设计数据表时需要满足的规范。这些规范确保了数据库的数据结构与操作的可靠性、一致性和可维护性。</p>
<p>第一范式（1NF）要求记录（行）不可再分，即每个属性（列）都是原子的、不可再分的数据项。</p>
<p>第二范式（2NF）要求每个非主属性必须完全依赖于主键（即没有部分依赖关系）。如果存在部分依赖，应该将主键分解成更小的部分，以消除部分依赖。</p>
<p>第三范式（3NF）要求在关系表中，不存在非主键列对于其他非主键列的传递函数依赖关系。如果存在传递函数依赖，应该将其分解成两个关系表，以消除传递函数依赖。</p>
<p>需要注意的是，严格地符合三大范式并不一定就是最优的设计，某些情况下还需要根据数据的实际情况进行灵活设计，以达到更好的性能和维护效果。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Spring-Recruitment/">#Spring Recruitment</a>
      
        <a href="/tags/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">#进程与线程</a>
      
        <a href="/tags/HTTP/">#HTTP</a>
      
        <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/">#浏览器</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>浏览器、进程和线程、计算机网络、数据库相关</div>
      <div>https://ustinians.github.io/2023/04/26/浏览器、进程和线程、计算机网络、数据库相关/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>想躺在云上</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年4月26日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/04/26/Webpack%EF%BC%8CGit%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%81%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/" title="Webpack，Git打包部署、性能优化、安全相关">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Webpack，Git打包部署、性能优化、安全相关</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/04/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/" title="数据结构相关总结">
                        <span class="hidden-mobile">数据结构相关总结</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
