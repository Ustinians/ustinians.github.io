

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="想躺在云上">
  <meta name="keywords" content="">
  
    <meta name="description" content="知识点整理(16)什么是CSS层叠性？CSS的层叠性是指当多个CSS规则都应用到同一个HTML元素时，浏览器如何处理其样式属性的优先级和叠加顺序的规则。通俗一点地说，就是 CSS 样式的优先级以及如何在冲突时决定使用哪一个规则的机制。 按优先级从高到低排序：  !important规则 行内样式 ID选择器 类选择器、属性选择器、伪类选择器 元素选择器、伪元素选择器 通配符和继承的样式  按照上述">
<meta property="og:type" content="article">
<meta property="og:title" content="知识点整理(16)">
<meta property="og:url" content="https://ustinians.github.io/2023/05/08/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-16/index.html">
<meta property="og:site_name" content="想躺在云上 - In doing we learn.">
<meta property="og:description" content="知识点整理(16)什么是CSS层叠性？CSS的层叠性是指当多个CSS规则都应用到同一个HTML元素时，浏览器如何处理其样式属性的优先级和叠加顺序的规则。通俗一点地说，就是 CSS 样式的优先级以及如何在冲突时决定使用哪一个规则的机制。 按优先级从高到低排序：  !important规则 行内样式 ID选择器 类选择器、属性选择器、伪类选择器 元素选择器、伪元素选择器 通配符和继承的样式  按照上述">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-05-08T07:21:24.000Z">
<meta property="article:modified_time" content="2023-05-08T07:56:44.468Z">
<meta property="article:author" content="想躺在云上">
<meta property="article:tag" content="前端学习">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>知识点整理(16) - 想躺在云上 - In doing we learn.</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"ustinians.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>想躺在云上</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="知识点整理(16)"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-05-08 15:21" pubdate>
          2023年5月8日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          89 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">知识点整理(16)</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="知识点整理-16"><a href="#知识点整理-16" class="headerlink" title="知识点整理(16)"></a>知识点整理(16)</h1><h2 id="什么是CSS层叠性？"><a href="#什么是CSS层叠性？" class="headerlink" title="什么是CSS层叠性？"></a>什么是CSS层叠性？</h2><p>CSS的层叠性是指<strong>当多个CSS规则都应用到同一个HTML元素时，浏览器如何处理其样式属性的优先级和叠加顺序的规则</strong>。通俗一点地说，就是 CSS 样式的优先级以及如何在冲突时决定使用哪一个规则的机制。</p>
<p>按优先级从高到低排序：</p>
<ol>
<li><code>!important</code>规则</li>
<li>行内样式</li>
<li>ID选择器</li>
<li>类选择器、属性选择器、伪类选择器</li>
<li>元素选择器、伪元素选择器</li>
<li>通配符和继承的样式</li>
</ol>
<p>按照上述规则，当多个CSS规则应用到同一个元素时，浏览器会依次比较它们的选择器优先级，并根据成败判断哪个规则的样式优先级更高。在优先级相同时，后面的规则会覆盖前面的规则。 然后再根据CSS属性的“继承性” 确定样式最终值。</p>
<p>例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-class">.note</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><br><span class="hljs-selector-id">#id1</span> &#123;<br>  <span class="hljs-attribute">color</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当一段HTML文本中包含<code>&lt;p id=&quot;id1&quot; class=&quot;note&quot;&gt;</code>标签时，应用到同一元素上的多个CSS规则的选择器，基于优先级的计算结果是，<code>#id1</code> 的优先级要高于 <code>.note</code> 和 <code>p</code>，<code>p</code> 的优先级要高于 <code>.note</code>。因此最终该元素的颜色属性值为 <code>green</code>。</p>
<h2 id="发布订阅模式存在那些风险？"><a href="#发布订阅模式存在那些风险？" class="headerlink" title="发布订阅模式存在那些风险？"></a>发布订阅模式存在那些风险？</h2><ol>
<li>内存泄漏：如果订阅者没有正确取消订阅或者发布者没有正确删除订阅者的引用，可能会导致内存泄漏。</li>
<li>效率问题：发布-订阅模式需要维护订阅列表和消息队列，消息处理可能会变得缓慢，特别是在处理大量消息时。</li>
<li>非明确的依赖关系：尽管发布者并不知道和关心它的观察者是谁，但观察者可能从发布者那里接收到许多他们并不关心的消息。这也可能导致发布者和观察者之间形成意外的依赖关系。</li>
<li>程序复杂度：在某些情况下，使用发布-订阅模式可以使程序变得复杂。特别是在处理多个发布者和订阅者之间复杂的交互时，可能会变得难以管理。</li>
</ol>
<h2 id="什么是TypeScript的泛型？"><a href="#什么是TypeScript的泛型？" class="headerlink" title="什么是TypeScript的泛型？"></a>什么是TypeScript的泛型？</h2><p><strong>TypeScript的泛型是一种通用的编程机制，可以在函数、类、接口等中定义类型参数，从而增强代码的灵活性和可重用性。</strong>泛型的主要作用是让我们能够编写可重用的代码组件，而不必每次都为不同的数据类型编写重复的代码。</p>
<p>在TypeScript中，泛型用尖括号 <code>&lt;T&gt;</code> 来表示。我们可以使用泛型来编写具有通用性的函数和类，例如：</p>
<p>示例1：在函数中使用泛型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br><br><span class="hljs-keyword">let</span> result = identity&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;Hello World&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>在此示例中，我们定义了一个叫 <code>identity</code> 的函数，该函数接受一个参数 <code>arg</code>，并返回该参数。除此以外，我们使用 <code>&lt;T&gt;</code> 表示参数的数据类型，在函数定义中使用 T 来代替实际的数据类型。当我们调用 <code>identity</code> 函数时，我们需要提供要传递的数据类型作为 <code>&lt;string&gt;</code>。</p>
<p>示例2：在类中使用泛型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericNumber</span>&lt;T&gt; &#123;<br>  <span class="hljs-attr">zeroValue</span>: T;<br>  <span class="hljs-attr">add</span>: <span class="hljs-function">(<span class="hljs-params">x: T, y: T</span>) =&gt;</span> T;<br>&#125;<br><br><span class="hljs-keyword">let</span> myNumber = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericNumber</span>&lt;<span class="hljs-built_in">number</span>&gt;();<br>myNumber.<span class="hljs-property">zeroValue</span> = <span class="hljs-number">0</span>;<br>myNumber.<span class="hljs-property">add</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) &#123; <span class="hljs-keyword">return</span> x + y; &#125;;<br></code></pre></td></tr></table></figure>

<p>在此示例中，我们定义了一个叫 <code>GenericNumber</code> 的类，该类有两个属性： <code>zeroValue</code> 和 <code>add</code>。这两个属性的类型都是泛型类型 <code>T</code>，其中 <code>zeroValue</code> 的默认值是传入的泛型类型 <code>T</code> 的默认值，而 <code>add</code> 是一个函数，接收两个泛型类型为 <code>T</code> 的参数，并返回一个泛型类型为 <code>T</code> 的结果。</p>
<p>总之，TypeScript的泛型使得我们可以编写更加通用和可复用的代码，从而减少代码的冗余，提高了程序的可维护性和可伸缩性。</p>
<h2 id="什么情况下用枚举类型？"><a href="#什么情况下用枚举类型？" class="headerlink" title="什么情况下用枚举类型？"></a>什么情况下用枚举类型？</h2><blockquote>
<p>在 TypeScript 中，枚举（Enumeration，缩写为 enum）类型是一种通过给一组固定的值起有意义的名字来给定名称的方法。</p>
</blockquote>
<p>我们通常使用枚举类型来描述某些特定的取值范围，比如天气、星期几、月份等等。枚举类型看起来比较像一个普通的对象，但是枚举类型的值集合是有限且固定的，它只能接受枚举中定义的某几个常量值。</p>
<p>下面是一个简单的枚举类型的例子，它表示一周的 7 天：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">WeekDay</span> &#123;<br>    <span class="hljs-title class_">Monday</span>,<br>    <span class="hljs-title class_">Tuesday</span>,<br>    <span class="hljs-title class_">Wednesday</span>,<br>    <span class="hljs-title class_">Thursday</span>,<br>    <span class="hljs-title class_">Friday</span>,<br>    <span class="hljs-title class_">Saturday</span>,<br>    <span class="hljs-title class_">Sunday</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个枚举类型中，我们定义了一周中的 7 天，从星期一到星期日。默认情况下，这些值的类型是数字类型，从 0 开始依次递增。我们可以通过为每个值手动赋值来自定义它们的值。</p>
<p>例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">WeekDay</span> &#123;<br>    <span class="hljs-title class_">Monday</span> = <span class="hljs-number">1</span>,<br>    <span class="hljs-title class_">Tuesday</span> = <span class="hljs-number">2</span>,<br>    <span class="hljs-title class_">Wednesday</span> = <span class="hljs-number">3</span>,<br>    <span class="hljs-title class_">Thursday</span> = <span class="hljs-number">4</span>,<br>    <span class="hljs-title class_">Friday</span> = <span class="hljs-number">5</span>,<br>    <span class="hljs-title class_">Saturday</span> = <span class="hljs-number">6</span>,<br>    <span class="hljs-title class_">Sunday</span> = <span class="hljs-number">7</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，我们手动给每个值赋予了对应的数字，星期一的值为 1，星期二的值为 2，以此类推。</p>
<p>使用枚举类型时，我们可以通过枚举属性的名字访问其对应的数值。例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">day</span>: <span class="hljs-title class_">WeekDay</span> = <span class="hljs-title class_">WeekDay</span>.<span class="hljs-property">Monday</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(day); <span class="hljs-comment">// 输出 1</span><br></code></pre></td></tr></table></figure>

<p>枚举类型的最大作用是提高代码的可读性和可维护性，它使得代码中的常量值更加具有可读性，从而减少了在使用常量值时出现错误的概率。同时，枚举类型还可以帮助我们实现更好的自动补全和类型检查。</p>
<h2 id="interface递归结构如何处理？"><a href="#interface递归结构如何处理？" class="headerlink" title="interface递归结构如何处理？"></a>interface递归结构如何处理？</h2><p>在 TypeScript 中，我们可以定义递归结构的 interface，也就是一个接口的某个属性的类型是这个接口本身。这种递归结构的接口的处理方式和其他接口的处理方式是类似的。</p>
<p>例如，我们可以定义一个树状结构的接口，如下所示：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">left</span>: <span class="hljs-title class_">TreeNode</span> | <span class="hljs-literal">null</span>;<br>  <span class="hljs-attr">right</span>: <span class="hljs-title class_">TreeNode</span> | <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述定义中，我们通过 <code>left</code> 和 <code>right</code> 属性指向了另外两个接口类型，这两个接口类型又包含了 <code>left</code> 和 <code>right</code> 两个属性，其类型为 <code>TreeNode</code> 或 <code>null</code> 。这个定义实际上定义了一个二叉树的数据结构。</p>
<p>我们可以在函数中使用这个接口类型来遍历这个二叉树并进行一些操作，例如输出每个节点的值：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">print</span>(<span class="hljs-params">node: TreeNode | <span class="hljs-literal">null</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(node.<span class="hljs-property">value</span>);<br>  <span class="hljs-title function_">print</span>(node.<span class="hljs-property">left</span>);<br>  <span class="hljs-title function_">print</span>(node.<span class="hljs-property">right</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个函数中，我们判断节点是否为空，如果不为空，输出节点值，然后以同样的方式遍历左子树（<code>node.left</code>）和右子树（<code>node.right</code>）。在递归调用过程中，输入参数的类型始终是 <code>TreeNode | null</code>，所以递归调用不会发生异常和错误。</p>
<p>总之，递归结构的 interface 可以被像其他接口一样使用，在递归函数中也能正常工作。但是，需要注意处理递归的边界条件，以避免递归导致的死循环或其它异常。</p>
<h2 id="async-x2F-await和Promise的应用场景？"><a href="#async-x2F-await和Promise的应用场景？" class="headerlink" title="async&#x2F;await和Promise的应用场景？"></a>async&#x2F;await和Promise的应用场景？</h2><p><strong>Promise的应用场景</strong></p>
<ul>
<li>异步加载数据：Promise是处理异步代码的一种方式，可以用来异步加载数据。比如从服务端获取数据，可以使用fetch API获取数据并返回Promise对象。</li>
<li>多个异步任务并行执行：Promise.all()可以将多个异步任务并行执行，等待所有任务执行完毕后再进行下一步操作，通常用于加载多个资源的场景。</li>
<li>多个异步任务串行执行：Promise.then()可以将异步任务按顺序串行执行，每个异步任务完成后再进行下一步操作，通常用于需要保持执行顺序的场景。</li>
</ul>
<p><strong>async&#x2F;await的应用场景</strong></p>
<ul>
<li>简化异步代码：async&#x2F;await语法可以简化异步代码，将异步操作写成同步代码的形式，提高代码的可读性和维护性。</li>
<li>避免回调地狱：async&#x2F;await语法可以避免回调地狱现象，使代码更加简洁易懂，减少代码耦合度和错误率。</li>
<li>多个异步任务串行执行：async&#x2F;await可以使用async函数和await关键字将异步任务按顺序串行执行，每个异步任务完成后再进行下一步操作，通常用于需要保持执行顺序的场景。</li>
</ul>
<h2 id="Promise本质上是函数还是对象？有哪些特性？"><a href="#Promise本质上是函数还是对象？有哪些特性？" class="headerlink" title="Promise本质上是函数还是对象？有哪些特性？"></a>Promise本质上是函数还是对象？有哪些特性？</h2><p>Promise 本质上是一个<strong>对象</strong>。</p>
<p>Promise 是用于处理异步操作的一种方式，它具有以下特性：</p>
<ol>
<li>Promise 是一个对象，可以通过 new Promise() 来创建。</li>
<li>Promise 对象有三种状态，分别是 pending（进行中）、fulfilled（已成功）和 rejected（已失败）。</li>
<li>通过 Promise 实例的then方法，可以将回调函数添加到 Promise 实例状态改变时的回调队列中，以便在异步操作完成（即状态改变）时能够被调用。</li>
<li>Promise 实例有一个then方法，它接收两个参数：一个成功回调和一个失败回调，这两个回调函数都是可选的。</li>
<li>如果 Promise 实例状态改变为 fulfilled，就会调用 then 方法中的成功回调；如果状态改变为 rejected，就会调用 then 方法中的失败回调。</li>
<li>then 方法会返回一个新的 Promise 实例，以便支持链式调用。</li>
<li>Promise 可以使用catch方法或者Promise.reject方法来处理已拒绝（rejected）的 Promise，这些方法也返回新的 Promise 实例。</li>
</ol>
<h2 id="Promise内部做了哪些事情？封装了哪些函数？"><a href="#Promise内部做了哪些事情？封装了哪些函数？" class="headerlink" title="Promise内部做了哪些事情？封装了哪些函数？"></a>Promise内部做了哪些事情？封装了哪些函数？</h2><p>Promise 内部主要做了以下几件事情：</p>
<ol>
<li>封装了异步操作：Promise 可以封装任何一种异步操作，例如 Ajax 请求、读取文件、计时器等。在创建 Promise 时可以通过回调函数来定义具体的异步操作，并将状态信息传递给 Promise 实例。</li>
<li>管理状态变化：Promise 内部维护了三种状态，分别是 pending、fulfilled 和 rejected。当异步操作执行成功时会将状态从 pending 改变为 fulfilled，否则将状态从 pending 改变为 rejected。</li>
<li>注册回调函数：Promise 提供了 then 方法，可以注册两个回调函数，分别是处理成功状态的回调函数和处理失败状态的回调函数。当异步操作状态发生变化后就会依次调用这些回调函数，从而完成后续操作。</li>
<li>处理异常状态：Promise 还可以通过 catch 方法来捕获异常状态，从而进一步处理异常情况。</li>
</ol>
<p>Promise 对象内部封装了一些函数，包括：</p>
<ol>
<li>Promise.resolve：可以将一个值转化为 Promise 对象，并将其立即解析为 fulfilled 状态。</li>
<li>Promise.reject：可以将一个值转化为 Promise 对象，并将其立即解析为 rejected 状态。</li>
<li>Promise.all：可以将多个 Promise 对象封装为一个新的 Promise 对象，并在所有的 Promise 对象都变为 fulfilled 状态之后将其解析。</li>
<li>Promise.race：可以将多个 Promise 对象封装为一个新的 Promise 对象，并在最早变为 fulfilled 或 rejected 状态的 Promise 对象解析。</li>
</ol>
<p>这些函数可以进一步帮助开发者简化代码，增强可读性，提高代码的可维护性。</p>
<h2 id="构造函数，实例，原型三者之间的关系？"><a href="#构造函数，实例，原型三者之间的关系？" class="headerlink" title="构造函数，实例，原型三者之间的关系？"></a>构造函数，实例，原型三者之间的关系？</h2><ol>
<li>构造函数：JavaScript 中的构造函数通常用来创建实例对象，并且在创建实例对象时会初始化实例对象中的属性和方法。构造函数可以使用 new 关键字来调用，创建出来的实例对象都是该构造函数的实例。</li>
<li>实例：在 JavaScript 中，实例是构造函数通过 new 关键字调用时创建出来的对象。每个实例对象都有其自己的属性和方法，与其他实例对象是独立的。</li>
<li>原型：原型是 JavaScript 中用于实现继承的机制，每个构造函数都有一个与之对应的原型对象，通过原型对象可以实现对实例对象的属性和方法的共享和继承。实例对象可以通过原型链访问原型对象中的属性和方法。</li>
</ol>
<p>在 JavaScript 中，每次创建一个构造函数的实例时，该实例都会拥有和原型对象相同的属性和方法。但是，添加或修改实例对象原型中的属性或方法并不会影响到其他实例对象，因为每个实例对象都有自己的属性和方法。可以通过给原型对象添加属性和方法来实现属性和方法的共享和继承。</p>
<h2 id="字符串的constructor指的是什么？"><a href="#字符串的constructor指的是什么？" class="headerlink" title="字符串的constructor指的是什么？"></a>字符串的constructor指的是什么？</h2><p>在 JavaScript 中，字符串是一种基本数据类型，它本身不是一个对象，因此没有构造函数。然而，在调用字符串的 constructor 属性时，会返回 String 对象的构造函数。这是因为 JavaScript 在引用基本数据类型时，会隐式地将其包装为对应的包装对象来实现一些操作。所以，当对字符串调用 constructor 属性时，实际上是对字符串进行了包装，将其转换为 String 对象，然后返回该对象的构造函数。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-property">constructor</span>); <span class="hljs-comment">// 返回 String() 构造函数</span><br></code></pre></td></tr></table></figure>

<p>此时 str 被转换为 String 对象，然后通过 String 对象的 constructor 属性返回构造函数 String()。需要注意的是，这种包装是临时的，即调用完后，会立即销毁包装对象，因此字符串可以使用 String 对象的属性和方法，但不会对原始字符串造成影响。</p>
<h2 id="类的私有成员和共享成员？"><a href="#类的私有成员和共享成员？" class="headerlink" title="类的私有成员和共享成员？"></a>类的私有成员和共享成员？</h2><p>在JavaScript中，ES6引入了class语法，使得我们可以使用类来实现面向对象编程。在类中，成员变量和成员方法可以分为私有成员和共享成员。</p>
<p>私有成员指只能在类内被访问的成员，外部无法访问。在ES6中，可以通过在类方法中使用闭包或Symbol来实现私有成员。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_privateVar</span> = <span class="hljs-string">&#x27;私有变量&#x27;</span>; <span class="hljs-comment">// 使用下划线来表示私有变量</span><br>    &#125;<br><br>    <span class="hljs-title function_">_privateMethod</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">// 私有方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的例子中，我们使用了一个下划线来表示私有变量，在类的构造函数中进行定义。同样地，我们也可以在类的方法中进行定义私有方法。</p>
<p>共享成员指可以在类外被访问的成员，通常是通过在类的原型中进行定义。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">prop</span> = <span class="hljs-string">&#x27;共享属性&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-title function_">sharedMethod</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">// 共享方法</span><br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sharedProp</span> = <span class="hljs-string">&#x27;共享属性&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>在上面的例子中，我们通过在类的原型中对属性和方法进行定义，使其成为共享成员。这样，在类的外部，我们可以使用类实例来访问共享属性和方法。</p>
<p>需要注意的是，在JavaScript中并没有真正的私有成员，所有成员都是可访问的。实现私有成员只是一种编程约定，遵循约定可以减少代码的出错率。</p>
<h2 id="Object-prototype-toString-call-中的call可以修改为apply或者bind吗？"><a href="#Object-prototype-toString-call-中的call可以修改为apply或者bind吗？" class="headerlink" title="Object.prototype.toString.call()中的call可以修改为apply或者bind吗？"></a>Object.prototype.toString.call()中的call可以修改为apply或者bind吗？</h2><p><code>Object.prototype.toString.call()</code>中的<code>call()</code>可以替换为<code>apply()</code>或者<code>bind()</code>。</p>
<p><code>call()</code>、<code>apply()</code>和<code>bind()</code>都可以用来调用函数，并且在调用函数时可以更改函数内部的<code>this</code>值。区别在于它们接收参数的方式不同。</p>
<p><code>call()</code>可以按照常规方式将参数一个个传递给函数，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;string&#x27;</span>); <span class="hljs-comment">// &quot;[object String]&quot;</span><br></code></pre></td></tr></table></figure>

<p>而<code>apply()</code>则接收一个数组作为参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-string">&#x27;string&#x27;</span>); <span class="hljs-comment">// &quot;[object String]&quot;</span><br></code></pre></td></tr></table></figure>

<p>注意，在使用<code>apply()</code>时，参数必须以数组的形式传递。</p>
<p><code>bind()</code>方法则返回一个新的函数，在调用新函数时使用指定的<code>this</code>值和参数列表。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> toString = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-string">&#x27;string&#x27;</span>);<br><span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;[object String]&quot;</span><br></code></pre></td></tr></table></figure>

<p>以上代码中，我们使用<code>bind()</code>方法将<code>Object.prototype.toString()</code>函数绑定到了字符串类型的值上并生成了一个新函数，然后直接调用新函数即可得到结果。</p>
<p>因此，虽然<code>call()</code>是最常见的用法，但我们可以根据实际需求来选择使用<code>apply()</code>或<code>bind()</code>方法。</p>
<h2 id="Set和Map数据结构如何转化为数组？"><a href="#Set和Map数据结构如何转化为数组？" class="headerlink" title="Set和Map数据结构如何转化为数组？"></a>Set和Map数据结构如何转化为数组？</h2><p>Set和Map都提供了一个<code>entries()</code>方法来返回一个迭代器对象，该迭代器对象的值是一个包含键值对的数组。我们可以使用扩展运算符或<code>Array.from()</code>方法将该迭代器对象转化为数组。</p>
<p>下面是实现示例：</p>
<h3 id="Set转化为数组"><a href="#Set转化为数组" class="headerlink" title="Set转化为数组"></a>Set转化为数组</h3><p>使用扩展运算符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-keyword">const</span> mySetArray = [...mySet];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mySetArray); <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure>

<p>使用<code>Array.from()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-keyword">const</span> mySetArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(mySet);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mySetArray); <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure>

<h3 id="Map转化为数组"><a href="#Map转化为数组" class="headerlink" title="Map转化为数组"></a>Map转化为数组</h3><p>使用扩展运算符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>], [<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">20</span>]]);<br><span class="hljs-keyword">const</span> myMapArray = [...myMap];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myMapArray); <span class="hljs-comment">// [[&#x27;name&#x27;, &#x27;Alice&#x27;], [&#x27;age&#x27;, 20]]</span><br></code></pre></td></tr></table></figure>

<p>使用<code>Array.from()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>], [<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">20</span>]]);<br><span class="hljs-keyword">const</span> myMapArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(myMap);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myMapArray); <span class="hljs-comment">// [[&#x27;name&#x27;, &#x27;Alice&#x27;], [&#x27;age&#x27;, 20]]</span><br></code></pre></td></tr></table></figure>

<p>可以看到，无论是Set还是Map，转化为数组的方式都是类似的，唯一的区别就是生成Set或Map时，传递给构造函数的参数不同。</p>
<h2 id="Webpack生命周期？"><a href="#Webpack生命周期？" class="headerlink" title="Webpack生命周期？"></a>Webpack生命周期？</h2><p>Webpack主要由5个生命周期阶段组成，分别是：</p>
<ol>
<li><code>环境准备（Environment Setup）</code>：Webpack从配置文件中读取配置选项，对于用户指定的输入文件和输出文件进行文件路径解析和处理等环境准备工作。</li>
<li><code>模块编译（Compilation）</code>：Webpack依次编译每个模块，将每个模块编译成一个或多个chunk。</li>
<li><code>生成资源（Asset Generation）</code>：Webpack将每个chunk转化为一个或多个文件，将这些文件输出到文件系统中，这个阶段还会调用插件来对生成的文件进行优化，例如压缩、添加hash等。</li>
<li><code>模块输出（Module Output）</code>：Webpack会将输出的文件路径和名称写入到清单文件中供Webpack进行引用。</li>
<li><code>完成（Done）</code>：Webpack编译成功，所有工作完成。</li>
</ol>
<p>每个生命周期阶段都有一系列的Hook，开发者可以使用这些Hook实现自己的逻辑，自定义Webpack的行为和规则。</p>
<p>例如，在生命周期阶段1中，Webpack提供了一个<code>envireonment</code> Hook用于准备环境。我们可以通过在配置文件中使用<code>plugins</code>选项配置，在该阶段执行自己编写的插件。类似的，每个生命周期阶段都提供了一些Hook，使用者可以根据具体需求进行自由配置。</p>
<h2 id="浏览器限制字体大小为12px，怎么实现8px的字体？"><a href="#浏览器限制字体大小为12px，怎么实现8px的字体？" class="headerlink" title="浏览器限制字体大小为12px，怎么实现8px的字体？"></a>浏览器限制字体大小为12px，怎么实现8px的字体？</h2><p>可以通过CSS的transform属性来实现缩小字体的效果。例如，可以在CSS中添加以下样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-size</span>: <span class="hljs-number">8px</span>;<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.67</span>);<br></code></pre></td></tr></table></figure>

<p>其中，缩放比例为0.67是因为12px到8px的比例为2:3，而0.67正好是3除以2的结果。这样，即使浏览器限制了字体大小，也可以通过缩小字体的方式来实现8px的字体。</p>
<h2 id="SPA和MPA相比的优缺点？"><a href="#SPA和MPA相比的优缺点？" class="headerlink" title="SPA和MPA相比的优缺点？"></a>SPA和MPA相比的优缺点？</h2><p>SPA（Single Page Application）和MPA（Multi-Page Application）是两种常见的Web应用开发架构。</p>
<p>SPA（Single-Page Application，单页面应用程序），指的是整个Web应用程序只由一个HTML页面和大量的JavaScript组成，它使用异步通信技术来实现部分数据的更新，将所有的内容都加载到一个页面中，通过动态更新实现页面内容的变化，从而避免了每次向服务器请求新的页面，给用户带来了更快的响应速度和更好的交互体验。SPA适用于对前端技术要求较高、对响应速度和用户体验要求较高的Web应用程序。常见的SPA框架有AngularJS、React、Vue等。</p>
<p>MPA（Multi-Page Application，多页面应用程序），指的是整个Web应用程序由多个HTML页面组成，每个页面都有自己的URL地址，单击页面链接时，请求新的页面并且刷新整个页面，需要等待服务器返回新页面的HTML和JavaScript代码。MPA适用于对SEO有较高要求、对前端技术要求不高的Web应用程序。常见的MPA框架有JSP、ASP、PHP等。</p>
<p>SPA的优点包括：</p>
<ol>
<li>用户体验好：SPA通常使用了前端技术，通过AJAX等技术实现了页面的无刷新更新和局部刷新，用户感觉更加流畅、快速。</li>
<li>开发效率高：开发人员只需要关注前端代码，后台接口提供数据即可，开发效率相对较高。</li>
<li>维护成本低：由于是单页面，代码结构简单，维护成本与开发时间相对较低。</li>
</ol>
<p>MPA的优点包括：</p>
<ol>
<li>SEO（搜索引擎优化）效果好：由于每个页面是一个独立的HTML文档，可以通过优化页面内容、标题、关键词等提升SEO效果。</li>
<li>支持多种页面效果：各种链接可以引导用户进入不同的页面，通过不同的技术实现不同的功能，如跳转、刷新等。</li>
<li>兼容性好：不需要依赖JavaScript来实现页面的渲染，所以兼容性较好。</li>
</ol>
<p>当然，SPA和MPA都有自己的缺点。例如，SPA可能存在对浏览器版本的兼容性要求较高，而MPA可能存在页面切换时的短暂空白等问题。选择哪种开发架构，需要根据具体业务需求和技术能力来决定。</p>
<h2 id="什么是生成器？"><a href="#什么是生成器？" class="headerlink" title="什么是生成器？"></a>什么是生成器？</h2><p>在 JavaScript 中，可以使用生成器（Generator）来生成一个值序列，类似于 Python 中的生成器。在 ES6 中，引入了生成器语法，以实现更简单、更易于维护的异步编程。生成器可以用 yield 关键字定义，用于生成需要返回的值和暂停函数执行的位置。在需要时，可以从上次停止的位置继续执行并生成下一个值序列。</p>
<p>下面是一个简单的 JavaScript 生成器的示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generator</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> g = <span class="hljs-title function_">generator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(g.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出 3</span><br></code></pre></td></tr></table></figure>

<p>在该示例中，使用 function* 定义了一个生成器 generator()，并用 yield 语句生成一个从 1 到 3 的值序列。通过调用 generator()，可以生成一个迭代器对象 g，用于逐一迭代返回的序列中的值。每次调用 g.next()，生成器都会从 yield 语句处继续执行，输出下一个值。</p>
<p>生成器的强大之处在于可以生成无穷序列，而不必真正生成它们，同样可以避免内存占用问题。同时，使用生成器还可以实现更易于维护的异步编程，如使用 yield 关键字暂停函数执行，等待异步操作完成，然后继续执行函数。</p>
<h2 id="什么是协程？"><a href="#什么是协程？" class="headerlink" title="什么是协程？"></a>什么是协程？</h2><p>协程（coroutine）也称为对称协程，是一种运行在单线程中的、用户态的轻量级线程，可以避免多线程编写代码时出现的锁、死锁、状态同步等问题，并且可以在不同协程之间进行任意切换和交互，实现类似并发的效果。协程是一种比线程更加轻量级的并发模型，不需要操作系统的支持，可以在应用程序层面实现并发和并行执行。</p>
<p>协程是一种特殊的函数，可以执行部分代码，暂停执行，等待外部信号或事件发生后再恢复执行，而不是中断整个线程。协程有自己的栈和指令指针，可以保存上下文，切换时可以快速恢复之前的状态，因此可以实现高并发、高吞吐量的效果。</p>
<p>以 JavaScript 中的 Generator 为例，Generator 本质上也是一种协程，可以通过 yield 语句实现暂停和恢复执行。当 Generator 函数执行到 yield 语句时，函数会暂停执行，返回一个迭代器对象，通过调用迭代器对象的 next() 方法，可以恢复函数执行并从上一次执行的地方继续执行直到遇到下一个 yield 语句或函数结束。通过这种方式，可以实现类似并发的效果，在单线程中同时执行多个任务。</p>
<p>协程的优点是可以避免线程切换的开销，可以更好地利用 CPU 和内存资源，同时可以避免竞态条件和死锁等问题。缺点是需要手动管理状态，编写复杂度较高。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/">#前端学习</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>知识点整理(16)</div>
      <div>https://ustinians.github.io/2023/05/08/知识点整理-16/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>想躺在云上</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年5月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/05/05/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-15/" title="知识点整理(15)">
                        <span class="hidden-mobile">知识点整理(15)</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
